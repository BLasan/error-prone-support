diff --git a/guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTestSuiteBuilder.java
index 02efe30663..081ddc220a 100644
--- a/guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/AbstractCollectionTestSuiteBuilder.java
@@ -51,8 +51,8 @@ public abstract class AbstractCollectionTestSuiteBuilder<
         B extends AbstractCollectionTestSuiteBuilder<B, E>, E>
     extends PerCollectionSizeTestSuiteBuilder<B, TestCollectionGenerator<E>, Collection<E>, E> {
   // Class parameters must be raw.
-  @SuppressWarnings("unchecked")
   @Override
+  @SuppressWarnings("unchecked")
   protected List<Class<? extends AbstractTester>> getTesters() {
     return Arrays.<Class<? extends AbstractTester>>asList(
         CollectionAddAllTester.class,
diff --git a/guava-testlib/src/com/google/common/collect/testing/AbstractContainerTester.java b/guava-testlib/src/com/google/common/collect/testing/AbstractContainerTester.java
index b86ef1750d..6e228b3886 100644
--- a/guava-testlib/src/com/google/common/collect/testing/AbstractContainerTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/AbstractContainerTester.java
@@ -16,12 +16,13 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Collections.unmodifiableList;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import org.junit.Ignore;
 
@@ -215,7 +216,7 @@ public abstract class AbstractContainerTester<C, E>
     for (E e : getSubjectGenerator().order(new ArrayList<E>(getSampleElements()))) {
       list.add(e);
     }
-    return Collections.unmodifiableList(list);
+    return unmodifiableList(list);
   }
 
   /**
diff --git a/guava-testlib/src/com/google/common/collect/testing/AbstractIteratorTester.java b/guava-testlib/src/com/google/common/collect/testing/AbstractIteratorTester.java
index f1b8f86d1b..308b4dc355 100644
--- a/guava-testlib/src/com/google/common/collect/testing/AbstractIteratorTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/AbstractIteratorTester.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Collections.frequency;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.fail;
 
@@ -23,7 +25,6 @@ import com.google.common.annotations.GwtCompatible;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
@@ -277,9 +278,7 @@ abstract class AbstractIteratorTester<E, I extends Iterator<E>> {
     // periodically we should manually try (steps * 3 / 2) here; all tests but
     // one should still pass (testVerifyGetsCalled()).
     stimuli = new Stimulus[steps];
-    if (!elementsToInsertIterable.iterator().hasNext()) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(elementsToInsertIterable.iterator().hasNext());
     elementsToInsert = Helpers.cycle(elementsToInsertIterable);
     this.features = Helpers.copyToSet(features);
     this.expectedElements = Helpers.copyToList(expectedElements);
@@ -352,7 +351,7 @@ abstract class AbstractIteratorTester<E, I extends Iterator<E>> {
   }
 
   private void compareResultsForThisListOfStimuli() {
-    int removes = Collections.frequency(Arrays.asList(stimuli), remove);
+    int removes = frequency(Arrays.asList(stimuli), remove);
     if ((!features.contains(IteratorFeature.SUPPORTS_REMOVE) && removes > 1)
         || (stimuli.length >= 5 && removes > 2)) {
       // removes are the most expensive thing to test, since they often throw exceptions with stack
diff --git a/guava-testlib/src/com/google/common/collect/testing/AbstractMapTester.java b/guava-testlib/src/com/google/common/collect/testing/AbstractMapTester.java
index 590c23be8c..51caab51b7 100644
--- a/guava-testlib/src/com/google/common/collect/testing/AbstractMapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/AbstractMapTester.java
@@ -145,8 +145,8 @@ public abstract class AbstractMapTester<K, V>
     }
   }
 
-  @SuppressWarnings("unchecked")
   @Override
+  @SuppressWarnings("unchecked")
   protected MinimalCollection<Entry<K, V>> createDisjointCollection() {
     return MinimalCollection.of(e3(), e4());
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/DerivedCollectionGenerators.java b/guava-testlib/src/com/google/common/collect/testing/DerivedCollectionGenerators.java
index a04d3ffe30..02641f5ae4 100644
--- a/guava-testlib/src/com/google/common/collect/testing/DerivedCollectionGenerators.java
+++ b/guava-testlib/src/com/google/common/collect/testing/DerivedCollectionGenerators.java
@@ -20,6 +20,7 @@ import static com.google.common.collect.testing.Helpers.castOrCopyToList;
 import static com.google.common.collect.testing.Helpers.equal;
 import static com.google.common.collect.testing.Helpers.mapEntry;
 import static java.util.Collections.sort;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.ArrayList;
@@ -239,8 +240,7 @@ public final class DerivedCollectionGenerators {
     @Override
     public V[] createArray(int length) {
       // noinspection UnnecessaryLocalVariable
-      V[] vs = ((TestMapGenerator<K, V>) mapGenerator.getInnerGenerator()).createValueArray(length);
-      return vs;
+      return ((TestMapGenerator<K, V>) mapGenerator.getInnerGenerator()).createValueArray(length);
     }
 
     @Override
@@ -379,9 +379,7 @@ public final class DerivedCollectionGenerators {
 
       // nulls are usually out of bounds for a subset, so ban them altogether
       for (Object o : elements) {
-        if (o == null) {
-          throw new NullPointerException();
-        }
+        requireNonNull(o);
       }
 
       // prepare extreme values to be filtered out of view
diff --git a/guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java
index db086aa307..b5c0bb39e1 100644
--- a/guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilder.java
@@ -16,7 +16,10 @@
 
 package com.google.common.collect.testing;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static java.util.Collections.disjoint;
+import static java.util.Collections.unmodifiableSet;
 import static java.util.logging.Level.FINER;
 
 import com.google.common.annotations.GwtIncompatible;
@@ -28,7 +31,6 @@ import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
@@ -114,7 +116,7 @@ public abstract class FeatureSpecificTestSuiteBuilder<
   }
 
   public Set<Feature<?>> getFeatures() {
-    return Collections.unmodifiableSet(features);
+    return unmodifiableSet(features);
   }
 
   // Name
@@ -123,11 +125,10 @@ public abstract class FeatureSpecificTestSuiteBuilder<
 
   /** Configures this builder produce a TestSuite with the given name. */
   public B named(String name) {
-    if (name.contains("(")) {
-      throw new IllegalArgumentException(
-          "Eclipse hides all characters after "
-              + "'('; please use '[]' or other characters instead of parentheses");
-    }
+    checkArgument(
+        !name.contains("("),
+        "Eclipse hides all characters after "
+            + "'('; please use '[]' or other characters instead of parentheses");
     this.name = name;
     return self();
   }
@@ -196,15 +197,9 @@ public abstract class FeatureSpecificTestSuiteBuilder<
 
   /** Throw {@link IllegalStateException} if {@link #createTestSuite()} can't be called yet. */
   protected void checkCanCreate() {
-    if (subjectGenerator == null) {
-      throw new IllegalStateException("Call using() before createTestSuite().");
-    }
-    if (name == null) {
-      throw new IllegalStateException("Call named() before createTestSuite().");
-    }
-    if (features == null) {
-      throw new IllegalStateException("Call withFeatures() before createTestSuite().");
-    }
+    checkState(subjectGenerator != null, "Call using() before createTestSuite().");
+    checkState(name != null, "Call named() before createTestSuite().");
+    checkState(features != null, "Call withFeatures() before createTestSuite().");
   }
 
   // Class parameters must be raw.
diff --git a/guava-testlib/src/com/google/common/collect/testing/Helpers.java b/guava-testlib/src/com/google/common/collect/testing/Helpers.java
index aac71cc4ef..c7acb76648 100644
--- a/guava-testlib/src/com/google/common/collect/testing/Helpers.java
+++ b/guava-testlib/src/com/google/common/collect/testing/Helpers.java
@@ -16,13 +16,16 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Collections.singletonMap;
 import static java.util.Collections.sort;
+import static java.util.Objects.requireNonNull;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.collect.Iterables;
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
@@ -71,13 +74,13 @@ public class Helpers {
 
   // Would use Maps.immutableEntry
   public static <K, V> Entry<K, V> mapEntry(K key, V value) {
-    return Collections.singletonMap(key, value).entrySet().iterator().next();
+    return singletonMap(key, value).entrySet().iterator().next();
   }
 
   private static boolean isEmpty(Iterable<?> iterable) {
     return iterable instanceof Collection
         ? ((Collection<?>) iterable).isEmpty()
-        : !iterable.iterator().hasNext();
+        : Iterables.isEmpty(iterable);
   }
 
   public static void assertEmpty(Iterable<?> iterable) {
@@ -380,8 +383,8 @@ public class Helpers {
         throw new UnsupportedOperationException();
       }
 
-      @SuppressWarnings("unchecked")
       @Override
+      @SuppressWarnings("unchecked")
       public boolean equals(Object o) {
         if (o instanceof Entry) {
           Entry<K, V> e = (Entry<K, V>) o;
@@ -419,8 +422,8 @@ public class Helpers {
 
   private static final Comparator<Comparable> NATURAL_ORDER =
       new Comparator<Comparable>() {
-        @SuppressWarnings("unchecked") // assume any Comparable is Comparable<Self>
-        @Override
+        @Override // assume any Comparable is Comparable<Self>
+        @SuppressWarnings("unchecked")
         public int compare(Comparable left, Comparable right) {
           return left.compareTo(right);
         }
@@ -452,9 +455,7 @@ public class Helpers {
     @GwtTransient private final String justAfterNull;
 
     protected NullsBefore(String justAfterNull) {
-      if (justAfterNull == null) {
-        throw new NullPointerException();
-      }
+      requireNonNull(justAfterNull);
 
       this.justAfterNull = justAfterNull;
     }
diff --git a/guava-testlib/src/com/google/common/collect/testing/IteratorFeature.java b/guava-testlib/src/com/google/common/collect/testing/IteratorFeature.java
index c447e2922e..1a5dfb5a83 100644
--- a/guava-testlib/src/com/google/common/collect/testing/IteratorFeature.java
+++ b/guava-testlib/src/com/google/common/collect/testing/IteratorFeature.java
@@ -16,8 +16,10 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Collections.emptySet;
+import static java.util.Collections.unmodifiableSet;
+
 import com.google.common.annotations.GwtCompatible;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.ListIterator;
@@ -49,12 +51,12 @@ public enum IteratorFeature {
    * A set containing none of the optional features of the {@link Iterator} or {@link ListIterator}
    * interfaces.
    */
-  public static final Set<IteratorFeature> UNMODIFIABLE = Collections.emptySet();
+  public static final Set<IteratorFeature> UNMODIFIABLE = emptySet();
 
   /**
    * A set containing all of the optional features of the {@link Iterator} and {@link ListIterator}
    * interfaces.
    */
   public static final Set<IteratorFeature> MODIFIABLE =
-      Collections.unmodifiableSet(EnumSet.allOf(IteratorFeature.class));
+      unmodifiableSet(EnumSet.allOf(IteratorFeature.class));
 }
diff --git a/guava-testlib/src/com/google/common/collect/testing/MapInterfaceTest.java b/guava-testlib/src/com/google/common/collect/testing/MapInterfaceTest.java
index 4849138785..1cbe2ae1b9 100644
--- a/guava-testlib/src/com/google/common/collect/testing/MapInterfaceTest.java
+++ b/guava-testlib/src/com/google/common/collect/testing/MapInterfaceTest.java
@@ -16,12 +16,14 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.emptySet;
 import static java.util.Collections.singleton;
+import static java.util.Collections.singletonMap;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
@@ -173,7 +175,7 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
 
     assertEquals(map.size() == 0, map.isEmpty());
     assertEquals(map.size(), keySet.size());
-    assertEquals(keySet.size() == 0, keySet.isEmpty());
+    assertEquals(keySet.isEmpty(), keySet.isEmpty());
     assertEquals(!keySet.isEmpty(), keySet.iterator().hasNext());
 
     int expectedKeySetHash = 0;
@@ -183,14 +185,14 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
       assertTrue(map.containsKey(key));
       assertTrue(map.containsValue(value));
       assertTrue(valueCollection.contains(value));
-      assertTrue(valueCollection.containsAll(Collections.singleton(value)));
+      assertTrue(valueCollection.containsAll(singleton(value)));
       assertTrue(entrySet.contains(mapEntry(key, value)));
       assertTrue(allowsNullKeys || (key != null));
     }
     assertEquals(expectedKeySetHash, keySet.hashCode());
 
     assertEquals(map.size(), valueCollection.size());
-    assertEquals(valueCollection.size() == 0, valueCollection.isEmpty());
+    assertEquals(valueCollection.isEmpty(), valueCollection.isEmpty());
     assertEquals(!valueCollection.isEmpty(), valueCollection.iterator().hasNext());
     for (V value : valueCollection) {
       assertTrue(map.containsValue(value));
@@ -198,7 +200,7 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
     }
 
     assertEquals(map.size(), entrySet.size());
-    assertEquals(entrySet.size() == 0, entrySet.isEmpty());
+    assertEquals(entrySet.isEmpty(), entrySet.isEmpty());
     assertEquals(!entrySet.isEmpty(), entrySet.iterator().hasNext());
     assertEntrySetNotContainsString(entrySet);
 
@@ -847,7 +849,7 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
     // Explicitly call `equals`; `assertEquals` might return fast
     assertTrue(map.equals(map));
     assertTrue(makePopulatedMap().equals(map));
-    assertFalse(map.equals(Collections.emptyMap()));
+    assertFalse(map.equals(emptyMap()));
     // no-inspection ObjectEqualsNull
     assertFalse(map.equals(null));
   }
@@ -899,8 +901,8 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
     // Explicitly call `equals`; `assertEquals` might return fast
     assertTrue(map.equals(map));
     assertTrue(makeEmptyMap().equals(map));
-    assertEquals(Collections.emptyMap(), map);
-    assertFalse(map.equals(Collections.emptySet()));
+    assertEquals(emptyMap(), map);
+    assertFalse(map.equals(emptySet()));
     // noinspection ObjectEqualsNull
     assertFalse(map.equals(null));
   }
@@ -1130,7 +1132,7 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
     } catch (UnsupportedOperationException e) {
       return;
     }
-    Map<K, V> mapToPut = Collections.singletonMap(keyToPut, valueToPut);
+    Map<K, V> mapToPut = singletonMap(keyToPut, valueToPut);
     if (supportsPut) {
       int initialSize = map.size();
       map.putAll(mapToPut);
@@ -1159,7 +1161,7 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
       return;
     }
     keyToPut = map.keySet().iterator().next();
-    Map<K, V> mapToPut = Collections.singletonMap(keyToPut, valueToPut);
+    Map<K, V> mapToPut = singletonMap(keyToPut, valueToPut);
     int initialSize = map.size();
     if (supportsPut) {
       map.putAll(mapToPut);
@@ -1267,12 +1269,12 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
     K key = keys.iterator().next();
     if (supportsRemove) {
       int initialSize = map.size();
-      assertTrue(keys.removeAll(Collections.singleton(key)));
+      assertTrue(keys.removeAll(singleton(key)));
       assertEquals(initialSize - 1, map.size());
       assertFalse(map.containsKey(key));
     } else {
       try {
-        keys.removeAll(Collections.singleton(key));
+        keys.removeAll(singleton(key));
         fail("Expected UnsupportedOperationException.");
       } catch (UnsupportedOperationException expected) {
       }
@@ -1291,12 +1293,12 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
     Set<K> keys = map.keySet();
     K key = keys.iterator().next();
     if (supportsRemove) {
-      keys.retainAll(Collections.singleton(key));
+      keys.retainAll(singleton(key));
       assertEquals(1, map.size());
       assertTrue(map.containsKey(key));
     } else {
       try {
-        keys.retainAll(Collections.singleton(key));
+        keys.retainAll(singleton(key));
         fail("Expected UnsupportedOperationException.");
       } catch (UnsupportedOperationException expected) {
       }
@@ -1617,6 +1619,6 @@ public abstract class MapInterfaceTest<K, V> extends TestCase {
   }
 
   static <K, V> Entry<K, V> mapEntry(K key, V value) {
-    return Collections.singletonMap(key, value).entrySet().iterator().next();
+    return singletonMap(key, value).entrySet().iterator().next();
   }
 }
diff --git a/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java
index d1ce3413dd..e628c81287 100644
--- a/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/MapTestSuiteBuilder.java
@@ -73,8 +73,8 @@ public class MapTestSuiteBuilder<K, V>
     return new MapTestSuiteBuilder<K, V>().usingGenerator(generator);
   }
 
-  @SuppressWarnings("unchecked") // Class parameters must be raw.
-  @Override
+  @Override // Class parameters must be raw.
+  @SuppressWarnings("unchecked")
   protected List<Class<? extends AbstractTester>> getTesters() {
     return Arrays.<Class<? extends AbstractTester>>asList(
         MapClearTester.class,
diff --git a/guava-testlib/src/com/google/common/collect/testing/MinimalCollection.java b/guava-testlib/src/com/google/common/collect/testing/MinimalCollection.java
index 2adf072514..f328da0c18 100644
--- a/guava-testlib/src/com/google/common/collect/testing/MinimalCollection.java
+++ b/guava-testlib/src/com/google/common/collect/testing/MinimalCollection.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtCompatible;
 import java.util.AbstractCollection;
 import java.util.Arrays;
@@ -54,9 +56,7 @@ public class MinimalCollection<E> extends AbstractCollection<E> {
 
     if (!allowNulls) {
       for (Object element : contents) {
-        if (element == null) {
-          throw new NullPointerException();
-        }
+        requireNonNull(element);
       }
     }
   }
@@ -70,9 +70,7 @@ public class MinimalCollection<E> extends AbstractCollection<E> {
   public boolean contains(Object object) {
     if (!allowNulls) {
       // behave badly
-      if (object == null) {
-        throw new NullPointerException();
-      }
+      requireNonNull(object);
     }
     Platform.checkCast(type, object); // behave badly
     return Arrays.asList(contents).contains(object);
@@ -83,9 +81,7 @@ public class MinimalCollection<E> extends AbstractCollection<E> {
     if (!allowNulls) {
       for (Object object : collection) {
         // behave badly
-        if (object == null) {
-          throw new NullPointerException();
-        }
+        requireNonNull(object);
       }
     }
     return super.containsAll(collection);
diff --git a/guava-testlib/src/com/google/common/collect/testing/NavigableSetTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/NavigableSetTestSuiteBuilder.java
index 4c86ab4620..7f30d422fa 100644
--- a/guava-testlib/src/com/google/common/collect/testing/NavigableSetTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/NavigableSetTestSuiteBuilder.java
@@ -18,6 +18,7 @@ package com.google.common.collect.testing;
 
 import static com.google.common.collect.testing.features.CollectionFeature.DESCENDING_VIEW;
 import static com.google.common.collect.testing.features.CollectionFeature.SUBSET_VIEW;
+import static java.util.Collections.reverse;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.DerivedCollectionGenerators.Bound;
@@ -26,7 +27,6 @@ import com.google.common.collect.testing.features.Feature;
 import com.google.common.collect.testing.testers.NavigableSetNavigationTester;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.NavigableSet;
 import java.util.Set;
@@ -127,7 +127,7 @@ public final class NavigableSetTestSuiteBuilder<E> extends SortedSetTestSuiteBui
                 for (E e : delegate.order(insertionOrder)) {
                   list.add(e);
                 }
-                Collections.reverse(list);
+                reverse(list);
                 return list;
               }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/PerCollectionSizeTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/PerCollectionSizeTestSuiteBuilder.java
index c0068b4f92..a611f1e7f7 100644
--- a/guava-testlib/src/com/google/common/collect/testing/PerCollectionSizeTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/PerCollectionSizeTestSuiteBuilder.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.Feature;
@@ -74,12 +76,10 @@ public abstract class PerCollectionSizeTestSuiteBuilder<
 
     logger.fine("   Sizes: " + formatFeatureSet(sizesToTest));
 
-    if (sizesToTest.isEmpty()) {
-      throw new IllegalStateException(
-          name
-              + ": no CollectionSizes specified (check the argument to "
-              + "FeatureSpecificTestSuiteBuilder.withFeatures().)");
-    }
+    checkState(
+        !sizesToTest.isEmpty(),
+        "%s: no CollectionSizes specified (check the argument to FeatureSpecificTestSuiteBuilder.withFeatures().)",
+        name);
 
     TestSuite suite = new TestSuite(name);
     for (Feature<?> collectionSize : sizesToTest) {
diff --git a/guava-testlib/src/com/google/common/collect/testing/SafeTreeMap.java b/guava-testlib/src/com/google/common/collect/testing/SafeTreeMap.java
index 5856e3b543..8d5e5e4e9f 100644
--- a/guava-testlib/src/com/google/common/collect/testing/SafeTreeMap.java
+++ b/guava-testlib/src/com/google/common/collect/testing/SafeTreeMap.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.AbstractSet;
@@ -66,9 +68,7 @@ public final class SafeTreeMap<K, V> implements Serializable, NavigableMap<K, V>
 
   private SafeTreeMap(NavigableMap<K, V> delegate) {
     this.delegate = delegate;
-    if (delegate == null) {
-      throw new NullPointerException();
-    }
+    requireNonNull(delegate);
     for (K k : keySet()) {
       checkValid(k);
     }
@@ -89,8 +89,8 @@ public final class SafeTreeMap<K, V> implements Serializable, NavigableMap<K, V>
     delegate.clear();
   }
 
-  @SuppressWarnings("unchecked")
   @Override
+  @SuppressWarnings("unchecked")
   public Comparator<? super K> comparator() {
     Comparator<? super K> comparator = delegate.comparator();
     if (comparator == null) {
diff --git a/guava-testlib/src/com/google/common/collect/testing/SafeTreeSet.java b/guava-testlib/src/com/google/common/collect/testing/SafeTreeSet.java
index 91d9fd9f75..d5e21a01cd 100644
--- a/guava-testlib/src/com/google/common/collect/testing/SafeTreeSet.java
+++ b/guava-testlib/src/com/google/common/collect/testing/SafeTreeSet.java
@@ -90,8 +90,8 @@ public final class SafeTreeSet<E> implements Serializable, NavigableSet<E> {
     delegate.clear();
   }
 
-  @SuppressWarnings("unchecked")
   @Override
+  @SuppressWarnings("unchecked")
   public Comparator<? super E> comparator() {
     Comparator<? super E> comparator = delegate.comparator();
     if (comparator == null) {
diff --git a/guava-testlib/src/com/google/common/collect/testing/SortedMapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/SortedMapTestSuiteBuilder.java
index 7944aaa6a0..d43238afa5 100644
--- a/guava-testlib/src/com/google/common/collect/testing/SortedMapTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/SortedMapTestSuiteBuilder.java
@@ -17,6 +17,7 @@
 package com.google.common.collect.testing;
 
 import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;
+import static java.util.Collections.emptySet;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.DerivedCollectionGenerators.Bound;
@@ -24,7 +25,6 @@ import com.google.common.collect.testing.DerivedCollectionGenerators.SortedMapSu
 import com.google.common.collect.testing.features.Feature;
 import com.google.common.collect.testing.testers.SortedMapNavigationTester;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -94,7 +94,7 @@ public class SortedMapTestSuiteBuilder<K, V> extends MapTestSuiteBuilder<K, V> {
 
     @Override
     public Set<Feature<? super Void>> getImpliedFeatures() {
-      return Collections.emptySet();
+      return emptySet();
     }
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java b/guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java
index 93ad38ccc5..33e893c8c9 100644
--- a/guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java
@@ -16,11 +16,11 @@
 
 package com.google.common.collect.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.testing.Helpers.assertEqualIgnoringOrder;
 import static com.google.common.collect.testing.Helpers.assertEqualInOrder;
 import static com.google.common.collect.testing.Platform.format;
 import static java.util.Comparator.naturalOrder;
+import static java.util.Objects.requireNonNull;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
@@ -57,7 +57,7 @@ public final class SpliteratorTester<E> {
     final Spliterator<E> spliterator;
 
     GeneralSpliterator(Spliterator<E> spliterator) {
-      this.spliterator = checkNotNull(spliterator);
+      this.spliterator = requireNonNull(spliterator);
     }
 
     abstract void forEachRemaining(Consumer<? super E> action);
@@ -277,7 +277,7 @@ public final class SpliteratorTester<E> {
   private final ImmutableSet<Supplier<GeneralSpliterator<E>>> spliteratorSuppliers;
 
   private SpliteratorTester(ImmutableSet<Supplier<GeneralSpliterator<E>>> spliteratorSuppliers) {
-    this.spliteratorSuppliers = checkNotNull(spliteratorSuppliers);
+    this.spliteratorSuppliers = requireNonNull(spliteratorSuppliers);
   }
 
   @SafeVarargs
diff --git a/guava-testlib/src/com/google/common/collect/testing/TestsForListsInJavaUtil.java b/guava-testlib/src/com/google/common/collect/testing/TestsForListsInJavaUtil.java
index e8eae2c252..d109b0c178 100644
--- a/guava-testlib/src/com/google/common/collect/testing/TestsForListsInJavaUtil.java
+++ b/guava-testlib/src/com/google/common/collect/testing/TestsForListsInJavaUtil.java
@@ -23,6 +23,11 @@ import static com.google.common.collect.testing.testers.ListSubListTester.getSub
 import static com.google.common.collect.testing.testers.ListSubListTester.getSubListOriginalListSetAffectsSubListMethod;
 import static com.google.common.collect.testing.testers.ListSubListTester.getSubListSubListRemoveAffectsOriginalLargeListMethod;
 import static java.util.Arrays.asList;
+import static java.util.Collections.checkedList;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptySet;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.unmodifiableList;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.features.CollectionFeature;
@@ -72,23 +77,23 @@ public class TestsForListsInJavaUtil {
   }
 
   protected Collection<Method> suppressForEmptyList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForSingletonList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForArraysAsList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForArrayList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForLinkedList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForCopyOnWriteArrayList() {
@@ -102,23 +107,23 @@ public class TestsForListsInJavaUtil {
   }
 
   protected Collection<Method> suppressForUnmodifiableList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForCheckedList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForAbstractList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForAbstractSequentialList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForVector() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   public Test testsForEmptyList() {
@@ -126,7 +131,7 @@ public class TestsForListsInJavaUtil {
             new TestStringListGenerator() {
               @Override
               public List<String> create(String[] elements) {
-                return Collections.emptyList();
+                return emptyList();
               }
             })
         .named("emptyList")
@@ -140,7 +145,7 @@ public class TestsForListsInJavaUtil {
             new TestStringListGenerator() {
               @Override
               public List<String> create(String[] elements) {
-                return Collections.singletonList(elements[0]);
+                return singletonList(elements[0]);
               }
             })
         .named("singletonList")
@@ -237,7 +242,7 @@ public class TestsForListsInJavaUtil {
               public List<String> create(String[] elements) {
                 List<String> innerList = new ArrayList<>();
                 Collections.addAll(innerList, elements);
-                return Collections.unmodifiableList(innerList);
+                return unmodifiableList(innerList);
               }
             })
         .named("unmodifiableList/ArrayList")
@@ -256,7 +261,7 @@ public class TestsForListsInJavaUtil {
               public List<String> create(String[] elements) {
                 List<String> innerList = new ArrayList<>();
                 Collections.addAll(innerList, elements);
-                return Collections.checkedList(innerList, String.class);
+                return checkedList(innerList, String.class);
               }
             })
         .named("checkedList/ArrayList")
diff --git a/guava-testlib/src/com/google/common/collect/testing/TestsForMapsInJavaUtil.java b/guava-testlib/src/com/google/common/collect/testing/TestsForMapsInJavaUtil.java
index fed059c399..5dfd095eeb 100644
--- a/guava-testlib/src/com/google/common/collect/testing/TestsForMapsInJavaUtil.java
+++ b/guava-testlib/src/com/google/common/collect/testing/TestsForMapsInJavaUtil.java
@@ -17,6 +17,18 @@
 package com.google.common.collect.testing;
 
 import static java.util.Arrays.asList;
+import static java.util.Collections.checkedMap;
+import static java.util.Collections.checkedNavigableMap;
+import static java.util.Collections.checkedSortedMap;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.emptyNavigableMap;
+import static java.util.Collections.emptySet;
+import static java.util.Collections.emptySortedMap;
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.synchronizedNavigableMap;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Collections.unmodifiableNavigableMap;
+import static java.util.Collections.unmodifiableSortedMap;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.features.CollectionFeature;
@@ -26,7 +38,6 @@ import com.google.common.collect.testing.testers.MapEntrySetTester;
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.EnumMap;
 import java.util.HashMap;
@@ -81,75 +92,75 @@ public class TestsForMapsInJavaUtil {
   }
 
   protected Collection<Method> suppressForCheckedMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForCheckedNavigableMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForCheckedSortedMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForEmptyMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   private Collection<Method> suppressForEmptyNavigableMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   private Collection<Method> suppressForEmptySortedMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForSingletonMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForHashMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForHashtable() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForLinkedHashMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForSynchronizedNavigableMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForTreeMapNatural() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForTreeMapWithComparator() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForUnmodifiableMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForUnmodifiableNavigableMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForUnmodifiableSortedMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForEnumMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForConcurrentHashMap() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForConcurrentSkipListMap() {
@@ -165,7 +176,7 @@ public class TestsForMapsInJavaUtil {
               @Override
               protected Map<String, String> create(Entry<String, String>[] entries) {
                 Map<String, String> map = populate(new HashMap<String, String>(), entries);
-                return Collections.checkedMap(map, String.class, String.class);
+                return checkedMap(map, String.class, String.class);
               }
             })
         .named("checkedMap/HashMap")
@@ -190,7 +201,7 @@ public class TestsForMapsInJavaUtil {
               @Override
               protected NavigableMap<String, String> create(Entry<String, String>[] entries) {
                 NavigableMap<String, String> map = populate(new TreeMap<String, String>(), entries);
-                return Collections.checkedNavigableMap(map, String.class, String.class);
+                return checkedNavigableMap(map, String.class, String.class);
               }
             })
         .named("checkedNavigableMap/TreeMap, natural")
@@ -214,7 +225,7 @@ public class TestsForMapsInJavaUtil {
               @Override
               protected SortedMap<String, String> create(Entry<String, String>[] entries) {
                 SortedMap<String, String> map = populate(new TreeMap<String, String>(), entries);
-                return Collections.checkedSortedMap(map, String.class, String.class);
+                return checkedSortedMap(map, String.class, String.class);
               }
             })
         .named("checkedSortedMap/TreeMap, natural")
@@ -237,7 +248,7 @@ public class TestsForMapsInJavaUtil {
             new TestStringMapGenerator() {
               @Override
               protected Map<String, String> create(Entry<String, String>[] entries) {
-                return Collections.emptyMap();
+                return emptyMap();
               }
             })
         .named("emptyMap")
@@ -251,7 +262,7 @@ public class TestsForMapsInJavaUtil {
             new TestStringSortedMapGenerator() {
               @Override
               protected NavigableMap<String, String> create(Entry<String, String>[] entries) {
-                return Collections.emptyNavigableMap();
+                return emptyNavigableMap();
               }
             })
         .named("emptyNavigableMap")
@@ -265,7 +276,7 @@ public class TestsForMapsInJavaUtil {
             new TestStringSortedMapGenerator() {
               @Override
               protected SortedMap<String, String> create(Entry<String, String>[] entries) {
-                return Collections.emptySortedMap();
+                return emptySortedMap();
               }
             })
         .named("emptySortedMap")
@@ -279,7 +290,7 @@ public class TestsForMapsInJavaUtil {
             new TestStringMapGenerator() {
               @Override
               protected Map<String, String> create(Entry<String, String>[] entries) {
-                return Collections.singletonMap(entries[0].getKey(), entries[0].getValue());
+                return singletonMap(entries[0].getKey(), entries[0].getValue());
               }
             })
         .named("singletonMap")
@@ -371,7 +382,7 @@ public class TestsForMapsInJavaUtil {
               @Override
               protected SortedMap<String, String> create(Entry<String, String>[] entries) {
                 NavigableMap<String, String> delegate = populate(new TreeMap<>(), entries);
-                return Collections.synchronizedNavigableMap(delegate);
+                return synchronizedNavigableMap(delegate);
               }
             })
         .named("synchronizedNavigableMap/TreeMap, natural")
@@ -441,7 +452,7 @@ public class TestsForMapsInJavaUtil {
             new TestStringMapGenerator() {
               @Override
               protected Map<String, String> create(Entry<String, String>[] entries) {
-                return Collections.unmodifiableMap(toHashMap(entries));
+                return unmodifiableMap(toHashMap(entries));
               }
             })
         .named("unmodifiableMap/HashMap")
@@ -460,7 +471,7 @@ public class TestsForMapsInJavaUtil {
             new TestStringSortedMapGenerator() {
               @Override
               protected NavigableMap<String, String> create(Entry<String, String>[] entries) {
-                return Collections.unmodifiableNavigableMap(populate(new TreeMap<>(), entries));
+                return unmodifiableNavigableMap(populate(new TreeMap<>(), entries));
               }
             })
         .named("unmodifiableNavigableMap/TreeMap, natural")
@@ -479,7 +490,7 @@ public class TestsForMapsInJavaUtil {
               @Override
               protected SortedMap<String, String> create(Entry<String, String>[] entries) {
                 SortedMap<String, String> map = populate(new TreeMap<String, String>(), entries);
-                return Collections.unmodifiableSortedMap(map);
+                return unmodifiableSortedMap(map);
               }
             })
         .named("unmodifiableSortedMap/TreeMap, natural")
diff --git a/guava-testlib/src/com/google/common/collect/testing/TestsForQueuesInJavaUtil.java b/guava-testlib/src/com/google/common/collect/testing/TestsForQueuesInJavaUtil.java
index 1a9870daf6..c15d6603af 100644
--- a/guava-testlib/src/com/google/common/collect/testing/TestsForQueuesInJavaUtil.java
+++ b/guava-testlib/src/com/google/common/collect/testing/TestsForQueuesInJavaUtil.java
@@ -16,13 +16,15 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Collections.checkedQueue;
+import static java.util.Collections.emptySet;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import java.lang.reflect.Method;
 import java.util.ArrayDeque;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.LinkedList;
 import java.util.PriorityQueue;
 import java.util.Queue;
@@ -63,43 +65,43 @@ public class TestsForQueuesInJavaUtil {
   }
 
   protected Collection<Method> suppressForCheckedQueue() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForArrayDeque() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForLinkedList() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForArrayBlockingQueue() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForConcurrentLinkedDeque() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForConcurrentLinkedQueue() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForLinkedBlockingDeque() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForLinkedBlockingQueue() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForPriorityBlockingQueue() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForPriorityQueue() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   public Test testsForCheckedQueue() {
@@ -108,7 +110,7 @@ public class TestsForQueuesInJavaUtil {
               @Override
               public Queue<String> create(String[] elements) {
                 Queue<String> queue = new LinkedList<>(MinimalCollection.of(elements));
-                return Collections.checkedQueue(queue, String.class);
+                return checkedQueue(queue, String.class);
               }
             })
         .named("checkedQueue/LinkedList")
diff --git a/guava-testlib/src/com/google/common/collect/testing/TestsForSetsInJavaUtil.java b/guava-testlib/src/com/google/common/collect/testing/TestsForSetsInJavaUtil.java
index 0141d8daf4..fcf5e98379 100644
--- a/guava-testlib/src/com/google/common/collect/testing/TestsForSetsInJavaUtil.java
+++ b/guava-testlib/src/com/google/common/collect/testing/TestsForSetsInJavaUtil.java
@@ -19,6 +19,16 @@ package com.google.common.collect.testing;
 import static com.google.common.collect.testing.testers.CollectionSpliteratorTester.getSpliteratorNotImmutableCollectionAllowsAddMethod;
 import static com.google.common.collect.testing.testers.CollectionSpliteratorTester.getSpliteratorNotImmutableCollectionAllowsRemoveMethod;
 import static java.util.Arrays.asList;
+import static java.util.Collections.checkedNavigableSet;
+import static java.util.Collections.checkedSet;
+import static java.util.Collections.checkedSortedSet;
+import static java.util.Collections.emptyNavigableSet;
+import static java.util.Collections.emptySet;
+import static java.util.Collections.emptySortedSet;
+import static java.util.Collections.singleton;
+import static java.util.Collections.synchronizedNavigableSet;
+import static java.util.Collections.unmodifiableNavigableSet;
+import static java.util.Collections.unmodifiableSet;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.features.CollectionFeature;
@@ -82,47 +92,47 @@ public class TestsForSetsInJavaUtil {
   }
 
   protected Collection<Method> suppressForCheckedNavigableSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForEmptySet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForEmptyNavigableSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForEmptySortedSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForSingletonSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForHashSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForLinkedHashSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForEnumSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForSynchronizedNavigableSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForTreeSetNatural() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForTreeSetWithComparator() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForCopyOnWriteArraySet() {
@@ -132,31 +142,31 @@ public class TestsForSetsInJavaUtil {
   }
 
   protected Collection<Method> suppressForUnmodifiableSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForUnmodifiableNavigableSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForCheckedSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForCheckedSortedSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForAbstractSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForConcurrentSkipListSetNatural() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   protected Collection<Method> suppressForConcurrentSkipListSetWithComparator() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   public Test testsForCheckedNavigableSet() {
@@ -166,7 +176,7 @@ public class TestsForSetsInJavaUtil {
               public NavigableSet<String> create(String[] elements) {
                 NavigableSet<String> innerSet = new TreeSet<>();
                 Collections.addAll(innerSet, elements);
-                return Collections.checkedNavigableSet(innerSet, String.class);
+                return checkedNavigableSet(innerSet, String.class);
               }
             })
         .named("checkedNavigableSet/TreeSet, natural")
@@ -186,7 +196,7 @@ public class TestsForSetsInJavaUtil {
             new TestStringSetGenerator() {
               @Override
               public Set<String> create(String[] elements) {
-                return Collections.emptySet();
+                return emptySet();
               }
             })
         .named("emptySet")
@@ -200,7 +210,7 @@ public class TestsForSetsInJavaUtil {
             new TestStringSortedSetGenerator() {
               @Override
               public NavigableSet<String> create(String[] elements) {
-                return Collections.emptyNavigableSet();
+                return emptyNavigableSet();
               }
             })
         .named("emptyNavigableSet")
@@ -214,7 +224,7 @@ public class TestsForSetsInJavaUtil {
             new TestStringSortedSetGenerator() {
               @Override
               public SortedSet<String> create(String[] elements) {
-                return Collections.emptySortedSet();
+                return emptySortedSet();
               }
             })
         .named("emptySortedSet")
@@ -228,7 +238,7 @@ public class TestsForSetsInJavaUtil {
             new TestStringSetGenerator() {
               @Override
               public Set<String> create(String[] elements) {
-                return Collections.singleton(elements[0]);
+                return singleton(elements[0]);
               }
             })
         .named("singleton")
@@ -310,7 +320,7 @@ public class TestsForSetsInJavaUtil {
               @Override
               public SortedSet<String> create(String[] elements) {
                 NavigableSet<String> delegate = new TreeSet<>(MinimalCollection.of(elements));
-                return Collections.synchronizedNavigableSet(delegate);
+                return synchronizedNavigableSet(delegate);
               }
             })
         .named("synchronizedNavigableSet/TreeSet, natural")
@@ -392,7 +402,7 @@ public class TestsForSetsInJavaUtil {
               public Set<String> create(String[] elements) {
                 Set<String> innerSet = new HashSet<>();
                 Collections.addAll(innerSet, elements);
-                return Collections.unmodifiableSet(innerSet);
+                return unmodifiableSet(innerSet);
               }
             })
         .named("unmodifiableSet/HashSet")
@@ -412,7 +422,7 @@ public class TestsForSetsInJavaUtil {
               public NavigableSet<String> create(String[] elements) {
                 NavigableSet<String> innerSet = new TreeSet<>();
                 Collections.addAll(innerSet, elements);
-                return Collections.unmodifiableNavigableSet(innerSet);
+                return unmodifiableNavigableSet(innerSet);
               }
             })
         .named("unmodifiableNavigableSet/TreeSet, natural")
@@ -432,7 +442,7 @@ public class TestsForSetsInJavaUtil {
               public Set<String> create(String[] elements) {
                 Set<String> innerSet = new HashSet<>();
                 Collections.addAll(innerSet, elements);
-                return Collections.checkedSet(innerSet, String.class);
+                return checkedSet(innerSet, String.class);
               }
             })
         .named("checkedSet/HashSet")
@@ -453,7 +463,7 @@ public class TestsForSetsInJavaUtil {
               public SortedSet<String> create(String[] elements) {
                 SortedSet<String> innerSet = new TreeSet<>();
                 Collections.addAll(innerSet, elements);
-                return Collections.checkedSortedSet(innerSet, String.class);
+                return checkedSortedSet(innerSet, String.class);
               }
             })
         .named("checkedSortedSet/TreeSet, natural")
diff --git a/guava-testlib/src/com/google/common/collect/testing/features/CollectionSize.java b/guava-testlib/src/com/google/common/collect/testing/features/CollectionSize.java
index 6203e51486..7df8de2682 100644
--- a/guava-testlib/src/com/google/common/collect/testing/features/CollectionSize.java
+++ b/guava-testlib/src/com/google/common/collect/testing/features/CollectionSize.java
@@ -16,13 +16,15 @@
 
 package com.google.common.collect.testing.features;
 
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.Collections.emptySet;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.testing.Helpers;
 import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Set;
 
 /**
@@ -62,7 +64,7 @@ public enum CollectionSize implements Feature<Collection>, Comparable<Collection
   private final Integer numElements;
 
   CollectionSize(int numElements) {
-    this.implied = Collections.emptySet();
+    this.implied = emptySet();
     this.numElements = numElements;
   }
 
@@ -79,10 +81,8 @@ public enum CollectionSize implements Feature<Collection>, Comparable<Collection
   }
 
   public int getNumElements() {
-    if (numElements == null) {
-      throw new IllegalStateException(
-          "A compound CollectionSize doesn't specify a number of elements.");
-    }
+    checkState(
+        numElements != null, "A compound CollectionSize doesn't specify a number of elements.");
     return numElements;
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/features/FeatureUtil.java b/guava-testlib/src/com/google/common/collect/testing/features/FeatureUtil.java
index 2d11a08634..d661bc8df6 100644
--- a/guava-testlib/src/com/google/common/collect/testing/features/FeatureUtil.java
+++ b/guava-testlib/src/com/google/common/collect/testing/features/FeatureUtil.java
@@ -16,6 +16,9 @@
 
 package com.google.common.collect.testing.features;
 
+import static java.util.Collections.disjoint;
+import static java.util.Collections.unmodifiableList;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.Helpers;
 import java.lang.annotation.Annotation;
@@ -23,7 +26,6 @@ import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Method;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -188,7 +190,7 @@ public class FeatureUtil {
         addImpliedFeatures(Helpers.<Feature<?>>copyToSet(presentFeatures));
     Set<Feature<?>> allAbsentFeatures =
         addImpliedFeatures(Helpers.<Feature<?>>copyToSet(absentFeatures));
-    if (!Collections.disjoint(allPresentFeatures, allAbsentFeatures)) {
+    if (!disjoint(allPresentFeatures, allAbsentFeatures)) {
       throw new ConflictingRequirementsException(
           "Annotation explicitly or "
               + "implicitly requires one or more features to be both present "
@@ -237,7 +239,7 @@ public class FeatureUtil {
             annotations.add(a);
           }
         }
-        annotations = Collections.unmodifiableList(annotations);
+        annotations = unmodifiableList(annotations);
         annotationCache.put(classOrMethod, annotations);
       }
       return annotations;
@@ -276,7 +278,7 @@ public class FeatureUtil {
       Set<Feature<?>> newFeatures,
       Object source)
       throws ConflictingRequirementsException {
-    if (!Collections.disjoint(newFeatures, earlierFeatures)) {
+    if (!disjoint(newFeatures, earlierFeatures)) {
       throw new ConflictingRequirementsException(
           String.format(
               Locale.ROOT,
diff --git a/guava-testlib/src/com/google/common/collect/testing/features/TesterAnnotation.java b/guava-testlib/src/com/google/common/collect/testing/features/TesterAnnotation.java
index 1831e417f0..02c900c07c 100644
--- a/guava-testlib/src/com/google/common/collect/testing/features/TesterAnnotation.java
+++ b/guava-testlib/src/com/google/common/collect/testing/features/TesterAnnotation.java
@@ -29,8 +29,8 @@ import java.lang.annotation.Target;
  *
  * @author George van den Driessche
  */
-@Target(value = {java.lang.annotation.ElementType.ANNOTATION_TYPE})
-@Retention(value = RetentionPolicy.RUNTIME)
+@Target(java.lang.annotation.ElementType.ANNOTATION_TYPE)
+@Retention(RetentionPolicy.RUNTIME)
 @Documented
 @GwtCompatible
 public @interface TesterAnnotation {}
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/AbstractListMultimapTester.java b/guava-testlib/src/com/google/common/collect/testing/google/AbstractListMultimapTester.java
index 7bce8b0120..f81f60f10e 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/AbstractListMultimapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/AbstractListMultimapTester.java
@@ -42,15 +42,15 @@ public class AbstractListMultimapTester<K, V>
     assertEqualInOrder(values, multimap().get(key));
 
     if (!values.isEmpty()) {
-      assertEqualInOrder(values, multimap().asMap().get(key));
+      assertEqualInOrder(values, multimap().get(key));
       assertFalse(multimap().isEmpty());
     } else {
-      assertNull(multimap().asMap().get(key));
+      assertNull(multimap().get(key));
     }
 
     assertEquals(values.size(), multimap().get(key).size());
-    assertEquals(values.size() > 0, multimap().containsKey(key));
-    assertEquals(values.size() > 0, multimap().keySet().contains(key));
-    assertEquals(values.size() > 0, multimap().keys().contains(key));
+    assertEquals(!values.isEmpty(), multimap().containsKey(key));
+    assertEquals(!values.isEmpty(), multimap().keySet().contains(key));
+    assertEquals(!values.isEmpty(), multimap().keys().contains(key));
   }
 }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultimapTester.java b/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultimapTester.java
index bcbbd135b0..73622275df 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultimapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultimapTester.java
@@ -150,17 +150,17 @@ public abstract class AbstractMultimapTester<K, V, M extends Multimap<K, V>>
     assertEqualIgnoringOrder(values, multimap().get(key));
 
     if (!values.isEmpty()) {
-      assertEqualIgnoringOrder(values, multimap().asMap().get(key));
+      assertEqualIgnoringOrder(values, multimap().get(key));
       assertFalse(multimap().isEmpty());
     } else {
-      assertNull(multimap().asMap().get(key));
+      assertNull(multimap().get(key));
     }
 
     assertEquals(values.size(), multimap().get(key).size());
 
-    assertEquals(values.size() > 0, multimap().containsKey(key));
-    assertEquals(values.size() > 0, multimap().keySet().contains(key));
-    assertEquals(values.size() > 0, multimap().keys().contains(key));
+    assertEquals(!values.isEmpty(), multimap().containsKey(key));
+    assertEquals(!values.isEmpty(), multimap().keySet().contains(key));
+    assertEquals(!values.isEmpty(), multimap().keys().contains(key));
   }
 
   protected final K k0() {
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultisetSetCountTester.java b/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultisetSetCountTester.java
index a72fd9fba5..bdcffa19f2 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultisetSetCountTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/AbstractMultisetSetCountTester.java
@@ -137,20 +137,20 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     }
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_oneToOne_addSupported() {
     assertOneToOne();
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_oneToOne_removeSupported() {
     assertOneToOne();
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(absent = {SUPPORTS_ADD, SUPPORTS_REMOVE})
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_oneToOne_unsupported() {
     try {
       assertOneToOne();
@@ -158,20 +158,20 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     }
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(SEVERAL)
   public void testSetCount_threeToThree_addSupported() {
     assertThreeToThree();
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testSetCount_threeToThree_removeSupported() {
     assertThreeToThree();
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(absent = {SUPPORTS_ADD, SUPPORTS_REMOVE})
+  @CollectionSize.Require(SEVERAL)
   public void testSetCount_threeToThree_unsupported() {
     try {
       assertThreeToThree();
@@ -186,7 +186,7 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     assertSetCount(e3(), 1);
   }
 
-  @CollectionFeature.Require({SUPPORTS_ADD, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_ADD})
   public void testSetCountZeroToOneConcurrentWithIteration() {
     try {
       Iterator<E> iterator = collection.iterator();
@@ -198,7 +198,7 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     }
   }
 
-  @CollectionFeature.Require({SUPPORTS_ADD, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_ADD})
   public void testSetCountZeroToOneConcurrentWithEntrySetIteration() {
     try {
       Iterator<Entry<E>> iterator = getMultiset().entrySet().iterator();
@@ -215,8 +215,8 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     assertSetCount(e3(), 3);
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_oneToThree_supported() {
     assertSetCount(e0(), 3);
   }
@@ -231,21 +231,21 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     assertSetCountIncreasingFailure(e3(), 3);
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(absent = SUPPORTS_ADD)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_oneToThree_unsupported() {
     assertSetCountIncreasingFailure(e3(), 3);
   }
 
   // Unconditional setCount size decreases:
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_oneToZero_supported() {
     assertSetCount(e0(), 0);
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
   public void testSetCountOneToZeroConcurrentWithIteration() {
     try {
@@ -258,7 +258,7 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     }
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
   public void testSetCountOneToZeroConcurrentWithEntrySetIteration() {
     try {
@@ -271,35 +271,35 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     }
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testSetCount_threeToZero_supported() {
     initThreeCopies();
     assertSetCount(e0(), 0);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testSetCount_threeToOne_supported() {
     initThreeCopies();
     assertSetCount(e0(), 1);
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(absent = SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_oneToZero_unsupported() {
     assertSetCountDecreasingFailure(e0(), 0);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(absent = SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testSetCount_threeToZero_unsupported() {
     initThreeCopies();
     assertSetCountDecreasingFailure(e0(), 0);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(absent = SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testSetCount_threeToOne_unsupported() {
     initThreeCopies();
     assertSetCountDecreasingFailure(e0(), 1);
@@ -307,15 +307,15 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
 
   // setCount with nulls:
 
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
   public void testSetCount_removeNull_nullSupported() {
     initCollectionWithNullElement();
     assertSetCount(null, 0);
   }
 
   @CollectionFeature.Require(
-      value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES},
+      value = {ALLOWS_NULL_VALUES, SUPPORTS_ADD},
       absent = RESTRICTS_ELEMENTS)
   public void testSetCount_addNull_nullSupported() {
     assertSetCount(null, 1);
@@ -346,8 +346,8 @@ public abstract class AbstractMultisetSetCountTester<E> extends AbstractMultiset
     }
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCount_existingNoNopNull_nullSupported() {
     initCollectionWithNullElement();
     try {
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/BiMapEntrySetTester.java b/guava-testlib/src/com/google/common/collect/testing/google/BiMapEntrySetTester.java
index 5c9a47989b..f23146406b 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/BiMapEntrySetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/BiMapEntrySetTester.java
@@ -31,8 +31,8 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class BiMapEntrySetTester<K, V> extends AbstractBiMapTester<K, V> {
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testSetValue_valueAbsent() {
     for (Entry<K, V> entry : getMap().entrySet()) {
       if (entry.getKey().equals(k0())) {
@@ -42,8 +42,8 @@ public class BiMapEntrySetTester<K, V> extends AbstractBiMapTester<K, V> {
     expectReplacement(entry(k0(), v3()));
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testSetValue_valuePresent() {
     for (Entry<K, V> entry : getMap().entrySet()) {
       if (entry.getKey().equals(k0())) {
@@ -57,8 +57,8 @@ public class BiMapEntrySetTester<K, V> extends AbstractBiMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testSetValueNullUnsupported() {
     for (Entry<K, V> entry : getMap().entrySet()) {
       try {
@@ -70,8 +70,8 @@ public class BiMapEntrySetTester<K, V> extends AbstractBiMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testSetValueNullSupported() {
     for (Entry<K, V> entry : getMap().entrySet()) {
       if (entry.getKey().equals(k0())) {
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/BiMapInverseTester.java b/guava-testlib/src/com/google/common/collect/testing/google/BiMapInverseTester.java
index 984558e2b7..460df42e9b 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/BiMapInverseTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/BiMapInverseTester.java
@@ -17,6 +17,7 @@
 package com.google.common.collect.testing.google;
 
 import static com.google.common.collect.testing.features.CollectionFeature.SERIALIZABLE;
+import static java.util.Collections.singletonList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -26,7 +27,6 @@ import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.testing.SerializableTester;
 import java.io.Serializable;
 import java.lang.reflect.Method;
-import java.util.Collections;
 import java.util.List;
 import org.junit.Ignore;
 
@@ -74,7 +74,7 @@ public class BiMapInverseTester<K, V> extends AbstractBiMapTester<K, V> {
    */
   @GwtIncompatible // reflection
   public static List<Method> getInverseSameAfterSerializingMethods() {
-    return Collections.singletonList(getMethod("testInverseSerialization"));
+    return singletonList(getMethod("testInverseSerialization"));
   }
 
   @GwtIncompatible // reflection
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/BiMapPutTester.java b/guava-testlib/src/com/google/common/collect/testing/google/BiMapPutTester.java
index 4bb72a2f38..23728e4aa9 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/BiMapPutTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/BiMapPutTester.java
@@ -34,9 +34,9 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
+  @SuppressWarnings("unchecked")
   public void testPutWithSameValueFails() {
     getMap().put(k0(), v0());
     try {
@@ -49,9 +49,9 @@ public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
     expectAdded(e0());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
+  @SuppressWarnings("unchecked")
   public void testPutPresentKeyDifferentValue() {
     getMap().put(k0(), v0());
     getMap().put(k0(), v1());
@@ -60,18 +60,18 @@ public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
     expectContents(Helpers.mapEntry(k0(), v1()));
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
+  @SuppressWarnings("unchecked")
   public void putDistinctKeysDistinctValues() {
     getMap().put(k0(), v0());
     getMap().put(k1(), v1());
     expectAdded(e0(), e1());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(ONE)
+  @MapFeature.Require(SUPPORTS_PUT)
+  @SuppressWarnings("unchecked")
   public void testForcePutKeyPresent() {
     getMap().forcePut(k0(), v1());
     expectContents(Helpers.mapEntry(k0(), v1()));
@@ -81,9 +81,9 @@ public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
     assertTrue(getMap().containsKey(k0()));
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(ONE)
+  @MapFeature.Require(SUPPORTS_PUT)
+  @SuppressWarnings("unchecked")
   public void testForcePutValuePresent() {
     getMap().forcePut(k1(), v0());
     expectContents(Helpers.mapEntry(k1(), v0()));
@@ -92,9 +92,9 @@ public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
     assertFalse(getMap().containsKey(k0()));
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_PUT)
+  @SuppressWarnings("unchecked")
   public void testForcePutKeyAndValuePresent() {
     getMap().forcePut(k0(), v1());
     expectContents(Helpers.mapEntry(k0(), v1()), Helpers.mapEntry(k2(), v2()));
@@ -103,9 +103,9 @@ public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
     assertFalse(getMap().containsValue(v0()));
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
   @CollectionSize.Require(ONE)
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
+  @SuppressWarnings("unchecked")
   public void testForcePutNullKeyPresent() {
     initMapWithNullKey();
 
@@ -122,9 +122,9 @@ public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
     assertEquals(1, getMap().size());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(ONE)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
+  @SuppressWarnings("unchecked")
   public void testForcePutNullValuePresent() {
     initMapWithNullValue();
 
@@ -143,9 +143,9 @@ public class BiMapPutTester<K, V> extends AbstractBiMapTester<K, V> {
 
   // nb: inverse is run through its own entire suite
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
+  @SuppressWarnings("unchecked")
   public void testInversePut() {
     getMap().put(k0(), v0());
     getMap().inverse().put(v1(), k1());
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/BiMapRemoveTester.java b/guava-testlib/src/com/google/common/collect/testing/google/BiMapRemoveTester.java
index e54256ad86..65cb0f1cf2 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/BiMapRemoveTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/BiMapRemoveTester.java
@@ -35,49 +35,49 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class BiMapRemoveTester<K, V> extends AbstractBiMapTester<K, V> {
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveKeyRemovesFromInverse() {
     getMap().remove(k0());
     expectMissing(e0());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveKeyFromKeySetRemovesFromInverse() {
     getMap().keySet().remove(k0());
     expectMissing(e0());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveFromValuesRemovesFromInverse() {
     getMap().values().remove(v0());
     expectMissing(e0());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveFromInverseRemovesFromForward() {
     getMap().inverse().remove(v0());
     expectMissing(e0());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveFromInverseKeySetRemovesFromForward() {
     getMap().inverse().keySet().remove(v0());
     expectMissing(e0());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveFromInverseValuesRemovesFromInverse() {
     getMap().inverse().values().remove(k0());
     expectMissing(e0());
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/BiMapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/google/BiMapTestSuiteBuilder.java
index 0821fb0b55..d3c40afc6d 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/BiMapTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/BiMapTestSuiteBuilder.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing.google;
 
+import static java.util.Collections.emptySet;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.BiMap;
 import com.google.common.collect.testing.AbstractTester;
@@ -32,7 +34,6 @@ import com.google.common.collect.testing.google.DerivedGoogleCollectionGenerator
 import com.google.common.collect.testing.google.DerivedGoogleCollectionGenerators.MapGenerator;
 import com.google.common.collect.testing.testers.SetCreationTester;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map.Entry;
@@ -69,7 +70,7 @@ public class BiMapTestSuiteBuilder<K, V>
 
     @Override
     public Set<Feature<? super Void>> getImpliedFeatures() {
-      return Collections.emptySet();
+      return emptySet();
     }
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/DerivedGoogleCollectionGenerators.java b/guava-testlib/src/com/google/common/collect/testing/google/DerivedGoogleCollectionGenerators.java
index 35579a01d7..0545fab220 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/DerivedGoogleCollectionGenerators.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/DerivedGoogleCollectionGenerators.java
@@ -69,14 +69,14 @@ public final class DerivedGoogleCollectionGenerators {
       return generator.order(insertionOrder);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public K[] createKeyArray(int length) {
       return (K[]) new Object[length];
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public V[] createValueArray(int length) {
       return (V[]) new Object[length];
     }
@@ -112,8 +112,8 @@ public final class DerivedGoogleCollectionGenerators {
       return Helpers.mapEntry(entry.getValue(), entry.getKey());
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public BiMap<V, K> create(Object... elements) {
       Entry<?, ?>[] entries = new Entry<?, ?>[elements.length];
       for (int i = 0; i < elements.length; i++) {
@@ -122,8 +122,8 @@ public final class DerivedGoogleCollectionGenerators {
       return generator.create((Object[]) entries).inverse();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Entry<V, K>[] createArray(int length) {
       return new Entry[length];
     }
@@ -133,14 +133,14 @@ public final class DerivedGoogleCollectionGenerators {
       return insertionOrder;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public V[] createKeyArray(int length) {
       return (V[]) new Object[length];
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public K[] createValueArray(int length) {
       return (K[]) new Object[length];
     }
@@ -194,9 +194,7 @@ public final class DerivedGoogleCollectionGenerators {
 
     @Override
     public V[] createArray(int length) {
-      V[] vs =
-          ((TestBiMapGenerator<K, V>) mapGenerator.getInnerGenerator()).createValueArray(length);
-      return vs;
+      return ((TestBiMapGenerator<K, V>) mapGenerator.getInnerGenerator()).createValueArray(length);
     }
 
     @Override
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/ListGenerators.java b/guava-testlib/src/com/google/common/collect/testing/google/ListGenerators.java
index 0839f09188..5a03acd60c 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/ListGenerators.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/ListGenerators.java
@@ -17,6 +17,7 @@
 package com.google.common.collect.testing.google;
 
 import static java.util.Arrays.asList;
+import static java.util.Collections.reverse;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableList;
@@ -28,7 +29,6 @@ import com.google.common.collect.testing.TestUnhashableCollectionGenerator;
 import com.google.common.collect.testing.UnhashableObject;
 import com.google.common.primitives.Chars;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -70,7 +70,7 @@ public final class ListGenerators {
     @Override
     protected List<String> create(String[] elements) {
       List<String> list = asList(elements);
-      Collections.reverse(list);
+      reverse(list);
       return ImmutableList.copyOf(list).reverse();
     }
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapAsMapTester.java b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapAsMapTester.java
index ca6f21af2c..fda2760af5 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapAsMapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapAsMapTester.java
@@ -16,6 +16,8 @@ package com.google.common.collect.testing.google;
 
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Lists;
@@ -27,7 +29,6 @@ import com.google.common.collect.testing.features.MapFeature;
 import com.google.common.testing.EqualsTester;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -52,7 +53,7 @@ public class ListMultimapAsMapTester<K, V> extends AbstractListMultimapTester<K,
 
   public void testAsMapGetImplementsList() {
     for (K key : multimap().keySet()) {
-      assertTrue(multimap().asMap().get(key) instanceof List);
+      assertTrue(multimap().get(key) instanceof List);
     }
   }
 
@@ -90,9 +91,8 @@ public class ListMultimapAsMapTester<K, V> extends AbstractListMultimapTester<K,
   public void testValuesRemove() {
     resetContainer(
         Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k1(), v0()), Helpers.mapEntry(k0(), v3()));
-    assertTrue(multimap().asMap().values().remove(Collections.singletonList(v0())));
+    assertTrue(multimap().asMap().values().remove(singletonList(v0())));
     assertEquals(2, multimap().size());
-    assertEquals(
-        Collections.singletonMap(k0(), Lists.newArrayList(v0(), v3())), multimap().asMap());
+    assertEquals(singletonMap(k0(), Lists.newArrayList(v0(), v3())), multimap().asMap());
   }
 }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapPutTester.java b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapPutTester.java
index c459496825..c80b5b062a 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapPutTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapPutTester.java
@@ -55,8 +55,8 @@ public class ListMultimapPutTester<K, V> extends AbstractListMultimapTester<K, V
     }
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutDuplicateValue() {
     List<Entry<K, V>> entries = copyToList(multimap().entries());
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapRemoveTester.java b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapRemoveTester.java
index 04ac0a2bc5..f19be25253 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapRemoveTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapRemoveTester.java
@@ -38,9 +38,9 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListMultimapRemoveTester<K, V> extends AbstractListMultimapTester<K, V> {
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testMultimapRemoveDeletesFirstOccurrence() {
     resetContainer(mapEntry(k0(), v0()), mapEntry(k0(), v1()), mapEntry(k0(), v0()));
 
@@ -49,9 +49,9 @@ public class ListMultimapRemoveTester<K, V> extends AbstractListMultimapTester<K
     assertContentsInOrder(list, v1(), v0());
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveAtIndexFromGetPropagates() {
     List<V> values = Arrays.asList(v0(), v1(), v0());
 
@@ -66,9 +66,9 @@ public class ListMultimapRemoveTester<K, V> extends AbstractListMultimapTester<K
     }
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveAtIndexFromAsMapPropagates() {
     List<V> values = Arrays.asList(v0(), v1(), v0());
 
@@ -76,7 +76,7 @@ public class ListMultimapRemoveTester<K, V> extends AbstractListMultimapTester<K
       resetContainer(mapEntry(k0(), v0()), mapEntry(k0(), v1()), mapEntry(k0(), v0()));
       List<V> expectedValues = copyToList(values);
 
-      List<V> asMapValue = (List<V>) multimap().asMap().get(k0());
+      List<V> asMapValue = (List<V>) multimap().get(k0());
       asMapValue.remove(i);
       expectedValues.remove(i);
 
@@ -84,9 +84,9 @@ public class ListMultimapRemoveTester<K, V> extends AbstractListMultimapTester<K
     }
   }
 
-  @SuppressWarnings("unchecked")
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testRemoveAtIndexFromAsMapEntrySetPropagates() {
     List<V> values = Arrays.asList(v0(), v1(), v0());
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapTestSuiteBuilder.java
index b55c7d648f..1c7cfb3f90 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/ListMultimapTestSuiteBuilder.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing.google;
 
+import static java.util.Collections.disjoint;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.testing.AbstractTester;
@@ -28,7 +30,6 @@ import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.Feature;
 import com.google.common.collect.testing.features.ListFeature;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map.Entry;
@@ -83,7 +84,7 @@ public class ListMultimapTestSuiteBuilder<K, V>
               ?, ? extends OneSizeTestContainerGenerator<ListMultimap<K, V>, Entry<K, V>>>
           parentBuilder) {
     Set<Feature<?>> features = computeMultimapAsMapGetFeatures(parentBuilder.getFeatures());
-    if (Collections.disjoint(features, EnumSet.allOf(CollectionSize.class))) {
+    if (disjoint(features, EnumSet.allOf(CollectionSize.class))) {
       return new TestSuite();
     } else {
       return ListTestSuiteBuilder.using(
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java b/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
index 3f445ca116..ad4c08939e 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
@@ -127,8 +127,8 @@ public class MapGenerators {
           mapEntry("toaster", -2));
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Entry<String, Integer>[] createArray(int length) {
       return new Entry[length];
     }
@@ -217,7 +217,7 @@ public class MapGenerators {
     }
 
     @Override
-    @SuppressWarnings({"unchecked", "rawtypes"}) // needed for arrays
+    @SuppressWarnings({"rawtypes", "unchecked"}) // needed for arrays
     public Entry<String, Collection<Integer>>[] createArray(int length) {
       return new Entry[length];
     }
@@ -234,7 +234,7 @@ public class MapGenerators {
     }
 
     @Override
-    @SuppressWarnings({"unchecked", "rawtypes"}) // needed for arrays
+    @SuppressWarnings({"rawtypes", "unchecked"}) // needed for arrays
     public ImmutableSet<Integer>[] createValueArray(int length) {
       return new ImmutableSet[length];
     }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapGetTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapGetTester.java
index dadb9a3245..ea1cc9f2b3 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapGetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapGetTester.java
@@ -47,7 +47,7 @@ public class MultimapAsMapGetTester<K, V> extends AbstractMultimapTester<K, V, M
   public void testPropagatesRemoveToMultimap() {
     resetContainer(
         Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()), Helpers.mapEntry(k0(), v2()));
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     assertTrue(result.remove(v0()));
     assertFalse(multimap().containsEntry(k0(), v0()));
     assertEquals(2, multimap().size());
@@ -56,7 +56,7 @@ public class MultimapAsMapGetTester<K, V> extends AbstractMultimapTester<K, V, M
   @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(SUPPORTS_REMOVE)
   public void testPropagatesRemoveLastElementToMultimap() {
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     assertTrue(result.remove(v0()));
     assertGet(k0());
   }
@@ -64,31 +64,31 @@ public class MultimapAsMapGetTester<K, V> extends AbstractMultimapTester<K, V, M
   @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(SUPPORTS_REMOVE)
   public void testPropagatesClearToMultimap() {
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     result.clear();
     assertGet(k0());
     assertEmpty(result);
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testAddNullValue() {
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     assertTrue(result.add(null));
     assertTrue(multimap().containsEntry(k0(), null));
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUE_QUERIES})
+  @MapFeature.Require({ALLOWS_NULL_VALUE_QUERIES, SUPPORTS_REMOVE})
   public void testRemoveNullValue() {
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     assertFalse(result.remove(null));
   }
 
   @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testAddNullValueUnsupported() {
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     try {
       result.add(null);
       fail("Expected NullPointerException");
@@ -99,17 +99,17 @@ public class MultimapAsMapGetTester<K, V> extends AbstractMultimapTester<K, V, M
   @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(SUPPORTS_PUT)
   public void testPropagatesAddToMultimap() {
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     result.add(v3());
     assertContentsAnyOrder(multimap().get(k0()), v0(), v3());
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_REMOVE, SUPPORTS_PUT})
+  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testPropagatesRemoveThenAddToMultimap() {
     int oldSize = getNumElements();
 
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     assertTrue(result.remove(v0()));
 
     assertFalse(multimap().containsKey(k0()));
@@ -130,7 +130,7 @@ public class MultimapAsMapGetTester<K, V> extends AbstractMultimapTester<K, V, M
   @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(SUPPORTS_REMOVE)
   public void testReflectsMultimapRemove() {
-    Collection<V> result = multimap().asMap().get(k0());
+    Collection<V> result = multimap().get(k0());
     multimap().removeAll(k0());
     assertEmpty(result);
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapTester.java
index 23b2351672..1cda6fe626 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapAsMapTester.java
@@ -57,7 +57,7 @@ public class MultimapAsMapTester<K, V> extends AbstractMultimapTester<K, V, Mult
         }
       }
 
-      Collection<V> collection = multimap().asMap().get(key);
+      Collection<V> collection = multimap().get(key);
       if (expectedValues.isEmpty()) {
         assertNull(collection);
       } else {
@@ -70,18 +70,18 @@ public class MultimapAsMapTester<K, V> extends AbstractMultimapTester<K, V, Mult
   @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testAsMapGetNullKeyPresent() {
     initMultimapWithNullKey();
-    assertContentsAnyOrder(multimap().asMap().get(null), getValueForNullKey());
+    assertContentsAnyOrder(multimap().get(null), getValueForNullKey());
   }
 
   @MapFeature.Require(ALLOWS_NULL_KEY_QUERIES)
   public void testAsMapGetNullKeyAbsent() {
-    assertNull(multimap().asMap().get(null));
+    assertNull(multimap().get(null));
   }
 
   @MapFeature.Require(absent = ALLOWS_NULL_KEY_QUERIES)
   public void testAsMapGetNullKeyUnsupported() {
     try {
-      multimap().asMap().get(null);
+      multimap().get(null);
       fail("Expected NullPointerException");
     } catch (NullPointerException expected) {
     }
@@ -129,8 +129,8 @@ public class MultimapAsMapTester<K, V> extends AbstractMultimapTester<K, V, Mult
     assertContentsInOrder(multimap().keySet(), k1());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testAsMapEntrySetIteratorRemovePropagatesToMultimap() {
     resetContainer(Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k0(), v3()));
     Set<Entry<K, Collection<V>>> asMapEntrySet = multimap().asMap().entrySet();
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapClearTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapClearTester.java
index 6ce9907c14..573d2f86e6 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapClearTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapClearTester.java
@@ -98,8 +98,8 @@ public class MultimapClearTester<K, V> extends AbstractMultimapTester<K, V, Mult
     assertCleared();
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testClearPropagatesToGet() {
     for (K key : sampleKeys()) {
       resetContainer();
@@ -109,12 +109,12 @@ public class MultimapClearTester<K, V> extends AbstractMultimapTester<K, V, Mult
     }
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testClearPropagatesToAsMapGet() {
     for (K key : sampleKeys()) {
       resetContainer();
-      Collection<V> collection = multimap().asMap().get(key);
+      Collection<V> collection = multimap().get(key);
       if (collection != null) {
         multimap().clear();
         assertEmpty(collection);
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsKeyTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsKeyTester.java
index a7dcd6626e..49dce23d06 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsKeyTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsKeyTester.java
@@ -67,8 +67,8 @@ public class MultimapContainsKeyTester<K, V> extends AbstractMultimapTester<K, V
     }
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testContainsKeyNullPresent() {
     initMultimapWithNullKey();
     assertTrue(multimap().containsKey(null));
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsValueTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsValueTester.java
index 00ca12ad51..862443304b 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsValueTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapContainsValueTester.java
@@ -44,8 +44,8 @@ public class MultimapContainsValueTester<K, V>
     assertFalse(multimap().containsValue(v3()));
   }
 
-  @MapFeature.Require(ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testContainsNullValueYes() {
     initMultimapWithNullValue();
     assertTrue(multimap().containsValue(null));
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapEntriesTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapEntriesTester.java
index 9874b884cc..ef694f2359 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapEntriesTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapEntriesTester.java
@@ -24,6 +24,7 @@ import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUE_QUERIES;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;
+import static java.util.Collections.singleton;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Multimap;
@@ -31,7 +32,6 @@ import com.google.common.collect.testing.Helpers;
 import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.MapFeature;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.Map.Entry;
 import org.junit.Ignore;
@@ -84,7 +84,7 @@ public class MultimapEntriesTester<K, V> extends AbstractMultimapTester<K, V, Mu
   @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRemoveAllPropagatesToMultimap() {
-    assertTrue(multimap().entries().removeAll(Collections.singleton(Helpers.mapEntry(k0(), v0()))));
+    assertTrue(multimap().entries().removeAll(singleton(Helpers.mapEntry(k0(), v0()))));
     expectMissing(Helpers.mapEntry(k0(), v0()));
     assertEquals(getNumElements() - 1, multimap().size());
     assertFalse(multimap().containsEntry(k0(), v0()));
@@ -93,14 +93,14 @@ public class MultimapEntriesTester<K, V> extends AbstractMultimapTester<K, V, Mu
   @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRetainAllPropagatesToMultimap() {
-    multimap().entries().retainAll(Collections.singleton(Helpers.mapEntry(k0(), v0())));
+    multimap().entries().retainAll(singleton(Helpers.mapEntry(k0(), v0())));
     assertEquals(getSubjectGenerator().create(Helpers.mapEntry(k0(), v0())), multimap());
     assertEquals(1, multimap().size());
     assertTrue(multimap().containsEntry(k0(), v0()));
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testIteratorRemovePropagatesToMultimap() {
     Iterator<Entry<K, V>> iterator = multimap().entries().iterator();
     assertEquals(Helpers.mapEntry(k0(), v0()), iterator.next());
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapGetTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapGetTester.java
index 6978473232..4fd6752e3d 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapGetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapGetTester.java
@@ -25,6 +25,7 @@ import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;
+import static java.util.Collections.singletonList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Multimap;
@@ -32,7 +33,6 @@ import com.google.common.collect.testing.Helpers;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.MapFeature;
 import java.util.Collection;
-import java.util.Collections;
 import org.junit.Ignore;
 
 /**
@@ -98,14 +98,14 @@ public class MultimapGetTester<K, V> extends AbstractMultimapTester<K, V, Multim
   @MapFeature.Require(SUPPORTS_PUT)
   public void testPropagatesAddAllToMultimap() {
     Collection<V> result = multimap().get(k0());
-    assertTrue(result.addAll(Collections.singletonList(v3())));
+    assertTrue(result.addAll(singletonList(v3())));
     assertTrue(multimap().containsKey(k0()));
     assertEquals(getNumElements() + 1, multimap().size());
     assertTrue(multimap().containsEntry(k0(), v3()));
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_REMOVE, SUPPORTS_PUT})
+  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testPropagatesRemoveLastThenAddToMultimap() {
     int oldSize = getNumElements();
 
@@ -127,8 +127,8 @@ public class MultimapGetTester<K, V> extends AbstractMultimapTester<K, V, Multim
     assertEquals(oldSize + 1, multimap().size());
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testGetNullPresent() {
     initMultimapWithNullKey();
     assertContains(multimap().get(null), getValueForNullKey());
@@ -149,8 +149,8 @@ public class MultimapGetTester<K, V> extends AbstractMultimapTester<K, V, Multim
     }
   }
 
-  @MapFeature.Require(ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testGetWithNullValue() {
     initMultimapWithNullValue();
     assertContains(multimap().get(getKeyForNullValue()), null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeySetTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeySetTester.java
index 100b15bb76..afd5ffc997 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeySetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeySetTester.java
@@ -63,8 +63,8 @@ public class MultimapKeySetTester<K, V> extends AbstractMultimapTester<K, V, Mul
     assertGet(k0());
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testKeySetIteratorRemove() {
     int key0Count = multimap().get(k0()).size();
     Iterator<K> keyItr = multimap().keySet().iterator();
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeysTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeysTester.java
index 6b2a93ca3d..00201c1beb 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeysTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapKeysTester.java
@@ -85,8 +85,8 @@ public class MultimapKeysTester<K, V> extends AbstractMultimapTester<K, V, Multi
     assertEquals(Math.max(original - 1, 0), multimap().get(k0()).size());
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testKeysEntrySetIteratorRemove() {
     Multiset<K> keys = multimap().keys();
     Iterator<Multiset.Entry<K>> itr = keys.entrySet().iterator();
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutAllMultimapTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutAllMultimapTester.java
index 92622933f8..418ea8cbce 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutAllMultimapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutAllMultimapTester.java
@@ -62,14 +62,14 @@ public class MultimapPutAllMultimapTester<K, V>
     assertTrue(multimap().containsEntry(k3(), v3()));
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPutAllWithNullValue() {
     Multimap<K, V> source = getSubjectGenerator().create(Helpers.mapEntry(k0(), null));
     assertTrue(multimap().putAll(source));
     assertTrue(multimap().containsEntry(k0(), null));
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testPutAllWithNullKey() {
     Multimap<K, V> source = getSubjectGenerator().create(Helpers.mapEntry(null, v0()));
     assertTrue(multimap().putAll(source));
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutIterableTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutIterableTester.java
index b36037877a..18634ca295 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutIterableTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutIterableTester.java
@@ -21,6 +21,7 @@ import static com.google.common.collect.testing.features.CollectionSize.ZERO;
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;
+import static java.util.Collections.singletonList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableSet;
@@ -29,6 +30,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.MapFeature;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
@@ -87,13 +89,13 @@ public class MultimapPutIterableTester<K, V> extends AbstractMultimapTester<K, V
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPutAllNullValueOnPresentKey_supported() {
     assertTrue(multimap().putAll(k0(), Lists.newArrayList(v3(), null)));
     assertGet(k0(), v0(), v3(), null);
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPutAllNullValueOnAbsentKey_supported() {
     assertTrue(multimap().putAll(k3(), Lists.newArrayList(v3(), null)));
     assertGet(k3(), v3(), null);
@@ -118,13 +120,13 @@ public class MultimapPutIterableTester<K, V> extends AbstractMultimapTester<K, V
     }
 
     Collection<V> values = multimap().get(k3());
-    if (values.size() == 0) {
+    if (values.isEmpty()) {
       expectUnchanged();
       // Be extra thorough in case internal state was corrupted by the expected null.
-      assertEquals(Lists.newArrayList(), Lists.newArrayList(values));
+      assertEquals(Lists.newArrayList(), new ArrayList<>(values));
       assertEquals(size, multimap().size());
     } else {
-      assertEquals(Lists.newArrayList(v3()), Lists.newArrayList(values));
+      assertEquals(Lists.newArrayList(v3()), new ArrayList<>(values));
       assertEquals(size + 1, multimap().size());
     }
   }
@@ -146,11 +148,11 @@ public class MultimapPutIterableTester<K, V> extends AbstractMultimapTester<K, V
      */
     expectUnchanged();
     // Be extra thorough in case internal state was corrupted by the expected null.
-    assertEquals(Lists.newArrayList(), Lists.newArrayList(multimap().get(k3())));
+    assertEquals(Lists.newArrayList(), new ArrayList<>(multimap().get(k3())));
     assertEquals(size, multimap().size());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testPutAllOnPresentNullKey() {
     assertTrue(multimap().putAll(null, Lists.newArrayList(v3(), v4())));
     assertGet(null, v3(), v4());
@@ -159,7 +161,7 @@ public class MultimapPutIterableTester<K, V> extends AbstractMultimapTester<K, V
   @MapFeature.Require(absent = ALLOWS_NULL_KEYS)
   public void testPutAllNullForbidden() {
     try {
-      multimap().putAll(null, Collections.singletonList(v3()));
+      multimap().putAll(null, singletonList(v3()));
       fail("Expected NullPointerException");
     } catch (NullPointerException expected) {
       // success
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutTester.java
index c108e8525c..a605bf1b71 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapPutTester.java
@@ -66,8 +66,8 @@ public class MultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Multim
     assertEquals(size + 1, multimap().size());
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutPresent() {
     int size = getNumElements();
 
@@ -95,7 +95,7 @@ public class MultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Multim
     assertEquals(size + 2, multimap().size());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPutNullValue_supported() {
     int size = getNumElements();
 
@@ -116,7 +116,7 @@ public class MultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Multim
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testPutNullKey() {
     int size = getNumElements();
 
@@ -153,8 +153,8 @@ public class MultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Multim
     assertContains(entries, Helpers.mapEntry(k0(), v3()));
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutPresentKeyPropagatesToGet() {
     List<K> keys = Helpers.copyToList(multimap().keySet());
     for (K key : keys) {
@@ -172,8 +172,8 @@ public class MultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Multim
     }
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutPresentKeyPropagatesToAsMapGet() {
     List<K> keys = Helpers.copyToList(multimap().keySet());
     for (K key : keys) {
@@ -181,7 +181,7 @@ public class MultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Multim
 
       int size = getNumElements();
 
-      Collection<V> collection = multimap().asMap().get(key);
+      Collection<V> collection = multimap().get(key);
       assertNotNull(collection);
       Collection<V> expectedCollection = Helpers.copyToList(collection);
 
@@ -192,8 +192,8 @@ public class MultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Multim
     }
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutPresentKeyPropagatesToAsMapEntrySet() {
     List<K> keys = Helpers.copyToList(multimap().keySet());
     for (K key : keys) {
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveAllTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveAllTester.java
index 185ba2c206..c8c55569c0 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveAllTester.java
@@ -76,7 +76,7 @@ public class MultimapRemoveAllTester<K, V> extends AbstractMultimapTester<K, V,
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_REMOVE})
   public void testRemoveAllNullKeyPresent() {
     initMultimapWithNullKey();
 
@@ -85,7 +85,7 @@ public class MultimapRemoveAllTester<K, V> extends AbstractMultimapTester<K, V,
     expectMissing(Helpers.mapEntry((K) null, getValueForNullKey()));
   }
 
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_ANY_NULL_QUERIES})
+  @MapFeature.Require({ALLOWS_ANY_NULL_QUERIES, SUPPORTS_REMOVE})
   public void testRemoveAllNullKeyAbsent() {
     assertEmpty(multimap().removeAll(null));
     expectUnchanged();
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveEntryTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveEntryTester.java
index 250a691f3f..a36d0b9634 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveEntryTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapRemoveEntryTester.java
@@ -62,7 +62,7 @@ public class MultimapRemoveEntryTester<K, V> extends AbstractMultimapTester<K, V
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_REMOVE})
   public void testRemoveNullKeyPresent() {
     initMultimapWithNullKey();
 
@@ -73,7 +73,7 @@ public class MultimapRemoveEntryTester<K, V> extends AbstractMultimapTester<K, V
   }
 
   @CollectionSize.Require(absent = ZERO)
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
   public void testRemoveNullValuePresent() {
     initMultimapWithNullValue();
 
@@ -83,13 +83,13 @@ public class MultimapRemoveEntryTester<K, V> extends AbstractMultimapTester<K, V
     assertGet(getKeyForNullValue(), ImmutableList.<V>of());
   }
 
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_KEY_QUERIES})
+  @MapFeature.Require({ALLOWS_NULL_KEY_QUERIES, SUPPORTS_REMOVE})
   public void testRemoveNullKeyAbsent() {
     assertFalse(multimap().remove(null, v0()));
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUE_QUERIES})
+  @MapFeature.Require({ALLOWS_NULL_VALUE_QUERIES, SUPPORTS_REMOVE})
   public void testRemoveNullValueAbsent() {
     assertFalse(multimap().remove(k0(), null));
     expectUnchanged();
@@ -117,8 +117,8 @@ public class MultimapRemoveEntryTester<K, V> extends AbstractMultimapTester<K, V
     expectUnchanged();
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRemovePropagatesToGet() {
     List<Entry<K, V>> entries = Helpers.copyToList(multimap().entries());
     for (Entry<K, V> entry : entries) {
@@ -138,8 +138,8 @@ public class MultimapRemoveEntryTester<K, V> extends AbstractMultimapTester<K, V
     }
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRemovePropagatesToAsMap() {
     List<Entry<K, V>> entries = Helpers.copyToList(multimap().entries());
     for (Entry<K, V> entry : entries) {
@@ -147,7 +147,7 @@ public class MultimapRemoveEntryTester<K, V> extends AbstractMultimapTester<K, V
 
       K key = entry.getKey();
       V value = entry.getValue();
-      Collection<V> collection = multimap().asMap().get(key);
+      Collection<V> collection = multimap().get(key);
       assertNotNull(collection);
       Collection<V> expectedCollection = Helpers.copyToList(collection);
 
@@ -159,8 +159,8 @@ public class MultimapRemoveEntryTester<K, V> extends AbstractMultimapTester<K, V
     }
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRemovePropagatesToAsMapEntrySet() {
     List<Entry<K, V>> entries = Helpers.copyToList(multimap().entries());
     for (Entry<K, V> entry : entries) {
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapReplaceValuesTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapReplaceValuesTester.java
index 3e2597d8db..5d5b1a7505 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapReplaceValuesTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapReplaceValuesTester.java
@@ -22,6 +22,8 @@ import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_PUT;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Multimap;
@@ -31,7 +33,6 @@ import com.google.common.collect.testing.features.MapFeature;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import org.junit.Ignore;
 
@@ -45,7 +46,7 @@ import org.junit.Ignore;
 public class MultimapReplaceValuesTester<K, V>
     extends AbstractMultimapTester<K, V, Multimap<K, V>> {
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testReplaceValuesWithNullValue() {
     @SuppressWarnings("unchecked")
     List<V> values = Arrays.asList(v0(), null, v3());
@@ -53,7 +54,7 @@ public class MultimapReplaceValuesTester<K, V>
     assertGet(k0(), values);
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testReplaceValuesWithNullKey() {
     @SuppressWarnings("unchecked")
     List<V> values = Arrays.asList(v0(), v2(), v3());
@@ -76,7 +77,7 @@ public class MultimapReplaceValuesTester<K, V>
     int size = multimap().size();
     List<V> oldValues = new ArrayList<>(multimap().get(k0()));
     @SuppressWarnings("unchecked")
-    List<V> values = Collections.emptyList();
+    List<V> values = emptyList();
     assertEquals(oldValues, new ArrayList<V>(multimap().replaceValues(k0(), values)));
     assertGet(k0());
     assertEquals(size - oldValues.size(), multimap().size());
@@ -119,10 +120,10 @@ public class MultimapReplaceValuesTester<K, V>
     assertContentsAnyOrder(getCollection, v0(), v2(), v3());
   }
 
-  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   public void testReplaceValuesRemoveNotSupported() {
-    List<V> values = Collections.singletonList(v3());
+    List<V> values = singletonList(v3());
     try {
       multimap().replaceValues(k0(), values);
       fail("Expected UnsupportedOperationException");
@@ -133,7 +134,7 @@ public class MultimapReplaceValuesTester<K, V>
 
   @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplaceValuesPutNotSupported() {
-    List<V> values = Collections.singletonList(v3());
+    List<V> values = singletonList(v3());
     try {
       multimap().replaceValues(k0(), values);
       fail("Expected UnsupportedOperationException");
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java
index af9d261c32..ea43c59852 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapTestSuiteBuilder.java
@@ -18,6 +18,8 @@ package com.google.common.collect.testing.google;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.testing.Helpers.mapEntry;
+import static java.util.Collections.disjoint;
+import static java.util.Collections.singleton;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableList;
@@ -44,7 +46,6 @@ import com.google.common.collect.testing.features.MapFeature;
 import com.google.common.testing.SerializableTester;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -180,7 +181,7 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
       FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<M, Entry<K, V>>>
           parentBuilder) {
     Set<Feature<?>> features = computeMultimapAsMapGetFeatures(parentBuilder.getFeatures());
-    if (Collections.disjoint(features, EnumSet.allOf(CollectionSize.class))) {
+    if (disjoint(features, EnumSet.allOf(CollectionSize.class))) {
       return new TestSuite();
     } else {
       return CollectionTestSuiteBuilder.using(
@@ -325,7 +326,7 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
 
     private Collection<V> createCollection(V v) {
       return ((TestMultimapGenerator<K, V, M>) multimapGenerator.getInnerGenerator())
-          .createCollection(Collections.singleton(v));
+          .createCollection(singleton(v));
     }
 
     @Override
@@ -357,8 +358,8 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
       return multimapGenerator.create(builder.toArray()).asMap();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Entry<K, Collection<V>>[] createArray(int length) {
       return new Entry[length];
     }
@@ -387,8 +388,8 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
           .createKeyArray(length);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Collection<V>[] createValueArray(int length) {
       return new Collection[length];
     }
@@ -417,8 +418,8 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
       return multimapGenerator.create(elements).entries();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Entry<K, V>[] createArray(int length) {
       return new Entry[length];
     }
@@ -456,8 +457,8 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
       return multimapGenerator.create((Object[]) entries).values();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public V[] createArray(int length) {
       return ((TestMultimapGenerator<K, V, M>) multimapGenerator.getInnerGenerator())
           .createValueArray(length);
@@ -527,8 +528,8 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
           .iterator();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public K[] createArray(int length) {
       return ((TestMultimapGenerator<K, V, M>) multimapGenerator.getInnerGenerator())
           .createKeyArray(length);
@@ -620,7 +621,7 @@ public class MultimapTestSuiteBuilder<K, V, M extends Multimap<K, V>>
       for (int i = 0; i < elements.length; i++) {
         array[i] = mapEntry(k, (V) elements[i]);
       }
-      return multimapGenerator.create((Object[]) array).asMap().get(k);
+      return multimapGenerator.create((Object[]) array).get(k);
     }
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultimapToStringTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultimapToStringTester.java
index 203f278b7f..6928ca8e9e 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultimapToStringTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultimapToStringTester.java
@@ -35,28 +35,28 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class MultimapToStringTester<K, V> extends AbstractMultimapTester<K, V, Multimap<K, V>> {
-  @CollectionSize.Require(ZERO)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(ZERO)
   public void testToStringEmpty() {
     assertEquals("{}", multimap().toString());
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(ONE)
   public void testToStringSingleton() {
     assertEquals("{" + k0() + "=[" + v0() + "]}", multimap().toString());
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testToStringWithNullKey() {
     initMultimapWithNullKey();
     testToStringMatchesAsMap();
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testToStringWithNullValue() {
     initMultimapWithNullValue();
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetCountTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetCountTester.java
index 7c07cd33d0..b5028ab81f 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetCountTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetCountTester.java
@@ -70,8 +70,8 @@ public class MultisetCountTester<E> extends AbstractMultisetTester<E> {
     }
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
   public void testCount_nullPresent() {
     initCollectionWithNullElement();
     assertEquals(1, getMultiset().count(null));
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetElementSetTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetElementSetTester.java
index baa6071f84..3d01753014 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetElementSetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetElementSetTester.java
@@ -21,6 +21,7 @@ import static com.google.common.collect.testing.features.CollectionFeature.SUPPO
 import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
+import static java.util.Collections.singleton;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -29,7 +30,6 @@ import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 import org.junit.Ignore;
@@ -50,17 +50,17 @@ public class MultisetElementSetTester<E> extends AbstractMultisetTester<E> {
     assertTrue(elementSet.contains(e3()));
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testElementSetReflectsRemove() {
     Set<E> elementSet = getMultiset().elementSet();
     assertTrue(elementSet.contains(e0()));
-    getMultiset().removeAll(Collections.singleton(e0()));
+    getMultiset().removeAll(singleton(e0()));
     assertFalse(elementSet.contains(e0()));
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testElementSetRemovePropagatesToMultiset() {
     Set<E> elementSet = getMultiset().elementSet();
     int size = getNumElements();
@@ -70,8 +70,8 @@ public class MultisetElementSetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expectedSize, getMultiset().size());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testElementSetRemoveDuplicatePropagatesToMultiset() {
     initThreeCopies();
     int size = getNumElements();
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetEntrySetTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetEntrySetTester.java
index 3bec616aae..0dd7cbf5b2 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetEntrySetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetEntrySetTester.java
@@ -23,6 +23,7 @@ import static com.google.common.collect.testing.features.CollectionSize.ONE;
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
 import static com.google.common.collect.testing.google.MultisetFeature.ENTRIES_ARE_VIEWS;
+import static java.util.Collections.singleton;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Iterables;
@@ -30,7 +31,6 @@ import com.google.common.collect.Multiset;
 import com.google.common.collect.Multisets;
 import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
-import java.util.Collections;
 import java.util.Iterator;
 import org.junit.Ignore;
 
@@ -49,8 +49,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertTrue("multiset not empty after entrySet().clear()", getMultiset().isEmpty());
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testEntrySet_iteratorRemovePropagates() {
     Iterator<Multiset.Entry<E>> iterator = getMultiset().entrySet().iterator();
     assertTrue(
@@ -68,8 +68,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
         getMultiset().isEmpty());
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testEntrySet_removePresent() {
     assertTrue(
         "multiset.entrySet.remove(presentEntry) returned false",
@@ -77,8 +77,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertFalse("multiset contains element after removing its entry", getMultiset().contains(e0()));
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testEntrySet_removeAbsent() {
     assertFalse(
         "multiset.entrySet.remove(missingEntry) returned true",
@@ -88,58 +88,50 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
         getMultiset().contains(e0()));
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testEntrySet_removeAllPresent() {
     assertTrue(
         "multiset.entrySet.removeAll(presentEntry) returned false",
-        getMultiset()
-            .entrySet()
-            .removeAll(Collections.singleton(Multisets.immutableEntry(e0(), 1))));
+        getMultiset().entrySet().removeAll(singleton(Multisets.immutableEntry(e0(), 1))));
     assertFalse("multiset contains element after removing its entry", getMultiset().contains(e0()));
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testEntrySet_removeAllAbsent() {
     assertFalse(
         "multiset.entrySet.remove(missingEntry) returned true",
-        getMultiset()
-            .entrySet()
-            .removeAll(Collections.singleton(Multisets.immutableEntry(e0(), 2))));
+        getMultiset().entrySet().removeAll(singleton(Multisets.immutableEntry(e0(), 2))));
     assertTrue(
         "multiset didn't contain element after removing a missing entry",
         getMultiset().contains(e0()));
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testEntrySet_retainAllPresent() {
     assertFalse(
         "multiset.entrySet.retainAll(presentEntry) returned false",
-        getMultiset()
-            .entrySet()
-            .retainAll(Collections.singleton(Multisets.immutableEntry(e0(), 1))));
+        getMultiset().entrySet().retainAll(singleton(Multisets.immutableEntry(e0(), 1))));
     assertTrue(
         "multiset doesn't contains element after retaining its entry",
         getMultiset().contains(e0()));
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testEntrySet_retainAllAbsent() {
     assertTrue(
         "multiset.entrySet.retainAll(missingEntry) returned true",
-        getMultiset()
-            .entrySet()
-            .retainAll(Collections.singleton(Multisets.immutableEntry(e0(), 2))));
+        getMultiset().entrySet().retainAll(singleton(Multisets.immutableEntry(e0(), 2))));
     assertFalse(
         "multiset contains element after retaining a different entry",
         getMultiset().contains(e0()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryViewReflectsRemove() {
     initThreeCopies();
@@ -152,8 +144,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, entry.getCount());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryReflectsIteratorRemove() {
     initThreeCopies();
@@ -171,8 +163,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, entry.getCount());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryReflectsClear() {
     initThreeCopies();
@@ -183,8 +175,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, entry.getCount());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryReflectsEntrySetClear() {
     initThreeCopies();
@@ -195,8 +187,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, entry.getCount());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryReflectsEntrySetIteratorRemove() {
     initThreeCopies();
@@ -207,8 +199,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, entry.getCount());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryReflectsElementSetClear() {
     initThreeCopies();
@@ -219,8 +211,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, entry.getCount());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryReflectsElementSetIteratorRemove() {
     initThreeCopies();
@@ -233,8 +225,8 @@ public class MultisetEntrySetTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, entry.getCount());
   }
 
+  @CollectionFeature.Require({SUPPORTS_ADD, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
-  @CollectionFeature.Require({SUPPORTS_REMOVE, SUPPORTS_ADD})
   @MultisetFeature.Require(ENTRIES_ARE_VIEWS)
   public void testEntryReflectsRemoveThenAdd() {
     initThreeCopies();
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetEqualsTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetEqualsTester.java
index 9d9fee0a1a..48a65e3eb7 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetEqualsTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetEqualsTester.java
@@ -50,8 +50,8 @@ public class MultisetEqualsTester<E> extends AbstractMultisetTester<E> {
     assertEquals(getMultiset().entrySet().hashCode(), getMultiset().hashCode());
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
   public void testEqualsMultisetWithNullValue() {
     new EqualsTester()
         .addEqualityGroup(getMultiset())
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetFeature.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetFeature.java
index d05c560021..8d741e91d5 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetFeature.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetFeature.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing.google;
 
+import static java.util.Collections.emptySet;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Multiset;
 import com.google.common.collect.testing.features.Feature;
@@ -23,7 +25,6 @@ import com.google.common.collect.testing.features.TesterAnnotation;
 import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
-import java.util.Collections;
 import java.util.Set;
 
 /**
@@ -41,7 +42,7 @@ public enum MultisetFeature implements Feature<Multiset> {
 
   @Override
   public Set<Feature<? super Multiset>> getImpliedFeatures() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   @Retention(RetentionPolicy.RUNTIME)
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetForEachEntryTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetForEachEntryTester.java
index 50c2ad507a..16ba9472ef 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetForEachEntryTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetForEachEntryTester.java
@@ -17,6 +17,7 @@
 package com.google.common.collect.testing.google;
 
 import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;
+import static java.util.Collections.singletonList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -27,7 +28,6 @@ import com.google.common.collect.testing.features.CollectionFeature;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import org.junit.Ignore;
 
@@ -58,7 +58,7 @@ public class MultisetForEachEntryTester<E> extends AbstractMultisetTester<E> {
 
   public void testForEachEntryDuplicates() {
     initThreeCopies();
-    List<Entry<E>> expected = Collections.singletonList(Multisets.immutableEntry(e0(), 3));
+    List<Entry<E>> expected = singletonList(Multisets.immutableEntry(e0(), 3));
     List<Entry<E>> actual = new ArrayList<>();
     getMultiset()
         .forEachEntry((element, count) -> actual.add(Multisets.immutableEntry(element, count)));
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetIteratorTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetIteratorTester.java
index 34a8c72585..7940da3f37 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetIteratorTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetIteratorTester.java
@@ -39,8 +39,8 @@ import org.junit.Ignore;
 @GwtCompatible(emulated = true)
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class MultisetIteratorTester<E> extends AbstractMultisetTester<E> {
+  @CollectionFeature.Require({KNOWN_ORDER, SUPPORTS_ITERATOR_REMOVE})
   @SuppressWarnings("unchecked")
-  @CollectionFeature.Require({SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})
   public void testRemovingIteratorKnownOrder() {
     new IteratorTester<E>(
         4,
@@ -54,8 +54,8 @@ public class MultisetIteratorTester<E> extends AbstractMultisetTester<E> {
     }.test();
   }
 
-  @SuppressWarnings("unchecked")
   @CollectionFeature.Require(value = SUPPORTS_ITERATOR_REMOVE, absent = KNOWN_ORDER)
+  @SuppressWarnings("unchecked")
   public void testRemovingIteratorUnknownOrder() {
     new IteratorTester<E>(
         4,
@@ -69,8 +69,8 @@ public class MultisetIteratorTester<E> extends AbstractMultisetTester<E> {
     }.test();
   }
 
-  @SuppressWarnings("unchecked")
   @CollectionFeature.Require(value = KNOWN_ORDER, absent = SUPPORTS_ITERATOR_REMOVE)
+  @SuppressWarnings("unchecked")
   public void testIteratorKnownOrder() {
     new IteratorTester<E>(
         4,
@@ -84,8 +84,8 @@ public class MultisetIteratorTester<E> extends AbstractMultisetTester<E> {
     }.test();
   }
 
+  @CollectionFeature.Require(absent = {KNOWN_ORDER, SUPPORTS_ITERATOR_REMOVE})
   @SuppressWarnings("unchecked")
-  @CollectionFeature.Require(absent = {SUPPORTS_ITERATOR_REMOVE, KNOWN_ORDER})
   public void testIteratorUnknownOrder() {
     new IteratorTester<E>(
         4,
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetNavigationTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetNavigationTester.java
index ce8e283a9c..81106ca459 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetNavigationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetNavigationTester.java
@@ -22,6 +22,8 @@ import static com.google.common.collect.testing.features.CollectionFeature.SUPPO
 import static com.google.common.collect.testing.features.CollectionSize.ONE;
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
+import static java.util.Collections.reverse;
+import static java.util.Collections.singletonList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.BoundType;
@@ -69,7 +71,7 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     Collections.sort(entries, sortedMultiset.comparator());
 
     // some tests assume SEVERAL == 3
-    if (entries.size() >= 1) {
+    if (!entries.isEmpty()) {
       a = Multisets.immutableEntry(entries.get(0), sortedMultiset.count(entries.get(0)));
       if (entries.size() >= 3) {
         b = Multisets.immutableEntry(entries.get(1), sortedMultiset.count(entries.get(1)));
@@ -167,9 +169,9 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(a, sortedMultiset.firstEntry());
   }
 
-  @SuppressWarnings("unchecked")
   @CollectionFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @SuppressWarnings("unchecked")
   public void testPollFirst() {
     assertEquals(a, sortedMultiset.pollFirstEntry());
     assertEquals(Arrays.asList(b, c), copyToList(sortedMultiset.entrySet()));
@@ -222,9 +224,9 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(c, sortedMultiset.lastEntry());
   }
 
-  @SuppressWarnings("unchecked")
   @CollectionFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @SuppressWarnings("unchecked")
   public void testPollLast() {
     assertEquals(c, sortedMultiset.pollLastEntry());
     assertEquals(Arrays.asList(a, b), copyToList(sortedMultiset.entrySet()));
@@ -246,7 +248,7 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     Iterators.addAll(ascending, sortedMultiset.entrySet().iterator());
     List<Entry<E>> descending = new ArrayList<>();
     Iterators.addAll(descending, sortedMultiset.descendingMultiset().entrySet().iterator());
-    Collections.reverse(descending);
+    reverse(descending);
     assertEquals(ascending, descending);
   }
 
@@ -264,7 +266,7 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     }
 
     try {
-      multiset.addAll(Collections.singletonList(entry.getElement()));
+      multiset.addAll(singletonList(entry.getElement()));
       fail("Expected IllegalArgumentException");
     } catch (IllegalArgumentException expected) {
     }
@@ -288,14 +290,14 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     }
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(ONE)
   public void testAddOutOfTailBoundsOne() {
     expectAddFailure(sortedMultiset.tailMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(SEVERAL)
   public void testAddOutOfTailBoundsSeveral() {
     expectAddFailure(sortedMultiset.tailMultiset(a.getElement(), OPEN), a);
     expectAddFailure(sortedMultiset.tailMultiset(b.getElement(), CLOSED), a);
@@ -308,14 +310,14 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     expectAddFailure(sortedMultiset.tailMultiset(c.getElement(), OPEN), c);
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(ONE)
   public void testAddOutOfHeadBoundsOne() {
     expectAddFailure(sortedMultiset.headMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(SEVERAL)
   public void testAddOutOfHeadBoundsSeveral() {
     expectAddFailure(sortedMultiset.headMultiset(c.getElement(), OPEN), c);
     expectAddFailure(sortedMultiset.headMultiset(b.getElement(), CLOSED), c);
@@ -328,14 +330,14 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     expectAddFailure(sortedMultiset.headMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testRemoveOutOfTailBoundsOne() {
     expectRemoveZero(sortedMultiset.tailMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testRemoveOutOfTailBoundsSeveral() {
     expectRemoveZero(sortedMultiset.tailMultiset(a.getElement(), OPEN), a);
     expectRemoveZero(sortedMultiset.tailMultiset(b.getElement(), CLOSED), a);
@@ -348,14 +350,14 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     expectRemoveZero(sortedMultiset.tailMultiset(c.getElement(), OPEN), c);
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testRemoveOutOfHeadBoundsOne() {
     expectRemoveZero(sortedMultiset.headMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testRemoveOutOfHeadBoundsSeveral() {
     expectRemoveZero(sortedMultiset.headMultiset(c.getElement(), OPEN), c);
     expectRemoveZero(sortedMultiset.headMultiset(b.getElement(), CLOSED), c);
@@ -368,14 +370,14 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     expectRemoveZero(sortedMultiset.headMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require({SUPPORTS_ADD, SUPPORTS_REMOVE})
+  @CollectionSize.Require(ONE)
   public void testSetCountOutOfTailBoundsOne() {
     expectSetCountFailure(sortedMultiset.tailMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require({SUPPORTS_ADD, SUPPORTS_REMOVE})
+  @CollectionSize.Require(SEVERAL)
   public void testSetCountOutOfTailBoundsSeveral() {
     expectSetCountFailure(sortedMultiset.tailMultiset(a.getElement(), OPEN), a);
     expectSetCountFailure(sortedMultiset.tailMultiset(b.getElement(), CLOSED), a);
@@ -388,14 +390,14 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     expectSetCountFailure(sortedMultiset.tailMultiset(c.getElement(), OPEN), c);
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require({SUPPORTS_ADD, SUPPORTS_REMOVE})
+  @CollectionSize.Require(ONE)
   public void testSetCountOutOfHeadBoundsOne() {
     expectSetCountFailure(sortedMultiset.headMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require({SUPPORTS_ADD, SUPPORTS_REMOVE})
+  @CollectionSize.Require(SEVERAL)
   public void testSetCountOutOfHeadBoundsSeveral() {
     expectSetCountFailure(sortedMultiset.headMultiset(c.getElement(), OPEN), c);
     expectSetCountFailure(sortedMultiset.headMultiset(b.getElement(), CLOSED), c);
@@ -408,8 +410,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     expectSetCountFailure(sortedMultiset.headMultiset(a.getElement(), OPEN), a);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(SEVERAL)
   public void testAddWithConflictingBounds() {
     testEmptyRangeSubMultisetSupportingAdd(
         sortedMultiset.subMultiset(a.getElement(), CLOSED, a.getElement(), OPEN));
@@ -425,8 +427,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
         sortedMultiset.subMultiset(b.getElement(), OPEN, a.getElement(), OPEN));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(SEVERAL)
   public void testConflictingBounds() {
     testEmptyRangeSubMultiset(
         sortedMultiset.subMultiset(a.getElement(), CLOSED, a.getElement(), OPEN));
@@ -600,8 +602,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     testSubMultisetDistinctElements(SubMultisetSpec.HEAD_OPEN);
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearTailOpen() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.headMultiset(b.getElement(), CLOSED).entrySet());
@@ -609,8 +611,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expected, copyToList(sortedMultiset.entrySet()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearTailOpenEntrySet() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.headMultiset(b.getElement(), CLOSED).entrySet());
@@ -618,8 +620,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expected, copyToList(sortedMultiset.entrySet()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearTailClosed() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.headMultiset(b.getElement(), OPEN).entrySet());
@@ -627,8 +629,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expected, copyToList(sortedMultiset.entrySet()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearTailClosedEntrySet() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.headMultiset(b.getElement(), OPEN).entrySet());
@@ -636,8 +638,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expected, copyToList(sortedMultiset.entrySet()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearHeadOpen() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.tailMultiset(b.getElement(), CLOSED).entrySet());
@@ -645,8 +647,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expected, copyToList(sortedMultiset.entrySet()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearHeadOpenEntrySet() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.tailMultiset(b.getElement(), CLOSED).entrySet());
@@ -654,8 +656,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expected, copyToList(sortedMultiset.entrySet()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearHeadClosed() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.tailMultiset(b.getElement(), OPEN).entrySet());
@@ -663,8 +665,8 @@ public class MultisetNavigationTester<E> extends AbstractMultisetTester<E> {
     assertEquals(expected, copyToList(sortedMultiset.entrySet()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testClearHeadClosedEntrySet() {
     List<Entry<E>> expected =
         copyToList(sortedMultiset.tailMultiset(b.getElement(), OPEN).entrySet());
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetRemoveTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetRemoveTester.java
index e6594c18a2..97258d8694 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetRemoveTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetRemoveTester.java
@@ -22,6 +22,7 @@ import static com.google.common.collect.testing.features.CollectionFeature.ALLOW
 import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
+import static java.util.Collections.singleton;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -31,7 +32,6 @@ import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import org.junit.Ignore;
 
@@ -70,8 +70,8 @@ public class MultisetRemoveTester<E> extends AbstractMultisetTester<E> {
     expectUnchanged();
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(absent = ZERO)
   public void testRemove_occurrences_present() {
     assertEquals(
         "multiset.remove(present, 2) didn't return the old count",
@@ -83,8 +83,8 @@ public class MultisetRemoveTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, getMultiset().count(e0()));
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testRemove_some_occurrences_present() {
     initThreeCopies();
     assertEquals(
@@ -142,8 +142,8 @@ public class MultisetRemoveTester<E> extends AbstractMultisetTester<E> {
         getMultiset().remove(WrongType.VALUE, 1));
   }
 
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
   public void testRemove_nullPresent() {
     initCollectionWithNullElement();
     assertEquals(1, getMultiset().remove(null, 2));
@@ -153,7 +153,7 @@ public class MultisetRemoveTester<E> extends AbstractMultisetTester<E> {
     assertEquals(0, getMultiset().count(null));
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_QUERIES})
+  @CollectionFeature.Require({ALLOWS_NULL_QUERIES, SUPPORTS_REMOVE})
   public void testRemove_nullAbsent() {
     assertEquals(0, getMultiset().remove(null, 2));
   }
@@ -167,20 +167,20 @@ public class MultisetRemoveTester<E> extends AbstractMultisetTester<E> {
     }
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testRemoveAllIgnoresCount() {
     initThreeCopies();
-    assertTrue(getMultiset().removeAll(Collections.singleton(e0())));
+    assertTrue(getMultiset().removeAll(singleton(e0())));
     assertEmpty(getMultiset());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_REMOVE)
+  @CollectionSize.Require(SEVERAL)
   public void testRetainAllIgnoresCount() {
     initThreeCopies();
     List<E> contents = Helpers.copyToList(getMultiset());
-    assertFalse(getMultiset().retainAll(Collections.singleton(e0())));
+    assertFalse(getMultiset().retainAll(singleton(e0())));
     expectContents(contents);
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetSetCountConditionallyTester.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetSetCountConditionallyTester.java
index d5e69638f4..781b6359cb 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetSetCountConditionallyTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetSetCountConditionallyTester.java
@@ -84,8 +84,8 @@ public class MultisetSetCountConditionallyTester<E> extends AbstractMultisetSetC
     expectUnchanged();
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(absent = ZERO)
   public void testSetCountConditional_oldCountTooSmallZero() {
     assertFalse(
         "setCount() with a too-small oldCount should return false",
@@ -93,8 +93,8 @@ public class MultisetSetCountConditionallyTester<E> extends AbstractMultisetSetC
     expectUnchanged();
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(SUPPORTS_ADD)
+  @CollectionSize.Require(SEVERAL)
   public void testSetCountConditional_oldCountTooSmallNonzero() {
     initThreeCopies();
     assertFalse(
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java
index 91d7a60e70..87b4b3aaf5 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java
@@ -17,6 +17,7 @@
 package com.google.common.collect.testing.google;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Collections.emptySet;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.Multiset;
@@ -36,7 +37,6 @@ import com.google.common.collect.testing.testers.CollectionSerializationEqualTes
 import com.google.common.testing.SerializableTester;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -64,7 +64,7 @@ public class MultisetTestSuiteBuilder<E>
 
     @Override
     public Set<Feature<? super Void>> getImpliedFeatures() {
-      return Collections.emptySet();
+      return emptySet();
     }
   }
 
@@ -230,8 +230,8 @@ public class MultisetTestSuiteBuilder<E>
       return ((Multiset<E>) gen.create(contents.toArray())).entrySet();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Multiset.Entry<E>[] createArray(int length) {
       return new Multiset.Entry[length];
     }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SetGenerators.java b/guava-testlib/src/com/google/common/collect/testing/google/SetGenerators.java
index 0b55a2798a..c787308315 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SetGenerators.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SetGenerators.java
@@ -16,13 +16,13 @@
 
 package com.google.common.collect.testing.google;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Lists.newArrayList;
 import static com.google.common.collect.Sets.newTreeSet;
 import static com.google.common.collect.testing.SampleElements.Strings.AFTER_LAST;
 import static com.google.common.collect.testing.SampleElements.Strings.AFTER_LAST_2;
 import static com.google.common.collect.testing.SampleElements.Strings.BEFORE_FIRST;
 import static com.google.common.collect.testing.SampleElements.Strings.BEFORE_FIRST_2;
+import static java.util.Collections.reverseOrder;
+import static java.util.Objects.requireNonNull;
 import static junit.framework.Assert.assertEquals;
 
 import com.google.common.annotations.GwtCompatible;
@@ -44,6 +44,7 @@ import com.google.common.collect.testing.TestStringSetGenerator;
 import com.google.common.collect.testing.TestStringSortedSetGenerator;
 import com.google.common.collect.testing.TestUnhashableCollectionGenerator;
 import com.google.common.collect.testing.UnhashableObject;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
@@ -129,8 +130,8 @@ public class SetGenerators {
   public static class DegeneratedImmutableSetGenerator extends TestStringSetGenerator {
     // Make sure we get what we think we're getting, or else this test
     // is pointless
-    @SuppressWarnings("cast")
     @Override
+    @SuppressWarnings("cast")
     protected Set<String> create(String[] elements) {
       return (ImmutableSet<String>) ImmutableSet.of(elements[0], elements[0]);
     }
@@ -181,7 +182,7 @@ public class SetGenerators {
 
   public static class ImmutableSortedSetExplicitComparator extends TestStringSetGenerator {
 
-    private static final Comparator<String> STRING_REVERSED = Collections.reverseOrder();
+    private static final Comparator<String> STRING_REVERSED = Comparator.reverseOrder();
 
     @Override
     protected SortedSet<String> create(String[] elements) {
@@ -190,7 +191,7 @@ public class SetGenerators {
 
     @Override
     public List<String> order(List<String> insertionOrder) {
-      Collections.sort(insertionOrder, Collections.reverseOrder());
+      Collections.sort(insertionOrder, Comparator.reverseOrder());
       return insertionOrder;
     }
   }
@@ -198,7 +199,7 @@ public class SetGenerators {
   public static class ImmutableSortedSetExplicitSuperclassComparatorGenerator
       extends TestStringSetGenerator {
 
-    private static final Comparator<Comparable<?>> COMPARABLE_REVERSED = Collections.reverseOrder();
+    private static final Comparator<Comparable<?>> COMPARABLE_REVERSED = reverseOrder();
 
     @Override
     protected SortedSet<String> create(String[] elements) {
@@ -207,7 +208,7 @@ public class SetGenerators {
 
     @Override
     public List<String> order(List<String> insertionOrder) {
-      Collections.sort(insertionOrder, Collections.reverseOrder());
+      Collections.sort(insertionOrder, Comparator.reverseOrder());
       return insertionOrder;
     }
   }
@@ -223,7 +224,7 @@ public class SetGenerators {
 
     @Override
     public List<String> order(List<String> insertionOrder) {
-      Collections.sort(insertionOrder, Collections.reverseOrder());
+      Collections.sort(insertionOrder, Comparator.reverseOrder());
       return insertionOrder;
     }
   }
@@ -320,7 +321,7 @@ public class SetGenerators {
     elementsPlus.addAll(Arrays.asList(elements));
     elementsPlus.add(AFTER_LAST);
     elementsPlus.add(AFTER_LAST_2);
-    return Ordering.explicit(Lists.newArrayList(elementsPlus));
+    return Ordering.explicit(new ArrayList<>(elementsPlus));
   }
 
   /*
@@ -339,7 +340,7 @@ public class SetGenerators {
     SortedSet<E> set = newTreeSet();
     for (E element : elements) {
       // Explicit null check because TreeSet wrongly accepts add(null) when empty.
-      set.add(checkNotNull(element));
+      set.add(requireNonNull(element));
     }
     return set;
   }
@@ -408,7 +409,7 @@ public class SetGenerators {
   private abstract static class AbstractContiguousSetGenerator
       extends TestIntegerSortedSetGenerator {
     protected final ContiguousSet<Integer> checkedCreate(SortedSet<Integer> elementsSet) {
-      List<Integer> elements = newArrayList(elementsSet);
+      List<Integer> elements = new ArrayList<>(elementsSet);
       /*
        * A ContiguousSet can't have holes. If a test demands a hole, it should be changed so that it
        * doesn't need one, or it should be suppressed for ContiguousSet.
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapAsMapTester.java b/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapAsMapTester.java
index 6e79957208..98e9460c19 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapAsMapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapAsMapTester.java
@@ -16,6 +16,8 @@ package com.google.common.collect.testing.google;
 
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;
+import static java.util.Collections.singleton;
+import static java.util.Collections.singletonMap;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Maps;
@@ -27,7 +29,6 @@ import com.google.common.collect.testing.features.MapFeature;
 import com.google.common.testing.EqualsTester;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -52,7 +53,7 @@ public class SetMultimapAsMapTester<K, V> extends AbstractMultimapTester<K, V, S
 
   public void testAsMapGetImplementsSet() {
     for (K key : multimap().keySet()) {
-      assertTrue(multimap().asMap().get(key) instanceof Set);
+      assertTrue(multimap().get(key) instanceof Set);
     }
   }
 
@@ -90,8 +91,8 @@ public class SetMultimapAsMapTester<K, V> extends AbstractMultimapTester<K, V, S
   public void testValuesRemove() {
     resetContainer(
         Helpers.mapEntry(k0(), v0()), Helpers.mapEntry(k1(), v0()), Helpers.mapEntry(k0(), v3()));
-    assertTrue(multimap().asMap().values().remove(Collections.singleton(v0())));
+    assertTrue(multimap().asMap().values().remove(singleton(v0())));
     assertEquals(2, multimap().size());
-    assertEquals(Collections.singletonMap(k0(), Sets.newHashSet(v0(), v3())), multimap().asMap());
+    assertEquals(singletonMap(k0(), Sets.newHashSet(v0(), v3())), multimap().asMap());
   }
 }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapPutTester.java b/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapPutTester.java
index 7aaf9dce54..65b9e01de3 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapPutTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapPutTester.java
@@ -39,8 +39,8 @@ import org.junit.Ignore;
 public class SetMultimapPutTester<K, V> extends AbstractMultimapTester<K, V, SetMultimap<K, V>> {
   // Tests for non-duplicate values are in MultimapPutTester
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutDuplicateValuePreservesSize() {
     assertFalse(multimap().put(k0(), v0()));
     assertEquals(getNumElements(), multimap().size());
@@ -64,8 +64,8 @@ public class SetMultimapPutTester<K, V> extends AbstractMultimapTester<K, V, Set
     }
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPutDuplicateValue_null() {
     initMultimapWithNullValue();
     assertFalse(multimap().put(getKeyForNullValue(), null));
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapTestSuiteBuilder.java
index 4368cee9bf..0ea713f501 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SetMultimapTestSuiteBuilder.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing.google;
 
+import static java.util.Collections.disjoint;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.testing.AbstractTester;
@@ -26,7 +28,6 @@ import com.google.common.collect.testing.SetTestSuiteBuilder;
 import com.google.common.collect.testing.TestSetGenerator;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.Feature;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map.Entry;
@@ -80,7 +81,7 @@ public class SetMultimapTestSuiteBuilder<K, V>
               ?, ? extends OneSizeTestContainerGenerator<SetMultimap<K, V>, Entry<K, V>>>
           parentBuilder) {
     Set<Feature<?>> features = computeMultimapAsMapGetFeatures(parentBuilder.getFeatures());
-    if (Collections.disjoint(features, EnumSet.allOf(CollectionSize.class))) {
+    if (disjoint(features, EnumSet.allOf(CollectionSize.class))) {
       return new TestSuite();
     } else {
       return SetTestSuiteBuilder.using(
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SortedMapGenerators.java b/guava-testlib/src/com/google/common/collect/testing/google/SortedMapGenerators.java
index 424fbb17ef..e1d2f09b2f 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SortedMapGenerators.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SortedMapGenerators.java
@@ -16,8 +16,8 @@
 
 package com.google.common.collect.testing.google;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.testing.Helpers.mapEntry;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableSortedMap;
@@ -48,7 +48,7 @@ public class SortedMapGenerators {
     public SortedMap<String, String> create(Entry<String, String>[] entries) {
       ImmutableSortedMap.Builder<String, String> builder = ImmutableSortedMap.naturalOrder();
       for (Entry<String, String> entry : entries) {
-        checkNotNull(entry);
+        requireNonNull(entry);
         builder.put(entry.getKey(), entry.getValue());
       }
       return builder.build();
@@ -76,8 +76,8 @@ public class SortedMapGenerators {
           mapEntry("toaster", -2));
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Entry<String, Integer>[] createArray(int length) {
       return new Entry[length];
     }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SortedMultisetTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/google/SortedMultisetTestSuiteBuilder.java
index b44494b81d..740c24f071 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SortedMultisetTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SortedMultisetTestSuiteBuilder.java
@@ -20,6 +20,7 @@ import static com.google.common.collect.testing.features.CollectionFeature.KNOWN
 import static com.google.common.collect.testing.features.CollectionFeature.RESTRICTS_ELEMENTS;
 import static com.google.common.collect.testing.features.CollectionFeature.SERIALIZABLE;
 import static com.google.common.collect.testing.features.CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS;
+import static java.util.Collections.emptySet;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.BoundType;
@@ -101,7 +102,7 @@ public class SortedMultisetTestSuiteBuilder<E> extends MultisetTestSuiteBuilder<
 
     @Override
     public Set<Feature<? super Void>> getImpliedFeatures() {
-      return Collections.emptySet();
+      return emptySet();
     }
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapAsMapTester.java b/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapAsMapTester.java
index e95b74f84b..d0c6fd7be9 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapAsMapTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapAsMapTester.java
@@ -45,7 +45,7 @@ public class SortedSetMultimapAsMapTester<K, V>
 
   public void testAsMapGetImplementsSortedSet() {
     for (K key : multimap().keySet()) {
-      SortedSet<V> valueSet = (SortedSet<V>) multimap().asMap().get(key);
+      SortedSet<V> valueSet = (SortedSet<V>) multimap().get(key);
       assertEquals(multimap().valueComparator(), valueSet.comparator());
     }
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapTestSuiteBuilder.java b/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapTestSuiteBuilder.java
index 66c5a8ed09..a110aed1b1 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapTestSuiteBuilder.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/SortedSetMultimapTestSuiteBuilder.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing.google;
 
+import static java.util.Collections.disjoint;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.testing.AbstractTester;
@@ -25,7 +27,6 @@ import com.google.common.collect.testing.OneSizeTestContainerGenerator;
 import com.google.common.collect.testing.SortedSetTestSuiteBuilder;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.Feature;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map.Entry;
@@ -82,7 +83,7 @@ public class SortedSetMultimapTestSuiteBuilder<K, V>
               ?, ? extends OneSizeTestContainerGenerator<SetMultimap<K, V>, Entry<K, V>>>
           parentBuilder) {
     Set<Feature<?>> features = computeMultimapAsMapGetFeatures(parentBuilder.getFeatures());
-    if (Collections.disjoint(features, EnumSet.allOf(CollectionSize.class))) {
+    if (disjoint(features, EnumSet.allOf(CollectionSize.class))) {
       return new TestSuite();
     } else {
       return SortedSetTestSuiteBuilder.using(
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/UnmodifiableCollectionTests.java b/guava-testlib/src/com/google/common/collect/testing/google/UnmodifiableCollectionTests.java
index 40b2c859d2..3ba1e524e4 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/UnmodifiableCollectionTests.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/UnmodifiableCollectionTests.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing.google;
 
+import static java.util.Collections.singleton;
+import static java.util.Collections.unmodifiableList;
 import static junit.framework.TestCase.assertEquals;
 import static junit.framework.TestCase.assertTrue;
 import static junit.framework.TestCase.fail;
@@ -24,13 +26,11 @@ import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.LinkedHashMultiset;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multiset;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map.Entry;
@@ -265,12 +265,11 @@ public class UnmodifiableCollectionTests {
    */
   public static <K, V> void assertMultimapIsUnmodifiable(
       Multimap<K, V> multimap, K sampleKey, V sampleValue) {
-    List<Entry<K, V>> originalEntries =
-        Collections.unmodifiableList(Lists.newArrayList(multimap.entries()));
+    List<Entry<K, V>> originalEntries = unmodifiableList(new ArrayList<>(multimap.entries()));
 
     assertMultimapRemainsUnmodified(multimap, originalEntries);
 
-    Collection<V> sampleValueAsCollection = Collections.singleton(sampleValue);
+    Collection<V> sampleValueAsCollection = singleton(sampleValue);
 
     // Test #clear()
     try {
@@ -380,7 +379,7 @@ public class UnmodifiableCollectionTests {
     if (!multimap.isEmpty()) {
       K presentKey = multimap.keySet().iterator().next();
       try {
-        multimap.asMap().get(presentKey).remove(sampleValue);
+        multimap.get(presentKey).remove(sampleValue);
         fail("asMap().get().remove() succeeded on unmodifiable multimap");
       } catch (UnsupportedOperationException expected) {
       }
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddAllTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddAllTester.java
index 5c21c9a931..81b127e298 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddAllTester.java
@@ -102,7 +102,7 @@ public class CollectionAddAllTester<E> extends AbstractCollectionTester<E> {
     expectUnchanged();
   }
 
-  @CollectionFeature.Require({SUPPORTS_ADD, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_ADD})
   @CollectionSize.Require(absent = ZERO)
   public void testAddAllConcurrentWithIteration() {
     try {
@@ -128,7 +128,7 @@ public class CollectionAddAllTester<E> extends AbstractCollectionTester<E> {
   }
 
   @CollectionFeature.Require(
-      value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES},
+      value = {ALLOWS_NULL_VALUES, SUPPORTS_ADD},
       absent = RESTRICTS_ELEMENTS)
   public void testAddAll_nullSupported() {
     List<E> containsNull = singletonList(null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddTester.java
index bed257c976..4c3d01319b 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionAddTester.java
@@ -72,7 +72,7 @@ public class CollectionAddTester<E> extends AbstractCollectionTester<E> {
   }
 
   @CollectionFeature.Require(
-      value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES},
+      value = {ALLOWS_NULL_VALUES, SUPPORTS_ADD},
       absent = RESTRICTS_ELEMENTS)
   public void testAdd_nullSupported() {
     assertTrue("add(null) should return true", collection.add(null));
@@ -90,7 +90,7 @@ public class CollectionAddTester<E> extends AbstractCollectionTester<E> {
     expectNullMissingWhenNullUnsupported("Should not contain null after unsupported add(null)");
   }
 
-  @CollectionFeature.Require({SUPPORTS_ADD, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_ADD})
   @CollectionSize.Require(absent = ZERO)
   public void testAddConcurrentWithIteration() {
     try {
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionClearTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionClearTester.java
index 9b97fff73e..37030781eb 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionClearTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionClearTester.java
@@ -69,7 +69,7 @@ public class CollectionClearTester<E> extends AbstractCollectionTester<E> {
     expectUnchanged();
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
   public void testClearConcurrentWithIteration() {
     try {
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionForEachTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionForEachTester.java
index af8490d31e..9dcf71370c 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionForEachTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionForEachTester.java
@@ -39,14 +39,14 @@ public class CollectionForEachTester<E> extends AbstractCollectionTester<E> {
   @CollectionFeature.Require(absent = KNOWN_ORDER)
   public void testForEachUnknownOrder() {
     List<E> elements = new ArrayList<>();
-    collection.forEach(elements::add);
+    elements.addAll(collection);
     Helpers.assertEqualIgnoringOrder(Arrays.asList(createSamplesArray()), elements);
   }
 
   @CollectionFeature.Require(KNOWN_ORDER)
   public void testForEachKnownOrder() {
     List<E> elements = new ArrayList<>();
-    collection.forEach(elements::add);
+    elements.addAll(collection);
     List<E> expected = Helpers.copyToList(getOrderedElements());
     assertEquals("Different ordered iteration", expected, elements);
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveAllTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveAllTester.java
index 0d59097377..ab9ad93aff 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveAllTester.java
@@ -22,6 +22,7 @@ import static com.google.common.collect.testing.features.CollectionFeature.FAILS
 import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_REMOVE;
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
+import static java.util.Collections.singleton;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.testing.AbstractCollectionTester;
@@ -29,7 +30,6 @@ import com.google.common.collect.testing.MinimalCollection;
 import com.google.common.collect.testing.WrongType;
 import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
-import java.util.Collections;
 import java.util.ConcurrentModificationException;
 import java.util.Iterator;
 import org.junit.Ignore;
@@ -79,7 +79,7 @@ public class CollectionRemoveAllTester<E> extends AbstractCollectionTester<E> {
     expectMissing(e0());
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
   public void testRemoveAllSomePresentConcurrentWithIteration() {
     try {
@@ -177,20 +177,18 @@ public class CollectionRemoveAllTester<E> extends AbstractCollectionTester<E> {
     expectUnchanged();
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_QUERIES})
+  @CollectionFeature.Require({ALLOWS_NULL_QUERIES, SUPPORTS_REMOVE})
   public void testRemoveAll_containsNullNoButAllowed() {
     MinimalCollection<?> containsNull = MinimalCollection.of((Object) null);
     assertFalse("removeAll(containsNull) should return false", collection.removeAll(containsNull));
     expectUnchanged();
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
   public void testRemoveAll_containsNullYes() {
     initCollectionWithNullElement();
-    assertTrue(
-        "removeAll(containsNull) should return true",
-        collection.removeAll(Collections.singleton(null)));
+    assertTrue("removeAll(containsNull) should return true", collection.removeAll(singleton(null)));
     // TODO: make this work with MinimalCollection
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveIfTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveIfTester.java
index bc0139f841..170aaf3bf8 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveIfTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveIfTester.java
@@ -64,7 +64,7 @@ public class CollectionRemoveIfTester<E> extends AbstractCollectionTester<E> {
     expectContents();
   }
 
-  @CollectionFeature.Require({SUPPORTS_ITERATOR_REMOVE, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_ITERATOR_REMOVE})
   @CollectionSize.Require(SEVERAL)
   public void testRemoveIfSomeMatchesConcurrentWithIteration() {
     try {
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveTester.java
index 49568fc280..be8e2c02d8 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRemoveTester.java
@@ -54,7 +54,7 @@ public class CollectionRemoveTester<E> extends AbstractCollectionTester<E> {
     expectMissing(e0());
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, FAILS_FAST_ON_CONCURRENT_MODIFICATION})
+  @CollectionFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
   public void testRemovePresentConcurrentWithIteration() {
     try {
@@ -73,7 +73,7 @@ public class CollectionRemoveTester<E> extends AbstractCollectionTester<E> {
     expectUnchanged();
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
   public void testRemove_nullPresent() {
     collection = getSubjectGenerator().create(createArrayWithNullElement());
@@ -122,7 +122,7 @@ public class CollectionRemoveTester<E> extends AbstractCollectionTester<E> {
     expectUnchanged();
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_QUERIES})
+  @CollectionFeature.Require({ALLOWS_NULL_QUERIES, SUPPORTS_REMOVE})
   public void testRemove_nullAllowed() {
     assertFalse("remove(null) should return false", collection.remove(null));
     expectUnchanged();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRetainAllTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRetainAllTester.java
index db7aef1392..1d5c1b5dc5 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRetainAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionRetainAllTester.java
@@ -169,14 +169,14 @@ public class CollectionRetainAllTester<E> extends AbstractCollectionTester<E> {
   // retainAll(subset)
 
   @CollectionFeature.Require(SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRetainAll_subset() {
     expectReturnsTrue(nonEmptyProperSubset);
     expectContents(nonEmptyProperSubset.toRetain);
   }
 
   @CollectionFeature.Require(absent = SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRetainAll_subsetUnsupported() {
     expectThrows(nonEmptyProperSubset);
     expectUnchanged();
@@ -199,14 +199,14 @@ public class CollectionRetainAllTester<E> extends AbstractCollectionTester<E> {
   // retainAll(partialOverlap)
 
   @CollectionFeature.Require(SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRetainAll_partialOverlap() {
     expectReturnsTrue(partialOverlap);
     expectContents(e2());
   }
 
   @CollectionFeature.Require(absent = SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRetainAll_partialOverlapUnsupported() {
     expectThrows(partialOverlap);
     expectUnchanged();
@@ -222,7 +222,7 @@ public class CollectionRetainAllTester<E> extends AbstractCollectionTester<E> {
   }
 
   @CollectionFeature.Require(SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRetainAll_containsDuplicatesSizeSeveral() {
     expectReturnsTrue(containsDuplicates);
     expectContents(e0());
@@ -244,7 +244,7 @@ public class CollectionRetainAllTester<E> extends AbstractCollectionTester<E> {
     expectContents();
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
   @CollectionSize.Require(ONE)
   public void testRetainAll_nullSingletonPreviouslySingletonWithNull() {
     initCollectionWithNullElement();
@@ -252,8 +252,8 @@ public class CollectionRetainAllTester<E> extends AbstractCollectionTester<E> {
     expectContents(createArrayWithNullElement());
   }
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRetainAll_nullSingletonPreviouslySeveralWithNull() {
     initCollectionWithNullElement();
     expectReturnsTrue(nullSingleton);
@@ -262,7 +262,7 @@ public class CollectionRetainAllTester<E> extends AbstractCollectionTester<E> {
 
   // nullSingleton.retainAll()
 
-  @CollectionFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
   public void testRetainAll_containsNonNullWithNull() {
     initCollectionWithNullElement();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionToStringTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionToStringTester.java
index f138ccfa91..232fa4c475 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/CollectionToStringTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/CollectionToStringTester.java
@@ -43,14 +43,14 @@ public class CollectionToStringTester<E> extends AbstractCollectionTester<E> {
     assertNotNull("toString() should not return null", collection.toString());
   }
 
-  @CollectionSize.Require(ZERO)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(ZERO)
   public void testToString_size0() {
     assertEquals("emptyCollection.toString should return []", "[]", collection.toString());
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(ONE)
   public void testToString_size1() {
     assertEquals(
         "size1Collection.toString should return [{element}]",
@@ -58,15 +58,15 @@ public class CollectionToStringTester<E> extends AbstractCollectionTester<E> {
         collection.toString());
   }
 
-  @CollectionSize.Require(SEVERAL)
   @CollectionFeature.Require(value = KNOWN_ORDER, absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(SEVERAL)
   public void testToString_sizeSeveral() {
     String expected = Helpers.copyToList(getOrderedElements()).toString();
     assertEquals("collection.toString() incorrect", expected, collection.toString());
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
   public void testToString_null() {
     initCollectionWithNullElement();
     testToString_minimal();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapPutIfAbsentTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapPutIfAbsentTester.java
index 6cf5be2327..b287460601 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapPutIfAbsentTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapPutIfAbsentTester.java
@@ -50,8 +50,8 @@ public class ConcurrentMapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V
     expectAdded(e3());
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutIfAbsent_supportedPresent() {
     assertEquals(
         "putIfAbsent(present, value) should return existing value",
@@ -71,8 +71,8 @@ public class ConcurrentMapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V
     expectMissing(e3());
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPutIfAbsent_unsupportedPresentExistingValue() {
     try {
       assertEquals(
@@ -84,8 +84,8 @@ public class ConcurrentMapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPutIfAbsent_unsupportedPresentDifferentValue() {
     try {
       getMap().putIfAbsent(k0(), v3());
@@ -118,8 +118,8 @@ public class ConcurrentMapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V
         "Should not contain null value after unsupported put(key, null)");
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testPutIfAbsent_putWithNullValueUnsupported() {
     try {
       getMap().putIfAbsent(k0(), null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapRemoveTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapRemoveTester.java
index 87cc319b3b..e098a8b612 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapRemoveTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapRemoveTester.java
@@ -42,8 +42,8 @@ public class ConcurrentMapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     return (ConcurrentMap<K, V>) super.getMap();
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRemove_supportedPresent() {
     assertTrue(getMap().remove(k0(), v0()));
     expectMissing(e0());
@@ -87,8 +87,8 @@ public class ConcurrentMapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   public void testRemove_unsupportedPresent() {
     try {
       getMap().remove(k0(), v0());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceEntryTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceEntryTester.java
index 57f631cd8b..eb4cb98f57 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceEntryTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceEntryTester.java
@@ -43,22 +43,22 @@ public class ConcurrentMapReplaceEntryTester<K, V> extends AbstractMapTester<K,
     return (ConcurrentMap<K, V>) super.getMap();
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplaceEntry_supportedPresent() {
     assertTrue(getMap().replace(k0(), v0(), v3()));
     expectReplacement(entry(k0(), v3()));
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplaceEntry_supportedPresentUnchanged() {
     assertTrue(getMap().replace(k0(), v0(), v0()));
     expectUnchanged();
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplaceEntry_supportedWrongValue() {
     assertFalse(getMap().replace(k0(), v3(), v4()));
     expectUnchanged();
@@ -70,8 +70,8 @@ public class ConcurrentMapReplaceEntryTester<K, V> extends AbstractMapTester<K,
     expectUnchanged();
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testReplaceEntry_presentNullValueUnsupported() {
     try {
       getMap().replace(k0(), v0(), null);
@@ -81,8 +81,8 @@ public class ConcurrentMapReplaceEntryTester<K, V> extends AbstractMapTester<K,
     expectUnchanged();
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES)
   public void testReplaceEntry_wrongValueNullValueUnsupported() {
     try {
       assertFalse(getMap().replace(k0(), v3(), null));
@@ -102,7 +102,7 @@ public class ConcurrentMapReplaceEntryTester<K, V> extends AbstractMapTester<K,
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUE_QUERIES})
+  @MapFeature.Require({ALLOWS_NULL_VALUE_QUERIES, SUPPORTS_PUT})
   public void testReplaceEntry_nullDifferentFromAbsent() {
     assertFalse(getMap().replace(k3(), null, v3()));
     expectUnchanged();
@@ -118,8 +118,8 @@ public class ConcurrentMapReplaceEntryTester<K, V> extends AbstractMapTester<K,
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplaceEntry_unsupportedPresent() {
     try {
       getMap().replace(k0(), v0(), v3());
@@ -129,8 +129,8 @@ public class ConcurrentMapReplaceEntryTester<K, V> extends AbstractMapTester<K,
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplaceEntry_unsupportedWrongValue() {
     try {
       getMap().replace(k0(), v3(), v4());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceTester.java
index f0bc164472..1a50f895f6 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ConcurrentMapReplaceTester.java
@@ -44,15 +44,15 @@ public class ConcurrentMapReplaceTester<K, V> extends AbstractMapTester<K, V> {
     return (ConcurrentMap<K, V>) super.getMap();
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplace_supportedPresent() {
     assertEquals(v0(), getMap().replace(k0(), v3()));
     expectReplacement(entry(k0(), v3()));
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplace_supportedPresentNoChange() {
     assertEquals(v0(), getMap().replace(k0(), v0()));
     expectUnchanged();
@@ -64,8 +64,8 @@ public class ConcurrentMapReplaceTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testReplace_presentNullValueUnsupported() {
     try {
       getMap().replace(k0(), null);
@@ -95,8 +95,8 @@ public class ConcurrentMapReplaceTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplace_unsupportedPresent() {
     try {
       getMap().replace(k0(), v3());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAllAtIndexTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAllAtIndexTester.java
index c3e338f1a4..cf8fcad8ef 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAllAtIndexTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAllAtIndexTester.java
@@ -40,8 +40,8 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAllAtIndex_supportedAllPresent() {
     assertTrue(
         "addAll(n, allPresent) should return true",
@@ -49,8 +49,8 @@ public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
     expectAdded(0, e0());
   }
 
-  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)
   public void testAddAllAtIndex_unsupportedAllPresent() {
     try {
       getList().addAll(0, MinimalCollection.of(e0()));
@@ -60,8 +60,8 @@ public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
     expectUnchanged();
   }
 
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAllAtIndex_supportedSomePresent() {
     assertTrue(
         "addAll(n, allPresent) should return true",
@@ -69,8 +69,8 @@ public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
     expectAdded(0, e0(), e3());
   }
 
-  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)
   public void testAddAllAtIndex_unsupportedSomePresent() {
     try {
       getList().addAll(0, MinimalCollection.of(e0(), e3()));
@@ -105,8 +105,8 @@ public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
     expectAdded(0, e0(), e1(), e0(), e1());
   }
 
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAllAtIndex_nullSupported() {
     List<E> containsNull = singletonList(null);
     assertTrue("addAll(n, containsNull) should return true", getList().addAll(0, containsNull));
@@ -117,8 +117,8 @@ public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
     expectAdded(0, (E) null);
   }
 
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAllAtIndex_nullUnsupported() {
     List<E> containsNull = singletonList(null);
     try {
@@ -131,8 +131,8 @@ public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
         "Should not contain null after unsupported addAll(n, containsNull)");
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testAddAllAtIndex_middle() {
     assertTrue(
         "addAll(middle, disjoint) should return true",
@@ -140,8 +140,8 @@ public class ListAddAllAtIndexTester<E> extends AbstractListTester<E> {
     expectAdded(getNumElements() / 2, createDisjointCollection());
   }
 
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAllAtIndex_end() {
     assertTrue(
         "addAll(end, disjoint) should return true",
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAtIndexTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAtIndexTester.java
index 32310b8d38..c474b17d57 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAtIndexTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListAddAtIndexTester.java
@@ -43,15 +43,15 @@ import org.junit.Ignore;
 @GwtCompatible(emulated = true)
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListAddAtIndexTester<E> extends AbstractListTester<E> {
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAtIndex_supportedPresent() {
     getList().add(0, e0());
     expectAdded(0, e0());
   }
 
-  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(absent = SUPPORTS_ADD_WITH_INDEX)
   /*
    * absent = ZERO isn't required, since unmodList.add() must
    * throw regardless, but it keeps the method name accurate.
@@ -95,29 +95,29 @@ public class ListAddAtIndexTester<E> extends AbstractListTester<E> {
     expectMissing(e3());
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testAddAtIndex_middle() {
     getList().add(getNumElements() / 2, e3());
     expectAdded(getNumElements() / 2, e3());
   }
 
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAtIndex_end() {
     getList().add(getNumElements(), e3());
     expectAdded(getNumElements(), e3());
   }
 
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAtIndex_nullSupported() {
     getList().add(0, null);
     expectAdded(0, (E) null);
   }
 
-  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)
+  @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
   public void testAddAtIndex_nullUnsupported() {
     try {
       getList().add(0, null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListAddTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListAddTester.java
index 8559d3464d..9aed7261f2 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListAddTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListAddTester.java
@@ -60,7 +60,7 @@ public class ListAddTester<E> extends AbstractListTester<E> {
     }
   }
 
-  @CollectionFeature.Require(value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_ADD})
   @CollectionSize.Require(absent = ZERO)
   public void testAdd_supportedNullPresent() {
     E[] array = createArrayWithNullElement();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListCreationTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListCreationTester.java
index 9d0b77ab2d..9e17e75b7b 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListCreationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListCreationTester.java
@@ -36,7 +36,7 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListCreationTester<E> extends AbstractListTester<E> {
   @CollectionFeature.Require(absent = REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testCreateWithDuplicates() {
     E[] array = createSamplesArray();
     array[1] = e0();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListEqualsTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListEqualsTester.java
index 3a09586f80..c5a837ca66 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListEqualsTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListEqualsTester.java
@@ -59,8 +59,8 @@ public class ListEqualsTester<E> extends AbstractListTester<E> {
         getList().equals(other));
   }
 
-  @CollectionSize.Require(absent = CollectionSize.ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = CollectionSize.ZERO)
   public void testEquals_containingNull() {
     ArrayList<E> elements = new ArrayList<>(getSampleElements());
     elements.set(elements.size() / 2, null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListIndexOfTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListIndexOfTester.java
index 7afb8c8281..c3443859cc 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListIndexOfTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListIndexOfTester.java
@@ -45,7 +45,7 @@ public class ListIndexOfTester<E> extends AbstractListIndexOfTester<E> {
   }
 
   @CollectionFeature.Require(absent = REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testIndexOf_duplicate() {
     E[] array = createSamplesArray();
     array[getNumElements() / 2] = e0();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListLastIndexOfTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListLastIndexOfTester.java
index 19f7f1e123..ec3148eba6 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListLastIndexOfTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListLastIndexOfTester.java
@@ -45,7 +45,7 @@ public class ListLastIndexOfTester<E> extends AbstractListIndexOfTester<E> {
   }
 
   @CollectionFeature.Require(absent = REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testLastIndexOf_duplicate() {
     E[] array = createSamplesArray();
     array[getNumElements() / 2] = e0();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListListIteratorTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListListIteratorTester.java
index 0d4b13e684..64c723cbd7 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListListIteratorTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListListIteratorTester.java
@@ -49,7 +49,7 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListListIteratorTester<E> extends AbstractListTester<E> {
   @CollectionFeature.Require(absent = SUPPORTS_REMOVE)
-  @ListFeature.Require(absent = {SUPPORTS_SET, SUPPORTS_ADD_WITH_INDEX})
+  @ListFeature.Require(absent = {SUPPORTS_ADD_WITH_INDEX, SUPPORTS_SET})
   public void testListIterator_unmodifiable() {
     runListIteratorTest(UNMODIFIABLE);
   }
@@ -59,7 +59,7 @@ public class ListListIteratorTester<E> extends AbstractListTester<E> {
    * modification operations.
    */
   @CollectionFeature.Require(SUPPORTS_REMOVE)
-  @ListFeature.Require({SUPPORTS_SET, SUPPORTS_ADD_WITH_INDEX})
+  @ListFeature.Require({SUPPORTS_ADD_WITH_INDEX, SUPPORTS_SET})
   public void testListIterator_fullyModifiable() {
     runListIteratorTest(MODIFIABLE);
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAllTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAllTester.java
index 513134cd44..90f141b7b5 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAllTester.java
@@ -37,7 +37,7 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListRemoveAllTester<E> extends AbstractListTester<E> {
   @CollectionFeature.Require(SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRemoveAll_duplicate() {
     ArrayWithDuplicate<E> arrayAndDuplicate = createArrayWithDuplicateElement();
     collection = getSubjectGenerator().create(arrayAndDuplicate.elements);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAtIndexTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAtIndexTester.java
index 9714251527..f7e5e74666 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAtIndexTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveAtIndexTester.java
@@ -40,8 +40,8 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListRemoveAtIndexTester<E> extends AbstractListTester<E> {
-  @ListFeature.Require(absent = SUPPORTS_REMOVE_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(absent = SUPPORTS_REMOVE_WITH_INDEX)
   public void testRemoveAtIndex_unsupported() {
     try {
       getList().remove(0);
@@ -71,21 +71,21 @@ public class ListRemoveAtIndexTester<E> extends AbstractListTester<E> {
     expectUnchanged();
   }
 
-  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   public void testRemoveAtIndex_first() {
     runRemoveTest(0);
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testRemoveAtIndex_middle() {
     runRemoveTest(getNumElements() / 2);
   }
 
   @CollectionFeature.Require(FAILS_FAST_ON_CONCURRENT_MODIFICATION)
-  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   public void testRemoveAtIndexConcurrentWithIteration() {
     try {
       Iterator<E> iterator = collection.iterator();
@@ -97,8 +97,8 @@ public class ListRemoveAtIndexTester<E> extends AbstractListTester<E> {
     }
   }
 
-  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   public void testRemoveAtIndex_last() {
     runRemoveTest(getNumElements() - 1);
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveTester.java
index 9c2c688aba..8b117fb565 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListRemoveTester.java
@@ -35,7 +35,7 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListRemoveTester<E> extends AbstractListTester<E> {
   @CollectionFeature.Require(SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRemove_duplicate() {
     ArrayWithDuplicate<E> arrayAndDuplicate = createArrayWithDuplicateElement();
     collection = getSubjectGenerator().create(arrayAndDuplicate.elements);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListRetainAllTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListRetainAllTester.java
index 96bd3b4004..655f398b73 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListRetainAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListRetainAllTester.java
@@ -39,7 +39,7 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListRetainAllTester<E> extends AbstractListTester<E> {
   @CollectionFeature.Require(SUPPORTS_REMOVE)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testRetainAll_duplicatesKept() {
     E[] array = createSamplesArray();
     array[1] = e0();
@@ -50,9 +50,9 @@ public class ListRetainAllTester<E> extends AbstractListTester<E> {
     expectContents(array);
   }
 
-  @SuppressWarnings("unchecked")
   @CollectionFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @SuppressWarnings("unchecked")
   public void testRetainAll_duplicatesRemoved() {
     E[] array = createSamplesArray();
     array[1] = e0();
@@ -63,9 +63,9 @@ public class ListRetainAllTester<E> extends AbstractListTester<E> {
     expectContents(e2());
   }
 
-  @SuppressWarnings("unchecked")
   @CollectionFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @SuppressWarnings("unchecked")
   public void testRetainAll_countIgnored() {
     resetContainer(getSubjectGenerator().create(e0(), e2(), e1(), e0()));
     assertTrue(getList().retainAll(Arrays.asList(e0(), e1())));
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListSetTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListSetTester.java
index 844f1b4d60..924a7605aa 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListSetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListSetTester.java
@@ -38,21 +38,21 @@ import org.junit.Ignore;
 @GwtCompatible(emulated = true)
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class ListSetTester<E> extends AbstractListTester<E> {
-  @ListFeature.Require(SUPPORTS_SET)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_SET)
   public void testSet() {
     doTestSet(e3());
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
   @ListFeature.Require(SUPPORTS_SET)
   public void testSet_null() {
     doTestSet(null);
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
   @ListFeature.Require(SUPPORTS_SET)
   public void testSet_replacingNull() {
     E[] elements = createSamplesArray();
@@ -117,9 +117,9 @@ public class ListSetTester<E> extends AbstractListTester<E> {
     expectUnchanged();
   }
 
+  @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
   @ListFeature.Require(SUPPORTS_SET)
-  @CollectionFeature.Require(absent = ALLOWS_NULL_VALUES)
   public void testSet_nullUnsupported() {
     try {
       getList().set(aValidIndex(), null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListSubListTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListSubListTester.java
index 553b693584..1690bb089d 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListSubListTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListSubListTester.java
@@ -24,6 +24,7 @@ import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_AD
 import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_REMOVE_WITH_INDEX;
 import static com.google.common.collect.testing.features.ListFeature.SUPPORTS_SET;
 import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -34,7 +35,6 @@ import com.google.common.collect.testing.features.ListFeature;
 import com.google.common.testing.SerializableTester;
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 import org.junit.Ignore;
@@ -91,8 +91,8 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
         getList().subList(0, getNumElements()));
   }
 
-  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   public void testSubList_subListRemoveAffectsOriginal() {
     List<E> subList = getList().subList(0, 1);
     subList.remove(0);
@@ -100,8 +100,8 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     expectContents(expected);
   }
 
-  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
   public void testSubList_subListClearAffectsOriginal() {
     List<E> subList = getList().subList(0, 1);
     subList.clear();
@@ -116,8 +116,8 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     expectAdded(0, e3());
   }
 
-  @ListFeature.Require(SUPPORTS_SET)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_SET)
   public void testSubList_subListSetAffectsOriginal() {
     List<E> subList = getList().subList(0, 1);
     subList.set(0, e3());
@@ -126,20 +126,20 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     expectContents(expected);
   }
 
-  @ListFeature.Require(SUPPORTS_SET)
   @CollectionSize.Require(absent = ZERO)
+  @ListFeature.Require(SUPPORTS_SET)
   public void testSubList_originalListSetAffectsSubList() {
     List<E> subList = getList().subList(0, 1);
     getList().set(0, e3());
     assertEquals(
         "A set() call to a list after a sublist has been created "
             + "should be reflected in the sublist",
-        Collections.singletonList(e3()),
+        singletonList(e3()),
         subList);
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @ListFeature.Require(SUPPORTS_REMOVE_WITH_INDEX)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testSubList_subListRemoveAffectsOriginalLargeList() {
     List<E> subList = getList().subList(1, 3);
     subList.remove(e2());
@@ -148,16 +148,16 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     expectContents(expected);
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @ListFeature.Require(SUPPORTS_ADD_WITH_INDEX)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testSubList_subListAddAtIndexAffectsOriginalLargeList() {
     List<E> subList = getList().subList(2, 3);
     subList.add(0, e3());
     expectAdded(2, e3());
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @ListFeature.Require(SUPPORTS_SET)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testSubList_subListSetAffectsOriginalLargeList() {
     List<E> subList = getList().subList(1, 2);
     subList.set(0, e3());
@@ -166,8 +166,8 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     expectContents(expected);
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @ListFeature.Require(SUPPORTS_SET)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testSubList_originalListSetAffectsSubListLargeList() {
     List<E> subList = getList().subList(1, 3);
     getList().set(1, e3());
@@ -183,17 +183,17 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     assertEquals("subList(0, 0).subList(0, 0) should be an empty list", emptyList(), subList);
   }
 
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testSubList_ofSubListNonEmpty() {
     List<E> subList = getList().subList(0, 2).subList(1, 2);
     assertEquals(
         "subList(0, 2).subList(1, 2) "
             + "should be a single-element list of the element at index 1",
-        Collections.singletonList(getOrderedElements().get(1)),
+        singletonList(getOrderedElements().get(1)),
         subList);
   }
 
-  @CollectionSize.Require(absent = {ZERO})
+  @CollectionSize.Require(absent = ZERO)
   public void testSubList_size() {
     List<E> list = getList();
     int size = getNumElements();
@@ -204,7 +204,7 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     assertEquals(0, list.subList(0, 0).size());
   }
 
-  @CollectionSize.Require(absent = {ZERO})
+  @CollectionSize.Require(absent = ZERO)
   public void testSubList_isEmpty() {
     List<E> list = getList();
     int size = getNumElements();
@@ -215,11 +215,11 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
             list.subList(1, size),
             list.subList(0, 0),
             list.subList(size, size))) {
-      assertEquals(subList.size() == 0, subList.isEmpty());
+      assertEquals(subList.isEmpty(), subList.isEmpty());
     }
   }
 
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testSubList_get() {
     List<E> list = getList();
     int size = getNumElements();
@@ -243,7 +243,7 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     }
   }
 
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testSubList_contains() {
     List<E> list = getList();
     int size = getNumElements();
@@ -261,7 +261,7 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     assertFalse(tail.contains(list.get(0)));
   }
 
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testSubList_indexOf() {
     List<E> list = getList();
     int size = getNumElements();
@@ -279,7 +279,7 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
     assertEquals(-1, tail.indexOf(list.get(0)));
   }
 
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testSubList_lastIndexOf() {
     List<E> list = getList();
     int size = list.size();
@@ -308,7 +308,7 @@ public class ListSubListTester<E> extends AbstractListTester<E> {
   }
 
   @CollectionFeature.Require(SERIALIZABLE_INCLUDING_VIEWS)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testReserializeSubList() {
     SerializableTester.reserializeAndAssert(getList().subList(0, 2));
   }
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/ListToArrayTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/ListToArrayTester.java
index 4c5eb091fe..40237e0ffc 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/ListToArrayTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/ListToArrayTester.java
@@ -41,12 +41,12 @@ public class ListToArrayTester<E> extends AbstractListTester<E> {
 
   @CollectionSize.Require(absent = ZERO)
   public void testToArray_tooSmall() {
-    Object[] actual = getList().toArray(new Object[0]);
+    Object[] actual = getList().toArray();
     assertArrayEquals("toArray(tooSmall) order should match list", createOrderedArray(), actual);
   }
 
   public void testToArray_largeEnough() {
-    Object[] actual = getList().toArray(new Object[getNumElements()]);
+    Object[] actual = getList().toArray();
     assertArrayEquals("toArray(largeEnough) order should match list", createOrderedArray(), actual);
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapClearTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapClearTester.java
index 64f5127e7f..468188762d 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapClearTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapClearTester.java
@@ -48,8 +48,8 @@ public class MapClearTester<K, V> extends AbstractMapTester<K, V> {
     assertFalse(getMap().entrySet().iterator().hasNext());
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   public void testClearConcurrentWithEntrySetIteration() {
     try {
       Iterator<Entry<K, V>> iterator = getMap().entrySet().iterator();
@@ -61,8 +61,8 @@ public class MapClearTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   public void testClearConcurrentWithKeySetIteration() {
     try {
       Iterator<K> iterator = getMap().keySet().iterator();
@@ -74,8 +74,8 @@ public class MapClearTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   public void testClearConcurrentWithValuesIteration() {
     try {
       Iterator<V> iterator = getMap().values().iterator();
@@ -87,8 +87,8 @@ public class MapClearTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   public void testClear_unsupported() {
     try {
       getMap().clear();
@@ -100,8 +100,8 @@ public class MapClearTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   public void testClear_unsupportedByEmptyCollection() {
     try {
       getMap().clear();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfAbsentTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfAbsentTester.java
index a6ca7be067..776ef47f99 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfAbsentTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfAbsentTester.java
@@ -54,8 +54,8 @@ public class MapComputeIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectAdded(e3());
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testComputeIfAbsent_supportedPresent() {
     assertEquals(
         "computeIfAbsent(present, function) should return existing value",
@@ -83,8 +83,8 @@ public class MapComputeIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testComputeIfAbsent_nullTreatedAsAbsent() {
     initMapWithNullValue();
     assertEquals(
@@ -100,7 +100,7 @@ public class MapComputeIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectReplacement(entry(getKeyForNullValue(), getValueForNullKey()));
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testComputeIfAbsent_nullKeySupported() {
     getMap()
         .computeIfAbsent(
@@ -147,8 +147,8 @@ public class MapComputeIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testComputeIfAbsent_unsupportedPresentExistingValue() {
     try {
       assertEquals(
@@ -166,8 +166,8 @@ public class MapComputeIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testComputeIfAbsent_unsupportedPresentDifferentValue() {
     try {
       assertEquals(
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfPresentTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfPresentTester.java
index 02e097a867..b4d1e82156 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfPresentTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeIfPresentTester.java
@@ -53,8 +53,8 @@ public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testComputeIfPresent_supportedPresent() {
     assertEquals(
         "computeIfPresent(present, function) should return new value",
@@ -70,8 +70,8 @@ public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {
     expectReplacement(entry(k0(), v3()));
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testComputeIfPresent_functionReturnsNull() {
     assertNull(
         "computeIfPresent(present, returnsNull) should return null",
@@ -86,8 +86,8 @@ public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {
     expectMissing(e0());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testComputeIfPresent_nullTreatedAsAbsent() {
     initMapWithNullValue();
     assertNull(
@@ -103,8 +103,8 @@ public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {
 
   static class ExpectedException extends RuntimeException {}
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testComputeIfPresent_functionThrows() {
     try {
       getMap()
@@ -121,8 +121,8 @@ public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testComputeIfPresent_nullKeySupportedPresent() {
     initMapWithNullKey();
     assertEquals(
@@ -142,7 +142,7 @@ public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {
     expectContents(expected);
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testComputeIfPresent_nullKeySupportedAbsent() {
     assertNull(
         "computeIfPresent(null, function) should return null",
@@ -169,8 +169,8 @@ public class MapComputeIfPresentTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testComputeIfPresent_unsupportedPresent() {
     try {
       getMap().computeIfPresent(k0(), (k, v) -> v3());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeTester.java
index eb79e08791..ecceaf96b9 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapComputeTester.java
@@ -71,8 +71,8 @@ public class MapComputeTester<K, V> extends AbstractMapTester<K, V> {
     assertEquals(getNumElements(), getMap().size());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testCompute_presentToPresent() {
     assertEquals(
         "Map.compute(present, functionReturningValue) should return new value",
@@ -89,8 +89,8 @@ public class MapComputeTester<K, V> extends AbstractMapTester<K, V> {
     assertEquals(getNumElements(), getMap().size());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testCompute_presentToAbsent() {
     assertNull(
         "Map.compute(present, functionReturningNull) should return null",
@@ -107,8 +107,8 @@ public class MapComputeTester<K, V> extends AbstractMapTester<K, V> {
     assertEquals(getNumElements() - 1, getMap().size());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testCompute_presentNullToPresentNonnull() {
     initMapWithNullValue();
     V value = getValueForNullKey();
@@ -127,8 +127,8 @@ public class MapComputeTester<K, V> extends AbstractMapTester<K, V> {
     assertEquals(getNumElements(), getMap().size());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testCompute_presentNullToNull() {
     // The spec is somewhat ambiguous about this case, but the actual default implementation
     // in Map will remove a present null.
@@ -147,8 +147,8 @@ public class MapComputeTester<K, V> extends AbstractMapTester<K, V> {
     assertEquals(getNumElements() - 1, getMap().size());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE, ALLOWS_NULL_KEYS})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testCompute_nullKeyPresentToPresent() {
     initMapWithNullKey();
     assertEquals(
@@ -167,8 +167,8 @@ public class MapComputeTester<K, V> extends AbstractMapTester<K, V> {
 
   static class ExpectedException extends RuntimeException {}
 
-  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({SUPPORTS_PUT, SUPPORTS_REMOVE})
   public void testCompute_presentFunctionThrows() {
     try {
       getMap()
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsKeyTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsKeyTester.java
index 3721db1174..2ac9adc331 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsKeyTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsKeyTester.java
@@ -55,15 +55,15 @@ public class MapContainsKeyTester<K, V> extends AbstractMapTester<K, V> {
     expectNullKeyMissingWhenNullKeysUnsupported("containsKey(null) should return false or throw");
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testContains_nonNullWhenNullContained() {
     initMapWithNullKey();
     assertFalse("containsKey(notPresent) should return false", getMap().containsKey(k3()));
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testContains_nullContained() {
     initMapWithNullKey();
     assertTrue("containsKey(null) should return true", getMap().containsKey(null));
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsValueTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsValueTester.java
index 044562ab6e..5047ed0e40 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsValueTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapContainsValueTester.java
@@ -57,15 +57,15 @@ public class MapContainsValueTester<K, V> extends AbstractMapTester<K, V> {
         "containsValue(null) should return false or throw");
   }
 
-  @MapFeature.Require(ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testContains_nonNullWhenNullContained() {
     initMapWithNullValue();
     assertFalse("containsValue(notPresent) should return false", getMap().containsValue(v3()));
   }
 
-  @MapFeature.Require(ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testContains_nullContained() {
     initMapWithNullValue();
     assertTrue("containsValue(null) should return true", getMap().containsValue(null));
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapCreationTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapCreationTester.java
index 0810dea28a..cdf7b1edab 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapCreationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapCreationTester.java
@@ -45,15 +45,15 @@ import org.junit.Ignore;
 @GwtCompatible(emulated = true)
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class MapCreationTester<K, V> extends AbstractMapTester<K, V> {
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testCreateWithNullKeySupported() {
     initMapWithNullKey();
     expectContents(createArrayWithNullKey());
   }
 
-  @MapFeature.Require(absent = ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = ALLOWS_NULL_KEYS)
   public void testCreateWithNullKeyUnsupported() {
     try {
       initMapWithNullKey();
@@ -62,15 +62,15 @@ public class MapCreationTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testCreateWithNullValueSupported() {
     initMapWithNullValue();
     expectContents(createArrayWithNullValue());
   }
 
-  @MapFeature.Require(absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = ALLOWS_NULL_VALUES)
   public void testCreateWithNullValueUnsupported() {
     try {
       initMapWithNullValue();
@@ -79,8 +79,8 @@ public class MapCreationTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({ALLOWS_NULL_KEYS, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_KEYS, ALLOWS_NULL_VALUES})
   public void testCreateWithNullKeyAndValueSupported() {
     Entry<K, V>[] entries = createSamplesArray();
     entries[getNullLocation()] = entry(null, null);
@@ -88,20 +88,20 @@ public class MapCreationTester<K, V> extends AbstractMapTester<K, V> {
     expectContents(entries);
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @MapFeature.Require(value = ALLOWS_NULL_KEYS, absent = REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testCreateWithDuplicates_nullDuplicatesNotRejected() {
     expectFirstRemoved(getEntriesMultipleNullKeys());
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @MapFeature.Require(absent = REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testCreateWithDuplicates_nonNullDuplicatesNotRejected() {
     expectFirstRemoved(getEntriesMultipleNonNullKeys());
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @MapFeature.Require({ALLOWS_NULL_KEYS, REJECTS_DUPLICATES_AT_CREATION})
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testCreateWithDuplicates_nullDuplicatesRejected() {
     Entry<K, V>[] entries = getEntriesMultipleNullKeys();
     try {
@@ -111,8 +111,8 @@ public class MapCreationTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
+  @CollectionSize.Require(absent = {ONE, ZERO})
   @MapFeature.Require(REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
   public void testCreateWithDuplicates_nonNullDuplicatesRejected() {
     Entry<K, V>[] entries = getEntriesMultipleNonNullKeys();
     try {
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapEntrySetTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapEntrySetTester.java
index 537f091b4a..4b4387aaaf 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapEntrySetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapEntrySetTester.java
@@ -52,8 +52,8 @@ public class MapEntrySetTester<K, V> extends AbstractMapTester<K, V> {
     INSTANCE;
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
+  @CollectionSize.Require(ONE)
   public void testEntrySetIteratorRemove() {
     Set<Entry<K, V>> entrySet = getMap().entrySet();
     Iterator<Entry<K, V>> entryItr = entrySet.iterator();
@@ -103,8 +103,8 @@ public class MapEntrySetTester<K, V> extends AbstractMapTester<K, V> {
     assertTrue(getMap().entrySet().contains(Helpers.mapEntry(getKeyForNullValue(), null)));
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testSetValue() {
     for (Entry<K, V> entry : getMap().entrySet()) {
       if (entry.getKey().equals(k0())) {
@@ -115,8 +115,8 @@ public class MapEntrySetTester<K, V> extends AbstractMapTester<K, V> {
     expectReplacement(entry(k0(), v3()));
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testSetValueWithNullValuesPresent() {
     for (Entry<K, V> entry : getMap().entrySet()) {
       if (entry.getKey().equals(k0())) {
@@ -127,8 +127,8 @@ public class MapEntrySetTester<K, V> extends AbstractMapTester<K, V> {
     expectReplacement(entry(k0(), (V) null));
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testSetValueWithNullValuesAbsent() {
     for (Entry<K, V> entry : getMap().entrySet()) {
       try {
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapForEachTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapForEachTester.java
index 40086a87ac..2ecb02eb8b 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapForEachTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapForEachTester.java
@@ -57,8 +57,8 @@ public class MapForEachTester<K, V> extends AbstractMapTester<K, V> {
     Helpers.assertEqualIgnoringOrder(getSampleEntries(), entries);
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testForEach_nullKeys() {
     initMapWithNullKey();
     List<Entry<K, V>> expectedEntries = Arrays.asList(createArrayWithNullKey());
@@ -67,8 +67,8 @@ public class MapForEachTester<K, V> extends AbstractMapTester<K, V> {
     Helpers.assertEqualIgnoringOrder(expectedEntries, entries);
   }
 
-  @MapFeature.Require(ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testForEach_nullValues() {
     initMapWithNullValue();
     List<Entry<K, V>> expectedEntries = Arrays.asList(createArrayWithNullValue());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapGetOrDefaultTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapGetOrDefaultTester.java
index 92094a8aac..812449db42 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapGetOrDefaultTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapGetOrDefaultTester.java
@@ -49,9 +49,7 @@ public class MapGetOrDefaultTester<K, V> extends AbstractMapTester<K, V> {
   @CollectionSize.Require(absent = ZERO)
   public void testGetOrDefault_presentNullDefault() {
     assertEquals(
-        "getOrDefault(present, null) should return the associated value",
-        v0(),
-        getMap().getOrDefault(k0(), null));
+        "getOrDefault(present, null) should return the associated value", v0(), getMap().get(k0()));
   }
 
   public void testGetOrDefault_absent() {
@@ -62,7 +60,7 @@ public class MapGetOrDefaultTester<K, V> extends AbstractMapTester<K, V> {
   }
 
   public void testGetOrDefault_absentNullDefault() {
-    assertNull("getOrDefault(absent, null) should return null", getMap().getOrDefault(k3(), null));
+    assertNull("getOrDefault(absent, null) should return null", getMap().get(k3()));
   }
 
   @MapFeature.Require(ALLOWS_NULL_KEY_QUERIES)
@@ -84,8 +82,8 @@ public class MapGetOrDefaultTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testGetOrDefault_nonNullWhenNullContained() {
     initMapWithNullKey();
     assertEquals(
@@ -94,8 +92,8 @@ public class MapGetOrDefaultTester<K, V> extends AbstractMapTester<K, V> {
         getMap().getOrDefault(k3(), v3()));
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testGetOrDefault_presentNull() {
     initMapWithNullKey();
     assertEquals(
@@ -104,8 +102,8 @@ public class MapGetOrDefaultTester<K, V> extends AbstractMapTester<K, V> {
         getMap().getOrDefault(null, v3()));
   }
 
-  @MapFeature.Require(ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testGetOrDefault_presentMappedToNull() {
     initMapWithNullValue();
     assertNull(
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapGetTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapGetTester.java
index 89610f26c7..2f3f2754e0 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapGetTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapGetTester.java
@@ -59,15 +59,15 @@ public class MapGetTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testGet_nonNullWhenNullContained() {
     initMapWithNullKey();
     assertNull("get(notPresent) should return null", get(k3()));
   }
 
-  @MapFeature.Require(ALLOWS_NULL_KEYS)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testGet_nullContained() {
     initMapWithNullKey();
     assertEquals("get(null) should return the associated value", getValueForNullKey(), get(null));
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapMergeTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapMergeTester.java
index c001afa009..da65752af8 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapMergeTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapMergeTester.java
@@ -58,8 +58,8 @@ public class MapMergeTester<K, V> extends AbstractMapTester<K, V> {
     expectAdded(e3());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testMappedToNull() {
     initMapWithNullValue();
     assertEquals(
@@ -76,7 +76,7 @@ public class MapMergeTester<K, V> extends AbstractMapTester<K, V> {
     expectReplacement(entry(getKeyForNullValue(), v3()));
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testMergeAbsentNullKey() {
     assertEquals(
         "Map.merge(null, value, function) should return value",
@@ -92,8 +92,8 @@ public class MapMergeTester<K, V> extends AbstractMapTester<K, V> {
     expectAdded(entry(null, v3()));
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testMergePresent() {
     assertEquals(
         "Map.merge(present, value, function) should return function result",
@@ -112,8 +112,8 @@ public class MapMergeTester<K, V> extends AbstractMapTester<K, V> {
 
   private static class ExpectedException extends RuntimeException {}
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testMergeFunctionThrows() {
     try {
       getMap()
@@ -131,8 +131,8 @@ public class MapMergeTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testMergePresentToNull() {
     assertNull(
         "Map.merge(present, value, functionReturningNull) should return null",
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapPutAllTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapPutAllTester.java
index 21d89d8d68..28af9176cd 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapPutAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapPutAllTester.java
@@ -93,15 +93,15 @@ public class MapPutAllTester<K, V> extends AbstractMapTester<K, V> {
     expectMissing(e3(), e4());
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutAll_supportedSomePresent() {
     putAll(MinimalCollection.of(e3(), e0()));
     expectAdded(e3());
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   public void testPutAllSomePresentConcurrentWithEntrySetIteration() {
     try {
       Iterator<Entry<K, V>> iterator = getMap().entrySet().iterator();
@@ -113,8 +113,8 @@ public class MapPutAllTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPutAll_unsupportedSomePresent() {
     try {
       putAll(MinimalCollection.of(e3(), e0()));
@@ -124,8 +124,8 @@ public class MapPutAllTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPutAll_unsupportedAllPresent() {
     try {
       putAll(MinimalCollection.of(e0()));
@@ -134,7 +134,7 @@ public class MapPutAllTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testPutAll_nullKeySupported() {
     putAll(containsNullKey);
     expectAdded(containsNullKey.get(0));
@@ -152,7 +152,7 @@ public class MapPutAllTester<K, V> extends AbstractMapTester<K, V> {
         "Should not contain null key after unsupported putAll(containsNullKey)");
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPutAll_nullValueSupported() {
     putAll(containsNullValue);
     expectAdded(containsNullValue.get(0));
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapPutIfAbsentTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapPutIfAbsentTester.java
index c9aa930eb0..9956e3dee9 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapPutIfAbsentTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapPutIfAbsentTester.java
@@ -45,8 +45,8 @@ public class MapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectAdded(e3());
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPutIfAbsent_supportedPresent() {
     assertEquals(
         "putIfAbsent(present, value) should return existing value",
@@ -66,8 +66,8 @@ public class MapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectMissing(e3());
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPutIfAbsent_unsupportedPresentExistingValue() {
     try {
       assertEquals(
@@ -79,8 +79,8 @@ public class MapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPutIfAbsent_unsupportedPresentDifferentValue() {
     try {
       getMap().putIfAbsent(k0(), v3());
@@ -113,8 +113,8 @@ public class MapPutIfAbsentTester<K, V> extends AbstractMapTester<K, V> {
         "Should not contain null value after unsupported put(key, null)");
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testPutIfAbsent_putWithNullValueUnsupported() {
     try {
       getMap().putIfAbsent(k0(), null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapPutTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapPutTester.java
index c9a745d4ad..1491b79b4b 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapPutTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapPutTester.java
@@ -59,8 +59,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     presentKeyNullValueEntry = entry(k0(), null);
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testPut_supportedPresent() {
     assertEquals("put(present, value) should return the old value", v0(), getMap().put(k0(), v3()));
     expectReplacement(entry(k0(), v3()));
@@ -72,8 +72,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     expectAdded(e3());
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   public void testPutAbsentConcurrentWithEntrySetIteration() {
     try {
       Iterator<Entry<K, V>> iterator = getMap().entrySet().iterator();
@@ -85,8 +85,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   public void testPutAbsentConcurrentWithKeySetIteration() {
     try {
       Iterator<K> iterator = getMap().keySet().iterator();
@@ -98,8 +98,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_PUT})
   public void testPutAbsentConcurrentWithValueIteration() {
     try {
       Iterator<V> iterator = getMap().values().iterator();
@@ -122,8 +122,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     expectMissing(e3());
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPut_unsupportedPresentExistingValue() {
     try {
       assertEquals("put(present, existingValue) should return present or throw", v0(), put(e0()));
@@ -132,8 +132,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testPut_unsupportedPresentDifferentValue() {
     try {
       getMap().put(k0(), v3());
@@ -143,14 +143,14 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testPut_nullKeySupportedNotPresent() {
     assertNull("put(null, value) should return null", put(nullKeyEntry));
     expectAdded(nullKeyEntry);
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_PUT})
   public void testPut_nullKeySupportedPresent() {
     Entry<K, V> newEntry = entry(null, v3());
     initMapWithNullKey();
@@ -176,7 +176,7 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
         "Should not contain null key after unsupported put(null, value)");
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPut_nullValueSupported() {
     assertNull("put(key, null) should return null", put(nullValueEntry));
     expectAdded(nullValueEntry);
@@ -194,8 +194,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
         "Should not contain null value after unsupported put(key, null)");
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPut_replaceWithNullValueSupported() {
     assertEquals(
         "put(present, null) should return the associated value",
@@ -204,8 +204,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     expectReplacement(presentKeyNullValueEntry);
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testPut_replaceWithNullValueUnsupported() {
     try {
       put(presentKeyNullValueEntry);
@@ -217,8 +217,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
         "Should not contain null after unsupported put(present, null)");
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPut_replaceNullValueWithNullSupported() {
     initMapWithNullValue();
     assertNull(
@@ -227,8 +227,8 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     expectContents(createArrayWithNullValue());
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUES})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPut_replaceNullValueWithNonNullSupported() {
     Entry<K, V> newEntry = entry(getKeyForNullValue(), v3());
     initMapWithNullValue();
@@ -239,7 +239,7 @@ public class MapPutTester<K, V> extends AbstractMapTester<K, V> {
     expectContents(expected);
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_KEYS, ALLOWS_NULL_VALUES})
+  @MapFeature.Require({ALLOWS_NULL_KEYS, ALLOWS_NULL_VALUES, SUPPORTS_PUT})
   public void testPut_nullKeyAndValueSupported() {
     assertNull("put(null, null) should return null", put(nullKeyValueEntry));
     expectAdded(nullKeyValueEntry);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveEntryTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveEntryTester.java
index a59a74a101..2638a20c13 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveEntryTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveEntryTester.java
@@ -37,8 +37,8 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class MapRemoveEntryTester<K, V> extends AbstractMapTester<K, V> {
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRemove_supportedPresent() {
     assertTrue(getMap().remove(k0(), v0()));
     expectMissing(e0());
@@ -82,8 +82,8 @@ public class MapRemoveEntryTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   public void testRemove_unsupportedPresent() {
     try {
       getMap().remove(k0(), v0());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveTester.java
index 00c074e5e8..94409fb05f 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapRemoveTester.java
@@ -44,8 +44,8 @@ import org.junit.Ignore;
 @GwtCompatible
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class MapRemoveTester<K, V> extends AbstractMapTester<K, V> {
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testRemove_present() {
     int initialSize = getMap().size();
     assertEquals("remove(present) should return the associated value", v0(), getMap().remove(k0()));
@@ -54,8 +54,8 @@ public class MapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     expectMissing(e0());
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   public void testRemovePresentConcurrentWithEntrySetIteration() {
     try {
       Iterator<Entry<K, V>> iterator = getMap().entrySet().iterator();
@@ -67,8 +67,8 @@ public class MapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   public void testRemovePresentConcurrentWithKeySetIteration() {
     try {
       Iterator<K> iterator = getMap().keySet().iterator();
@@ -80,8 +80,8 @@ public class MapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require({FAILS_FAST_ON_CONCURRENT_MODIFICATION, SUPPORTS_REMOVE})
   public void testRemovePresentConcurrentWithValuesIteration() {
     try {
       Iterator<V> iterator = getMap().values().iterator();
@@ -99,8 +99,8 @@ public class MapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_KEYS})
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require({ALLOWS_NULL_KEYS, SUPPORTS_REMOVE})
   public void testRemove_nullPresent() {
     initMapWithNullKey();
 
@@ -114,8 +114,8 @@ public class MapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     expectMissing(entry(null, getValueForNullKey()));
   }
 
-  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   public void testRemove_unsupported() {
     try {
       getMap().remove(k0());
@@ -148,7 +148,7 @@ public class MapRemoveTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_REMOVE, ALLOWS_NULL_KEY_QUERIES})
+  @MapFeature.Require({ALLOWS_NULL_KEY_QUERIES, SUPPORTS_REMOVE})
   public void testRemove_nullSupportedMissing() {
     assertNull("remove(null) should return null", getMap().remove(null));
     expectUnchanged();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceAllTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceAllTester.java
index eb37a60135..8283698f15 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceAllTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceAllTester.java
@@ -65,8 +65,8 @@ public class MapReplaceAllTester<K, V> extends AbstractMapTester<K, V> {
     expectContents(expectedEntries);
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionFeature.Require(KNOWN_ORDER)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplaceAllPreservesOrder() {
     getMap()
         .replaceAll(
@@ -82,8 +82,8 @@ public class MapReplaceAllTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplaceAll_unsupported() {
     try {
       getMap()
@@ -100,8 +100,8 @@ public class MapReplaceAllTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplaceAll_unsupportedByEmptyCollection() {
     try {
       getMap()
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceEntryTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceEntryTester.java
index 8a619da4db..4613fbe509 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceEntryTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceEntryTester.java
@@ -38,8 +38,8 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplaceEntry_supportedPresent() {
     try {
       assertTrue(getMap().replace(k0(), v0(), v3()));
@@ -49,15 +49,15 @@ public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplaceEntry_supportedPresentUnchanged() {
     assertTrue(getMap().replace(k0(), v0(), v0()));
     expectUnchanged();
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplaceEntry_supportedWrongValue() {
     assertFalse(getMap().replace(k0(), v3(), v4()));
     expectUnchanged();
@@ -69,8 +69,8 @@ public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testReplaceEntry_presentNullValueUnsupported() {
     try {
       getMap().replace(k0(), v0(), null);
@@ -80,8 +80,8 @@ public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUE_QUERIES)
   public void testReplaceEntry_wrongValueNullValueUnsupported() {
     try {
       assertFalse(getMap().replace(k0(), v3(), null));
@@ -101,7 +101,7 @@ public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require({SUPPORTS_PUT, ALLOWS_NULL_VALUE_QUERIES})
+  @MapFeature.Require({ALLOWS_NULL_VALUE_QUERIES, SUPPORTS_PUT})
   public void testReplaceEntry_nullDifferentFromAbsent() {
     assertFalse(getMap().replace(k3(), null, v3()));
     expectUnchanged();
@@ -117,8 +117,8 @@ public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplaceEntry_unsupportedPresent() {
     try {
       getMap().replace(k0(), v0(), v3());
@@ -128,8 +128,8 @@ public class MapReplaceEntryTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplaceEntry_unsupportedWrongValue() {
     try {
       getMap().replace(k0(), v3(), v4());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceTester.java
index b4101f2671..abb961fe82 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapReplaceTester.java
@@ -39,8 +39,8 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class MapReplaceTester<K, V> extends AbstractMapTester<K, V> {
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplace_supportedPresent() {
     try {
       assertEquals(v0(), getMap().replace(k0(), v3()));
@@ -50,8 +50,8 @@ public class MapReplaceTester<K, V> extends AbstractMapTester<K, V> {
     }
   }
 
-  @MapFeature.Require(SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(SUPPORTS_PUT)
   public void testReplace_supportedPresentNoChange() {
     assertEquals(v0(), getMap().replace(k0(), v0()));
     expectUnchanged();
@@ -63,8 +63,8 @@ public class MapReplaceTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(value = SUPPORTS_PUT, absent = ALLOWS_NULL_VALUES)
   public void testReplace_presentNullValueUnsupported() {
     try {
       getMap().replace(k0(), null);
@@ -94,8 +94,8 @@ public class MapReplaceTester<K, V> extends AbstractMapTester<K, V> {
     expectUnchanged();
   }
 
-  @MapFeature.Require(absent = SUPPORTS_PUT)
   @CollectionSize.Require(absent = ZERO)
+  @MapFeature.Require(absent = SUPPORTS_PUT)
   public void testReplace_unsupportedPresent() {
     try {
       getMap().replace(k0(), v3());
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java
index 429f8f4957..5ba3245f13 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/MapToStringTester.java
@@ -45,28 +45,28 @@ public class MapToStringTester<K, V> extends AbstractMapTester<K, V> {
     assertNotNull("toString() should not return null", getMap().toString());
   }
 
-  @CollectionSize.Require(ZERO)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(ZERO)
   public void testToString_size0() {
     assertEquals("emptyMap.toString should return {}", "{}", getMap().toString());
   }
 
-  @CollectionSize.Require(ONE)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(ONE)
   public void testToString_size1() {
     assertEquals("size1Map.toString should return {entry}", "{" + e0() + "}", getMap().toString());
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(ALLOWS_NULL_KEYS)
   public void testToStringWithNullKey() {
     initMapWithNullKey();
     testToString_formatting();
   }
 
-  @CollectionSize.Require(absent = ZERO)
   @CollectionFeature.Require(absent = NON_STANDARD_TOSTRING)
+  @CollectionSize.Require(absent = ZERO)
   @MapFeature.Require(ALLOWS_NULL_VALUES)
   public void testToStringWithNullValue() {
     initMapWithNullValue();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/NavigableMapNavigationTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/NavigableMapNavigationTester.java
index ebb86b6156..cfbf2662b0 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/NavigableMapNavigationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/NavigableMapNavigationTester.java
@@ -20,6 +20,7 @@ import static com.google.common.collect.testing.features.CollectionSize.ONE;
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
 import static com.google.common.collect.testing.features.MapFeature.SUPPORTS_REMOVE;
+import static java.util.Collections.reverse;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.AbstractMapTester;
@@ -61,7 +62,7 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
     Collections.sort(entries, Helpers.<K, V>entryComparator(navigableMap.comparator()));
 
     // some tests assume SEVERAL == 3
-    if (entries.size() >= 1) {
+    if (!entries.isEmpty()) {
       a = entries.get(0);
       if (entries.size() >= 3) {
         b = entries.get(1);
@@ -83,8 +84,8 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
     assertNull(navigableMap.firstEntry());
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testEmptyMapPollFirst() {
     assertNull(navigableMap.pollFirstEntry());
   }
@@ -106,8 +107,8 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
     assertNull(navigableMap.lastEntry());
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(ZERO)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testEmptyMapPollLast() {
     assertNull(navigableMap.pollLastEntry());
   }
@@ -117,8 +118,8 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
     assertEquals(a, navigableMap.firstEntry());
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(ONE)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testSingletonMapPollFirst() {
     assertEquals(a, navigableMap.pollFirstEntry());
     assertTrue(navigableMap.isEmpty());
@@ -141,8 +142,8 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
     assertEquals(a, navigableMap.lastEntry());
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(ONE)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testSingletonMapPollLast() {
     assertEquals(a, navigableMap.pollLastEntry());
     assertTrue(navigableMap.isEmpty());
@@ -153,8 +154,8 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
     assertEquals(a, navigableMap.firstEntry());
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testPollFirst() {
     assertEquals(a, navigableMap.pollFirstEntry());
     assertEquals(entries.subList(1, entries.size()), Helpers.copyToList(navigableMap.entrySet()));
@@ -218,16 +219,16 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
     assertEquals(c, navigableMap.lastEntry());
   }
 
-  @MapFeature.Require(SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(SUPPORTS_REMOVE)
   public void testPollLast() {
     assertEquals(c, navigableMap.pollLastEntry());
     assertEquals(
         entries.subList(0, entries.size() - 1), Helpers.copyToList(navigableMap.entrySet()));
   }
 
-  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   @CollectionSize.Require(SEVERAL)
+  @MapFeature.Require(absent = SUPPORTS_REMOVE)
   public void testPollLastUnsupported() {
     try {
       navigableMap.pollLastEntry();
@@ -239,7 +240,7 @@ public class NavigableMapNavigationTester<K, V> extends AbstractMapTester<K, V>
   @CollectionSize.Require(SEVERAL)
   public void testDescendingNavigation() {
     List<Entry<K, V>> descending = new ArrayList<>(navigableMap.descendingMap().entrySet());
-    Collections.reverse(descending);
+    reverse(descending);
     assertEquals(entries, descending);
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/NavigableSetNavigationTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/NavigableSetNavigationTester.java
index 8b056b4cb1..58d5b6e967 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/NavigableSetNavigationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/NavigableSetNavigationTester.java
@@ -20,6 +20,7 @@ import static com.google.common.collect.testing.features.CollectionFeature.SUPPO
 import static com.google.common.collect.testing.features.CollectionSize.ONE;
 import static com.google.common.collect.testing.features.CollectionSize.SEVERAL;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
+import static java.util.Collections.reverse;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.Helpers;
@@ -62,7 +63,7 @@ public class NavigableSetNavigationTester<E> extends AbstractSetTester<E> {
     Collections.sort(values, navigableSet.comparator());
 
     // some tests assume SEVERAL == 3
-    if (values.size() >= 1) {
+    if (!values.isEmpty()) {
       a = values.get(0);
       if (values.size() >= 3) {
         b = values.get(1);
@@ -222,7 +223,7 @@ public class NavigableSetNavigationTester<E> extends AbstractSetTester<E> {
     for (Iterator<E> i = navigableSet.descendingIterator(); i.hasNext(); ) {
       descending.add(i.next());
     }
-    Collections.reverse(descending);
+    reverse(descending);
     assertEquals(values, descending);
   }
 
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/QueueOfferTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/QueueOfferTester.java
index 3b17289538..cfbd0f9d05 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/QueueOfferTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/QueueOfferTester.java
@@ -39,7 +39,7 @@ public class QueueOfferTester<E> extends AbstractQueueTester<E> {
     expectAdded(e3());
   }
 
-  @CollectionFeature.Require({SUPPORTS_ADD, ALLOWS_NULL_VALUES})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_ADD})
   public void testOffer_nullSupported() {
     assertTrue("offer(null) should return true", getQueue().offer(null));
     expectAdded((E) null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/SetAddTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/SetAddTester.java
index 197496827e..f3905924df 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/SetAddTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/SetAddTester.java
@@ -44,7 +44,7 @@ public class SetAddTester<E> extends AbstractSetTester<E> {
     expectUnchanged();
   }
 
-  @CollectionFeature.Require(value = {SUPPORTS_ADD, ALLOWS_NULL_VALUES})
+  @CollectionFeature.Require({ALLOWS_NULL_VALUES, SUPPORTS_ADD})
   @CollectionSize.Require(absent = ZERO)
   public void testAdd_supportedNullPresent() {
     E[] array = createArrayWithNullElement();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/SetCreationTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/SetCreationTester.java
index 0c1be6b7ab..c9d29a7643 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/SetCreationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/SetCreationTester.java
@@ -39,7 +39,7 @@ import org.junit.Ignore;
 @Ignore // Affects only Android test runner, which respects JUnit 4 annotations on JUnit 3 tests.
 public class SetCreationTester<E> extends AbstractSetTester<E> {
   @CollectionFeature.Require(value = ALLOWS_NULL_VALUES, absent = REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testCreateWithDuplicates_nullDuplicatesNotRejected() {
     E[] array = createArrayWithNullElement();
     array[0] = null;
@@ -50,7 +50,7 @@ public class SetCreationTester<E> extends AbstractSetTester<E> {
   }
 
   @CollectionFeature.Require(absent = REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testCreateWithDuplicates_nonNullDuplicatesNotRejected() {
     E[] array = createSamplesArray();
     array[1] = e0();
@@ -61,7 +61,7 @@ public class SetCreationTester<E> extends AbstractSetTester<E> {
   }
 
   @CollectionFeature.Require({ALLOWS_NULL_VALUES, REJECTS_DUPLICATES_AT_CREATION})
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testCreateWithDuplicates_nullDuplicatesRejected() {
     E[] array = createArrayWithNullElement();
     array[0] = null;
@@ -73,7 +73,7 @@ public class SetCreationTester<E> extends AbstractSetTester<E> {
   }
 
   @CollectionFeature.Require(REJECTS_DUPLICATES_AT_CREATION)
-  @CollectionSize.Require(absent = {ZERO, ONE})
+  @CollectionSize.Require(absent = {ONE, ZERO})
   public void testCreateWithDuplicates_nonNullDuplicatesRejected() {
     E[] array = createSamplesArray();
     array[1] = e0();
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/SetEqualsTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/SetEqualsTester.java
index 839e1737c7..7af49d5243 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/SetEqualsTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/SetEqualsTester.java
@@ -51,8 +51,8 @@ public class SetEqualsTester<E> extends AbstractSetTester<E> {
         getSet().equals(MinimalSet.from(elements)));
   }
 
-  @CollectionSize.Require(absent = CollectionSize.ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = CollectionSize.ZERO)
   public void testEquals_containingNull() {
     Collection<E> elements = getSampleElements(getNumElements() - 1);
     elements.add(null);
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/SetHashCodeTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/SetHashCodeTester.java
index 5f60327d47..175bda03f5 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/SetHashCodeTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/SetHashCodeTester.java
@@ -46,8 +46,8 @@ public class SetHashCodeTester<E> extends AbstractSetTester<E> {
         getSet().hashCode());
   }
 
-  @CollectionSize.Require(absent = CollectionSize.ZERO)
   @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = CollectionSize.ZERO)
   public void testHashCode_containingNull() {
     Collection<E> elements = getSampleElements(getNumElements() - 1);
     int expectedHashCode = 0;
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/SortedMapNavigationTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/SortedMapNavigationTester.java
index 691fee139b..563fcc7d72 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/SortedMapNavigationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/SortedMapNavigationTester.java
@@ -60,7 +60,7 @@ public class SortedMapNavigationTester<K, V> extends AbstractMapTester<K, V> {
     Collections.sort(entries, Helpers.<K, V>entryComparator(navigableMap.comparator()));
 
     // some tests assume SEVERAL == 3
-    if (entries.size() >= 1) {
+    if (!entries.isEmpty()) {
       a = entries.get(0);
       if (entries.size() >= 3) {
         c = entries.get(2);
@@ -172,8 +172,8 @@ public class SortedMapNavigationTester<K, V> extends AbstractMapTester<K, V> {
     if (comparator == null) {
       comparator =
           new Comparator<K>() {
-            @SuppressWarnings("unchecked")
             @Override
+            @SuppressWarnings("unchecked")
             public int compare(K o1, K o2) {
               return ((Comparable) o1).compareTo(o2);
             }
diff --git a/guava-testlib/src/com/google/common/collect/testing/testers/SortedSetNavigationTester.java b/guava-testlib/src/com/google/common/collect/testing/testers/SortedSetNavigationTester.java
index bf5ac223a9..a37c80736d 100644
--- a/guava-testlib/src/com/google/common/collect/testing/testers/SortedSetNavigationTester.java
+++ b/guava-testlib/src/com/google/common/collect/testing/testers/SortedSetNavigationTester.java
@@ -57,7 +57,7 @@ public class SortedSetNavigationTester<E> extends AbstractSetTester<E> {
     Collections.sort(values, sortedSet.comparator());
 
     // some tests assume SEVERAL == 3
-    if (values.size() >= 1) {
+    if (!values.isEmpty()) {
       a = values.get(0);
       if (values.size() >= 3) {
         b = values.get(1);
diff --git a/guava-testlib/src/com/google/common/testing/ArbitraryInstances.java b/guava-testlib/src/com/google/common/testing/ArbitraryInstances.java
index 1325d7f8c0..ed1628a486 100644
--- a/guava-testlib/src/com/google/common/testing/ArbitraryInstances.java
+++ b/guava-testlib/src/com/google/common/testing/ArbitraryInstances.java
@@ -17,6 +17,8 @@
 package com.google.common.testing;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Predicates.alwaysTrue;
+import static java.util.UUID.randomUUID;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.CharMatcher;
@@ -25,7 +27,6 @@ import com.google.common.base.Defaults;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.common.base.Splitter;
 import com.google.common.base.Stopwatch;
 import com.google.common.base.Ticker;
@@ -214,13 +215,13 @@ public final class ArbitraryInstances {
           .put(OptionalInt.class, OptionalInt.empty())
           .put(OptionalLong.class, OptionalLong.empty())
           .put(OptionalDouble.class, OptionalDouble.empty())
-          .put(UUID.class, UUID.randomUUID())
+          .put(UUID.class, randomUUID())
           // common.base
           .put(CharMatcher.class, CharMatcher.none())
           .put(Joiner.class, Joiner.on(','))
           .put(Splitter.class, Splitter.on(','))
           .put(com.google.common.base.Optional.class, com.google.common.base.Optional.absent())
-          .put(Predicate.class, Predicates.alwaysTrue())
+          .put(Predicate.class, alwaysTrue())
           .put(Equivalence.class, Equivalence.equals())
           .put(Ticker.class, Ticker.systemTicker())
           .put(Stopwatch.class, Stopwatch.createUnstarted())
diff --git a/guava-testlib/src/com/google/common/testing/ClassSanityTester.java b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java
index 0c8daf08e1..1f6a7b8095 100644
--- a/guava-testlib/src/com/google/common/testing/ClassSanityTester.java
+++ b/guava-testlib/src/com/google/common/testing/ClassSanityTester.java
@@ -17,9 +17,9 @@
 package com.google.common.testing;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
 import static com.google.common.testing.NullPointerTester.isNullable;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -46,6 +46,7 @@ import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
@@ -155,9 +156,9 @@ public final class ClassSanityTester {
    * @since 17.0
    */
   public <T> ClassSanityTester setDistinctValues(Class<T> type, T value1, T value2) {
-    checkNotNull(type);
-    checkNotNull(value1);
-    checkNotNull(value2);
+    requireNonNull(type);
+    requireNonNull(value1);
+    requireNonNull(value2);
     checkArgument(!Objects.equal(value1, value2), "Duplicate value provided.");
     distinctValues.replaceValues(type, ImmutableList.of(value1, value2));
     setDefault(type, value1);
@@ -591,7 +592,7 @@ public final class ClassSanityTester {
             });
     tester.addEqualityGroup(instance, createInstance(factory, equalArgs));
     for (int i = 0; i < params.size(); i++) {
-      List<Object> newArgs = Lists.newArrayList(args);
+      List<Object> newArgs = new ArrayList<>(args);
       Object newArg = argGenerators.get(i).generateFresh(params.get(i).getType());
 
       if (newArg == null || Objects.equal(args.get(i), newArg)) {
@@ -615,7 +616,7 @@ public final class ClassSanityTester {
       Invokable<?, ?> factory, List<Parameter> params, List<Object> args)
       throws ParameterNotInstantiableException, FactoryMethodReturnsNullException,
           InvocationTargetException, IllegalAccessException {
-    List<Object> equalArgs = Lists.newArrayList(args);
+    List<Object> equalArgs = new ArrayList<>(args);
     for (int i = 0; i < args.size(); i++) {
       Parameter param = params.get(i);
       Object arg = args.get(i);
@@ -639,7 +640,7 @@ public final class ClassSanityTester {
   private static boolean hashCodeInsensitiveToArgReference(
       Invokable<?, ?> factory, List<Object> args, int i, Object alternateArg)
       throws FactoryMethodReturnsNullException, InvocationTargetException, IllegalAccessException {
-    List<Object> tentativeArgs = Lists.newArrayList(args);
+    List<Object> tentativeArgs = new ArrayList<>(args);
     tentativeArgs.set(i, alternateArg);
     return createInstance(factory, tentativeArgs).hashCode()
         == createInstance(factory, args).hashCode();
@@ -647,7 +648,7 @@ public final class ClassSanityTester {
 
   // distinctValues is a type-safe class-values mapping, but we don't have a type-safe data
   // structure to hold the mappings.
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   private FreshValueGenerator newFreshValueGenerator() {
     FreshValueGenerator generator =
         new FreshValueGenerator() {
diff --git a/guava-testlib/src/com/google/common/testing/ClusterException.java b/guava-testlib/src/com/google/common/testing/ClusterException.java
index 688ffa5ab2..0180cb2a58 100644
--- a/guava-testlib/src/com/google/common/testing/ClusterException.java
+++ b/guava-testlib/src/com/google/common/testing/ClusterException.java
@@ -16,11 +16,13 @@
 
 package com.google.common.testing;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Collections.unmodifiableCollection;
+
 import com.google.common.annotations.GwtCompatible;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 
 /**
  * An {@link ClusterException} is a data structure that allows for some code to "throw multiple
@@ -68,7 +70,7 @@ final class ClusterException extends RuntimeException {
         exceptions.size() + " exceptions were thrown. The first exception is listed as a cause.",
         exceptions.iterator().next());
     ArrayList<Throwable> temp = new ArrayList<>(exceptions);
-    this.exceptions = Collections.unmodifiableCollection(temp);
+    this.exceptions = unmodifiableCollection(temp);
   }
 
   /**
@@ -99,9 +101,7 @@ final class ClusterException extends RuntimeException {
    * @throws IllegalArgumentException if {@code exceptions} is empty
    */
   public static RuntimeException create(Collection<? extends Throwable> exceptions) {
-    if (exceptions.size() == 0) {
-      throw new IllegalArgumentException("Can't create an ExceptionCollection with no exceptions");
-    }
+    checkArgument(!exceptions.isEmpty(), "Can't create an ExceptionCollection with no exceptions");
     if (exceptions.size() == 1) {
       Throwable temp = exceptions.iterator().next();
       if (temp instanceof RuntimeException) {
diff --git a/guava-testlib/src/com/google/common/testing/CollectorTester.java b/guava-testlib/src/com/google/common/testing/CollectorTester.java
index ab6e544d8a..5b75bcadd0 100644
--- a/guava-testlib/src/com/google/common/testing/CollectorTester.java
+++ b/guava-testlib/src/com/google/common/testing/CollectorTester.java
@@ -16,13 +16,13 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.reverse;
+import static java.util.Objects.requireNonNull;
 import static junit.framework.Assert.assertTrue;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Objects;
@@ -69,8 +69,8 @@ public final class CollectorTester<T, A, R> {
 
   private CollectorTester(
       Collector<T, A, R> collector, BiPredicate<? super R, ? super R> equivalence) {
-    this.collector = checkNotNull(collector);
-    this.equivalence = checkNotNull(equivalence);
+    this.collector = requireNonNull(collector);
+    this.equivalence = requireNonNull(equivalence);
   }
 
   /**
@@ -142,7 +142,7 @@ public final class CollectorTester<T, A, R> {
     List<T> list = Arrays.asList(inputs);
     doExpectCollects(expectedResult, list);
     if (collector.characteristics().contains(Collector.Characteristics.UNORDERED)) {
-      Collections.reverse(list);
+      reverse(list);
       doExpectCollects(expectedResult, list);
     }
     return this;
diff --git a/guava-testlib/src/com/google/common/testing/DummyProxy.java b/guava-testlib/src/com/google/common/testing/DummyProxy.java
index 85e229d518..6793c31e9a 100644
--- a/guava-testlib/src/com/google/common/testing/DummyProxy.java
+++ b/guava-testlib/src/com/google/common/testing/DummyProxy.java
@@ -16,8 +16,8 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.testing.NullPointerTester.isNullable;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableList;
@@ -75,7 +75,7 @@ abstract class DummyProxy {
       for (int i = 0; i < args.length; i++) {
         Parameter param = params.get(i);
         if (!isNullable(param)) {
-          checkNotNull(args[i]);
+          requireNonNull(args[i]);
         }
       }
       return dummyReturnValue(interfaceType.resolveType(method.getGenericReturnType()));
diff --git a/guava-testlib/src/com/google/common/testing/EqualsTester.java b/guava-testlib/src/com/google/common/testing/EqualsTester.java
index 9c93c9a492..a0f20a73e7 100644
--- a/guava-testlib/src/com/google/common/testing/EqualsTester.java
+++ b/guava-testlib/src/com/google/common/testing/EqualsTester.java
@@ -16,7 +16,7 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 
@@ -86,7 +86,7 @@ public final class EqualsTester {
   }
 
   EqualsTester(RelationshipTester.ItemReporter itemReporter) {
-    this.itemReporter = checkNotNull(itemReporter);
+    this.itemReporter = requireNonNull(itemReporter);
   }
 
   /**
@@ -94,7 +94,7 @@ public final class EqualsTester {
    * equal to any other equality groups added to this tester.
    */
   public EqualsTester addEqualityGroup(Object... equalityGroup) {
-    checkNotNull(equalityGroup);
+    requireNonNull(equalityGroup);
     equalityGroups.add(ImmutableList.copyOf(equalityGroup));
     return this;
   }
diff --git a/guava-testlib/src/com/google/common/testing/EquivalenceTester.java b/guava-testlib/src/com/google/common/testing/EquivalenceTester.java
index 8de2625d0e..49db3ea5be 100644
--- a/guava-testlib/src/com/google/common/testing/EquivalenceTester.java
+++ b/guava-testlib/src/com/google/common/testing/EquivalenceTester.java
@@ -16,7 +16,7 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 
@@ -57,7 +57,7 @@ public final class EquivalenceTester<T> {
   private final List<T> items = Lists.newArrayList();
 
   private EquivalenceTester(Equivalence<? super T> equivalence) {
-    this.equivalence = checkNotNull(equivalence);
+    this.equivalence = requireNonNull(equivalence);
     this.delegate = new RelationshipTester<>(equivalence, "equivalent", "hash", new ItemReporter());
   }
 
diff --git a/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java b/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java
index 605d3a055b..4bd3ac0d42 100644
--- a/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java
+++ b/guava-testlib/src/com/google/common/testing/ForwardingWrapperTester.java
@@ -17,8 +17,8 @@
 package com.google.common.testing;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
+import static java.util.Objects.requireNonNull;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.fail;
 
@@ -73,7 +73,7 @@ public final class ForwardingWrapperTester {
    */
   public <T> void testForwarding(
       Class<T> interfaceType, Function<? super T, ? extends T> wrapperFunction) {
-    checkNotNull(wrapperFunction);
+    requireNonNull(wrapperFunction);
     checkArgument(interfaceType.isInterface(), "%s isn't an interface", interfaceType);
     Method[] methods = getMostConcreteMethods(interfaceType);
     AccessibleObject.setAccessible(methods, true);
diff --git a/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java b/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java
index bb51e408b2..843345df61 100644
--- a/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java
+++ b/guava-testlib/src/com/google/common/testing/FreshValueGenerator.java
@@ -16,8 +16,8 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.CharMatcher;
@@ -166,7 +166,7 @@ class FreshValueGenerator {
   private final Map<Type, Integer> emptyInstanceGenerated = new HashMap<>();
 
   final <T> void addSampleInstances(Class<T> type, Iterable<? extends T> instances) {
-    sampleInstances.putAll(checkNotNull(type), checkNotNull(instances));
+    sampleInstances.putAll(requireNonNull(type), requireNonNull(instances));
   }
 
   /**
@@ -943,15 +943,15 @@ class FreshValueGenerator {
     return table;
   }
 
-  @SuppressWarnings("rawtypes") // TreeBasedTable.create() is defined as such
-  @Generates
+  @Generates // TreeBasedTable.create() is defined as such
+  @SuppressWarnings("rawtypes")
   static <R extends Comparable, C extends Comparable, V>
       RowSortedTable<R, C, V> generateRowSortedTable(R row, C column, V value) {
     return generateTreeBasedTable(row, column, value);
   }
 
-  @SuppressWarnings("rawtypes") // TreeBasedTable.create() is defined as such
-  @Generates
+  @Generates // TreeBasedTable.create() is defined as such
+  @SuppressWarnings("rawtypes")
   static <R extends Comparable, C extends Comparable, V>
       TreeBasedTable<R, C, V> generateTreeBasedTable(R row, C column, V value) {
     TreeBasedTable<R, C, V> table = TreeBasedTable.create();
diff --git a/guava-testlib/src/com/google/common/testing/NullPointerTester.java b/guava-testlib/src/com/google/common/testing/NullPointerTester.java
index 3eb317605f..a6aad2b77f 100644
--- a/guava-testlib/src/com/google/common/testing/NullPointerTester.java
+++ b/guava-testlib/src/com/google/common/testing/NullPointerTester.java
@@ -17,7 +17,7 @@
 package com.google.common.testing;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
@@ -80,7 +80,7 @@ public final class NullPointerTester {
    * object.
    */
   public <T> NullPointerTester setDefault(Class<T> type, T value) {
-    defaults.putInstance(type, checkNotNull(value));
+    defaults.putInstance(type, requireNonNull(value));
     return this;
   }
 
@@ -90,7 +90,7 @@ public final class NullPointerTester {
    * @since 13.0
    */
   public NullPointerTester ignore(Method method) {
-    ignoredMembers.add(checkNotNull(method));
+    ignoredMembers.add(requireNonNull(method));
     return this;
   }
 
@@ -100,7 +100,7 @@ public final class NullPointerTester {
    * @since 22.0
    */
   public NullPointerTester ignore(Constructor<?> constructor) {
-    ignoredMembers.add(checkNotNull(constructor));
+    ignoredMembers.add(requireNonNull(constructor));
     return this;
   }
 
@@ -439,7 +439,7 @@ public final class NullPointerTester {
       }
 
       private /*static*/ <S> S doConvert(TypeToken<S> type) {
-        return checkNotNull(getDefaultValue(type));
+        return requireNonNull(getDefaultValue(type));
       }
     };
   }
diff --git a/guava-testlib/src/com/google/common/testing/Platform.java b/guava-testlib/src/com/google/common/testing/Platform.java
index b107966ec9..63f60ccd00 100644
--- a/guava-testlib/src/com/google/common/testing/Platform.java
+++ b/guava-testlib/src/com/google/common/testing/Platform.java
@@ -16,7 +16,7 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.ByteArrayInputStream;
@@ -35,7 +35,7 @@ final class Platform {
   /** Serializes and deserializes the specified object. */
   @SuppressWarnings("unchecked")
   static <T> T reserialize(T object) {
-    checkNotNull(object);
+    requireNonNull(object);
     ByteArrayOutputStream bytes = new ByteArrayOutputStream();
     try {
       ObjectOutputStream out = new ObjectOutputStream(bytes);
diff --git a/guava-testlib/src/com/google/common/testing/RelationshipTester.java b/guava-testlib/src/com/google/common/testing/RelationshipTester.java
index d5b9b6a186..4e2e61d062 100644
--- a/guava-testlib/src/com/google/common/testing/RelationshipTester.java
+++ b/guava-testlib/src/com/google/common/testing/RelationshipTester.java
@@ -16,7 +16,7 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Equivalence;
@@ -59,10 +59,10 @@ final class RelationshipTester<T> {
       String relationshipName,
       String hashName,
       ItemReporter itemReporter) {
-    this.equivalence = checkNotNull(equivalence);
-    this.relationshipName = checkNotNull(relationshipName);
-    this.hashName = checkNotNull(hashName);
-    this.itemReporter = checkNotNull(itemReporter);
+    this.equivalence = requireNonNull(equivalence);
+    this.relationshipName = requireNonNull(relationshipName);
+    this.hashName = requireNonNull(hashName);
+    this.itemReporter = requireNonNull(itemReporter);
   }
 
   // TODO(cpovirk): should we reject null items, since the tests already check null automatically?
diff --git a/guava-testlib/src/com/google/common/testing/TearDownStack.java b/guava-testlib/src/com/google/common/testing/TearDownStack.java
index bab025a61f..6080abf961 100644
--- a/guava-testlib/src/com/google/common/testing/TearDownStack.java
+++ b/guava-testlib/src/com/google/common/testing/TearDownStack.java
@@ -16,11 +16,10 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.collect.Lists;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.util.ArrayList;
 import java.util.LinkedList;
@@ -57,7 +56,7 @@ public class TearDownStack implements TearDownAccepter {
   @Override
   public final void addTearDown(TearDown tearDown) {
     synchronized (stack) {
-      stack.addFirst(checkNotNull(tearDown));
+      stack.addFirst(requireNonNull(tearDown));
     }
   }
 
@@ -66,7 +65,7 @@ public class TearDownStack implements TearDownAccepter {
     List<Throwable> exceptions = new ArrayList<>();
     List<TearDown> stackCopy;
     synchronized (stack) {
-      stackCopy = Lists.newArrayList(stack);
+      stackCopy = new ArrayList<>(stack);
       stack.clear();
     }
     for (TearDown tearDown : stackCopy) {
@@ -80,7 +79,7 @@ public class TearDownStack implements TearDownAccepter {
         }
       }
     }
-    if (!suppressThrows && (exceptions.size() > 0)) {
+    if (!suppressThrows && !exceptions.isEmpty()) {
       throw ClusterException.create(exceptions);
     }
   }
diff --git a/guava-testlib/src/com/google/common/testing/TestLogHandler.java b/guava-testlib/src/com/google/common/testing/TestLogHandler.java
index 41dca2ec8b..68a61861d1 100644
--- a/guava-testlib/src/com/google/common/testing/TestLogHandler.java
+++ b/guava-testlib/src/com/google/common/testing/TestLogHandler.java
@@ -16,9 +16,10 @@
 
 package com.google.common.testing;
 
+import static java.util.Collections.unmodifiableList;
+
 import com.google.common.annotations.GwtCompatible;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
@@ -82,6 +83,6 @@ public class TestLogHandler extends Handler {
    */
   public synchronized List<LogRecord> getStoredLogRecords() {
     List<LogRecord> result = new ArrayList<>(list);
-    return Collections.unmodifiableList(result);
+    return unmodifiableList(result);
   }
 }
diff --git a/guava-testlib/src/com/google/common/util/concurrent/testing/AbstractListenableFutureTest.java b/guava-testlib/src/com/google/common/util/concurrent/testing/AbstractListenableFutureTest.java
index b5bec2c094..08ca9c83b1 100644
--- a/guava-testlib/src/com/google/common/util/concurrent/testing/AbstractListenableFutureTest.java
+++ b/guava-testlib/src/com/google/common/util/concurrent/testing/AbstractListenableFutureTest.java
@@ -204,7 +204,7 @@ public abstract class AbstractListenableFutureTest extends TestCase {
 
       // Right in the middle start up a thread to close the latch.
       if (i == 10) {
-        new Thread(() -> latch.countDown()).start();
+        new Thread(latch::countDown).start();
       }
 
       future.addListener(listenerLatch::countDown, exec);
diff --git a/guava-testlib/src/com/google/common/util/concurrent/testing/SameThreadScheduledExecutorService.java b/guava-testlib/src/com/google/common/util/concurrent/testing/SameThreadScheduledExecutorService.java
index 25b7ef791c..c254fbae6d 100644
--- a/guava-testlib/src/com/google/common/util/concurrent/testing/SameThreadScheduledExecutorService.java
+++ b/guava-testlib/src/com/google/common/util/concurrent/testing/SameThreadScheduledExecutorService.java
@@ -17,9 +17,9 @@
 package com.google.common.util.concurrent.testing;
 
 import static com.google.common.util.concurrent.MoreExecutors.newDirectExecutorService;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableScheduledFuture;
@@ -71,33 +71,33 @@ class SameThreadScheduledExecutorService extends AbstractExecutorService
 
   @Override
   public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-    Preconditions.checkNotNull(unit, "unit must not be null!");
+    requireNonNull(unit, "unit must not be null!");
     return delegate.awaitTermination(timeout, unit);
   }
 
   @Override
   public <T> ListenableFuture<T> submit(Callable<T> task) {
-    Preconditions.checkNotNull(task, "task must not be null!");
+    requireNonNull(task, "task must not be null!");
     return delegate.submit(task);
   }
 
   @Override
   public <T> ListenableFuture<T> submit(Runnable task, T result) {
-    Preconditions.checkNotNull(task, "task must not be null!");
-    Preconditions.checkNotNull(result, "result must not be null!");
+    requireNonNull(task, "task must not be null!");
+    requireNonNull(result, "result must not be null!");
     return delegate.submit(task, result);
   }
 
   @Override
   public ListenableFuture<?> submit(Runnable task) {
-    Preconditions.checkNotNull(task, "task must not be null!");
+    requireNonNull(task, "task must not be null!");
     return delegate.submit(task);
   }
 
   @Override
   public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
       throws InterruptedException {
-    Preconditions.checkNotNull(tasks, "tasks must not be null!");
+    requireNonNull(tasks, "tasks must not be null!");
     return delegate.invokeAll(tasks);
   }
 
@@ -105,44 +105,44 @@ class SameThreadScheduledExecutorService extends AbstractExecutorService
   public <T> List<Future<T>> invokeAll(
       Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
       throws InterruptedException {
-    Preconditions.checkNotNull(tasks, "tasks must not be null!");
-    Preconditions.checkNotNull(unit, "unit must not be null!");
+    requireNonNull(tasks, "tasks must not be null!");
+    requireNonNull(unit, "unit must not be null!");
     return delegate.invokeAll(tasks, timeout, unit);
   }
 
   @Override
   public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
       throws InterruptedException, ExecutionException {
-    Preconditions.checkNotNull(tasks, "tasks must not be null!");
+    requireNonNull(tasks, "tasks must not be null!");
     return delegate.invokeAny(tasks);
   }
 
   @Override
   public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
-    Preconditions.checkNotNull(tasks, "tasks must not be null!");
-    Preconditions.checkNotNull(unit, "unit must not be null!");
+    requireNonNull(tasks, "tasks must not be null!");
+    requireNonNull(unit, "unit must not be null!");
     return delegate.invokeAny(tasks, timeout, unit);
   }
 
   @Override
   public void execute(Runnable command) {
-    Preconditions.checkNotNull(command, "command must not be null!");
+    requireNonNull(command, "command must not be null!");
     delegate.execute(command);
   }
 
   @Override
   public ListenableScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
-    Preconditions.checkNotNull(command, "command must not be null");
-    Preconditions.checkNotNull(unit, "unit must not be null!");
+    requireNonNull(command, "command must not be null");
+    requireNonNull(unit, "unit must not be null!");
     return schedule(java.util.concurrent.Executors.callable(command), delay, unit);
   }
 
   @Override
   public <V> ListenableScheduledFuture<V> schedule(
       Callable<V> callable, long delay, TimeUnit unit) {
-    Preconditions.checkNotNull(callable, "callable must not be null!");
-    Preconditions.checkNotNull(unit, "unit must not be null!");
+    requireNonNull(callable, "callable must not be null!");
+    requireNonNull(unit, "unit must not be null!");
     ListenableFuture<V> delegateFuture = submit(callable);
     return new ImmediateScheduledFuture<>(delegateFuture);
   }
@@ -158,19 +158,19 @@ class SameThreadScheduledExecutorService extends AbstractExecutorService
     @Override
     public V get(long timeout, TimeUnit unit)
         throws InterruptedException, ExecutionException, TimeoutException {
-      Preconditions.checkNotNull(unit, "unit must not be null!");
+      requireNonNull(unit, "unit must not be null!");
       return get();
     }
 
     @Override
     public long getDelay(TimeUnit unit) {
-      Preconditions.checkNotNull(unit, "unit must not be null!");
+      requireNonNull(unit, "unit must not be null!");
       return 0;
     }
 
     @Override
     public int compareTo(Delayed other) {
-      Preconditions.checkNotNull(other, "other must not be null!");
+      requireNonNull(other, "other must not be null!");
       return 0;
     }
   }
diff --git a/guava-testlib/test/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilderTest.java b/guava-testlib/test/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilderTest.java
index 72b18ea4b7..50c2e65ed8 100644
--- a/guava-testlib/test/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilderTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/FeatureSpecificTestSuiteBuilderTest.java
@@ -16,8 +16,8 @@
 
 package com.google.common.collect.testing;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.testing.features.CollectionFeature;
-import java.util.Collections;
 import java.util.List;
 import junit.framework.Test;
 import junit.framework.TestCase;
@@ -49,7 +49,7 @@ public class FeatureSpecificTestSuiteBuilderTest extends TestCase {
 
     @Override
     protected List<Class<? extends AbstractTester>> getTesters() {
-      return Collections.<Class<? extends AbstractTester>>singletonList(MyAbstractTester.class);
+      return ImmutableList.of(MyAbstractTester.class);
     }
   }
 
diff --git a/guava-testlib/test/com/google/common/collect/testing/HelpersTest.java b/guava-testlib/test/com/google/common/collect/testing/HelpersTest.java
index 41f4bfb275..a4cfd94d3e 100644
--- a/guava-testlib/test/com/google/common/collect/testing/HelpersTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/HelpersTest.java
@@ -20,9 +20,10 @@ import static com.google.common.collect.testing.Helpers.NullsBeforeB;
 import static com.google.common.collect.testing.Helpers.testComparator;
 
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -48,7 +49,7 @@ public class HelpersTest extends TestCase {
         new Iterable<Object>() {
           @Override
           public Iterator<Object> iterator() {
-            return Collections.emptyList().iterator();
+            return ImmutableList.of().iterator();
           }
         });
 
@@ -63,7 +64,7 @@ public class HelpersTest extends TestCase {
           new Iterable<String>() {
             @Override
             public Iterator<String> iterator() {
-              return Collections.singleton("a").iterator();
+              return ImmutableSet.of("a").iterator();
             }
           });
       throw new Error();
diff --git a/guava-testlib/test/com/google/common/collect/testing/IteratorTesterTest.java b/guava-testlib/test/com/google/common/collect/testing/IteratorTesterTest.java
index 283f51efe6..7ce8189b55 100644
--- a/guava-testlib/test/com/google/common/collect/testing/IteratorTesterTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/IteratorTesterTest.java
@@ -16,6 +16,7 @@
 
 package com.google.common.collect.testing;
 
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Lists.newArrayList;
 import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
 import static java.util.Collections.emptyList;
@@ -131,9 +132,7 @@ public class IteratorTesterTest extends TestCase {
 
     @Override
     public void remove() {
-      if (nextThrewException) {
-        throw new IllegalStateException();
-      }
+      checkState(!nextThrewException);
       iterator.remove();
     }
   }
@@ -259,7 +258,7 @@ public class IteratorTesterTest extends TestCase {
   }
 
   public void testSimilarException() {
-    List<Integer> emptyList = emptyList();
+    List<Integer> emptyList = ImmutableList.of();
     IteratorTester<Integer> tester =
         new IteratorTester<Integer>(
             1, MODIFIABLE, emptyList, IteratorTester.KnownOrder.KNOWN_ORDER) {
@@ -291,7 +290,7 @@ public class IteratorTesterTest extends TestCase {
   }
 
   public void testMismatchedException() {
-    List<Integer> emptyList = emptyList();
+    List<Integer> emptyList = ImmutableList.of();
     IteratorTester<Integer> tester =
         new IteratorTester<Integer>(
             1, MODIFIABLE, emptyList, IteratorTester.KnownOrder.KNOWN_ORDER) {
diff --git a/guava-testlib/test/com/google/common/collect/testing/MapTestSuiteBuilderTests.java b/guava-testlib/test/com/google/common/collect/testing/MapTestSuiteBuilderTests.java
index 5fd0d0368d..3d0e069c11 100644
--- a/guava-testlib/test/com/google/common/collect/testing/MapTestSuiteBuilderTests.java
+++ b/guava-testlib/test/com/google/common/collect/testing/MapTestSuiteBuilderTests.java
@@ -16,9 +16,9 @@
 
 package com.google.common.collect.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_KEYS;
 import static com.google.common.collect.testing.features.MapFeature.ALLOWS_NULL_VALUES;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
@@ -108,7 +108,7 @@ public final class MapTestSuiteBuilderTests extends TestCase {
 
               @Override
               public String put(String key, String value) {
-                checkNotNull(key);
+                requireNonNull(key);
                 return map.put(key, value);
               }
             };
@@ -185,7 +185,7 @@ public final class MapTestSuiteBuilderTests extends TestCase {
 
                         @Override
                         public String setValue(String value) {
-                          checkNotNull(value);
+                          requireNonNull(value);
                           return next.setValue(value);
                         }
 
@@ -261,7 +261,7 @@ public final class MapTestSuiteBuilderTests extends TestCase {
 
               @Override
               public String put(String key, String value) {
-                checkNotNull(value);
+                requireNonNull(value);
                 return map.put(key, value);
               }
             };
diff --git a/guava-testlib/test/com/google/common/collect/testing/MinimalCollectionTest.java b/guava-testlib/test/com/google/common/collect/testing/MinimalCollectionTest.java
index 38cadf3bff..1a0171a991 100644
--- a/guava-testlib/test/com/google/common/collect/testing/MinimalCollectionTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/MinimalCollectionTest.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect.testing;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import java.util.Collection;
@@ -35,9 +37,7 @@ public class MinimalCollectionTest extends TestCase {
               public Collection<String> create(String[] elements) {
                 // TODO: MinimalCollection should perhaps throw
                 for (Object element : elements) {
-                  if (element == null) {
-                    throw new NullPointerException();
-                  }
+                  requireNonNull(element);
                 }
                 return MinimalCollection.of(elements);
               }
diff --git a/guava-testlib/test/com/google/common/collect/testing/MinimalIterableTest.java b/guava-testlib/test/com/google/common/collect/testing/MinimalIterableTest.java
index f6fae31056..ca5c6dc70d 100644
--- a/guava-testlib/test/com/google/common/collect/testing/MinimalIterableTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/MinimalIterableTest.java
@@ -17,7 +17,7 @@
 package com.google.common.collect.testing;
 
 import com.google.common.annotations.GwtCompatible;
-import java.util.Collections;
+import com.google.common.collect.ImmutableSet;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import junit.framework.TestCase;
@@ -65,7 +65,7 @@ public class MinimalIterableTest extends TestCase {
   }
 
   public void testFrom_empty() {
-    Iterable<String> iterable = MinimalIterable.from(Collections.<String>emptySet());
+    Iterable<String> iterable = MinimalIterable.from(ImmutableSet.of());
     Iterator<String> iterator = iterable.iterator();
     assertFalse(iterator.hasNext());
     try {
@@ -81,7 +81,7 @@ public class MinimalIterableTest extends TestCase {
   }
 
   public void testFrom_one() {
-    Iterable<String> iterable = MinimalIterable.from(Collections.singleton("a"));
+    Iterable<String> iterable = MinimalIterable.from(ImmutableSet.of("a"));
     Iterator<String> iterator = iterable.iterator();
     assertTrue(iterator.hasNext());
     assertEquals("a", iterator.next());
diff --git a/guava-testlib/test/com/google/common/collect/testing/SafeTreeMapTest.java b/guava-testlib/test/com/google/common/collect/testing/SafeTreeMapTest.java
index f03ff0a09f..5f60a9e6b4 100644
--- a/guava-testlib/test/com/google/common/collect/testing/SafeTreeMapTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/SafeTreeMapTest.java
@@ -20,13 +20,13 @@ import static java.util.Collections.sort;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableSortedMap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.testing.Helpers.NullsBeforeTwo;
 import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.features.MapFeature;
 import com.google.common.testing.SerializableTester;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -107,8 +107,8 @@ public class SafeTreeMapTest extends TestCase {
     SerializableTester.reserializeAndAssert(map.entrySet());
     SerializableTester.reserializeAndAssert(map.keySet());
     assertEquals(
-        Lists.newArrayList(map.values()),
-        Lists.newArrayList(SerializableTester.reserialize(map.values())));
+        new ArrayList<>(map.values()),
+        new ArrayList<>(SerializableTester.reserialize(map.values())));
   }
 
   @GwtIncompatible // SerializableTester
diff --git a/guava-testlib/test/com/google/common/collect/testing/SafeTreeSetTest.java b/guava-testlib/test/com/google/common/collect/testing/SafeTreeSetTest.java
index ea5a7840ad..2af61f8de4 100644
--- a/guava-testlib/test/com/google/common/collect/testing/SafeTreeSetTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/SafeTreeSetTest.java
@@ -18,12 +18,12 @@ package com.google.common.collect.testing;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableSortedMap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import com.google.common.collect.testing.features.CollectionFeature;
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.testing.SerializableTester;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -49,7 +49,7 @@ public class SafeTreeSetTest extends TestCase {
 
                   @Override
                   public List<String> order(List<String> insertionOrder) {
-                    return Lists.newArrayList(Sets.newTreeSet(insertionOrder));
+                    return new ArrayList<>(Sets.newTreeSet(insertionOrder));
                   }
                 })
             .withFeatures(
@@ -70,7 +70,7 @@ public class SafeTreeSetTest extends TestCase {
 
                   @Override
                   public List<String> order(List<String> insertionOrder) {
-                    return Lists.newArrayList(Sets.newTreeSet(insertionOrder));
+                    return new ArrayList<>(Sets.newTreeSet(insertionOrder));
                   }
                 })
             .withFeatures(
@@ -89,8 +89,8 @@ public class SafeTreeSetTest extends TestCase {
     SerializableTester.reserializeAndAssert(map.entrySet());
     SerializableTester.reserializeAndAssert(map.keySet());
     assertEquals(
-        Lists.newArrayList(map.values()),
-        Lists.newArrayList(SerializableTester.reserialize(map.values())));
+        new ArrayList<>(map.values()),
+        new ArrayList<>(SerializableTester.reserialize(map.values())));
   }
 
   @GwtIncompatible // SerializableTester
diff --git a/guava-testlib/test/com/google/common/collect/testing/features/FeatureUtilTest.java b/guava-testlib/test/com/google/common/collect/testing/features/FeatureUtilTest.java
index 0b86451291..4395d09d13 100644
--- a/guava-testlib/test/com/google/common/collect/testing/features/FeatureUtilTest.java
+++ b/guava-testlib/test/com/google/common/collect/testing/features/FeatureUtilTest.java
@@ -24,7 +24,6 @@ import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
-import java.util.Collections;
 import java.util.Set;
 import junit.framework.TestCase;
 
@@ -48,7 +47,7 @@ public class FeatureUtilTest extends TestCase {
 
     @Override
     public Set<Feature<? super ExampleBaseInterface>> getImpliedFeatures() {
-      return Collections.emptySet();
+      return ImmutableSet.of();
     }
 
     @Retention(RetentionPolicy.RUNTIME)
@@ -93,7 +92,7 @@ public class FeatureUtilTest extends TestCase {
   @Retention(RetentionPolicy.RUNTIME)
   @interface NonTesterAnnotation {}
 
-  @ExampleBaseFeature.Require({ExampleBaseFeature.BASE_FEATURE_1})
+  @ExampleBaseFeature.Require(ExampleBaseFeature.BASE_FEATURE_1)
   private abstract static class ExampleBaseInterfaceTester extends TestCase {
     protected final void doNotActuallyRunThis() {
       fail("Nobody's meant to actually run this!");
@@ -102,37 +101,37 @@ public class FeatureUtilTest extends TestCase {
 
   @AndroidIncompatible // Android attempts to run directly
   @NonTesterAnnotation
-  @ExampleDerivedFeature.Require({ExampleDerivedFeature.DERIVED_FEATURE_2})
+  @ExampleDerivedFeature.Require(ExampleDerivedFeature.DERIVED_FEATURE_2)
   private static class ExampleDerivedInterfaceTester extends ExampleBaseInterfaceTester {
     // Exists to test that our framework doesn't run it:
-    @SuppressWarnings("unused")
     @ExampleDerivedFeature.Require({
       ExampleDerivedFeature.DERIVED_FEATURE_1,
       ExampleDerivedFeature.DERIVED_FEATURE_2
     })
+    @SuppressWarnings("unused")
     public void testRequiringTwoExplicitDerivedFeatures() throws Exception {
       doNotActuallyRunThis();
     }
 
     // Exists to test that our framework doesn't run it:
-    @SuppressWarnings("unused")
     @ExampleDerivedFeature.Require({
       ExampleDerivedFeature.DERIVED_FEATURE_1,
       ExampleDerivedFeature.DERIVED_FEATURE_3
     })
+    @SuppressWarnings("unused")
     public void testRequiringAllThreeDerivedFeatures() {
       doNotActuallyRunThis();
     }
 
     // Exists to test that our framework doesn't run it:
+    @ExampleBaseFeature.Require(absent = ExampleBaseFeature.BASE_FEATURE_1)
     @SuppressWarnings("unused")
-    @ExampleBaseFeature.Require(absent = {ExampleBaseFeature.BASE_FEATURE_1})
     public void testRequiringConflictingFeatures() throws Exception {
       doNotActuallyRunThis();
     }
   }
 
-  @ExampleDerivedFeature.Require(absent = {ExampleDerivedFeature.DERIVED_FEATURE_2})
+  @ExampleDerivedFeature.Require(absent = ExampleDerivedFeature.DERIVED_FEATURE_2)
   private static class ConflictingRequirementsExampleDerivedInterfaceTester
       extends ExampleBaseInterfaceTester {}
 
@@ -197,15 +196,14 @@ public class FeatureUtilTest extends TestCase {
     assertEquals(
         FeatureUtil.buildTesterRequirements(ExampleBaseInterfaceTester.class),
         new TesterRequirements(
-            Sets.<Feature<?>>newHashSet(ExampleBaseFeature.BASE_FEATURE_1),
-            Collections.<Feature<?>>emptySet()));
+            Sets.<Feature<?>>newHashSet(ExampleBaseFeature.BASE_FEATURE_1), ImmutableSet.of()));
 
     assertEquals(
         FeatureUtil.buildTesterRequirements(ExampleDerivedInterfaceTester.class),
         new TesterRequirements(
             Sets.<Feature<?>>newHashSet(
                 ExampleBaseFeature.BASE_FEATURE_1, ExampleDerivedFeature.DERIVED_FEATURE_2),
-            Collections.<Feature<?>>emptySet()));
+            ImmutableSet.of()));
   }
 
   @AndroidIncompatible // Android runs ExampleDerivedInterfaceTester directly if it exists
@@ -219,7 +217,7 @@ public class FeatureUtilTest extends TestCase {
                 ExampleBaseFeature.BASE_FEATURE_1,
                 ExampleDerivedFeature.DERIVED_FEATURE_1,
                 ExampleDerivedFeature.DERIVED_FEATURE_2),
-            Collections.<Feature<?>>emptySet()));
+            ImmutableSet.of()));
     assertEquals(
         FeatureUtil.buildTesterRequirements(
             ExampleDerivedInterfaceTester.class.getMethod("testRequiringAllThreeDerivedFeatures")),
@@ -229,7 +227,7 @@ public class FeatureUtilTest extends TestCase {
                 ExampleDerivedFeature.DERIVED_FEATURE_1,
                 ExampleDerivedFeature.DERIVED_FEATURE_2,
                 ExampleDerivedFeature.DERIVED_FEATURE_3),
-            Collections.<Feature<?>>emptySet()));
+            ImmutableSet.of()));
   }
 
   @AndroidIncompatible // Android runs ExampleDerivedInterfaceTester directly if it exists
@@ -268,6 +266,6 @@ public class FeatureUtilTest extends TestCase {
                 Sets.<Feature<?>>newHashSet(
                     ExampleDerivedFeature.DERIVED_FEATURE_1,
                     ExampleDerivedFeature.DERIVED_FEATURE_2)),
-            Collections.<Feature<?>>emptySet()));
+            ImmutableSet.of()));
   }
 }
diff --git a/guava-testlib/test/com/google/common/testing/ArbitraryInstancesTest.java b/guava-testlib/test/com/google/common/testing/ArbitraryInstancesTest.java
index dfd26a0c73..58d6bbea17 100644
--- a/guava-testlib/test/com/google/common/testing/ArbitraryInstancesTest.java
+++ b/guava-testlib/test/com/google/common/testing/ArbitraryInstancesTest.java
@@ -195,8 +195,8 @@ public class ArbitraryInstancesTest extends TestCase {
     assertEquals(ImmutableMultiset.of(), ArbitraryInstances.get(Multiset.class));
     assertEquals(ImmutableMultiset.of(), ArbitraryInstances.get(ImmutableMultiset.class));
     assertTrue(ArbitraryInstances.get(SortedMultiset.class).isEmpty());
-    assertEquals(ImmutableMultimap.of(), ArbitraryInstances.get(Multimap.class));
-    assertEquals(ImmutableMultimap.of(), ArbitraryInstances.get(ImmutableMultimap.class));
+    assertEquals(ImmutableListMultimap.of(), ArbitraryInstances.get(Multimap.class));
+    assertEquals(ImmutableListMultimap.of(), ArbitraryInstances.get(ImmutableMultimap.class));
     assertTrue(ArbitraryInstances.get(SortedSetMultimap.class).isEmpty());
     assertEquals(ImmutableTable.of(), ArbitraryInstances.get(Table.class));
     assertEquals(ImmutableTable.of(), ArbitraryInstances.get(ImmutableTable.class));
diff --git a/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java b/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java
index 4aa3d60ff0..f456832048 100644
--- a/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java
+++ b/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java
@@ -16,8 +16,9 @@
 
 package com.google.common.testing;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.base.Functions;
 import com.google.common.base.Optional;
@@ -34,7 +35,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
@@ -644,7 +644,7 @@ public class ClassSanityTesterTest extends TestCase {
     }
 
     public InstantiableFactoryMethodChosen(NotInstantiable x) {
-      checkNotNull(x);
+      requireNonNull(x);
       this.name = "x1";
     }
 
@@ -653,7 +653,7 @@ public class ClassSanityTesterTest extends TestCase {
     }
 
     public static InstantiableFactoryMethodChosen create(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
       return new InstantiableFactoryMethodChosen("good");
     }
   }
@@ -674,7 +674,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Object wrapped;
 
     Wrapper(Object wrapped) {
-      this.wrapped = checkNotNull(wrapped);
+      this.wrapped = requireNonNull(wrapped);
     }
 
     @Override
@@ -709,12 +709,12 @@ public class ClassSanityTesterTest extends TestCase {
     final String name;
 
     public InstantiableConstructorChosen(String name) {
-      checkNotNull(name);
+      requireNonNull(name);
       this.name = "good";
     }
 
     public InstantiableConstructorChosen(NotInstantiable x) {
-      checkNotNull(x);
+      requireNonNull(x);
       this.name = "x1";
     }
 
@@ -729,7 +729,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final int b;
 
     private GoodEquals(String a, int b) {
-      this.a = checkNotNull(a);
+      this.a = requireNonNull(a);
       this.b = b;
     }
 
@@ -801,7 +801,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Integer i;
 
     public SameIntegerInstance(Integer i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -824,7 +824,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Long i;
 
     public SameLongInstance(Long i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -847,7 +847,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Float i;
 
     public SameFloatInstance(Float i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -870,7 +870,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Double i;
 
     public SameDoubleInstance(Double i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -893,7 +893,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Short i;
 
     public SameShortInstance(Short i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -916,7 +916,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Byte i;
 
     public SameByteInstance(Byte i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -939,7 +939,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Character i;
 
     public SameCharacterInstance(Character i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -961,7 +961,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Boolean i;
 
     public SameBooleanInstance(Boolean i) {
-      this.i = checkNotNull(i);
+      this.i = requireNonNull(i);
     }
 
     @Override
@@ -983,7 +983,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final String s;
 
     public SameStringInstance(String s) {
-      this.s = checkNotNull(s);
+      this.s = requireNonNull(s);
     }
 
     @Override
@@ -1005,7 +1005,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Object s;
 
     public SameObjectInstance(Object s) {
-      this.s = checkNotNull(s);
+      this.s = requireNonNull(s);
     }
 
     @Override
@@ -1027,7 +1027,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Runnable s;
 
     public SameInterfaceInstance(Runnable s) {
-      this.s = checkNotNull(s);
+      this.s = requireNonNull(s);
     }
 
     @Override
@@ -1049,7 +1049,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final List<?> s;
 
     public SameListInstance(List<?> s) {
-      this.s = checkNotNull(s);
+      this.s = requireNonNull(s);
     }
 
     @Override
@@ -1072,8 +1072,8 @@ public class ClassSanityTesterTest extends TestCase {
 
     // This should be ignored.
     public WithStreamParameter(Stream<?> s, String str) {
-      this.list = s.collect(Collectors.toList());
-      checkNotNull(str);
+      this.list = s.collect(toImmutableList());
+      requireNonNull(str);
     }
   }
 
@@ -1081,7 +1081,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final ReferentialEquality s;
 
     public UsesReferentialEquality(ReferentialEquality s) {
-      this.s = checkNotNull(s);
+      this.s = requireNonNull(s);
     }
 
     @Override
@@ -1103,7 +1103,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final TimeUnit s;
 
     public UsesEnum(TimeUnit s) {
-      this.s = checkNotNull(s);
+      this.s = requireNonNull(s);
     }
 
     @Override
@@ -1148,11 +1148,11 @@ public class ClassSanityTesterTest extends TestCase {
 
   static class GoodNulls {
     public GoodNulls(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
 
     public void rejectNull(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
   }
 
@@ -1163,7 +1163,7 @@ public class ClassSanityTesterTest extends TestCase {
   public static class NoNullCheckNeededDespitNotInstantiable {
 
     public NoNullCheckNeededDespitNotInstantiable(NotInstantiable x) {
-      checkNotNull(x);
+      requireNonNull(x);
     }
 
     @SuppressWarnings("unused") // reflected
@@ -1212,7 +1212,7 @@ public class ClassSanityTesterTest extends TestCase {
     final String name;
 
     private FactoryMethodDoesNotAcceptNull(String name) {
-      this.name = checkNotNull(name);
+      this.name = requireNonNull(name);
     }
 
     public static FactoryMethodDoesNotAcceptNull create(String name) {
@@ -1234,7 +1234,7 @@ public class ClassSanityTesterTest extends TestCase {
     final String name;
 
     ConstructorDoesNotAcceptNull(String name) {
-      this.name = checkNotNull(name);
+      this.name = requireNonNull(name);
     }
   }
 
@@ -1246,7 +1246,7 @@ public class ClassSanityTesterTest extends TestCase {
     private final Map<NotInstantiable, NotInstantiable> m;
 
     public ConstructorParameterMapOfNotInstantiable(Map<NotInstantiable, NotInstantiable> m) {
-      this.m = checkNotNull(m);
+      this.m = requireNonNull(m);
     }
 
     @Override
@@ -1267,7 +1267,7 @@ public class ClassSanityTesterTest extends TestCase {
   // Test that we should get a distinct parameter error when doing equals test.
   static class ConstructorParameterWithOptionalNotInstantiable {
     public ConstructorParameterWithOptionalNotInstantiable(Optional<NotInstantiable> x) {
-      checkNotNull(x);
+      requireNonNull(x);
     }
 
     @Override
@@ -1338,7 +1338,7 @@ public class ClassSanityTesterTest extends TestCase {
   private enum EnumFailsToCheckNull {
     A;
 
-    @SuppressWarnings({"unused", "EmptyMethod"})
+    @SuppressWarnings({"EmptyMethod", "unused"})
     public void failToCheckNull(String s) {}
   }
 
diff --git a/guava-testlib/test/com/google/common/testing/EqualsTesterTest.java b/guava-testlib/test/com/google/common/testing/EqualsTesterTest.java
index d615af6633..07d5a17a05 100644
--- a/guava-testlib/test/com/google/common/testing/EqualsTesterTest.java
+++ b/guava-testlib/test/com/google/common/testing/EqualsTesterTest.java
@@ -16,8 +16,9 @@
 
 package com.google.common.testing;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
 import java.util.Set;
@@ -320,8 +321,7 @@ public class EqualsTesterTest extends TestCase {
     public int hashCode() {
       int result = 17;
       result = 37 * result + aspect1;
-      result = 37 * result + aspect2;
-      return result;
+      return 37 * result + aspect2;
     }
   }
 
@@ -335,8 +335,8 @@ public class EqualsTesterTest extends TestCase {
       this.aspect2 = aspect2;
     }
 
-    @SuppressWarnings("EqualsHashCode")
     @Override
+    @SuppressWarnings("EqualsHashCode")
     public boolean equals(Object o) {
       if (!(o instanceof InvalidHashCodeObject)) {
         return false;
@@ -404,7 +404,7 @@ public class EqualsTesterTest extends TestCase {
     private final String name;
 
     NamedObject(String name) {
-      this.name = Preconditions.checkNotNull(name);
+      this.name = requireNonNull(name);
     }
 
     NamedObject addPeers(String... names) {
diff --git a/guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java b/guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java
index 9bad916fe3..3880c7d94c 100644
--- a/guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java
+++ b/guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java
@@ -17,13 +17,14 @@
 package com.google.common.testing;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.base.Converter;
 import com.google.common.base.Function;
 import com.google.common.base.Supplier;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableMultiset;
@@ -70,7 +71,7 @@ public class NullPointerTesterTest extends TestCase {
   public static class OneArg {
 
     public static void staticOneArgCorrectlyThrowsNpe(String s) {
-      checkNotNull(s); // expect NPE here on null
+      requireNonNull(s); // expect NPE here on null
     }
 
     public static void staticOneArgThrowsOtherThanNpe(String s) {
@@ -105,15 +106,15 @@ public class NullPointerTesterTest extends TestCase {
     }
 
     public static void staticOneArgCheckForNullThrowsNPE(@javax.annotation.CheckForNull String s) {
-      checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
+      requireNonNull(s); // doesn't check if you said you'd accept null, but you don't
     }
 
     public static void staticOneArgNullableThrowsNPE(@Nullable String s) {
-      checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
+      requireNonNull(s); // doesn't check if you said you'd accept null, but you don't
     }
 
     public void oneArgCorrectlyThrowsNpe(String s) {
-      checkNotNull(s); // expect NPE here on null
+      requireNonNull(s); // expect NPE here on null
     }
 
     public void oneArgThrowsOtherThanNpe(String s) {
@@ -143,11 +144,11 @@ public class NullPointerTesterTest extends TestCase {
     }
 
     public void oneArgCheckForNullThrowsNPE(@javax.annotation.CheckForNull String s) {
-      checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
+      requireNonNull(s); // doesn't check if you said you'd accept null, but you don't
     }
 
     public void oneArgNullableThrowsNPE(@Nullable String s) {
-      checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
+      requireNonNull(s); // doesn't check if you said you'd accept null, but you don't
     }
   }
 
@@ -184,7 +185,7 @@ public class NullPointerTesterTest extends TestCase {
 
   private static class ThrowsNpe {
     public static void christenPoodle(String name) {
-      checkNotNull(name);
+      requireNonNull(name);
     }
   }
 
@@ -208,7 +209,7 @@ public class NullPointerTesterTest extends TestCase {
 
   private interface InterfaceStaticMethodChecksNull {
     static String create(String s) {
-      return checkNotNull(s);
+      return requireNonNull(s);
     }
   }
 
@@ -226,7 +227,7 @@ public class NullPointerTesterTest extends TestCase {
     }
 
     default void checksNull(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
   }
 
@@ -450,7 +451,7 @@ public class NullPointerTesterTest extends TestCase {
     for (TwoArg.Action first : TwoArg.Action.values()) {
       for (TwoArg.Action second : TwoArg.Action.values()) {
         TwoArg bar = new TwoArg(first, second);
-        if (first.equals(TwoArg.Action.THROW_A_NPE) && second.equals(TwoArg.Action.THROW_A_NPE)) {
+        if (first == TwoArg.Action.THROW_A_NPE && second == TwoArg.Action.THROW_A_NPE) {
           verifyBarPass(method, bar); // require both params to throw NPE
         } else {
           verifyBarFail(method, bar);
@@ -464,7 +465,7 @@ public class NullPointerTesterTest extends TestCase {
     for (TwoArg.Action first : TwoArg.Action.values()) {
       for (TwoArg.Action second : TwoArg.Action.values()) {
         TwoArg bar = new TwoArg(first, second);
-        if (first.equals(TwoArg.Action.THROW_A_NPE)) {
+        if (first == TwoArg.Action.THROW_A_NPE) {
           verifyBarPass(method, bar); // only pass if 1st param throws NPE
         } else {
           verifyBarFail(method, bar);
@@ -478,7 +479,7 @@ public class NullPointerTesterTest extends TestCase {
     for (TwoArg.Action first : TwoArg.Action.values()) {
       for (TwoArg.Action second : TwoArg.Action.values()) {
         TwoArg bar = new TwoArg(first, second);
-        if (second.equals(TwoArg.Action.THROW_A_NPE)) {
+        if (second == TwoArg.Action.THROW_A_NPE) {
           verifyBarPass(method, bar); // only pass if 2nd param throws NPE
         } else {
           verifyBarFail(method, bar);
@@ -515,15 +516,15 @@ public class NullPointerTesterTest extends TestCase {
     public void noArg() {}
 
     public void oneArg(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
 
     void packagePrivateOneArg(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
 
     protected void protectedOneArg(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
 
     public void oneNullableArg(@Nullable String s) {}
@@ -533,25 +534,25 @@ public class NullPointerTesterTest extends TestCase {
     }
 
     public void twoArg(String s, Integer i) {
-      checkNotNull(s);
+      requireNonNull(s);
       i.intValue();
     }
 
     public void twoMixedArgs(String s, @Nullable Integer i) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
 
     public void twoMixedArgs(@Nullable Integer i, String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
 
     public void twoMixedArgsThrows(String s, @Nullable Integer i) {
-      checkNotNull(s);
+      requireNonNull(s);
       doThrow(i);
     }
 
     public void twoMixedArgsThrows(@Nullable Integer i, String s) {
-      checkNotNull(s);
+      requireNonNull(s);
       doThrow(i);
     }
 
@@ -566,11 +567,9 @@ public class NullPointerTesterTest extends TestCase {
     }
 
     public static void staticOneArg(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
 
-    public static void staticOneNullableArg(@Nullable String s) {}
-
     public static void staticOneNullableArgThrows(@Nullable String s) {
       doThrow(s);
     }
@@ -605,7 +604,7 @@ public class NullPointerTesterTest extends TestCase {
   private static class PassOneNullableArgThrowsNPE extends PassObject {
     @Override
     public void oneNullableArg(@Nullable String s) {
-      checkNotNull(s); // ok to throw NPE
+      requireNonNull(s); // ok to throw NPE
     }
   }
 
@@ -640,7 +639,7 @@ public class NullPointerTesterTest extends TestCase {
   private static class FailTwoArgsSecondArgDoesntThrowNPE extends PassObject {
     @Override
     public void twoArg(String s, Integer i) {
-      checkNotNull(s);
+      requireNonNull(s);
       // Fail: missing NPE for i
     }
   }
@@ -652,7 +651,7 @@ public class NullPointerTesterTest extends TestCase {
   private static class FailTwoArgsSecondArgThrowsWrongType extends PassObject {
     @Override
     public void twoArg(String s, Integer i) {
-      checkNotNull(s);
+      requireNonNull(s);
       doThrow(i); // Fail:  throwing non-NPE exception for null i
     }
   }
@@ -686,7 +685,7 @@ public class NullPointerTesterTest extends TestCase {
   private static class PassTwoMixedArgsNullableArgThrowsNPE extends PassObject {
     @Override
     public void twoMixedArgs(String s, @Nullable Integer i) {
-      checkNotNull(s);
+      requireNonNull(s);
       i.intValue(); // ok to throw NPE?
     }
   }
@@ -698,7 +697,7 @@ public class NullPointerTesterTest extends TestCase {
   private static class PassTwoMixedArgSecondNullableArgThrowsOther extends PassObject {
     @Override
     public void twoMixedArgs(String s, @Nullable Integer i) {
-      checkNotNull(s);
+      requireNonNull(s);
       doThrow(i); // ok to throw non-NPE exception for null i
     }
   }
@@ -732,7 +731,7 @@ public class NullPointerTesterTest extends TestCase {
   private static class PassTwoNullableArgsFirstThrowsNPE extends PassObject {
     @Override
     public void twoNullableArgs(@Nullable String s, @Nullable Integer i) {
-      checkNotNull(s); // ok to throw NPE?
+      requireNonNull(s); // ok to throw NPE?
     }
   }
 
@@ -870,7 +869,7 @@ public class NullPointerTesterTest extends TestCase {
   @SuppressWarnings("unused") // used by reflection
   private static class CanCreateDefault {
     public void foo(@Nullable HardToCreate ignored, String required) {
-      checkNotNull(required);
+      requireNonNull(required);
     }
   }
 
@@ -881,8 +880,8 @@ public class NullPointerTesterTest extends TestCase {
   @SuppressWarnings("unused") // used by reflection
   private static class CannotCreateDefault {
     public void foo(HardToCreate ignored, String required) {
-      checkNotNull(ignored);
-      checkNotNull(required);
+      requireNonNull(ignored);
+      requireNonNull(required);
     }
   }
 
@@ -951,8 +950,8 @@ public class NullPointerTesterTest extends TestCase {
 
     @Override
     public void doSomething(String bar, Integer baz) {
-      checkNotNull(bar);
-      checkNotNull(baz);
+      requireNonNull(bar);
+      requireNonNull(baz);
     }
   }
 
@@ -987,7 +986,7 @@ public class NullPointerTesterTest extends TestCase {
         }
       }
       for (Object arg : args) {
-        checkNotNull(arg); // to fulfill null check
+        requireNonNull(arg); // to fulfill null check
       }
     }
   }
@@ -1060,8 +1059,8 @@ public class NullPointerTesterTest extends TestCase {
               ImmutableSortedSet.of(),
               ImmutableMultiset.of(),
               ImmutableMultiset.of(),
-              ImmutableMultimap.of(),
-              ImmutableMultimap.of(),
+              ImmutableListMultimap.of(),
+              ImmutableListMultimap.of(),
               ImmutableTable.of(),
               ImmutableTable.of());
     }
@@ -1426,7 +1425,7 @@ public class NullPointerTesterTest extends TestCase {
 
   private class Inner {
     public Inner(String s) {
-      checkNotNull(s);
+      requireNonNull(s);
     }
   }
 
@@ -1444,8 +1443,8 @@ public class NullPointerTesterTest extends TestCase {
   }
 
   static class OverridesEquals {
-    @SuppressWarnings("EqualsHashCode")
     @Override
+    @SuppressWarnings("EqualsHashCode")
     public boolean equals(Object o) {
       return true;
     }
@@ -1468,7 +1467,7 @@ public class NullPointerTesterTest extends TestCase {
 
     @SuppressWarnings("unused") // Called by reflection
     public FailOnOneOfTwoConstructors(Object o) {
-      checkNotNull(o);
+      requireNonNull(o);
     }
   }
 
@@ -1493,7 +1492,7 @@ public class NullPointerTesterTest extends TestCase {
     @SuppressWarnings("unused") // Called by reflection
     public void x(X x) {
       xWasCalled = true;
-      checkNotNull(x);
+      requireNonNull(x);
     }
 
     @SuppressWarnings("unused") // Called by reflection
diff --git a/guava-testlib/test/com/google/common/testing/SerializableTesterTest.java b/guava-testlib/test/com/google/common/testing/SerializableTesterTest.java
index 753c4ab631..d16bbc755c 100644
--- a/guava-testlib/test/com/google/common/testing/SerializableTesterTest.java
+++ b/guava-testlib/test/com/google/common/testing/SerializableTesterTest.java
@@ -80,8 +80,8 @@ public class SerializableTesterTest extends TestCase {
   private static class ClassWhichIsAlwaysEqualButHasDifferentHashcodes implements Serializable {
     private static final long serialVersionUID = 2L;
 
-    @SuppressWarnings("EqualsHashCode")
     @Override
+    @SuppressWarnings("EqualsHashCode")
     public boolean equals(Object other) {
       return (other instanceof ClassWhichIsAlwaysEqualButHasDifferentHashcodes);
     }
diff --git a/guava-testlib/test/com/google/common/testing/anotherpackage/ForwardingWrapperTesterTest.java b/guava-testlib/test/com/google/common/testing/anotherpackage/ForwardingWrapperTesterTest.java
index 6e3bf2397d..96b3b4a08c 100644
--- a/guava-testlib/test/com/google/common/testing/anotherpackage/ForwardingWrapperTesterTest.java
+++ b/guava-testlib/test/com/google/common/testing/anotherpackage/ForwardingWrapperTesterTest.java
@@ -117,8 +117,8 @@ public class ForwardingWrapperTesterTest extends TestCase {
           public Runnable apply(final Runnable runnable) {
             return new ForwardingRunnable(runnable) {
 
-              @SuppressWarnings("EqualsHashCode")
               @Override
+              @SuppressWarnings("EqualsHashCode")
               public boolean equals(Object o) {
                 if (o instanceof ForwardingRunnable) {
                   ForwardingRunnable that = (ForwardingRunnable) o;
diff --git a/guava-testlib/test/com/google/common/testing/anotherpackage/SomeClassThatDoesNotUseNullable.java b/guava-testlib/test/com/google/common/testing/anotherpackage/SomeClassThatDoesNotUseNullable.java
index 6a17d1e283..893ced4e32 100644
--- a/guava-testlib/test/com/google/common/testing/anotherpackage/SomeClassThatDoesNotUseNullable.java
+++ b/guava-testlib/test/com/google/common/testing/anotherpackage/SomeClassThatDoesNotUseNullable.java
@@ -25,6 +25,4 @@ public class SomeClassThatDoesNotUseNullable {
   protected void protectedButDoesNotCheckNull(String s) {}
 
   public void publicButDoesNotCheckNull(String s) {}
-
-  public static void staticButDoesNotCheckNull(String s) {}
 }
diff --git a/guava/src/com/google/common/base/Absent.java b/guava/src/com/google/common/base/Absent.java
index f96136b5ef..4311816a1d 100644
--- a/guava/src/com/google/common/base/Absent.java
+++ b/guava/src/com/google/common/base/Absent.java
@@ -14,10 +14,10 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.emptySet;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
-import java.util.Collections;
 import java.util.Set;
 import javax.annotation.CheckForNull;
 
@@ -46,35 +46,35 @@ final class Absent<T> extends Optional<T> {
 
   @Override
   public T or(T defaultValue) {
-    return checkNotNull(defaultValue, "use Optional.orNull() instead of Optional.or(null)");
+    return requireNonNull(defaultValue, "use Optional.orNull() instead of Optional.or(null)");
   }
 
-  @SuppressWarnings("unchecked") // safe covariant cast
-  @Override
+  @Override // safe covariant cast
+  @SuppressWarnings("unchecked")
   public Optional<T> or(Optional<? extends T> secondChoice) {
-    return (Optional<T>) checkNotNull(secondChoice);
+    return (Optional<T>) requireNonNull(secondChoice);
   }
 
   @Override
   public T or(Supplier<? extends T> supplier) {
-    return checkNotNull(
+    return requireNonNull(
         supplier.get(), "use Optional.orNull() instead of a Supplier that returns null");
   }
 
-  @Override
   @CheckForNull
+  @Override
   public T orNull() {
     return null;
   }
 
   @Override
   public Set<T> asSet() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   @Override
   public <V> Optional<V> transform(Function<? super T, V> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     return Optional.absent();
   }
 
diff --git a/guava/src/com/google/common/base/Ascii.java b/guava/src/com/google/common/base/Ascii.java
index 0c651bb27b..564ff1a05e 100644
--- a/guava/src/com/google/common/base/Ascii.java
+++ b/guava/src/com/google/common/base/Ascii.java
@@ -15,7 +15,7 @@
 package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 
@@ -548,7 +548,7 @@ public final class Ascii {
    * @since 16.0
    */
   public static String truncate(CharSequence seq, int maxLength, String truncationIndicator) {
-    checkNotNull(seq);
+    requireNonNull(seq);
 
     // length to truncate the sequence to, not including the truncation indicator
     int truncationLength = maxLength - truncationIndicator.length();
diff --git a/guava/src/com/google/common/base/CaseFormat.java b/guava/src/com/google/common/base/CaseFormat.java
index 7b393ebd7e..e3aef9a521 100644
--- a/guava/src/com/google/common/base/CaseFormat.java
+++ b/guava/src/com/google/common/base/CaseFormat.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -123,8 +122,8 @@ public enum CaseFormat {
    * the behavior of this method is undefined but we make a reasonable effort at converting anyway.
    */
   public final String to(CaseFormat format, String str) {
-    checkNotNull(format);
-    checkNotNull(str);
+    requireNonNull(format);
+    requireNonNull(str);
     return (format == this) ? str : convert(format, str);
   }
 
@@ -166,8 +165,8 @@ public enum CaseFormat {
     private final CaseFormat targetFormat;
 
     StringConverter(CaseFormat sourceFormat, CaseFormat targetFormat) {
-      this.sourceFormat = checkNotNull(sourceFormat);
-      this.targetFormat = checkNotNull(targetFormat);
+      this.sourceFormat = requireNonNull(sourceFormat);
+      this.targetFormat = requireNonNull(targetFormat);
     }
 
     @Override
@@ -184,7 +183,7 @@ public enum CaseFormat {
     public boolean equals(@CheckForNull Object object) {
       if (object instanceof StringConverter) {
         StringConverter that = (StringConverter) object;
-        return sourceFormat.equals(that.sourceFormat) && targetFormat.equals(that.targetFormat);
+        return sourceFormat == that.sourceFormat && targetFormat == that.targetFormat;
       }
       return false;
     }
diff --git a/guava/src/com/google/common/base/CharMatcher.java b/guava/src/com/google/common/base/CharMatcher.java
index 253bc6a22f..a23e3847d8 100644
--- a/guava/src/com/google/common/base/CharMatcher.java
+++ b/guava/src/com/google/common/base/CharMatcher.java
@@ -15,8 +15,8 @@
 package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -956,7 +956,7 @@ public abstract class CharMatcher implements Predicate<Character> {
     private final String description;
 
     NamedFastMatcher(String description) {
-      this.description = checkNotNull(description);
+      this.description = requireNonNull(description);
     }
 
     @Override
@@ -1039,7 +1039,7 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public boolean matchesAllOf(CharSequence sequence) {
-      checkNotNull(sequence);
+      requireNonNull(sequence);
       return true;
     }
 
@@ -1050,7 +1050,7 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public String removeFrom(CharSequence sequence) {
-      checkNotNull(sequence);
+      requireNonNull(sequence);
       return "";
     }
 
@@ -1077,7 +1077,7 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public String trimFrom(CharSequence sequence) {
-      checkNotNull(sequence);
+      requireNonNull(sequence);
       return "";
     }
 
@@ -1088,12 +1088,12 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public CharMatcher and(CharMatcher other) {
-      return checkNotNull(other);
+      return requireNonNull(other);
     }
 
     @Override
     public CharMatcher or(CharMatcher other) {
-      checkNotNull(other);
+      requireNonNull(other);
       return this;
     }
 
@@ -1119,7 +1119,7 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public int indexIn(CharSequence sequence) {
-      checkNotNull(sequence);
+      requireNonNull(sequence);
       return -1;
     }
 
@@ -1132,7 +1132,7 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public int lastIndexIn(CharSequence sequence) {
-      checkNotNull(sequence);
+      requireNonNull(sequence);
       return -1;
     }
 
@@ -1143,7 +1143,7 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public boolean matchesNoneOf(CharSequence sequence) {
-      checkNotNull(sequence);
+      requireNonNull(sequence);
       return true;
     }
 
@@ -1159,7 +1159,7 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public String replaceFrom(CharSequence sequence, CharSequence replacement) {
-      checkNotNull(replacement);
+      requireNonNull(replacement);
       return sequence.toString();
     }
 
@@ -1185,19 +1185,19 @@ public abstract class CharMatcher implements Predicate<Character> {
 
     @Override
     public int countIn(CharSequence sequence) {
-      checkNotNull(sequence);
+      requireNonNull(sequence);
       return 0;
     }
 
     @Override
     public CharMatcher and(CharMatcher other) {
-      checkNotNull(other);
+      requireNonNull(other);
       return this;
     }
 
     @Override
     public CharMatcher or(CharMatcher other) {
-      return checkNotNull(other);
+      return requireNonNull(other);
     }
 
     @Override
@@ -1496,7 +1496,7 @@ public abstract class CharMatcher implements Predicate<Character> {
     final CharMatcher original;
 
     Negated(CharMatcher original) {
-      this.original = checkNotNull(original);
+      this.original = requireNonNull(original);
     }
 
     @Override
@@ -1546,8 +1546,8 @@ public abstract class CharMatcher implements Predicate<Character> {
     final CharMatcher second;
 
     And(CharMatcher a, CharMatcher b) {
-      first = checkNotNull(a);
-      second = checkNotNull(b);
+      first = requireNonNull(a);
+      second = requireNonNull(b);
     }
 
     @Override
@@ -1579,8 +1579,8 @@ public abstract class CharMatcher implements Predicate<Character> {
     final CharMatcher second;
 
     Or(CharMatcher a, CharMatcher b) {
-      first = checkNotNull(a);
-      second = checkNotNull(b);
+      first = requireNonNull(a);
+      second = requireNonNull(b);
     }
 
     @GwtIncompatible // used only from other GwtIncompatible code
@@ -1739,8 +1739,8 @@ public abstract class CharMatcher implements Predicate<Character> {
       return Arrays.binarySearch(chars, c) >= 0;
     }
 
-    @Override
-    @GwtIncompatible // used only from other GwtIncompatible code
+    @GwtIncompatible
+    @Override // used only from other GwtIncompatible code
     void setBits(BitSet table) {
       for (char c : chars) {
         table.set(c);
@@ -1797,7 +1797,7 @@ public abstract class CharMatcher implements Predicate<Character> {
     private final Predicate<? super Character> predicate;
 
     ForPredicate(Predicate<? super Character> predicate) {
-      this.predicate = checkNotNull(predicate);
+      this.predicate = requireNonNull(predicate);
     }
 
     @Override
@@ -1805,10 +1805,10 @@ public abstract class CharMatcher implements Predicate<Character> {
       return predicate.apply(c);
     }
 
-    @SuppressWarnings("deprecation") // intentional; deprecation is for callers primarily
-    @Override
+    @Override // intentional; deprecation is for callers primarily
+    @SuppressWarnings("deprecation")
     public boolean apply(Character character) {
-      return predicate.apply(checkNotNull(character));
+      return predicate.apply(requireNonNull(character));
     }
 
     @Override
diff --git a/guava/src/com/google/common/base/Converter.java b/guava/src/com/google/common/base/Converter.java
index 422480d164..639c6208ad 100644
--- a/guava/src/com/google/common/base/Converter.java
+++ b/guava/src/com/google/common/base/Converter.java
@@ -15,7 +15,7 @@
 package com.google.common.base;
 
 import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -201,7 +201,7 @@ public abstract class Converter<A, B> implements Function<A, B> {
   B correctedDoForward(@CheckForNull A a) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
-      return a == null ? null : checkNotNull(doForward(a));
+      return a == null ? null : requireNonNull(doForward(a));
     } else {
       return unsafeDoForward(a);
     }
@@ -211,7 +211,7 @@ public abstract class Converter<A, B> implements Function<A, B> {
   A correctedDoBackward(@CheckForNull B b) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
-      return b == null ? null : checkNotNull(doBackward(b));
+      return b == null ? null : requireNonNull(doBackward(b));
     } else {
       return unsafeDoBackward(b);
     }
@@ -273,7 +273,7 @@ public abstract class Converter<A, B> implements Function<A, B> {
    * (`implements Function<@PolyNull A, @PolyNull B>`), at least as far as I know.)
    */
   public Iterable<B> convertAll(Iterable<? extends A> fromIterable) {
-    checkNotNull(fromIterable, "fromIterable");
+    requireNonNull(fromIterable, "fromIterable");
     return new Iterable<B>() {
       @Override
       public Iterator<B> iterator() {
@@ -285,9 +285,9 @@ public abstract class Converter<A, B> implements Function<A, B> {
             return fromIterator.hasNext();
           }
 
-          @Override
-          @SuppressWarnings("nullness") // See code comments on convertAll and Converter.apply.
           @CheckForNull
+          @Override // See code comments on convertAll and Converter.apply.
+          @SuppressWarnings("nullness")
           public B next() {
             return convert(fromIterator.next());
           }
@@ -340,14 +340,14 @@ public abstract class Converter<A, B> implements Function<A, B> {
       throw new AssertionError();
     }
 
-    @Override
     @CheckForNull
+    @Override
     A correctedDoForward(@CheckForNull B b) {
       return original.correctedDoBackward(b);
     }
 
-    @Override
     @CheckForNull
+    @Override
     B correctedDoBackward(@CheckForNull A a) {
       return original.correctedDoForward(a);
     }
@@ -392,7 +392,7 @@ public abstract class Converter<A, B> implements Function<A, B> {
 
   /** Package-private non-final implementation of andThen() so only we can override it. */
   <C> Converter<A, C> doAndThen(Converter<B, C> secondConverter) {
-    return new ConverterComposition<>(this, checkNotNull(secondConverter));
+    return new ConverterComposition<>(this, requireNonNull(secondConverter));
   }
 
   private static final class ConverterComposition<A, B, C> extends Converter<A, C>
@@ -422,14 +422,14 @@ public abstract class Converter<A, B> implements Function<A, B> {
       throw new AssertionError();
     }
 
-    @Override
     @CheckForNull
+    @Override
     C correctedDoForward(@CheckForNull A a) {
       return second.correctedDoForward(first.correctedDoForward(a));
     }
 
-    @Override
     @CheckForNull
+    @Override
     A correctedDoBackward(@CheckForNull C c) {
       return first.correctedDoBackward(second.correctedDoBackward(c));
     }
@@ -459,9 +459,9 @@ public abstract class Converter<A, B> implements Function<A, B> {
   /**
    * @deprecated Provided to satisfy the {@code Function} interface; use {@link #convert} instead.
    */
-  @Deprecated
-  @Override
   @CanIgnoreReturnValue
+  @CheckForNull
+  @Deprecated
   /*
    * Even though we implement `Function<A, B>` instead of `Function<@Nullable A, @Nullable B>` (as
    * discussed in a code comment at the top of the class), we declare our override of Function.apply
@@ -492,9 +492,9 @@ public abstract class Converter<A, B> implements Function<A, B> {
    * various hypothetical futures. (Plus, a tool that were that smart would likely already introduce
    * problems with LegacyConverter.)
    */
-  @SuppressWarnings("nullness")
-  @CheckForNull
   @InlineMe(replacement = "this.convert(a)")
+  @Override
+  @SuppressWarnings("nullness")
   public final B apply(@CheckForNull A a) {
     return convert(a);
   }
@@ -545,8 +545,8 @@ public abstract class Converter<A, B> implements Function<A, B> {
     private FunctionBasedConverter(
         Function<? super A, ? extends B> forwardFunction,
         Function<? super B, ? extends A> backwardFunction) {
-      this.forwardFunction = checkNotNull(forwardFunction);
-      this.backwardFunction = checkNotNull(backwardFunction);
+      this.forwardFunction = requireNonNull(forwardFunction);
+      this.backwardFunction = requireNonNull(backwardFunction);
     }
 
     @Override
@@ -610,7 +610,7 @@ public abstract class Converter<A, B> implements Function<A, B> {
 
     @Override
     <S> Converter<T, S> doAndThen(Converter<T, S> otherConverter) {
-      return checkNotNull(otherConverter, "otherConverter");
+      return requireNonNull(otherConverter, "otherConverter");
     }
 
     /*
diff --git a/guava/src/com/google/common/base/Defaults.java b/guava/src/com/google/common/base/Defaults.java
index 5d12343ed2..6c97d5d13d 100644
--- a/guava/src/com/google/common/base/Defaults.java
+++ b/guava/src/com/google/common/base/Defaults.java
@@ -14,7 +14,7 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import javax.annotation.CheckForNull;
@@ -38,10 +38,10 @@ public final class Defaults {
    * false} for {@code boolean} and {@code '\0'} for {@code char}. For non-primitive types and
    * {@code void}, {@code null} is returned.
    */
-  @SuppressWarnings("unchecked")
   @CheckForNull
+  @SuppressWarnings("unchecked")
   public static <T> T defaultValue(Class<T> type) {
-    checkNotNull(type);
+    requireNonNull(type);
     if (type.isPrimitive()) {
       if (type == boolean.class) {
         return (T) Boolean.FALSE;
diff --git a/guava/src/com/google/common/base/Enums.java b/guava/src/com/google/common/base/Enums.java
index 5c55b65942..f2ba734261 100644
--- a/guava/src/com/google/common/base/Enums.java
+++ b/guava/src/com/google/common/base/Enums.java
@@ -14,7 +14,7 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -65,8 +65,8 @@ public final class Enums {
    * @since 12.0
    */
   public static <T extends Enum<T>> Optional<T> getIfPresent(Class<T> enumClass, String value) {
-    checkNotNull(enumClass);
-    checkNotNull(value);
+    requireNonNull(enumClass);
+    requireNonNull(value);
     return Platform.getEnumIfPresent(enumClass, value);
   }
 
@@ -115,7 +115,7 @@ public final class Enums {
     private final Class<T> enumClass;
 
     StringConverter(Class<T> enumClass) {
-      this.enumClass = checkNotNull(enumClass);
+      this.enumClass = requireNonNull(enumClass);
     }
 
     @Override
diff --git a/guava/src/com/google/common/base/Equivalence.java b/guava/src/com/google/common/base/Equivalence.java
index 4e2e89886a..d232fa9052 100644
--- a/guava/src/com/google/common/base/Equivalence.java
+++ b/guava/src/com/google/common/base/Equivalence.java
@@ -14,7 +14,7 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.ForOverride;
@@ -229,7 +229,7 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
     @ParametricNullness private final T reference;
 
     private Wrapper(Equivalence<? super T> equivalence, @ParametricNullness T reference) {
-      this.equivalence = checkNotNull(equivalence);
+      this.equivalence = requireNonNull(equivalence);
       this.reference = reference;
     }
 
@@ -318,7 +318,7 @@ public abstract class Equivalence<T> implements BiPredicate<@Nullable T, @Nullab
     @CheckForNull private final T target;
 
     EquivalentToPredicate(Equivalence<T> equivalence, @CheckForNull T target) {
-      this.equivalence = checkNotNull(equivalence);
+      this.equivalence = requireNonNull(equivalence);
       this.target = target;
     }
 
diff --git a/guava/src/com/google/common/base/FinalizableReferenceQueue.java b/guava/src/com/google/common/base/FinalizableReferenceQueue.java
index 7447b8051d..70dfac8ed2 100644
--- a/guava/src/com/google/common/base/FinalizableReferenceQueue.java
+++ b/guava/src/com/google/common/base/FinalizableReferenceQueue.java
@@ -242,8 +242,8 @@ public class FinalizableReferenceQueue implements Closeable {
     // finding Finalizer on the system class path even if it is there.
     @VisibleForTesting static boolean disabled;
 
-    @Override
     @CheckForNull
+    @Override
     public Class<?> loadFinalizer() {
       if (disabled) {
         return null;
@@ -280,8 +280,8 @@ public class FinalizableReferenceQueue implements Closeable {
             + "loader. To support reclaiming this class loader, either resolve the underlying "
             + "issue, or move Guava to your system class path.";
 
-    @Override
     @CheckForNull
+    @Override
     public Class<?> loadFinalizer() {
       try {
         /*
diff --git a/guava/src/com/google/common/base/Function.java b/guava/src/com/google/common/base/Function.java
index 45287b744a..0844cf5360 100644
--- a/guava/src/com/google/common/base/Function.java
+++ b/guava/src/com/google/common/base/Function.java
@@ -45,8 +45,8 @@ import org.checkerframework.checker.nullness.qual.Nullable;
 @ElementTypesAreNonnullByDefault
 public interface Function<F extends @Nullable Object, T extends @Nullable Object>
     extends java.util.function.Function<F, T> {
-  @Override
-  @CanIgnoreReturnValue // TODO(kevinb): remove this
+  @CanIgnoreReturnValue
+  @Override // TODO(kevinb): remove this
   @ParametricNullness
   T apply(@ParametricNullness F input);
 
diff --git a/guava/src/com/google/common/base/FunctionalEquivalence.java b/guava/src/com/google/common/base/FunctionalEquivalence.java
index 4383f4f36c..c913767817 100644
--- a/guava/src/com/google/common/base/FunctionalEquivalence.java
+++ b/guava/src/com/google/common/base/FunctionalEquivalence.java
@@ -14,7 +14,7 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -40,8 +40,8 @@ final class FunctionalEquivalence<F, T> extends Equivalence<F> implements Serial
 
   FunctionalEquivalence(
       Function<? super F, ? extends @Nullable T> function, Equivalence<T> resultEquivalence) {
-    this.function = checkNotNull(function);
-    this.resultEquivalence = checkNotNull(resultEquivalence);
+    this.function = requireNonNull(function);
+    this.resultEquivalence = requireNonNull(resultEquivalence);
   }
 
   @Override
diff --git a/guava/src/com/google/common/base/Functions.java b/guava/src/com/google/common/base/Functions.java
index 5710dcf054..0970f2a3b1 100644
--- a/guava/src/com/google/common/base/Functions.java
+++ b/guava/src/com/google/common/base/Functions.java
@@ -16,7 +16,7 @@ package com.google.common.base;
 
 import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
@@ -69,7 +69,7 @@ public final class Functions {
 
     @Override
     public String apply(Object o) {
-      checkNotNull(o); // eager for GWT.
+      requireNonNull(o); // eager for GWT.
       return o.toString();
     }
 
@@ -90,8 +90,8 @@ public final class Functions {
   private enum IdentityFunction implements Function<@Nullable Object, @Nullable Object> {
     INSTANCE;
 
-    @Override
     @CheckForNull
+    @Override
     public Object apply(@CheckForNull Object o) {
       return o;
     }
@@ -144,7 +144,7 @@ public final class Functions {
     final Map<K, V> map;
 
     FunctionForMapNoDefault(Map<K, V> map) {
-      this.map = checkNotNull(map);
+      this.map = requireNonNull(map);
     }
 
     @Override
@@ -184,7 +184,7 @@ public final class Functions {
     @ParametricNullness final V defaultValue;
 
     ForMapWithDefault(Map<K, ? extends V> map, @ParametricNullness V defaultValue) {
-      this.map = checkNotNull(map);
+      this.map = requireNonNull(map);
       this.defaultValue = defaultValue;
     }
 
@@ -245,8 +245,8 @@ public final class Functions {
     private final Function<A, ? extends B> f;
 
     public FunctionComposition(Function<B, C> g, Function<A, ? extends B> f) {
-      this.g = checkNotNull(g);
-      this.f = checkNotNull(f);
+      this.g = requireNonNull(g);
+      this.f = requireNonNull(f);
     }
 
     @Override
@@ -299,7 +299,7 @@ public final class Functions {
     private final Predicate<T> predicate;
 
     private PredicateFunction(Predicate<T> predicate) {
-      this.predicate = checkNotNull(predicate);
+      this.predicate = requireNonNull(predicate);
     }
 
     @Override
@@ -399,7 +399,7 @@ public final class Functions {
     private final Supplier<T> supplier;
 
     private SupplierFunction(Supplier<T> supplier) {
-      this.supplier = checkNotNull(supplier);
+      this.supplier = requireNonNull(supplier);
     }
 
     @Override
diff --git a/guava/src/com/google/common/base/JdkPattern.java b/guava/src/com/google/common/base/JdkPattern.java
index 4788398b7c..d30855e250 100644
--- a/guava/src/com/google/common/base/JdkPattern.java
+++ b/guava/src/com/google/common/base/JdkPattern.java
@@ -14,6 +14,8 @@
 
 package com.google.common.base;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.regex.Matcher;
@@ -26,7 +28,7 @@ final class JdkPattern extends CommonPattern implements Serializable {
   private final Pattern pattern;
 
   JdkPattern(Pattern pattern) {
-    this.pattern = Preconditions.checkNotNull(pattern);
+    this.pattern = requireNonNull(pattern);
   }
 
   @Override
@@ -53,7 +55,7 @@ final class JdkPattern extends CommonPattern implements Serializable {
     final Matcher matcher;
 
     JdkMatcher(Matcher matcher) {
-      this.matcher = Preconditions.checkNotNull(matcher);
+      this.matcher = requireNonNull(matcher);
     }
 
     @Override
diff --git a/guava/src/com/google/common/base/Joiner.java b/guava/src/com/google/common/base/Joiner.java
index 8b29f68f8a..159971d200 100644
--- a/guava/src/com/google/common/base/Joiner.java
+++ b/guava/src/com/google/common/base/Joiner.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -80,7 +79,7 @@ public class Joiner {
   private final String separator;
 
   private Joiner(String separator) {
-    this.separator = checkNotNull(separator);
+    this.separator = requireNonNull(separator);
   }
 
   private Joiner(Joiner prototype) {
@@ -112,7 +111,7 @@ public class Joiner {
   @CanIgnoreReturnValue
   public <A extends Appendable> A appendTo(A appendable, Iterator<? extends @Nullable Object> parts)
       throws IOException {
-    checkNotNull(appendable);
+    requireNonNull(appendable);
     if (parts.hasNext()) {
       appendable.append(toString(parts.next()));
       while (parts.hasNext()) {
@@ -237,7 +236,7 @@ public class Joiner {
    * nullText} for any provided null elements.
    */
   public Joiner useForNull(String nullText) {
-    checkNotNull(nullText);
+    requireNonNull(nullText);
     return new Joiner(this) {
       @Override
       CharSequence toString(@CheckForNull Object part) {
@@ -265,8 +264,8 @@ public class Joiner {
       @Override
       public <A extends Appendable> A appendTo(
           A appendable, Iterator<? extends @Nullable Object> parts) throws IOException {
-        checkNotNull(appendable, "appendable");
-        checkNotNull(parts, "parts");
+        requireNonNull(appendable, "appendable");
+        requireNonNull(parts, "parts");
         while (parts.hasNext()) {
           Object part = parts.next();
           if (part != null) {
@@ -338,7 +337,7 @@ public class Joiner {
 
     private MapJoiner(Joiner joiner, String keyValueSeparator) {
       this.joiner = joiner; // only "this" is ever passed, so don't checkNotNull
-      this.keyValueSeparator = checkNotNull(keyValueSeparator);
+      this.keyValueSeparator = requireNonNull(keyValueSeparator);
     }
 
     /**
@@ -383,7 +382,7 @@ public class Joiner {
     @CanIgnoreReturnValue
     public <A extends Appendable> A appendTo(A appendable, Iterator<? extends Entry<?, ?>> parts)
         throws IOException {
-      checkNotNull(appendable);
+      requireNonNull(appendable);
       if (parts.hasNext()) {
         Entry<?, ?> entry = parts.next();
         appendable.append(joiner.toString(entry.getKey()));
@@ -494,15 +493,15 @@ public class Joiner {
 
   private static Iterable<@Nullable Object> iterable(
       @CheckForNull Object first, @CheckForNull Object second, @Nullable Object[] rest) {
-    checkNotNull(rest);
+    requireNonNull(rest);
     return new AbstractList<@Nullable Object>() {
       @Override
       public int size() {
         return rest.length + 2;
       }
 
-      @Override
       @CheckForNull
+      @Override
       public Object get(int index) {
         switch (index) {
           case 0:
diff --git a/guava/src/com/google/common/base/MoreObjects.java b/guava/src/com/google/common/base/MoreObjects.java
index 16e12bb507..fde8faf75f 100644
--- a/guava/src/com/google/common/base/MoreObjects.java
+++ b/guava/src/com/google/common/base/MoreObjects.java
@@ -14,7 +14,7 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -173,7 +173,7 @@ public final class MoreObjects {
 
     /** Use {@link MoreObjects#toStringHelper(Object)} to create an instance. */
     private ToStringHelper(String className) {
-      this.className = checkNotNull(className);
+      this.className = requireNonNull(className);
     }
 
     /**
@@ -428,7 +428,7 @@ public final class MoreObjects {
     private ToStringHelper addHolder(String name, @CheckForNull Object value) {
       ValueHolder valueHolder = addHolder();
       valueHolder.value = value;
-      valueHolder.name = checkNotNull(name);
+      valueHolder.name = requireNonNull(name);
       return this;
     }
 
@@ -447,7 +447,7 @@ public final class MoreObjects {
     private ToStringHelper addUnconditionalHolder(String name, Object value) {
       UnconditionalValueHolder valueHolder = addUnconditionalHolder();
       valueHolder.value = value;
-      valueHolder.name = checkNotNull(name);
+      valueHolder.name = requireNonNull(name);
       return this;
     }
 
diff --git a/guava/src/com/google/common/base/Optional.java b/guava/src/com/google/common/base/Optional.java
index b47705e82f..c7a24b7565 100644
--- a/guava/src/com/google/common/base/Optional.java
+++ b/guava/src/com/google/common/base/Optional.java
@@ -14,7 +14,7 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -103,7 +103,7 @@ public abstract class Optional<T> implements Serializable {
    * @throws NullPointerException if {@code reference} is null
    */
   public static <T> Optional<T> of(T reference) {
-    return new Present<T>(checkNotNull(reference));
+    return new Present<T>(requireNonNull(reference));
   }
 
   /**
@@ -334,16 +334,16 @@ public abstract class Optional<T> implements Serializable {
   @Beta
   public static <T> Iterable<T> presentInstances(
       final Iterable<? extends Optional<? extends T>> optionals) {
-    checkNotNull(optionals);
+    requireNonNull(optionals);
     return new Iterable<T>() {
       @Override
       public Iterator<T> iterator() {
         return new AbstractIterator<T>() {
           private final Iterator<? extends Optional<? extends T>> iterator =
-              checkNotNull(optionals.iterator());
+              requireNonNull(optionals.iterator());
 
-          @Override
           @CheckForNull
+          @Override
           protected T computeNext() {
             while (iterator.hasNext()) {
               Optional<? extends T> optional = iterator.next();
diff --git a/guava/src/com/google/common/base/PairwiseEquivalence.java b/guava/src/com/google/common/base/PairwiseEquivalence.java
index 74be27fd7c..38022503bb 100644
--- a/guava/src/com/google/common/base/PairwiseEquivalence.java
+++ b/guava/src/com/google/common/base/PairwiseEquivalence.java
@@ -14,6 +14,8 @@
 
 package com.google.common.base;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Iterator;
@@ -27,7 +29,7 @@ final class PairwiseEquivalence<E, T extends @Nullable E> extends Equivalence<It
   final Equivalence<E> elementEquivalence;
 
   PairwiseEquivalence(Equivalence<E> elementEquivalence) {
-    this.elementEquivalence = Preconditions.checkNotNull(elementEquivalence);
+    this.elementEquivalence = requireNonNull(elementEquivalence);
   }
 
   @Override
diff --git a/guava/src/com/google/common/base/Platform.java b/guava/src/com/google/common/base/Platform.java
index 137f879603..019276a221 100644
--- a/guava/src/com/google/common/base/Platform.java
+++ b/guava/src/com/google/common/base/Platform.java
@@ -14,6 +14,8 @@
 
 package com.google.common.base;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtCompatible;
 import java.lang.ref.WeakReference;
 import java.util.Locale;
@@ -82,7 +84,7 @@ final class Platform {
   }
 
   static CommonPattern compilePattern(String pattern) {
-    Preconditions.checkNotNull(pattern);
+    requireNonNull(pattern);
     return patternCompiler.compile(pattern);
   }
 
diff --git a/guava/src/com/google/common/base/Preconditions.java b/guava/src/com/google/common/base/Preconditions.java
index 1d9729951c..0fafe252e1 100644
--- a/guava/src/com/google/common/base/Preconditions.java
+++ b/guava/src/com/google/common/base/Preconditions.java
@@ -14,6 +14,7 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Strings.lenientFormat;
 
 import com.google.common.annotations.GwtCompatible;
@@ -193,9 +194,7 @@ public final class Preconditions {
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(boolean b, String errorMessageTemplate, int p1) {
-    if (!b) {
-      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
-    }
+    checkArgument(b, lenientFormat(errorMessageTemplate, p1));
   }
 
   /**
@@ -206,9 +205,7 @@ public final class Preconditions {
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(boolean b, String errorMessageTemplate, long p1) {
-    if (!b) {
-      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
-    }
+    checkArgument(b, lenientFormat(errorMessageTemplate, p1));
   }
 
   /**
@@ -220,9 +217,7 @@ public final class Preconditions {
    */
   public static void checkArgument(
       boolean b, String errorMessageTemplate, @CheckForNull Object p1) {
-    if (!b) {
-      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
-    }
+    checkArgument(b, lenientFormat(errorMessageTemplate, p1));
   }
 
   /**
@@ -233,9 +228,7 @@ public final class Preconditions {
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(boolean b, String errorMessageTemplate, char p1, char p2) {
-    if (!b) {
-      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
-    }
+    checkArgument(b, lenientFormat(errorMessageTemplate, p1, p2));
   }
 
   /**
@@ -246,9 +239,7 @@ public final class Preconditions {
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(boolean b, String errorMessageTemplate, char p1, int p2) {
-    if (!b) {
-      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
-    }
+    checkArgument(b, lenientFormat(errorMessageTemplate, p1, p2));
   }
 
   /**
@@ -259,9 +250,7 @@ public final class Preconditions {
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(boolean b, String errorMessageTemplate, char p1, long p2) {
-    if (!b) {
-      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
-    }
+    checkArgument(b, lenientFormat(errorMessageTemplate, p1, p2));
   }
 
   /**
diff --git a/guava/src/com/google/common/base/Predicates.java b/guava/src/com/google/common/base/Predicates.java
index 53598571d7..553891a049 100644
--- a/guava/src/com/google/common/base/Predicates.java
+++ b/guava/src/com/google/common/base/Predicates.java
@@ -14,7 +14,7 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -116,7 +116,7 @@ public final class Predicates {
    */
   public static <T extends @Nullable Object> Predicate<T> and(
       Predicate<? super T> first, Predicate<? super T> second) {
-    return new AndPredicate<>(Predicates.<T>asList(checkNotNull(first), checkNotNull(second)));
+    return new AndPredicate<>(Predicates.<T>asList(requireNonNull(first), requireNonNull(second)));
   }
 
   /**
@@ -150,7 +150,7 @@ public final class Predicates {
    */
   public static <T extends @Nullable Object> Predicate<T> or(
       Predicate<? super T> first, Predicate<? super T> second) {
-    return new OrPredicate<>(Predicates.<T>asList(checkNotNull(first), checkNotNull(second)));
+    return new OrPredicate<>(Predicates.<T>asList(requireNonNull(first), requireNonNull(second)));
   }
 
   /**
@@ -195,8 +195,8 @@ public final class Predicates {
    *
    * @since 20.0 (since 10.0 under the incorrect name {@code assignableFrom})
    */
-  @GwtIncompatible // Class.isAssignableFrom
-  @Beta
+  @Beta // Class.isAssignableFrom
+  @GwtIncompatible
   public static Predicate<Class<?>> subtypeOf(Class<?> clazz) {
     return new SubtypeOfPredicate(clazz);
   }
@@ -247,7 +247,7 @@ public final class Predicates {
    *
    * @since 3.0
    */
-  @GwtIncompatible(value = "java.util.regex.Pattern")
+  @GwtIncompatible("java.util.regex.Pattern")
   public static Predicate<CharSequence> contains(Pattern pattern) {
     return new ContainsPatternPredicate(new JdkPattern(pattern));
   }
@@ -327,7 +327,7 @@ public final class Predicates {
     final Predicate<T> predicate;
 
     NotPredicate(Predicate<T> predicate) {
-      this.predicate = checkNotNull(predicate);
+      this.predicate = requireNonNull(predicate);
     }
 
     @Override
@@ -511,7 +511,7 @@ public final class Predicates {
     private final Class<?> clazz;
 
     private InstanceOfPredicate(Class<?> clazz) {
-      this.clazz = checkNotNull(clazz);
+      this.clazz = requireNonNull(clazz);
     }
 
     @Override
@@ -549,7 +549,7 @@ public final class Predicates {
     private final Class<?> clazz;
 
     private SubtypeOfPredicate(Class<?> clazz) {
-      this.clazz = checkNotNull(clazz);
+      this.clazz = requireNonNull(clazz);
     }
 
     @Override
@@ -587,7 +587,7 @@ public final class Predicates {
     private final Collection<?> target;
 
     private InPredicate(Collection<?> target) {
-      this.target = checkNotNull(target);
+      this.target = requireNonNull(target);
     }
 
     @Override
@@ -630,8 +630,8 @@ public final class Predicates {
     final Function<A, ? extends B> f;
 
     private CompositionPredicate(Predicate<B> p, Function<A, ? extends B> f) {
-      this.p = checkNotNull(p);
-      this.f = checkNotNull(f);
+      this.p = requireNonNull(p);
+      this.f = requireNonNull(f);
     }
 
     @Override
@@ -670,7 +670,7 @@ public final class Predicates {
     final CommonPattern pattern;
 
     ContainsPatternPredicate(CommonPattern pattern) {
-      this.pattern = checkNotNull(pattern);
+      this.pattern = requireNonNull(pattern);
     }
 
     @Override
@@ -743,7 +743,7 @@ public final class Predicates {
   static <T> List<T> defensiveCopy(Iterable<T> iterable) {
     ArrayList<T> list = new ArrayList<>();
     for (T element : iterable) {
-      list.add(checkNotNull(element));
+      list.add(requireNonNull(element));
     }
     return list;
   }
diff --git a/guava/src/com/google/common/base/Present.java b/guava/src/com/google/common/base/Present.java
index 4e62da29e9..c5a994bf0c 100644
--- a/guava/src/com/google/common/base/Present.java
+++ b/guava/src/com/google/common/base/Present.java
@@ -14,10 +14,10 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.singleton;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
-import java.util.Collections;
 import java.util.Set;
 import javax.annotation.CheckForNull;
 
@@ -43,19 +43,19 @@ final class Present<T> extends Optional<T> {
 
   @Override
   public T or(T defaultValue) {
-    checkNotNull(defaultValue, "use Optional.orNull() instead of Optional.or(null)");
+    requireNonNull(defaultValue, "use Optional.orNull() instead of Optional.or(null)");
     return reference;
   }
 
   @Override
   public Optional<T> or(Optional<? extends T> secondChoice) {
-    checkNotNull(secondChoice);
+    requireNonNull(secondChoice);
     return this;
   }
 
   @Override
   public T or(Supplier<? extends T> supplier) {
-    checkNotNull(supplier);
+    requireNonNull(supplier);
     return reference;
   }
 
@@ -66,13 +66,13 @@ final class Present<T> extends Optional<T> {
 
   @Override
   public Set<T> asSet() {
-    return Collections.singleton(reference);
+    return singleton(reference);
   }
 
   @Override
   public <V> Optional<V> transform(Function<? super T, V> function) {
     return new Present<>(
-        checkNotNull(
+        requireNonNull(
             function.apply(reference),
             "the Function passed to Optional.transform() must not return null."));
   }
diff --git a/guava/src/com/google/common/base/Splitter.java b/guava/src/com/google/common/base/Splitter.java
index e60e9887df..6295b0e3c8 100644
--- a/guava/src/com/google/common/base/Splitter.java
+++ b/guava/src/com/google/common/base/Splitter.java
@@ -15,13 +15,14 @@
 package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -140,7 +141,7 @@ public final class Splitter {
    * @return a splitter, with default settings, that uses this matcher
    */
   public static Splitter on(final CharMatcher separatorMatcher) {
-    checkNotNull(separatorMatcher);
+    requireNonNull(separatorMatcher);
 
     return new Splitter(
         new Strategy() {
@@ -170,7 +171,7 @@ public final class Splitter {
    * @return a splitter, with default settings, that recognizes that separator
    */
   public static Splitter on(final String separator) {
-    checkArgument(separator.length() != 0, "The separator may not be the empty string.");
+    checkArgument(!separator.isEmpty(), "The separator may not be the empty string.");
     if (separator.length() == 1) {
       return Splitter.on(separator.charAt(0));
     }
@@ -369,7 +370,7 @@ public final class Splitter {
    */
   // TODO(kevinb): throw if a trimmer was already specified!
   public Splitter trimResults(CharMatcher trimmer) {
-    checkNotNull(trimmer);
+    requireNonNull(trimmer);
     return new Splitter(strategy, omitEmptyStrings, trimmer, limit);
   }
 
@@ -382,7 +383,7 @@ public final class Splitter {
    * @return an iteration over the segments split from the parameter
    */
   public Iterable<String> split(final CharSequence sequence) {
-    checkNotNull(sequence);
+    requireNonNull(sequence);
 
     return new Iterable<String>() {
       @Override
@@ -413,7 +414,7 @@ public final class Splitter {
    * @since 15.0
    */
   public List<String> splitToList(CharSequence sequence) {
-    checkNotNull(sequence);
+    requireNonNull(sequence);
 
     Iterator<String> iterator = splittingIterator(sequence);
     List<String> result = new ArrayList<>();
@@ -422,7 +423,7 @@ public final class Splitter {
       result.add(iterator.next());
     }
 
-    return Collections.unmodifiableList(result);
+    return unmodifiableList(result);
   }
 
   /**
@@ -502,7 +503,7 @@ public final class Splitter {
 
     private MapSplitter(Splitter outerSplitter, Splitter entrySplitter) {
       this.outerSplitter = outerSplitter; // only "this" is passed
-      this.entrySplitter = checkNotNull(entrySplitter);
+      this.entrySplitter = requireNonNull(entrySplitter);
     }
 
     /**
@@ -531,7 +532,7 @@ public final class Splitter {
 
         checkArgument(!entryFields.hasNext(), INVALID_ENTRY_MESSAGE, entry);
       }
-      return Collections.unmodifiableMap(map);
+      return unmodifiableMap(map);
     }
   }
 
diff --git a/guava/src/com/google/common/base/Stopwatch.java b/guava/src/com/google/common/base/Stopwatch.java
index 37f7bd2634..7b30c6a8a5 100644
--- a/guava/src/com/google/common/base/Stopwatch.java
+++ b/guava/src/com/google/common/base/Stopwatch.java
@@ -14,8 +14,8 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.TimeUnit.DAYS;
 import static java.util.concurrent.TimeUnit.HOURS;
 import static java.util.concurrent.TimeUnit.MICROSECONDS;
@@ -137,7 +137,7 @@ public final class Stopwatch {
   }
 
   Stopwatch(Ticker ticker) {
-    this.ticker = checkNotNull(ticker, "ticker");
+    this.ticker = requireNonNull(ticker, "ticker");
   }
 
   /**
diff --git a/guava/src/com/google/common/base/Strings.java b/guava/src/com/google/common/base/Strings.java
index 459acbca1a..8d8b833ec8 100644
--- a/guava/src/com/google/common/base/Strings.java
+++ b/guava/src/com/google/common/base/Strings.java
@@ -15,7 +15,7 @@
 package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static java.util.logging.Level.WARNING;
 
 import com.google.common.annotations.GwtCompatible;
@@ -92,7 +92,7 @@ public final class Strings {
    * @return the padded string
    */
   public static String padStart(String string, int minLength, char padChar) {
-    checkNotNull(string); // eager for GWT.
+    requireNonNull(string); // eager for GWT.
     if (string.length() >= minLength) {
       return string;
     }
@@ -123,7 +123,7 @@ public final class Strings {
    * @return the padded string
    */
   public static String padEnd(String string, int minLength, char padChar) {
-    checkNotNull(string); // eager for GWT.
+    requireNonNull(string); // eager for GWT.
     if (string.length() >= minLength) {
       return string;
     }
@@ -150,7 +150,7 @@ public final class Strings {
   @InlineMe(replacement = "string.repeat(count)")
   @InlineMeValidationDisabled("Java 11+ API only")
   public static String repeat(String string, int count) {
-    checkNotNull(string); // eager for GWT.
+    requireNonNull(string); // eager for GWT.
 
     if (count <= 1) {
       checkArgument(count >= 0, "invalid count: %s", count);
@@ -183,8 +183,8 @@ public final class Strings {
    * @since 11.0
    */
   public static String commonPrefix(CharSequence a, CharSequence b) {
-    checkNotNull(a);
-    checkNotNull(b);
+    requireNonNull(a);
+    requireNonNull(b);
 
     int maxPrefixLength = Math.min(a.length(), b.length());
     int p = 0;
@@ -205,8 +205,8 @@ public final class Strings {
    * @since 11.0
    */
   public static String commonSuffix(CharSequence a, CharSequence b) {
-    checkNotNull(a);
-    checkNotNull(b);
+    requireNonNull(a);
+    requireNonNull(b);
 
     int maxSuffixLength = Math.min(a.length(), b.length());
     int s = 0;
diff --git a/guava/src/com/google/common/base/Suppliers.java b/guava/src/com/google/common/base/Suppliers.java
index 6ced905b98..b8cb646456 100644
--- a/guava/src/com/google/common/base/Suppliers.java
+++ b/guava/src/com/google/common/base/Suppliers.java
@@ -16,7 +16,6 @@ package com.google.common.base;
 
 import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -57,8 +56,8 @@ public final class Suppliers {
     final Supplier<F> supplier;
 
     SupplierComposition(Function<? super F, T> function, Supplier<F> supplier) {
-      this.function = checkNotNull(function);
-      this.supplier = checkNotNull(supplier);
+      this.function = requireNonNull(function);
+      this.supplier = requireNonNull(supplier);
     }
 
     @Override
@@ -124,7 +123,7 @@ public final class Suppliers {
     @CheckForNull transient T value;
 
     MemoizingSupplier(Supplier<T> delegate) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
@@ -164,7 +163,7 @@ public final class Suppliers {
     @CheckForNull T value;
 
     NonSerializableMemoizingSupplier(Supplier<T> delegate) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
@@ -240,7 +239,7 @@ public final class Suppliers {
     transient volatile long expirationNanos;
 
     ExpiringMemoizingSupplier(Supplier<T> delegate, long duration, TimeUnit unit) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
       this.durationNanos = unit.toNanos(duration);
       checkArgument(duration > 0, "duration (%s %s) must be > 0", duration, unit);
     }
@@ -339,7 +338,7 @@ public final class Suppliers {
     final Supplier<T> delegate;
 
     ThreadSafeSupplier(Supplier<T> delegate) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
@@ -378,8 +377,8 @@ public final class Suppliers {
     INSTANCE;
 
     // Note: This makes T a "pass-through type"
-    @Override
     @CheckForNull
+    @Override
     public Object apply(Supplier<@Nullable Object> input) {
       return input.get();
     }
diff --git a/guava/src/com/google/common/base/Throwables.java b/guava/src/com/google/common/base/Throwables.java
index e45ce800cb..22b27355aa 100644
--- a/guava/src/com/google/common/base/Throwables.java
+++ b/guava/src/com/google/common/base/Throwables.java
@@ -14,7 +14,6 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Arrays.asList;
 import static java.util.Collections.unmodifiableList;
 import static java.util.Objects.requireNonNull;
@@ -30,7 +29,6 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.AbstractList;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import javax.annotation.CheckForNull;
 
@@ -72,7 +70,7 @@ public final class Throwables {
   @GwtIncompatible // Class.cast, Class.isInstance
   public static <X extends Throwable> void throwIfInstanceOf(
       Throwable throwable, Class<X> declaredType) throws X {
-    checkNotNull(throwable);
+    requireNonNull(throwable);
     if (declaredType.isInstance(throwable)) {
       throw declaredType.cast(throwable);
     }
@@ -126,7 +124,7 @@ public final class Throwables {
    * @since 20.0
    */
   public static void throwIfUnchecked(Throwable throwable) {
-    checkNotNull(throwable);
+    requireNonNull(throwable);
     if (throwable instanceof RuntimeException) {
       throw (RuntimeException) throwable;
     }
@@ -201,7 +199,7 @@ public final class Throwables {
   public static <X1 extends Throwable, X2 extends Throwable> void propagateIfPossible(
       @CheckForNull Throwable throwable, Class<X1> declaredType1, Class<X2> declaredType2)
       throws X1, X2 {
-    checkNotNull(declaredType2);
+    requireNonNull(declaredType2);
     propagateIfInstanceOf(throwable, declaredType1);
     propagateIfPossible(throwable, declaredType2);
   }
@@ -235,8 +233,8 @@ public final class Throwables {
    *     {@code Throwables.propagate}</a>.
    */
   @CanIgnoreReturnValue
-  @GwtIncompatible
   @Deprecated
+  @GwtIncompatible
   public static RuntimeException propagate(Throwable throwable) {
     throwIfUnchecked(throwable);
     throw new RuntimeException(throwable);
@@ -290,7 +288,7 @@ public final class Throwables {
    * @throws IllegalArgumentException if there is a loop in the causal chain
    */
   public static List<Throwable> getCausalChain(Throwable throwable) {
-    checkNotNull(throwable);
+    requireNonNull(throwable);
     List<Throwable> causes = new ArrayList<>(4);
     causes.add(throwable);
 
@@ -312,7 +310,7 @@ public final class Throwables {
       }
       advanceSlowPointer = !advanceSlowPointer; // only advance every other iteration
     }
-    return Collections.unmodifiableList(causes);
+    return unmodifiableList(causes);
   }
 
   /**
@@ -328,8 +326,8 @@ public final class Throwables {
    *     ClassCastException}'s cause is {@code throwable}.
    * @since 22.0
    */
-  @GwtIncompatible // Class.cast(Object)
-  @CheckForNull
+  @CheckForNull // Class.cast(Object)
+  @GwtIncompatible
   public static <X extends Throwable> X getCauseAs(
       Throwable throwable, Class<X> expectedCauseType) {
     try {
@@ -407,7 +405,7 @@ public final class Throwables {
 
   @GwtIncompatible // invokeAccessibleNonThrowingMethod
   private static List<StackTraceElement> jlaStackTrace(Throwable t) {
-    checkNotNull(t);
+    requireNonNull(t);
     /*
      * TODO(cpovirk): Consider optimizing iterator() to catch IOOBE instead of doing bounds checks.
      *
@@ -481,8 +479,8 @@ public final class Throwables {
    * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not allowed in
    * AppEngine, and not present in non-Sun JDKs.
    */
-  @GwtIncompatible // java.lang.reflect
-  @CheckForNull
+  @CheckForNull // java.lang.reflect
+  @GwtIncompatible
   private static Object getJLA() {
     try {
       /*
@@ -507,8 +505,8 @@ public final class Throwables {
    * Returns the Method that can be used to resolve an individual StackTraceElement, or null if that
    * method cannot be found (it is only to be found in fairly recent JDKs).
    */
-  @GwtIncompatible // java.lang.reflect
-  @CheckForNull
+  @CheckForNull // java.lang.reflect
+  @GwtIncompatible
   private static Method getGetMethod() {
     return getJlaMethod("getStackTraceElement", Throwable.class, int.class);
   }
@@ -522,8 +520,8 @@ public final class Throwables {
    * <p>See <a href="https://github.com/google/guava/issues/2887">Throwables#lazyStackTrace throws
    * UnsupportedOperationException</a>.
    */
-  @GwtIncompatible // java.lang.reflect
-  @CheckForNull
+  @CheckForNull // java.lang.reflect
+  @GwtIncompatible
   private static Method getSizeMethod(Object jla) {
     try {
       Method getStackTraceDepth = getJlaMethod("getStackTraceDepth", Throwable.class);
@@ -537,8 +535,8 @@ public final class Throwables {
     }
   }
 
-  @GwtIncompatible // java.lang.reflect
-  @CheckForNull
+  @CheckForNull // java.lang.reflect
+  @GwtIncompatible
   private static Method getJlaMethod(String name, Class<?>... parameterTypes) throws ThreadDeath {
     try {
       return Class.forName(JAVA_LANG_ACCESS_CLASSNAME, false, null).getMethod(name, parameterTypes);
diff --git a/guava/src/com/google/common/base/Utf8.java b/guava/src/com/google/common/base/Utf8.java
index bb945a35f0..8ababa4732 100644
--- a/guava/src/com/google/common/base/Utf8.java
+++ b/guava/src/com/google/common/base/Utf8.java
@@ -14,6 +14,7 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static java.lang.Character.MAX_SURROGATE;
 import static java.lang.Character.MIN_SURROGATE;
@@ -90,9 +91,7 @@ public final class Utf8 {
         // jdk7+: if (Character.isSurrogate(c)) {
         if (MIN_SURROGATE <= c && c <= MAX_SURROGATE) {
           // Check that we have a well-formed surrogate pair.
-          if (Character.codePointAt(sequence, i) == c) {
-            throw new IllegalArgumentException(unpairedSurrogateMsg(i));
-          }
+          checkArgument(Character.codePointAt(sequence, i) != c, unpairedSurrogateMsg(i));
           i++;
         }
       }
diff --git a/guava/src/com/google/common/base/internal/Finalizer.java b/guava/src/com/google/common/base/internal/Finalizer.java
index b45ec15787..765a43441b 100644
--- a/guava/src/com/google/common/base/internal/Finalizer.java
+++ b/guava/src/com/google/common/base/internal/Finalizer.java
@@ -14,6 +14,8 @@
 
 package com.google.common.base.internal;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import java.lang.ref.PhantomReference;
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
@@ -72,9 +74,9 @@ public class Finalizer implements Runnable {
      * 2) To detect when FinalizableReference's class loader has to be garbage collected, at which
      * point, Finalizer can stop running
      */
-    if (!finalizableReferenceClass.getName().equals(FINALIZABLE_REFERENCE)) {
-      throw new IllegalArgumentException("Expected " + FINALIZABLE_REFERENCE + ".");
-    }
+    checkArgument(
+        finalizableReferenceClass.getName().equals(FINALIZABLE_REFERENCE),
+        "Expected " + FINALIZABLE_REFERENCE + ".");
 
     Finalizer finalizer = new Finalizer(finalizableReferenceClass, queue, frqReference);
     String threadName = Finalizer.class.getName();
@@ -138,8 +140,8 @@ public class Finalizer implements Runnable {
   }
 
   /** Loops continuously, pulling references off the queue and cleaning them up. */
-  @SuppressWarnings("InfiniteLoopStatement")
   @Override
+  @SuppressWarnings("InfiniteLoopStatement")
   public void run() {
     while (true) {
       try {
diff --git a/guava/src/com/google/common/cache/AbstractCache.java b/guava/src/com/google/common/cache/AbstractCache.java
index 42829c0b23..bd389562fc 100644
--- a/guava/src/com/google/common/cache/AbstractCache.java
+++ b/guava/src/com/google/common/cache/AbstractCache.java
@@ -234,15 +234,15 @@ public abstract class AbstractCache<K, V> implements Cache<K, V> {
       missCount.add(count);
     }
 
-    @SuppressWarnings("GoodTime") // b/122668874
-    @Override
+    @Override // b/122668874
+    @SuppressWarnings("GoodTime")
     public void recordLoadSuccess(long loadTime) {
       loadSuccessCount.increment();
       totalLoadTime.add(loadTime);
     }
 
-    @SuppressWarnings("GoodTime") // b/122668874
-    @Override
+    @Override // b/122668874
+    @SuppressWarnings("GoodTime")
     public void recordLoadException(long loadTime) {
       loadExceptionCount.increment();
       totalLoadTime.add(loadTime);
diff --git a/guava/src/com/google/common/cache/CacheBuilder.java b/guava/src/com/google/common/cache/CacheBuilder.java
index 0ccb9c8c45..acab309336 100644
--- a/guava/src/com/google/common/cache/CacheBuilder.java
+++ b/guava/src/com/google/common/cache/CacheBuilder.java
@@ -15,8 +15,8 @@
 package com.google.common.cache;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -212,12 +212,12 @@ public final class CacheBuilder<K, V> {
             @Override
             public void recordMisses(int count) {}
 
-            @SuppressWarnings("GoodTime") // b/122668874
-            @Override
+            @Override // b/122668874
+            @SuppressWarnings("GoodTime")
             public void recordLoadSuccess(long loadTime) {}
 
-            @SuppressWarnings("GoodTime") // b/122668874
-            @Override
+            @Override // b/122668874
+            @SuppressWarnings("GoodTime")
             public void recordLoadException(long loadTime) {}
 
             @Override
@@ -313,8 +313,8 @@ public final class CacheBuilder<K, V> {
    *
    * @since 12.0
    */
-  @GwtIncompatible // To be supported
-  @CheckReturnValue
+  @CheckReturnValue // To be supported
+  @GwtIncompatible
   public static CacheBuilder<Object, Object> from(CacheBuilderSpec spec) {
     return spec.toCacheBuilder().lenientParsing();
   }
@@ -326,8 +326,8 @@ public final class CacheBuilder<K, V> {
    * @param spec a String in the format specified by {@link CacheBuilderSpec}
    * @since 12.0
    */
-  @GwtIncompatible // To be supported
-  @CheckReturnValue
+  @CheckReturnValue // To be supported
+  @GwtIncompatible
   public static CacheBuilder<Object, Object> from(String spec) {
     return from(CacheBuilderSpec.parse(spec));
   }
@@ -354,7 +354,7 @@ public final class CacheBuilder<K, V> {
   @GwtIncompatible // To be supported
   CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence) {
     checkState(keyEquivalence == null, "key equivalence was already set to %s", keyEquivalence);
-    keyEquivalence = checkNotNull(equivalence);
+    keyEquivalence = requireNonNull(equivalence);
     return this;
   }
 
@@ -375,7 +375,7 @@ public final class CacheBuilder<K, V> {
   CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence) {
     checkState(
         valueEquivalence == null, "value equivalence was already set to %s", valueEquivalence);
-    this.valueEquivalence = checkNotNull(equivalence);
+    this.valueEquivalence = requireNonNull(equivalence);
     return this;
   }
 
@@ -570,7 +570,7 @@ public final class CacheBuilder<K, V> {
     // safely limiting the kinds of caches this can produce
     @SuppressWarnings("unchecked")
     CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;
-    me.weigher = checkNotNull(weigher);
+    me.weigher = requireNonNull(weigher);
     return me;
   }
 
@@ -610,7 +610,7 @@ public final class CacheBuilder<K, V> {
 
   CacheBuilder<K, V> setKeyStrength(Strength strength) {
     checkState(keyStrength == null, "Key strength was already set to %s", keyStrength);
-    keyStrength = checkNotNull(strength);
+    keyStrength = requireNonNull(strength);
     return this;
   }
 
@@ -667,7 +667,7 @@ public final class CacheBuilder<K, V> {
 
   CacheBuilder<K, V> setValueStrength(Strength strength) {
     checkState(valueStrength == null, "Value strength was already set to %s", valueStrength);
-    valueStrength = checkNotNull(strength);
+    valueStrength = requireNonNull(strength);
     return this;
   }
 
@@ -695,8 +695,8 @@ public final class CacheBuilder<K, V> {
    * @throws ArithmeticException for durations greater than +/- approximately 292 years
    * @since 25.0
    */
-  @J2ObjCIncompatible
-  @GwtIncompatible // java.time.Duration
+  @GwtIncompatible
+  @J2ObjCIncompatible // java.time.Duration
   @SuppressWarnings("GoodTime") // java.time.Duration decomposition
   public CacheBuilder<K, V> expireAfterWrite(java.time.Duration duration) {
     return expireAfterWrite(toNanosSaturated(duration), TimeUnit.NANOSECONDS);
@@ -765,8 +765,8 @@ public final class CacheBuilder<K, V> {
    * @throws ArithmeticException for durations greater than +/- approximately 292 years
    * @since 25.0
    */
-  @J2ObjCIncompatible
-  @GwtIncompatible // java.time.Duration
+  @GwtIncompatible
+  @J2ObjCIncompatible // java.time.Duration
   @SuppressWarnings("GoodTime") // java.time.Duration decomposition
   public CacheBuilder<K, V> expireAfterAccess(java.time.Duration duration) {
     return expireAfterAccess(toNanosSaturated(duration), TimeUnit.NANOSECONDS);
@@ -843,8 +843,8 @@ public final class CacheBuilder<K, V> {
    * @throws ArithmeticException for durations greater than +/- approximately 292 years
    * @since 25.0
    */
-  @J2ObjCIncompatible
-  @GwtIncompatible // java.time.Duration
+  @GwtIncompatible
+  @J2ObjCIncompatible // java.time.Duration
   @SuppressWarnings("GoodTime") // java.time.Duration decomposition
   public CacheBuilder<K, V> refreshAfterWrite(java.time.Duration duration) {
     return refreshAfterWrite(toNanosSaturated(duration), TimeUnit.NANOSECONDS);
@@ -882,7 +882,7 @@ public final class CacheBuilder<K, V> {
   @GwtIncompatible // To be supported (synchronously).
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit) {
-    checkNotNull(unit);
+    requireNonNull(unit);
     checkState(refreshNanos == UNSET_INT, "refresh was already set to %s ns", refreshNanos);
     checkArgument(duration > 0, "duration must be positive: %s %s", duration, unit);
     this.refreshNanos = unit.toNanos(duration);
@@ -906,7 +906,7 @@ public final class CacheBuilder<K, V> {
    */
   public CacheBuilder<K, V> ticker(Ticker ticker) {
     checkState(this.ticker == null);
-    this.ticker = checkNotNull(ticker);
+    this.ticker = requireNonNull(ticker);
     return this;
   }
 
@@ -946,7 +946,7 @@ public final class CacheBuilder<K, V> {
     // safely limiting the kinds of caches this can produce
     @SuppressWarnings("unchecked")
     CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;
-    me.removalListener = checkNotNull(listener);
+    me.removalListener = requireNonNull(listener);
     return me;
   }
 
diff --git a/guava/src/com/google/common/cache/CacheBuilderSpec.java b/guava/src/com/google/common/cache/CacheBuilderSpec.java
index 7757f3bc49..ae30d62eca 100644
--- a/guava/src/com/google/common/cache/CacheBuilderSpec.java
+++ b/guava/src/com/google/common/cache/CacheBuilderSpec.java
@@ -292,9 +292,7 @@ public final class CacheBuilderSpec {
 
     @Override
     public void parse(CacheBuilderSpec spec, String key, @Nullable String value) {
-      if (isNullOrEmpty(value)) {
-        throw new IllegalArgumentException("value of key " + key + " omitted");
-      }
+      checkArgument(!isNullOrEmpty(value), "value of key %s omitted", key);
       try {
         parseInteger(spec, Integer.parseInt(value));
       } catch (NumberFormatException e) {
@@ -310,9 +308,7 @@ public final class CacheBuilderSpec {
 
     @Override
     public void parse(CacheBuilderSpec spec, String key, @Nullable String value) {
-      if (isNullOrEmpty(value)) {
-        throw new IllegalArgumentException("value of key " + key + " omitted");
-      }
+      checkArgument(!isNullOrEmpty(value), "value of key %s omitted", key);
       try {
         parseLong(spec, Long.parseLong(value));
       } catch (NumberFormatException e) {
@@ -419,9 +415,7 @@ public final class CacheBuilderSpec {
 
     @Override
     public void parse(CacheBuilderSpec spec, String key, @CheckForNull String value) {
-      if (isNullOrEmpty(value)) {
-        throw new IllegalArgumentException("value of key " + key + " omitted");
-      }
+      checkArgument(!isNullOrEmpty(value), "value of key %s omitted", key);
       try {
         char lastChar = value.charAt(value.length() - 1);
         TimeUnit timeUnit;
diff --git a/guava/src/com/google/common/cache/CacheLoader.java b/guava/src/com/google/common/cache/CacheLoader.java
index 7a5e017d03..afd8d3146f 100644
--- a/guava/src/com/google/common/cache/CacheLoader.java
+++ b/guava/src/com/google/common/cache/CacheLoader.java
@@ -14,7 +14,7 @@
 
 package com.google.common.cache;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -97,8 +97,8 @@ public abstract class CacheLoader<K, V> {
    */
   @GwtIncompatible // Futures
   public ListenableFuture<V> reload(K key, V oldValue) throws Exception {
-    checkNotNull(key);
-    checkNotNull(oldValue);
+    requireNonNull(key);
+    requireNonNull(oldValue);
     return Futures.immediateFuture(load(key));
   }
 
@@ -161,12 +161,12 @@ public abstract class CacheLoader<K, V> {
     private final Function<K, V> computingFunction;
 
     public FunctionToCacheLoader(Function<K, V> computingFunction) {
-      this.computingFunction = checkNotNull(computingFunction);
+      this.computingFunction = requireNonNull(computingFunction);
     }
 
     @Override
     public V load(K key) {
-      return computingFunction.apply(checkNotNull(key));
+      return computingFunction.apply(requireNonNull(key));
     }
 
     private static final long serialVersionUID = 0;
@@ -185,8 +185,8 @@ public abstract class CacheLoader<K, V> {
   @GwtIncompatible // Executor + Futures
   public static <K, V> CacheLoader<K, V> asyncReloading(
       final CacheLoader<K, V> loader, final Executor executor) {
-    checkNotNull(loader);
-    checkNotNull(executor);
+    requireNonNull(loader);
+    requireNonNull(executor);
     return new CacheLoader<K, V>() {
       @Override
       public V load(K key) throws Exception {
@@ -219,12 +219,12 @@ public abstract class CacheLoader<K, V> {
     private final Supplier<V> computingSupplier;
 
     public SupplierToCacheLoader(Supplier<V> computingSupplier) {
-      this.computingSupplier = checkNotNull(computingSupplier);
+      this.computingSupplier = requireNonNull(computingSupplier);
     }
 
     @Override
     public V load(Object key) {
-      checkNotNull(key);
+      requireNonNull(key);
       return computingSupplier.get();
     }
 
diff --git a/guava/src/com/google/common/cache/ForwardingCache.java b/guava/src/com/google/common/cache/ForwardingCache.java
index 2d3a2b5fd2..dba0165f7e 100644
--- a/guava/src/com/google/common/cache/ForwardingCache.java
+++ b/guava/src/com/google/common/cache/ForwardingCache.java
@@ -14,8 +14,9 @@
 
 package com.google.common.cache;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ForwardingObject;
 import com.google.common.collect.ImmutableMap;
 import java.util.Map;
@@ -45,8 +46,8 @@ public abstract class ForwardingCache<K, V> extends ForwardingObject implements
   /**
    * @since 11.0
    */
-  @Override
   @CheckForNull
+  @Override
   public V getIfPresent(Object key) {
     return delegate().getIfPresent(key);
   }
@@ -136,7 +137,7 @@ public abstract class ForwardingCache<K, V> extends ForwardingObject implements
     private final Cache<K, V> delegate;
 
     protected SimpleForwardingCache(Cache<K, V> delegate) {
-      this.delegate = Preconditions.checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
diff --git a/guava/src/com/google/common/cache/ForwardingLoadingCache.java b/guava/src/com/google/common/cache/ForwardingLoadingCache.java
index ecd44ca8d8..7123cc69f8 100644
--- a/guava/src/com/google/common/cache/ForwardingLoadingCache.java
+++ b/guava/src/com/google/common/cache/ForwardingLoadingCache.java
@@ -14,8 +14,9 @@
 
 package com.google.common.cache;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
 import java.util.concurrent.ExecutionException;
 
@@ -77,7 +78,7 @@ public abstract class ForwardingLoadingCache<K, V> extends ForwardingCache<K, V>
     private final LoadingCache<K, V> delegate;
 
     protected SimpleForwardingLoadingCache(LoadingCache<K, V> delegate) {
-      this.delegate = Preconditions.checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
diff --git a/guava/src/com/google/common/cache/LocalCache.java b/guava/src/com/google/common/cache/LocalCache.java
index 584298e4da..934f666e99 100644
--- a/guava/src/com/google/common/cache/LocalCache.java
+++ b/guava/src/com/google/common/cache/LocalCache.java
@@ -14,7 +14,6 @@
 
 package com.google.common.cache;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.cache.CacheBuilder.NULL_TICKER;
 import static com.google.common.cache.CacheBuilder.UNSET_INT;
@@ -22,6 +21,7 @@ import static com.google.common.util.concurrent.Futures.transform;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 import static java.util.Collections.unmodifiableSet;
+import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 import com.google.common.annotations.GwtCompatible;
@@ -1692,7 +1692,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   @VisibleForTesting
   ValueReference<K, V> newValueReference(ReferenceEntry<K, V> entry, V value, int weight) {
     int hash = entry.getHash();
-    return valueStrength.referenceValue(segmentFor(hash), entry, checkNotNull(value), weight);
+    return valueStrength.referenceValue(segmentFor(hash), entry, requireNonNull(value), weight);
   }
 
   int hash(@Nullable Object key) {
@@ -1761,7 +1761,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
   /** Returns true if the entry has expired. */
   boolean isExpired(ReferenceEntry<K, V> entry, long now) {
-    checkNotNull(entry);
+    requireNonNull(entry);
     if (expiresAfterAccess() && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {
       return true;
     }
@@ -1940,7 +1940,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
         StatsCounter statsCounter) {
       this.map = map;
       this.maxSegmentWeight = maxSegmentWeight;
-      this.statsCounter = checkNotNull(statsCounter);
+      this.statsCounter = requireNonNull(statsCounter);
       initTable(newEntryArray(initialCapacity));
 
       keyReferenceQueue = map.usesKeyReferences() ? new ReferenceQueue<K>() : null;
@@ -1978,7 +1978,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     @GuardedBy("this")
     ReferenceEntry<K, V> newEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
-      return map.entryFactory.newEntry(this, checkNotNull(key), hash, next);
+      return map.entryFactory.newEntry(this, requireNonNull(key), hash, next);
     }
 
     /**
@@ -2021,8 +2021,8 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
     // loading
 
     V get(K key, int hash, CacheLoader<? super K, V> loader) throws ExecutionException {
-      checkNotNull(key);
-      checkNotNull(loader);
+      requireNonNull(key);
+      requireNonNull(loader);
       try {
         if (count != 0) { // read-volatile
           // don't call getLiveEntry, which would ignore loading values
@@ -3374,8 +3374,8 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
       }
     }
 
-    @VisibleForTesting
     @GuardedBy("this")
+    @VisibleForTesting
     boolean removeEntry(ReferenceEntry<K, V> entry, int hash, RemovalCause cause) {
       int newCount = this.count - 1;
       AtomicReferenceArray<ReferenceEntry<K, V>> table = this.table;
@@ -3949,12 +3949,12 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   V get(K key, CacheLoader<? super K, V> loader) throws ExecutionException {
-    int hash = hash(checkNotNull(key));
+    int hash = hash(requireNonNull(key));
     return segmentFor(hash).get(key, hash, loader);
   }
 
   public @Nullable V getIfPresent(Object key) {
-    int hash = hash(checkNotNull(key));
+    int hash = hash(requireNonNull(key));
     V value = segmentFor(hash).get(key, hash);
     if (value == null) {
       globalStatsCounter.recordMisses(1);
@@ -4049,8 +4049,8 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
    */
   @Nullable Map<K, V> loadAll(Set<? extends K> keys, CacheLoader<? super K, V> loader)
       throws ExecutionException {
-    checkNotNull(loader);
-    checkNotNull(keys);
+    requireNonNull(loader);
+    requireNonNull(keys);
     Stopwatch stopwatch = Stopwatch.createStarted();
     Map<K, V> result;
     boolean success = false;
@@ -4120,7 +4120,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   void refresh(K key) {
-    int hash = hash(checkNotNull(key));
+    int hash = hash(requireNonNull(key));
     segmentFor(hash).refresh(key, hash, defaultLoader, false);
   }
 
@@ -4176,47 +4176,47 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
   @Override
   public V put(K key, V value) {
-    checkNotNull(key);
-    checkNotNull(value);
+    requireNonNull(key);
+    requireNonNull(value);
     int hash = hash(key);
     return segmentFor(hash).put(key, hash, value, false);
   }
 
   @Override
   public V putIfAbsent(K key, V value) {
-    checkNotNull(key);
-    checkNotNull(value);
+    requireNonNull(key);
+    requireNonNull(value);
     int hash = hash(key);
     return segmentFor(hash).put(key, hash, value, true);
   }
 
   @Override
   public V compute(K key, BiFunction<? super K, ? super @Nullable V, ? extends V> function) {
-    checkNotNull(key);
-    checkNotNull(function);
+    requireNonNull(key);
+    requireNonNull(function);
     int hash = hash(key);
     return segmentFor(hash).compute(key, hash, function);
   }
 
   @Override
   public V computeIfAbsent(K key, Function<? super K, ? extends V> function) {
-    checkNotNull(key);
-    checkNotNull(function);
+    requireNonNull(key);
+    requireNonNull(function);
     return compute(key, (k, oldValue) -> (oldValue == null) ? function.apply(key) : oldValue);
   }
 
   @Override
   public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> function) {
-    checkNotNull(key);
-    checkNotNull(function);
+    requireNonNull(key);
+    requireNonNull(function);
     return compute(key, (k, oldValue) -> (oldValue == null) ? null : function.apply(k, oldValue));
   }
 
   @Override
   public V merge(K key, V newValue, BiFunction<? super V, ? super V, ? extends V> function) {
-    checkNotNull(key);
-    checkNotNull(newValue);
-    checkNotNull(function);
+    requireNonNull(key);
+    requireNonNull(newValue);
+    requireNonNull(function);
     return compute(
         key, (k, oldValue) -> (oldValue == null) ? newValue : function.apply(oldValue, newValue));
   }
@@ -4248,8 +4248,8 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
   @Override
   public boolean replace(K key, @Nullable V oldValue, V newValue) {
-    checkNotNull(key);
-    checkNotNull(newValue);
+    requireNonNull(key);
+    requireNonNull(newValue);
     if (oldValue == null) {
       return false;
     }
@@ -4259,8 +4259,8 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
   @Override
   public V replace(K key, V value) {
-    checkNotNull(key);
-    checkNotNull(value);
+    requireNonNull(key);
+    requireNonNull(value);
     int hash = hash(key);
     return segmentFor(hash).replace(key, hash, value);
   }
@@ -4299,8 +4299,8 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
   @RetainedWith @Nullable Set<Entry<K, V>> entrySet;
 
-  @Override
-  @GwtIncompatible // Not supported.
+  @GwtIncompatible
+  @Override // Not supported.
   public Set<Entry<K, V>> entrySet() {
     // does not impact recency ordering
     Set<Entry<K, V>> es = entrySet;
@@ -4532,7 +4532,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
   }
 
   boolean removeIf(BiPredicate<? super K, ? super V> filter) {
-    checkNotNull(filter);
+    requireNonNull(filter);
     boolean changed = false;
     for (K key : keySet()) {
       while (true) {
@@ -4589,7 +4589,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     @Override
     public boolean removeIf(Predicate<? super V> filter) {
-      checkNotNull(filter);
+      requireNonNull(filter);
       return LocalCache.this.removeIf((k, v) -> filter.test(v));
     }
 
@@ -4621,7 +4621,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     @Override
     public boolean removeIf(Predicate<? super Entry<K, V>> filter) {
-      checkNotNull(filter);
+      requireNonNull(filter);
       return LocalCache.this.removeIf((k, v) -> filter.test(Maps.immutableEntry(k, v)));
     }
 
@@ -4845,7 +4845,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     @Override
     public V get(K key, final Callable<? extends V> valueLoader) throws ExecutionException {
-      checkNotNull(valueLoader);
+      requireNonNull(valueLoader);
       return localCache.get(
           key,
           new CacheLoader<Object, V>() {
@@ -4873,7 +4873,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     @Override
     public void invalidate(Object key) {
-      checkNotNull(key);
+      requireNonNull(key);
       localCache.remove(key);
     }
 
@@ -4926,7 +4926,7 @@ class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V>
 
     LocalLoadingCache(
         CacheBuilder<? super K, ? super V> builder, CacheLoader<? super K, V> loader) {
-      super(new LocalCache<K, V>(builder, checkNotNull(loader)));
+      super(new LocalCache<K, V>(builder, requireNonNull(loader)));
     }
 
     // LoadingCache methods
diff --git a/guava/src/com/google/common/cache/RemovalListeners.java b/guava/src/com/google/common/cache/RemovalListeners.java
index 38edf35287..4f2424da2c 100644
--- a/guava/src/com/google/common/cache/RemovalListeners.java
+++ b/guava/src/com/google/common/cache/RemovalListeners.java
@@ -14,7 +14,7 @@
 
 package com.google.common.cache;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import java.util.concurrent.Executor;
@@ -40,8 +40,8 @@ public final class RemovalListeners {
    */
   public static <K, V> RemovalListener<K, V> asynchronous(
       RemovalListener<K, V> listener, Executor executor) {
-    checkNotNull(listener);
-    checkNotNull(executor);
+    requireNonNull(listener);
+    requireNonNull(executor);
     return (RemovalNotification<K, V> notification) ->
         executor.execute(() -> listener.onRemoval(notification));
   }
diff --git a/guava/src/com/google/common/cache/RemovalNotification.java b/guava/src/com/google/common/cache/RemovalNotification.java
index b96fc57091..e72d848e93 100644
--- a/guava/src/com/google/common/cache/RemovalNotification.java
+++ b/guava/src/com/google/common/cache/RemovalNotification.java
@@ -14,7 +14,7 @@
 
 package com.google.common.cache;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.AbstractMap.SimpleImmutableEntry;
@@ -52,7 +52,7 @@ public final class RemovalNotification<K, V>
 
   private RemovalNotification(@CheckForNull K key, @CheckForNull V value, RemovalCause cause) {
     super(key, value);
-    this.cause = checkNotNull(cause);
+    this.cause = requireNonNull(cause);
   }
 
   /** Returns the cause for which the entry was removed. */
diff --git a/guava/src/com/google/common/collect/AbstractBiMap.java b/guava/src/com/google/common/collect/AbstractBiMap.java
index bf97e1a7c8..3517b81df7 100644
--- a/guava/src/com/google/common/collect/AbstractBiMap.java
+++ b/guava/src/com/google/common/collect/AbstractBiMap.java
@@ -117,15 +117,15 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
   // Modification Operations
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
     return putInBothMaps(key, value, false);
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V forcePut(@ParametricNullness K key, @ParametricNullness V value) {
     return putInBothMaps(key, value, true);
   }
@@ -161,8 +161,8 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V remove(@CheckForNull Object key) {
     return containsKey(key) ? removeFromBothMaps(key) : null;
   }
@@ -207,9 +207,7 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
         itr.remove();
       }
     }
-    if (broken != null) {
-      throw new IllegalArgumentException("value already present: " + broken.getValue());
-    }
+    checkArgument(broken == null, "value already present: %s", broken.getValue());
   }
 
   @Override
@@ -368,9 +366,7 @@ abstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Obj
 
       @Override
       public void remove() {
-        if (entry == null) {
-          throw new IllegalStateException("no calls to next() since the last call to remove()");
-        }
+        checkState(entry != null, "no calls to next() since the last call to remove()");
         V value = entry.getValue();
         iterator.remove();
         removeFromInverseMap(value);
diff --git a/guava/src/com/google/common/collect/AbstractListMultimap.java b/guava/src/com/google/common/collect/AbstractListMultimap.java
index 46c4ee2448..51cf8c4d11 100644
--- a/guava/src/com/google/common/collect/AbstractListMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractListMultimap.java
@@ -16,10 +16,12 @@
 
 package com.google.common.collect;
 
+import static java.util.Collections.emptyList;
+import static java.util.Collections.unmodifiableList;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.CheckForNull;
@@ -51,13 +53,13 @@ abstract class AbstractListMultimap<K extends @Nullable Object, V extends @Nulla
 
   @Override
   List<V> createUnmodifiableEmptyCollection() {
-    return Collections.emptyList();
+    return emptyList();
   }
 
   @Override
   <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
       Collection<E> collection) {
-    return Collections.unmodifiableList((List<E>) collection);
+    return unmodifiableList((List<E>) collection);
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java b/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
index 4c5a0f0418..ca30765eca 100644
--- a/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractMapBasedMultimap.java
@@ -17,9 +17,9 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
+import static java.util.Collections.unmodifiableCollection;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -28,7 +28,6 @@ import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.AbstractCollection;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.ConcurrentModificationException;
 import java.util.Iterator;
@@ -266,7 +265,7 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
 
   <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
       Collection<E> collection) {
-    return Collections.unmodifiableCollection(collection);
+    return unmodifiableCollection(collection);
   }
 
   @Override
@@ -575,7 +574,7 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
 
     @Override
     public boolean retainAll(Collection<?> c) {
-      checkNotNull(c);
+      requireNonNull(c);
       int oldSize = size(); // calls refreshIfEmpty
       boolean changed = delegate.retainAll(c);
       if (changed) {
@@ -635,8 +634,8 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return (SortedSet<V>) getDelegate();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super V> comparator() {
       return getSortedSetDelegate().comparator();
     }
@@ -697,38 +696,38 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return (NavigableSet<V>) super.getSortedSetDelegate();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V lower(@ParametricNullness V v) {
       return getSortedSetDelegate().lower(v);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V floor(@ParametricNullness V v) {
       return getSortedSetDelegate().floor(v);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V ceiling(@ParametricNullness V v) {
       return getSortedSetDelegate().ceiling(v);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V higher(@ParametricNullness V v) {
       return getSortedSetDelegate().higher(v);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V pollFirst() {
       return Iterators.pollNext(iterator());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V pollLast() {
       return Iterators.pollNext(descendingIterator());
     }
@@ -1028,8 +1027,8 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return (SortedMap<K, Collection<V>>) super.map();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return sortedMap().comparator();
     }
@@ -1073,38 +1072,38 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return (NavigableMap<K, Collection<V>>) super.sortedMap();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K lower(@ParametricNullness K k) {
       return sortedMap().lowerKey(k);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K floor(@ParametricNullness K k) {
       return sortedMap().floorKey(k);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K ceiling(@ParametricNullness K k) {
       return sortedMap().ceilingKey(k);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K higher(@ParametricNullness K k) {
       return sortedMap().higherKey(k);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K pollFirst() {
       return Iterators.pollNext(iterator());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K pollLast() {
       return Iterators.pollNext(descendingIterator());
     }
@@ -1317,7 +1316,7 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     map.forEach(
         (key, valueCollection) -> valueCollection.forEach(value -> action.accept(key, value)));
   }
@@ -1361,8 +1360,8 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return Maps.safeContainsKey(submap, key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Collection<V> get(@CheckForNull Object key) {
       Collection<V> collection = Maps.safeGet(submap, key);
       if (collection == null) {
@@ -1383,8 +1382,8 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return submap.size();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Collection<V> remove(@CheckForNull Object key) {
       Collection<V> collection = submap.remove(key);
       if (collection == null) {
@@ -1501,8 +1500,8 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return (SortedMap<K, Collection<V>>) submap;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return sortedMap().comparator();
     }
@@ -1562,80 +1561,80 @@ abstract class AbstractMapBasedMultimap<K extends @Nullable Object, V extends @N
       return (NavigableMap<K, Collection<V>>) super.sortedMap();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> lowerEntry(@ParametricNullness K key) {
       Entry<K, Collection<V>> entry = sortedMap().lowerEntry(key);
       return (entry == null) ? null : wrapEntry(entry);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K lowerKey(@ParametricNullness K key) {
       return sortedMap().lowerKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> floorEntry(@ParametricNullness K key) {
       Entry<K, Collection<V>> entry = sortedMap().floorEntry(key);
       return (entry == null) ? null : wrapEntry(entry);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K floorKey(@ParametricNullness K key) {
       return sortedMap().floorKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> ceilingEntry(@ParametricNullness K key) {
       Entry<K, Collection<V>> entry = sortedMap().ceilingEntry(key);
       return (entry == null) ? null : wrapEntry(entry);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K ceilingKey(@ParametricNullness K key) {
       return sortedMap().ceilingKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> higherEntry(@ParametricNullness K key) {
       Entry<K, Collection<V>> entry = sortedMap().higherEntry(key);
       return (entry == null) ? null : wrapEntry(entry);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K higherKey(@ParametricNullness K key) {
       return sortedMap().higherKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> firstEntry() {
       Entry<K, Collection<V>> entry = sortedMap().firstEntry();
       return (entry == null) ? null : wrapEntry(entry);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> lastEntry() {
       Entry<K, Collection<V>> entry = sortedMap().lastEntry();
       return (entry == null) ? null : wrapEntry(entry);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> pollFirstEntry() {
       return pollAsMapEntry(entrySet().iterator());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, Collection<V>> pollLastEntry() {
       return pollAsMapEntry(descendingMap().entrySet().iterator());
     }
diff --git a/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java b/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java
index b37214e022..58a6db2456 100644
--- a/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java
+++ b/guava/src/com/google/common/collect/AbstractMapBasedMultiset.java
@@ -17,7 +17,6 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
@@ -162,7 +161,7 @@ abstract class AbstractMapBasedMultiset<E extends @Nullable Object> extends Abst
 
   @Override
   public void forEachEntry(ObjIntConsumer<? super E> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     backingMap.forEach((element, count) -> action.accept(element, count.get()));
   }
 
diff --git a/guava/src/com/google/common/collect/AbstractMultimap.java b/guava/src/com/google/common/collect/AbstractMultimap.java
index 299decbe6e..d7b3baf23a 100644
--- a/guava/src/com/google/common/collect/AbstractMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractMultimap.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -80,7 +80,7 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
   @CanIgnoreReturnValue
   @Override
   public boolean putAll(@ParametricNullness K key, Iterable<? extends V> values) {
-    checkNotNull(values);
+    requireNonNull(values);
     // make sure we only call values.iterator() once
     // and we only call get(key) if values is nonempty
     if (values instanceof Collection) {
@@ -105,7 +105,7 @@ abstract class AbstractMultimap<K extends @Nullable Object, V extends @Nullable
   @CanIgnoreReturnValue
   @Override
   public Collection<V> replaceValues(@ParametricNullness K key, Iterable<? extends V> values) {
-    checkNotNull(values);
+    requireNonNull(values);
     Collection<V> result = removeAll(key);
     putAll(key, values);
     return result;
diff --git a/guava/src/com/google/common/collect/AbstractNavigableMap.java b/guava/src/com/google/common/collect/AbstractNavigableMap.java
index 47048d06ac..83733923f6 100644
--- a/guava/src/com/google/common/collect/AbstractNavigableMap.java
+++ b/guava/src/com/google/common/collect/AbstractNavigableMap.java
@@ -37,30 +37,30 @@ import org.checkerframework.checker.nullness.qual.Nullable;
 abstract class AbstractNavigableMap<K extends @Nullable Object, V extends @Nullable Object>
     extends IteratorBasedAbstractMap<K, V> implements NavigableMap<K, V> {
 
-  @Override
   @CheckForNull
+  @Override
   public abstract V get(@CheckForNull Object key);
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> firstEntry() {
     return Iterators.getNext(entryIterator(), null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> lastEntry() {
     return Iterators.getNext(descendingEntryIterator(), null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> pollFirstEntry() {
     return Iterators.pollNext(entryIterator());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> pollLastEntry() {
     return Iterators.pollNext(descendingEntryIterator());
   }
@@ -87,50 +87,50 @@ abstract class AbstractNavigableMap<K extends @Nullable Object, V extends @Nulla
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> lowerEntry(@ParametricNullness K key) {
     return headMap(key, false).lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> floorEntry(@ParametricNullness K key) {
     return headMap(key, true).lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> ceilingEntry(@ParametricNullness K key) {
     return tailMap(key, true).firstEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> higherEntry(@ParametricNullness K key) {
     return tailMap(key, false).firstEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K lowerKey(@ParametricNullness K key) {
     return Maps.keyOrNull(lowerEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K floorKey(@ParametricNullness K key) {
     return Maps.keyOrNull(floorEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K ceilingKey(@ParametricNullness K key) {
     return Maps.keyOrNull(ceilingEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K higherKey(@ParametricNullness K key) {
     return Maps.keyOrNull(higherEntry(key));
   }
diff --git a/guava/src/com/google/common/collect/AbstractRangeSet.java b/guava/src/com/google/common/collect/AbstractRangeSet.java
index d112a11f18..8ce6cac8da 100644
--- a/guava/src/com/google/common/collect/AbstractRangeSet.java
+++ b/guava/src/com/google/common/collect/AbstractRangeSet.java
@@ -32,8 +32,8 @@ abstract class AbstractRangeSet<C extends Comparable> implements RangeSet<C> {
     return rangeContaining(value) != null;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public abstract Range<C> rangeContaining(C value);
 
   @Override
diff --git a/guava/src/com/google/common/collect/AbstractSetMultimap.java b/guava/src/com/google/common/collect/AbstractSetMultimap.java
index 90aa9dcb2f..08e5315c7c 100644
--- a/guava/src/com/google/common/collect/AbstractSetMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractSetMultimap.java
@@ -16,10 +16,12 @@
 
 package com.google.common.collect;
 
+import static java.util.Collections.emptySet;
+import static java.util.Collections.unmodifiableSet;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -51,13 +53,13 @@ abstract class AbstractSetMultimap<K extends @Nullable Object, V extends @Nullab
 
   @Override
   Set<V> createUnmodifiableEmptyCollection() {
-    return Collections.emptySet();
+    return emptySet();
   }
 
   @Override
   <E extends @Nullable Object> Collection<E> unmodifiableCollectionSubclass(
       Collection<E> collection) {
-    return Collections.unmodifiableSet((Set<E>) collection);
+    return unmodifiableSet((Set<E>) collection);
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/AbstractSortedMultiset.java b/guava/src/com/google/common/collect/AbstractSortedMultiset.java
index 621e8f98a5..a39c9b6253 100644
--- a/guava/src/com/google/common/collect/AbstractSortedMultiset.java
+++ b/guava/src/com/google/common/collect/AbstractSortedMultiset.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.j2objc.annotations.WeakOuter;
@@ -46,7 +46,7 @@ abstract class AbstractSortedMultiset<E extends @Nullable Object> extends Abstra
   }
 
   AbstractSortedMultiset(Comparator<? super E> comparator) {
-    this.comparator = checkNotNull(comparator);
+    this.comparator = requireNonNull(comparator);
   }
 
   @Override
@@ -64,22 +64,22 @@ abstract class AbstractSortedMultiset<E extends @Nullable Object> extends Abstra
     return comparator;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> firstEntry() {
     Iterator<Entry<E>> entryIterator = entryIterator();
-    return entryIterator.hasNext() ? entryIterator.next() : null;
+    return Iterators.getNext(entryIterator, null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> lastEntry() {
     Iterator<Entry<E>> entryIterator = descendingEntryIterator();
-    return entryIterator.hasNext() ? entryIterator.next() : null;
+    return Iterators.getNext(entryIterator, null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollFirstEntry() {
     Iterator<Entry<E>> entryIterator = entryIterator();
     if (entryIterator.hasNext()) {
@@ -91,8 +91,8 @@ abstract class AbstractSortedMultiset<E extends @Nullable Object> extends Abstra
     return null;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollLastEntry() {
     Iterator<Entry<E>> entryIterator = descendingEntryIterator();
     if (entryIterator.hasNext()) {
@@ -111,8 +111,8 @@ abstract class AbstractSortedMultiset<E extends @Nullable Object> extends Abstra
       @ParametricNullness E toElement,
       BoundType toBoundType) {
     // These are checked elsewhere, but NullPointerTester wants them checked eagerly.
-    checkNotNull(fromBoundType);
-    checkNotNull(toBoundType);
+    requireNonNull(fromBoundType);
+    requireNonNull(toBoundType);
     return tailMultiset(fromElement, fromBoundType).headMultiset(toElement, toBoundType);
   }
 
diff --git a/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java b/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java
index 32316133a0..e83c22e8fc 100644
--- a/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java
+++ b/guava/src/com/google/common/collect/AbstractSortedSetMultimap.java
@@ -16,10 +16,11 @@
 
 package com.google.common.collect;
 
+import static java.util.Collections.unmodifiableSortedSet;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Map;
 import java.util.NavigableSet;
 import java.util.SortedSet;
@@ -60,7 +61,7 @@ abstract class AbstractSortedSetMultimap<K extends @Nullable Object, V extends @
     if (collection instanceof NavigableSet) {
       return Sets.unmodifiableNavigableSet((NavigableSet<E>) collection);
     } else {
-      return Collections.unmodifiableSortedSet((SortedSet<E>) collection);
+      return unmodifiableSortedSet((SortedSet<E>) collection);
     }
   }
 
diff --git a/guava/src/com/google/common/collect/AbstractTable.java b/guava/src/com/google/common/collect/AbstractTable.java
index 99a1215906..5cc9ca4306 100644
--- a/guava/src/com/google/common/collect/AbstractTable.java
+++ b/guava/src/com/google/common/collect/AbstractTable.java
@@ -75,8 +75,8 @@ abstract class AbstractTable<
     return row != null && Maps.safeContainsKey(row, columnKey);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     Map<C, V> row = Maps.safeGet(rowMap(), rowKey);
     return (row == null) ? null : Maps.safeGet(row, columnKey);
@@ -93,16 +93,16 @@ abstract class AbstractTable<
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     Map<C, V> row = Maps.safeGet(rowMap(), rowKey);
     return (row == null) ? null : Maps.safeRemove(row, columnKey);
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(
       @ParametricNullness R rowKey, @ParametricNullness C columnKey, @ParametricNullness V value) {
     return row(rowKey).put(columnKey, value);
diff --git a/guava/src/com/google/common/collect/AllEqualOrdering.java b/guava/src/com/google/common/collect/AllEqualOrdering.java
index f6ca6faff7..dfb7c1f4af 100644
--- a/guava/src/com/google/common/collect/AllEqualOrdering.java
+++ b/guava/src/com/google/common/collect/AllEqualOrdering.java
@@ -48,8 +48,8 @@ final class AllEqualOrdering extends Ordering<@Nullable Object> implements Seria
     return ImmutableList.copyOf(iterable);
   }
 
-  @SuppressWarnings("unchecked")
   @Override
+  @SuppressWarnings("unchecked")
   public <S extends @Nullable Object> Ordering<S> reverse() {
     return (Ordering<S>) this;
   }
diff --git a/guava/src/com/google/common/collect/ArrayTable.java b/guava/src/com/google/common/collect/ArrayTable.java
index 1349386d68..1d501cd02b 100644
--- a/guava/src/com/google/common/collect/ArrayTable.java
+++ b/guava/src/com/google/common/collect/ArrayTable.java
@@ -18,8 +18,8 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Collections.emptyMap;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -276,19 +276,16 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(K key, @ParametricNullness V value) {
       Integer index = keyIndex.get(key);
-      if (index == null) {
-        throw new IllegalArgumentException(
-            getKeyRole() + " " + key + " not in " + keyIndex.keySet());
-      }
+      checkArgument(index != null, "%s %s not in %s", getKeyRole(), key, keyIndex.keySet());
       return setValue(index, value);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object key) {
       throw new UnsupportedOperationException();
     }
@@ -385,9 +382,9 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link #eraseAll}
    */
+  @Deprecated
   @DoNotCall("Always throws UnsupportedOperationException")
   @Override
-  @Deprecated
   public void clear() {
     throw new UnsupportedOperationException();
   }
@@ -438,8 +435,8 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
     return false;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
@@ -461,11 +458,11 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    *     columnKey} is not in {@link #columnKeySet()}.
    */
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(R rowKey, C columnKey, @CheckForNull V value) {
-    checkNotNull(rowKey);
-    checkNotNull(columnKey);
+    requireNonNull(rowKey);
+    requireNonNull(columnKey);
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     checkArgument(rowIndex != null, "Row %s not in %s", rowKey, rowList);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
@@ -499,11 +496,11 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link #erase}
    */
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CanIgnoreReturnValue
-  @Override
-  @Deprecated
   @CheckForNull
+  @Deprecated
+  @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     throw new UnsupportedOperationException();
   }
@@ -586,8 +583,8 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
         return columnList.get(columnIndex);
       }
 
-      @Override
       @CheckForNull
+      @Override
       public V getValue() {
         return at(rowIndex, columnIndex);
       }
@@ -614,7 +611,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    */
   @Override
   public Map<R, @Nullable V> column(C columnKey) {
-    checkNotNull(columnKey);
+    requireNonNull(columnKey);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
     if (columnIndex == null) {
       return emptyMap();
@@ -636,14 +633,14 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
       return "Row";
     }
 
-    @Override
     @CheckForNull
+    @Override
     V getValue(int index) {
       return at(index, columnIndex);
     }
 
-    @Override
     @CheckForNull
+    @Override
     V setValue(int index, @CheckForNull V newValue) {
       return set(index, columnIndex, newValue);
     }
@@ -689,8 +686,8 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map<R, @Nullable V> put(C key, Map<R, @Nullable V> value) {
       throw new UnsupportedOperationException();
     }
@@ -709,7 +706,7 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
    */
   @Override
   public Map<C, @Nullable V> row(R rowKey) {
-    checkNotNull(rowKey);
+    requireNonNull(rowKey);
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     if (rowIndex == null) {
       return emptyMap();
@@ -731,14 +728,14 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
       return "Column";
     }
 
-    @Override
     @CheckForNull
+    @Override
     V getValue(int index) {
       return at(rowIndex, index);
     }
 
-    @Override
     @CheckForNull
+    @Override
     V setValue(int index, @CheckForNull V newValue) {
       return set(rowIndex, index, newValue);
     }
@@ -784,8 +781,8 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map<C, @Nullable V> put(R key, Map<C, @Nullable V> value) {
       throw new UnsupportedOperationException();
     }
@@ -808,8 +805,8 @@ public final class ArrayTable<R, C, V> extends AbstractTable<R, C, @Nullable V>
   @Override
   Iterator<@Nullable V> valuesIterator() {
     return new AbstractIndexedListIterator<@Nullable V>(size()) {
-      @Override
       @CheckForNull
+      @Override
       protected V get(int index) {
         return getValue(index);
       }
diff --git a/guava/src/com/google/common/collect/BiMap.java b/guava/src/com/google/common/collect/BiMap.java
index 12eb4e3e1b..7c24cf3e84 100644
--- a/guava/src/com/google/common/collect/BiMap.java
+++ b/guava/src/com/google/common/collect/BiMap.java
@@ -47,8 +47,8 @@ public interface BiMap<K extends @Nullable Object, V extends @Nullable Object> e
    *     #forcePut} instead.
    */
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   V put(@ParametricNullness K key, @ParametricNullness V value);
 
   /**
diff --git a/guava/src/com/google/common/collect/ByFunctionOrdering.java b/guava/src/com/google/common/collect/ByFunctionOrdering.java
index 43ebdddf62..a019f57c0f 100644
--- a/guava/src/com/google/common/collect/ByFunctionOrdering.java
+++ b/guava/src/com/google/common/collect/ByFunctionOrdering.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
@@ -37,8 +37,8 @@ final class ByFunctionOrdering<F extends @Nullable Object, T extends @Nullable O
   final Ordering<T> ordering;
 
   ByFunctionOrdering(Function<F, ? extends T> function, Ordering<T> ordering) {
-    this.function = checkNotNull(function);
-    this.ordering = checkNotNull(ordering);
+    this.function = requireNonNull(function);
+    this.ordering = requireNonNull(ordering);
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/CollectCollectors.java b/guava/src/com/google/common/collect/CollectCollectors.java
index f582660c8e..d01df86d9d 100644
--- a/guava/src/com/google/common/collect/CollectCollectors.java
+++ b/guava/src/com/google/common/collect/CollectCollectors.java
@@ -17,7 +17,9 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toMap;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -33,7 +35,6 @@ import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.function.ToIntFunction;
 import java.util.stream.Collector;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -82,7 +83,7 @@ final class CollectCollectors {
 
   static <E> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet(
       Comparator<? super E> comparator) {
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     return Collector.of(
         () -> new ImmutableSortedSet.Builder<E>(comparator),
         ImmutableSortedSet.Builder::add,
@@ -143,12 +144,12 @@ final class CollectCollectors {
 
   static <T extends @Nullable Object, E> Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(
       Function<? super T, ? extends E> elementFunction, ToIntFunction<? super T> countFunction) {
-    checkNotNull(elementFunction);
-    checkNotNull(countFunction);
+    requireNonNull(elementFunction);
+    requireNonNull(countFunction);
     return Collector.of(
         LinkedHashMultiset::create,
         (multiset, t) ->
-            multiset.add(checkNotNull(elementFunction.apply(t)), countFunction.applyAsInt(t)),
+            multiset.add(requireNonNull(elementFunction.apply(t)), countFunction.applyAsInt(t)),
         (multiset1, multiset2) -> {
           multiset1.addAll(multiset2);
           return multiset1;
@@ -161,9 +162,9 @@ final class CollectCollectors {
           Function<? super T, E> elementFunction,
           ToIntFunction<? super T> countFunction,
           Supplier<M> multisetSupplier) {
-    checkNotNull(elementFunction);
-    checkNotNull(countFunction);
-    checkNotNull(multisetSupplier);
+    requireNonNull(elementFunction);
+    requireNonNull(countFunction);
+    requireNonNull(multisetSupplier);
     return Collector.of(
         multisetSupplier,
         (ms, t) -> ms.add(elementFunction.apply(t), countFunction.applyAsInt(t)),
@@ -178,8 +179,8 @@ final class CollectCollectors {
   static <T extends @Nullable Object, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
     return Collector.of(
         ImmutableMap.Builder<K, V>::new,
         (builder, input) -> builder.put(keyFunction.apply(input), valueFunction.apply(input)),
@@ -192,12 +193,11 @@ final class CollectCollectors {
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
           BinaryOperator<V> mergeFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(mergeFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
+    requireNonNull(mergeFunction);
     return collectingAndThen(
-        Collectors.toMap(keyFunction, valueFunction, mergeFunction, LinkedHashMap::new),
-        ImmutableMap::copyOf);
+        toMap(keyFunction, valueFunction, mergeFunction, LinkedHashMap::new), ImmutableMap::copyOf);
   }
 
   static <T extends @Nullable Object, K, V>
@@ -205,9 +205,9 @@ final class CollectCollectors {
           Comparator<? super K> comparator,
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(comparator);
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
+    requireNonNull(comparator);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
     /*
      * We will always fail if there are duplicate keys, and the keys are always sorted by
      * the Comparator, so the entries can come in an arbitrary order -- so we report UNORDERED.
@@ -226,21 +226,20 @@ final class CollectCollectors {
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
           BinaryOperator<V> mergeFunction) {
-    checkNotNull(comparator);
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(mergeFunction);
+    requireNonNull(comparator);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
+    requireNonNull(mergeFunction);
     return collectingAndThen(
-        Collectors.toMap(
-            keyFunction, valueFunction, mergeFunction, () -> new TreeMap<K, V>(comparator)),
+        toMap(keyFunction, valueFunction, mergeFunction, () -> new TreeMap<K, V>(comparator)),
         ImmutableSortedMap::copyOfSorted);
   }
 
   static <T extends @Nullable Object, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
     return Collector.of(
         ImmutableBiMap.Builder<K, V>::new,
         (builder, input) -> builder.put(keyFunction.apply(input), valueFunction.apply(input)),
@@ -253,8 +252,8 @@ final class CollectCollectors {
       Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
     return Collector.of(
         () ->
             new EnumMapAccumulator<K, V>(
@@ -282,9 +281,9 @@ final class CollectCollectors {
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
           BinaryOperator<V> mergeFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(mergeFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
+    requireNonNull(mergeFunction);
     // not UNORDERED because we don't know if mergeFunction is commutative
     return Collector.of(
         () -> new EnumMapAccumulator<K, V>(mergeFunction),
@@ -339,8 +338,8 @@ final class CollectCollectors {
       Collector<T, ?, ImmutableRangeMap<K, V>> toImmutableRangeMap(
           Function<? super T, Range<K>> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
     return Collector.of(
         ImmutableRangeMap::<K, V>builder,
         (builder, input) -> builder.put(keyFunction.apply(input), valueFunction.apply(input)),
@@ -354,8 +353,8 @@ final class CollectCollectors {
       Collector<T, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(keyFunction, "keyFunction");
-    checkNotNull(valueFunction, "valueFunction");
+    requireNonNull(keyFunction, "keyFunction");
+    requireNonNull(valueFunction, "valueFunction");
     return Collector.of(
         ImmutableListMultimap::<K, V>builder,
         (builder, t) -> builder.put(keyFunction.apply(t), valueFunction.apply(t)),
@@ -367,11 +366,11 @@ final class CollectCollectors {
       Collector<T, ?, ImmutableListMultimap<K, V>> flatteningToImmutableListMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends Stream<? extends V>> valuesFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valuesFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valuesFunction);
     return collectingAndThen(
         flatteningToMultimap(
-            input -> checkNotNull(keyFunction.apply(input)),
+            input -> requireNonNull(keyFunction.apply(input)),
             input -> valuesFunction.apply(input).peek(Preconditions::checkNotNull),
             MultimapBuilder.linkedHashKeys().arrayListValues()::<K, V>build),
         ImmutableListMultimap::copyOf);
@@ -381,8 +380,8 @@ final class CollectCollectors {
       Collector<T, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(keyFunction, "keyFunction");
-    checkNotNull(valueFunction, "valueFunction");
+    requireNonNull(keyFunction, "keyFunction");
+    requireNonNull(valueFunction, "valueFunction");
     return Collector.of(
         ImmutableSetMultimap::<K, V>builder,
         (builder, t) -> builder.put(keyFunction.apply(t), valueFunction.apply(t)),
@@ -394,11 +393,11 @@ final class CollectCollectors {
       Collector<T, ?, ImmutableSetMultimap<K, V>> flatteningToImmutableSetMultimap(
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends Stream<? extends V>> valuesFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valuesFunction);
+    requireNonNull(keyFunction);
+    requireNonNull(valuesFunction);
     return collectingAndThen(
         flatteningToMultimap(
-            input -> checkNotNull(keyFunction.apply(input)),
+            input -> requireNonNull(keyFunction.apply(input)),
             input -> valuesFunction.apply(input).peek(Preconditions::checkNotNull),
             MultimapBuilder.linkedHashKeys().linkedHashSetValues()::<K, V>build),
         ImmutableSetMultimap::copyOf);
@@ -413,9 +412,9 @@ final class CollectCollectors {
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends V> valueFunction,
           Supplier<M> multimapSupplier) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(multimapSupplier);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
+    requireNonNull(multimapSupplier);
     return Collector.of(
         multimapSupplier,
         (multimap, input) -> multimap.put(keyFunction.apply(input), valueFunction.apply(input)),
@@ -434,9 +433,9 @@ final class CollectCollectors {
           Function<? super T, ? extends K> keyFunction,
           Function<? super T, ? extends Stream<? extends V>> valueFunction,
           Supplier<M> multimapSupplier) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(multimapSupplier);
+    requireNonNull(keyFunction);
+    requireNonNull(valueFunction);
+    requireNonNull(multimapSupplier);
     return Collector.of(
         multimapSupplier,
         (multimap, input) -> {
diff --git a/guava/src/com/google/common/collect/CollectPreconditions.java b/guava/src/com/google/common/collect/CollectPreconditions.java
index c649b03233..daa6106af2 100644
--- a/guava/src/com/google/common/collect/CollectPreconditions.java
+++ b/guava/src/com/google/common/collect/CollectPreconditions.java
@@ -16,6 +16,7 @@
 
 package com.google.common.collect;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 
 import com.google.common.annotations.GwtCompatible;
@@ -36,24 +37,18 @@ final class CollectPreconditions {
 
   @CanIgnoreReturnValue
   static int checkNonnegative(int value, String name) {
-    if (value < 0) {
-      throw new IllegalArgumentException(name + " cannot be negative but was: " + value);
-    }
+    checkArgument(value >= 0, "%s cannot be negative but was: %s", name, value);
     return value;
   }
 
   @CanIgnoreReturnValue
   static long checkNonnegative(long value, String name) {
-    if (value < 0) {
-      throw new IllegalArgumentException(name + " cannot be negative but was: " + value);
-    }
+    checkArgument(value >= 0, "%s cannot be negative but was: %s", name, value);
     return value;
   }
 
   static void checkPositive(int value, String name) {
-    if (value <= 0) {
-      throw new IllegalArgumentException(name + " must be positive but was: " + value);
-    }
+    checkArgument(value > 0, "%s must be positive but was: %s", name, value);
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/CollectSpliterators.java b/guava/src/com/google/common/collect/CollectSpliterators.java
index 7d0e82f203..8a263ce2a8 100644
--- a/guava/src/com/google/common/collect/CollectSpliterators.java
+++ b/guava/src/com/google/common/collect/CollectSpliterators.java
@@ -17,9 +17,9 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.lang.Math.max;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.j2objc.annotations.Weak;
@@ -72,8 +72,8 @@ final class CollectSpliterators {
         delegate.forEachRemaining((IntConsumer) i -> action.accept(function.apply(i)));
       }
 
-      @Override
       @CheckForNull
+      @Override
       public Spliterator<T> trySplit() {
         Spliterator.OfInt split = delegate.trySplit();
         return (split == null) ? null : new WithCharacteristics(split);
@@ -92,8 +92,8 @@ final class CollectSpliterators {
             | extraCharacteristics;
       }
 
-      @Override
       @CheckForNull
+      @Override
       public Comparator<? super T> getComparator() {
         if (hasCharacteristics(Spliterator.SORTED)) {
           return comparator;
@@ -113,8 +113,8 @@ final class CollectSpliterators {
       Spliterator<OutElementT> map(
           Spliterator<InElementT> fromSpliterator,
           Function<? super InElementT, ? extends OutElementT> function) {
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
+    requireNonNull(fromSpliterator);
+    requireNonNull(function);
     return new Spliterator<OutElementT>() {
 
       @Override
@@ -128,8 +128,8 @@ final class CollectSpliterators {
         fromSpliterator.forEachRemaining(fromElement -> action.accept(function.apply(fromElement)));
       }
 
-      @Override
       @CheckForNull
+      @Override
       public Spliterator<OutElementT> trySplit() {
         Spliterator<InElementT> fromSplit = fromSpliterator.trySplit();
         return (fromSplit != null) ? map(fromSplit, function) : null;
@@ -151,8 +151,8 @@ final class CollectSpliterators {
   /** Returns a {@code Spliterator} filtered by the specified predicate. */
   static <T extends @Nullable Object> Spliterator<T> filter(
       Spliterator<T> fromSpliterator, Predicate<? super T> predicate) {
-    checkNotNull(fromSpliterator);
-    checkNotNull(predicate);
+    requireNonNull(fromSpliterator);
+    requireNonNull(predicate);
     class Splitr implements Spliterator<T>, Consumer<T> {
       @CheckForNull T holder = null;
 
@@ -178,8 +178,8 @@ final class CollectSpliterators {
         return false;
       }
 
-      @Override
       @CheckForNull
+      @Override
       public Spliterator<T> trySplit() {
         Spliterator<T> fromSplit = fromSpliterator.trySplit();
         return (fromSplit == null) ? null : filter(fromSplit, predicate);
@@ -190,8 +190,8 @@ final class CollectSpliterators {
         return fromSpliterator.estimateSize() / 2;
       }
 
-      @Override
       @CheckForNull
+      @Override
       public Comparator<? super T> getComparator() {
         return fromSpliterator.getComparator();
       }
@@ -224,8 +224,8 @@ final class CollectSpliterators {
     checkArgument(
         (topCharacteristics & Spliterator.SORTED) == 0,
         "flatMap does not support SORTED characteristic");
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
+    requireNonNull(fromSpliterator);
+    requireNonNull(function);
     return new FlatMapSpliteratorOfObject<>(
         null, fromSpliterator, function, topCharacteristics, topSize);
   }
@@ -246,8 +246,8 @@ final class CollectSpliterators {
     checkArgument(
         (topCharacteristics & Spliterator.SORTED) == 0,
         "flatMap does not support SORTED characteristic");
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
+    requireNonNull(fromSpliterator);
+    requireNonNull(function);
     return new FlatMapSpliteratorOfInt<>(
         null, fromSpliterator, function, topCharacteristics, topSize);
   }
@@ -268,8 +268,8 @@ final class CollectSpliterators {
     checkArgument(
         (topCharacteristics & Spliterator.SORTED) == 0,
         "flatMap does not support SORTED characteristic");
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
+    requireNonNull(fromSpliterator);
+    requireNonNull(function);
     return new FlatMapSpliteratorOfLong<>(
         null, fromSpliterator, function, topCharacteristics, topSize);
   }
@@ -290,8 +290,8 @@ final class CollectSpliterators {
     checkArgument(
         (topCharacteristics & Spliterator.SORTED) == 0,
         "flatMap does not support SORTED characteristic");
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
+    requireNonNull(fromSpliterator);
+    requireNonNull(function);
     return new FlatMapSpliteratorOfDouble<>(
         null, fromSpliterator, function, topCharacteristics, topSize);
   }
@@ -381,8 +381,8 @@ final class CollectSpliterators {
       estimatedSize = 0;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public final OutSpliteratorT trySplit() {
       Spliterator<InElementT> fromSplit = from.trySplit();
       if (fromSplit != null) {
diff --git a/guava/src/com/google/common/collect/Collections2.java b/guava/src/com/google/common/collect/Collections2.java
index eb928596a3..0d1cbc3b69 100644
--- a/guava/src/com/google/common/collect/Collections2.java
+++ b/guava/src/com/google/common/collect/Collections2.java
@@ -17,8 +17,8 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static java.util.Collections.reverse;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -94,7 +94,7 @@ public final class Collections2 {
       return ((FilteredCollection<E>) unfiltered).createCombined(predicate);
     }
 
-    return new FilteredCollection<E>(checkNotNull(unfiltered), checkNotNull(predicate));
+    return new FilteredCollection<E>(requireNonNull(unfiltered), requireNonNull(predicate));
   }
 
   /**
@@ -102,7 +102,7 @@ public final class Collections2 {
    * throws a {@code ClassCastException} or {@code NullPointerException}.
    */
   static boolean safeContains(Collection<?> collection, @CheckForNull Object object) {
-    checkNotNull(collection);
+    requireNonNull(collection);
     try {
       return collection.contains(object);
     } catch (ClassCastException | NullPointerException e) {
@@ -115,7 +115,7 @@ public final class Collections2 {
    * throws a {@code ClassCastException} or {@code NullPointerException}.
    */
   static boolean safeRemove(Collection<?> collection, @CheckForNull Object object) {
-    checkNotNull(collection);
+    requireNonNull(collection);
     try {
       return collection.remove(object);
     } catch (ClassCastException | NullPointerException e) {
@@ -188,7 +188,7 @@ public final class Collections2 {
 
     @Override
     public void forEach(Consumer<? super E> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       unfiltered.forEach(
           (E e) -> {
             if (predicate.test(e)) {
@@ -214,7 +214,7 @@ public final class Collections2 {
 
     @Override
     public boolean removeIf(java.util.function.Predicate<? super E> filter) {
-      checkNotNull(filter);
+      requireNonNull(filter);
       return unfiltered.removeIf(element -> predicate.apply(element) && filter.test(element));
     }
 
@@ -272,8 +272,8 @@ public final class Collections2 {
     final Function<? super F, ? extends T> function;
 
     TransformedCollection(Collection<F> fromCollection, Function<? super F, ? extends T> function) {
-      this.fromCollection = checkNotNull(fromCollection);
-      this.function = checkNotNull(function);
+      this.fromCollection = requireNonNull(fromCollection);
+      this.function = requireNonNull(function);
     }
 
     @Override
@@ -298,13 +298,13 @@ public final class Collections2 {
 
     @Override
     public void forEach(Consumer<? super T> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       fromCollection.forEach((F f) -> action.accept(function.apply(f)));
     }
 
     @Override
     public boolean removeIf(java.util.function.Predicate<? super T> filter) {
-      checkNotNull(filter);
+      requireNonNull(filter);
       return fromCollection.removeIf(element -> filter.test(function.apply(element)));
     }
 
@@ -514,12 +514,12 @@ public final class Collections2 {
     final Comparator<? super E> comparator;
 
     OrderedPermutationIterator(List<E> list, Comparator<? super E> comparator) {
-      this.nextPermutation = Lists.newArrayList(list);
+      this.nextPermutation = new ArrayList<>(list);
       this.comparator = comparator;
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected List<E> computeNext() {
       if (nextPermutation == null) {
         return endOfData();
@@ -544,7 +544,7 @@ public final class Collections2 {
       int l = findNextL(j);
       Collections.swap(nextPermutation, j, l);
       int n = nextPermutation.size();
-      Collections.reverse(nextPermutation.subList(j + 1, n));
+      reverse(nextPermutation.subList(j + 1, n));
     }
 
     int findNextJ() {
@@ -652,8 +652,8 @@ public final class Collections2 {
       j = Integer.MAX_VALUE;
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected List<E> computeNext() {
       if (j <= 0) {
         return endOfData();
diff --git a/guava/src/com/google/common/collect/CompactHashMap.java b/guava/src/com/google/common/collect/CompactHashMap.java
index c18c207a89..d6739ec7bc 100644
--- a/guava/src/com/google/common/collect/CompactHashMap.java
+++ b/guava/src/com/google/common/collect/CompactHashMap.java
@@ -16,7 +16,8 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static com.google.common.collect.CompactHashing.UNSET;
 import static com.google.common.collect.Hashing.smearedHash;
@@ -27,7 +28,6 @@ import static java.util.Objects.requireNonNull;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
-import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.WeakOuter;
@@ -117,7 +117,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
    * Maximum allowed false positive probability of detecting a hash flooding attack given random
    * input.
    */
-  @VisibleForTesting() static final double HASH_FLOODING_FPP = 0.001;
+  @VisibleForTesting static final double HASH_FLOODING_FPP = 0.001;
 
   /**
    * Maximum allowed length of a hash table bucket before falling back to a j.u.LinkedHashMap-based
@@ -248,7 +248,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
 
   /** Pseudoconstructor for serialization support. */
   void init(int expectedSize) {
-    Preconditions.checkArgument(expectedSize >= 0, "Expected size must be >= 0");
+    checkArgument(expectedSize >= 0, "Expected size must be >= 0");
 
     // Save expectedSize for use in allocArrays()
     this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);
@@ -263,7 +263,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
   /** Handle lazy allocation of arrays. */
   @CanIgnoreReturnValue
   int allocArrays() {
-    Preconditions.checkState(needsAllocArrays(), "Arrays already allocated");
+    checkState(needsAllocArrays(), "Arrays already allocated");
 
     int expectedSize = metadata;
     int buckets = CompactHashing.tableSize(expectedSize);
@@ -277,9 +277,9 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return expectedSize;
   }
 
+  @CheckForNull
   @SuppressWarnings("unchecked")
   @VisibleForTesting
-  @CheckForNull
   Map<K, V> delegateOrNull() {
     if (table instanceof Map) {
       return (Map<K, V>) table;
@@ -291,8 +291,8 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return new LinkedHashMap<>(tableSize, 1.0f);
   }
 
-  @VisibleForTesting
   @CanIgnoreReturnValue
+  @VisibleForTesting
   Map<K, V> convertToHashFloodingResistantImplementation() {
     Map<K, V> newDelegate = createHashFloodingResistantDelegate(hashTableMask() + 1);
     for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
@@ -331,8 +331,8 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
     if (needsAllocArrays()) {
       allocArrays();
@@ -506,8 +506,8 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
     return (delegate != null) ? delegate.containsKey(key) : indexOf(key) != -1;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     Map<K, V> delegate = delegateOrNull();
     if (delegate != null) {
@@ -522,9 +522,9 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
   }
 
   @CanIgnoreReturnValue
-  @SuppressWarnings("unchecked") // known to be a V
+  @CheckForNull // known to be a V
   @Override
-  @CheckForNull
+  @SuppressWarnings("unchecked")
   public V remove(@CheckForNull Object key) {
     Map<K, V> delegate = delegateOrNull();
     if (delegate != null) {
@@ -674,7 +674,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
 
   @Override
   public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     Map<K, V> delegate = delegateOrNull();
     if (delegate != null) {
       delegate.replaceAll(function);
@@ -756,7 +756,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
 
     @Override
     public void forEach(Consumer<? super K> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       Map<K, V> delegate = delegateOrNull();
       if (delegate != null) {
         delegate.keySet().forEach(action);
@@ -784,7 +784,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     Map<K, V> delegate = delegateOrNull();
     if (delegate != null) {
       delegate.forEach(action);
@@ -1002,7 +1002,7 @@ class CompactHashMap<K extends @Nullable Object, V extends @Nullable Object>
 
     @Override
     public void forEach(Consumer<? super V> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       Map<K, V> delegate = delegateOrNull();
       if (delegate != null) {
         delegate.values().forEach(action);
diff --git a/guava/src/com/google/common/collect/CompactHashSet.java b/guava/src/com/google/common/collect/CompactHashSet.java
index 4ffd8e6e10..cbe64da6ad 100644
--- a/guava/src/com/google/common/collect/CompactHashSet.java
+++ b/guava/src/com/google/common/collect/CompactHashSet.java
@@ -16,7 +16,8 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static com.google.common.collect.CompactHashing.UNSET;
 import static com.google.common.collect.Hashing.smearedHash;
@@ -25,7 +26,6 @@ import static java.util.Objects.requireNonNull;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
-import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
@@ -131,7 +131,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
    * Maximum allowed false positive probability of detecting a hash flooding attack given random
    * input.
    */
-  @VisibleForTesting() static final double HASH_FLOODING_FPP = 0.001;
+  @VisibleForTesting static final double HASH_FLOODING_FPP = 0.001;
 
   /**
    * Maximum allowed length of a hash table bucket before falling back to a j.u.LinkedHashSet based
@@ -214,7 +214,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
 
   /** Pseudoconstructor for serialization support. */
   void init(int expectedSize) {
-    Preconditions.checkArgument(expectedSize >= 0, "Expected size must be >= 0");
+    checkArgument(expectedSize >= 0, "Expected size must be >= 0");
 
     // Save expectedSize for use in allocArrays()
     this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);
@@ -229,7 +229,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
   /** Handle lazy allocation of arrays. */
   @CanIgnoreReturnValue
   int allocArrays() {
-    Preconditions.checkState(needsAllocArrays(), "Arrays already allocated");
+    checkState(needsAllocArrays(), "Arrays already allocated");
 
     int expectedSize = metadata;
     int buckets = CompactHashing.tableSize(expectedSize);
@@ -242,9 +242,9 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     return expectedSize;
   }
 
+  @CheckForNull
   @SuppressWarnings("unchecked")
   @VisibleForTesting
-  @CheckForNull
   Set<E> delegateOrNull() {
     if (table instanceof Set) {
       return (Set<E>) table;
@@ -256,8 +256,8 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
     return new LinkedHashSet<>(tableSize, 1.0f);
   }
 
-  @VisibleForTesting
   @CanIgnoreReturnValue
+  @VisibleForTesting
   Set<E> convertToHashFloodingResistantImplementation() {
     Set<E> newDelegate = createHashFloodingResistantDelegate(hashTableMask() + 1);
     for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
@@ -602,7 +602,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
 
   @Override
   public void forEach(Consumer<? super E> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     Set<E> delegate = delegateOrNull();
     if (delegate != null) {
       delegate.forEach(action);
@@ -621,7 +621,7 @@ class CompactHashSet<E extends @Nullable Object> extends AbstractSet<E> implemen
 
   @Override
   public boolean isEmpty() {
-    return size() == 0;
+    return this.isEmpty();
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/CompactHashing.java b/guava/src/com/google/common/collect/CompactHashing.java
index a8fe90214c..c1d6c11f09 100644
--- a/guava/src/com/google/common/collect/CompactHashing.java
+++ b/guava/src/com/google/common/collect/CompactHashing.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Objects;
 import com.google.common.primitives.Ints;
@@ -74,11 +76,12 @@ final class CompactHashing {
 
   /** Creates and returns a properly-sized array with the given number of buckets. */
   static Object createTable(int buckets) {
-    if (buckets < 2
-        || buckets > Ints.MAX_POWER_OF_TWO
-        || Integer.highestOneBit(buckets) != buckets) {
-      throw new IllegalArgumentException("must be power of 2 between 2^1 and 2^30: " + buckets);
-    }
+    checkArgument(
+        buckets >= 2
+            && buckets <= Ints.MAX_POWER_OF_TWO
+            && Integer.highestOneBit(buckets) == buckets,
+        "must be power of 2 between 2^1 and 2^30: %s",
+        buckets);
     if (buckets <= BYTE_MAX_SIZE) {
       return new byte[buckets];
     } else if (buckets <= SHORT_MAX_SIZE) {
diff --git a/guava/src/com/google/common/collect/CompactLinkedHashMap.java b/guava/src/com/google/common/collect/CompactLinkedHashMap.java
index 97b3a4b1c3..04ef58994c 100644
--- a/guava/src/com/google/common/collect/CompactLinkedHashMap.java
+++ b/guava/src/com/google/common/collect/CompactLinkedHashMap.java
@@ -131,8 +131,8 @@ class CompactLinkedHashMap<K extends @Nullable Object, V extends @Nullable Objec
     return new LinkedHashMap<K, V>(tableSize, 1.0f, accessOrder);
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   Map<K, V> convertToHashFloodingResistantImplementation() {
     Map<K, V> result = super.convertToHashFloodingResistantImplementation();
     links = null;
diff --git a/guava/src/com/google/common/collect/CompactLinkedHashSet.java b/guava/src/com/google/common/collect/CompactLinkedHashSet.java
index c1d813cdb4..150005213a 100644
--- a/guava/src/com/google/common/collect/CompactLinkedHashSet.java
+++ b/guava/src/com/google/common/collect/CompactLinkedHashSet.java
@@ -148,8 +148,8 @@ class CompactLinkedHashSet<E extends @Nullable Object> extends CompactHashSet<E>
     return expectedSize;
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   Set<E> convertToHashFloodingResistantImplementation() {
     Set<E> result = super.convertToHashFloodingResistantImplementation();
     this.predecessor = null;
diff --git a/guava/src/com/google/common/collect/ComparatorOrdering.java b/guava/src/com/google/common/collect/ComparatorOrdering.java
index 8b34070744..12c918c877 100644
--- a/guava/src/com/google/common/collect/ComparatorOrdering.java
+++ b/guava/src/com/google/common/collect/ComparatorOrdering.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
@@ -32,7 +32,7 @@ final class ComparatorOrdering<T extends @Nullable Object> extends Ordering<T>
   final Comparator<T> comparator;
 
   ComparatorOrdering(Comparator<T> comparator) {
-    this.comparator = checkNotNull(comparator);
+    this.comparator = requireNonNull(comparator);
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/Comparators.java b/guava/src/com/google/common/collect/Comparators.java
index 5779be31bf..ca537c3f5b 100644
--- a/guava/src/com/google/common/collect/Comparators.java
+++ b/guava/src/com/google/common/collect/Comparators.java
@@ -16,8 +16,10 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static java.util.Comparator.nullsFirst;
+import static java.util.Comparator.nullsLast;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
@@ -63,7 +65,7 @@ public final class Comparators {
   // think tip it over into being worthwhile.
   public static <T extends @Nullable Object, S extends T> Comparator<Iterable<S>> lexicographical(
       Comparator<T> comparator) {
-    return new LexicographicalOrdering<S>(checkNotNull(comparator));
+    return new LexicographicalOrdering<S>(requireNonNull(comparator));
   }
 
   /**
@@ -73,7 +75,7 @@ public final class Comparators {
    */
   public static <T extends @Nullable Object> boolean isInOrder(
       Iterable<? extends T> iterable, Comparator<T> comparator) {
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     Iterator<? extends T> it = iterable.iterator();
     if (it.hasNext()) {
       T prev = it.next();
@@ -95,7 +97,7 @@ public final class Comparators {
    */
   public static <T extends @Nullable Object> boolean isInStrictOrder(
       Iterable<? extends T> iterable, Comparator<T> comparator) {
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     Iterator<? extends T> it = iterable.iterator();
     if (it.hasNext()) {
       T prev = it.next();
@@ -133,7 +135,7 @@ public final class Comparators {
   public static <T extends @Nullable Object> Collector<T, ?, List<T>> least(
       int k, Comparator<? super T> comparator) {
     checkNonnegative(k, "k");
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     return Collector.of(
         () -> TopKSelector.<T>least(k, comparator),
         TopKSelector::offer,
@@ -175,9 +177,9 @@ public final class Comparators {
    * @since 22.0
    */
   public static <T> Comparator<Optional<T>> emptiesFirst(Comparator<? super T> valueComparator) {
-    checkNotNull(valueComparator);
+    requireNonNull(valueComparator);
     return Comparator.<Optional<T>, @Nullable T>comparing(
-        o -> o.orElse(null), Comparator.nullsFirst(valueComparator));
+        o -> o.orElse(null), nullsFirst(valueComparator));
   }
 
   /**
@@ -188,9 +190,9 @@ public final class Comparators {
    * @since 22.0
    */
   public static <T> Comparator<Optional<T>> emptiesLast(Comparator<? super T> valueComparator) {
-    checkNotNull(valueComparator);
+    requireNonNull(valueComparator);
     return Comparator.<Optional<T>, @Nullable T>comparing(
-        o -> o.orElse(null), Comparator.nullsLast(valueComparator));
+        o -> o.orElse(null), nullsLast(valueComparator));
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/ComparisonChain.java b/guava/src/com/google/common/collect/ComparisonChain.java
index 9c05205ec0..06fa13ae91 100644
--- a/guava/src/com/google/common/collect/ComparisonChain.java
+++ b/guava/src/com/google/common/collect/ComparisonChain.java
@@ -68,8 +68,8 @@ public abstract class ComparisonChain {
 
   private static final ComparisonChain ACTIVE =
       new ComparisonChain() {
-        @SuppressWarnings("unchecked") // unsafe; see discussion on supertype
-        @Override
+        @Override // unsafe; see discussion on supertype
+        @SuppressWarnings("unchecked")
         public ComparisonChain compare(Comparable<?> left, Comparable<?> right) {
           return classify(((Comparable<Object>) left).compareTo(right));
         }
diff --git a/guava/src/com/google/common/collect/ConcurrentHashMultiset.java b/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
index f60e2081e3..49d8c25ae4 100644
--- a/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
+++ b/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
@@ -17,9 +17,9 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -203,7 +203,7 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
   @CanIgnoreReturnValue
   @Override
   public int add(E element, int occurrences) {
-    checkNotNull(element);
+    requireNonNull(element);
     if (occurrences == 0) {
       return count(element);
     }
@@ -347,7 +347,7 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
   @CanIgnoreReturnValue
   @Override
   public int setCount(E element, int count) {
-    checkNotNull(element);
+    requireNonNull(element);
     checkNonnegative(count, "count");
     while (true) {
       AtomicInteger existingCounter = Maps.safeGet(countMap, element);
@@ -403,7 +403,7 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
   @CanIgnoreReturnValue
   @Override
   public boolean setCount(E element, int expectedOldCount, int newCount) {
-    checkNotNull(element);
+    requireNonNull(element);
     checkNonnegative(expectedOldCount, "oldCount");
     checkNonnegative(newCount, "newCount");
 
@@ -510,8 +510,8 @@ public final class ConcurrentHashMultiset<E> extends AbstractMultiset<E> impleme
           private final Iterator<Map.Entry<E, AtomicInteger>> mapEntries =
               countMap.entrySet().iterator();
 
-          @Override
           @CheckForNull
+          @Override
           protected Entry<E> computeNext() {
             while (true) {
               if (!mapEntries.hasNext()) {
diff --git a/guava/src/com/google/common/collect/ConsumingQueueIterator.java b/guava/src/com/google/common/collect/ConsumingQueueIterator.java
index 7721e1277c..9b5d512ecd 100644
--- a/guava/src/com/google/common/collect/ConsumingQueueIterator.java
+++ b/guava/src/com/google/common/collect/ConsumingQueueIterator.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Queue;
@@ -31,11 +31,11 @@ final class ConsumingQueueIterator<T extends @Nullable Object> extends AbstractI
   private final Queue<T> queue;
 
   ConsumingQueueIterator(Queue<T> queue) {
-    this.queue = checkNotNull(queue);
+    this.queue = requireNonNull(queue);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public T computeNext() {
     // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.
     if (queue.isEmpty()) {
diff --git a/guava/src/com/google/common/collect/ContiguousSet.java b/guava/src/com/google/common/collect/ContiguousSet.java
index d08af0d0ce..f504ac8669 100644
--- a/guava/src/com/google/common/collect/ContiguousSet.java
+++ b/guava/src/com/google/common/collect/ContiguousSet.java
@@ -15,7 +15,6 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -62,8 +61,8 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
    */
   public static <C extends Comparable> ContiguousSet<C> create(
       Range<C> range, DiscreteDomain<C> domain) {
-    checkNotNull(range);
-    checkNotNull(domain);
+    requireNonNull(range);
+    requireNonNull(domain);
     Range<C> effectiveRange = range;
     try {
       if (!range.hasLowerBound()) {
@@ -156,7 +155,7 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
 
   @Override
   public ContiguousSet<C> headSet(C toElement) {
-    return headSetImpl(checkNotNull(toElement), false);
+    return headSetImpl(requireNonNull(toElement), false);
   }
 
   /**
@@ -165,13 +164,13 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
   @GwtIncompatible // NavigableSet
   @Override
   public ContiguousSet<C> headSet(C toElement, boolean inclusive) {
-    return headSetImpl(checkNotNull(toElement), inclusive);
+    return headSetImpl(requireNonNull(toElement), inclusive);
   }
 
   @Override
   public ContiguousSet<C> subSet(C fromElement, C toElement) {
-    checkNotNull(fromElement);
-    checkNotNull(toElement);
+    requireNonNull(fromElement);
+    requireNonNull(toElement);
     checkArgument(comparator().compare(fromElement, toElement) <= 0);
     return subSetImpl(fromElement, true, toElement, false);
   }
@@ -183,15 +182,15 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
   @Override
   public ContiguousSet<C> subSet(
       C fromElement, boolean fromInclusive, C toElement, boolean toInclusive) {
-    checkNotNull(fromElement);
-    checkNotNull(toElement);
+    requireNonNull(fromElement);
+    requireNonNull(toElement);
     checkArgument(comparator().compare(fromElement, toElement) <= 0);
     return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);
   }
 
   @Override
   public ContiguousSet<C> tailSet(C fromElement) {
-    return tailSetImpl(checkNotNull(fromElement), true);
+    return tailSetImpl(requireNonNull(fromElement), true);
   }
 
   /**
@@ -200,7 +199,7 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
   @GwtIncompatible // NavigableSet
   @Override
   public ContiguousSet<C> tailSet(C fromElement, boolean inclusive) {
-    return tailSetImpl(checkNotNull(fromElement), inclusive);
+    return tailSetImpl(requireNonNull(fromElement), inclusive);
   }
 
   /*
@@ -245,8 +244,8 @@ public abstract class ContiguousSet<C extends Comparable> extends ImmutableSorte
    */
   public abstract Range<C> range(BoundType lowerBoundType, BoundType upperBoundType);
 
-  @Override
-  @GwtIncompatible // NavigableSet
+  @GwtIncompatible
+  @Override // NavigableSet
   ImmutableSortedSet<C> createDescendingSet() {
     return new DescendingImmutableSortedSet<>(this);
   }
diff --git a/guava/src/com/google/common/collect/Cut.java b/guava/src/com/google/common/collect/Cut.java
index 21fe5ff2dd..073c5a2bc7 100644
--- a/guava/src/com/google/common/collect/Cut.java
+++ b/guava/src/com/google/common/collect/Cut.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Booleans;
@@ -89,8 +89,8 @@ abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializ
     return endpoint;
   }
 
-  @SuppressWarnings("unchecked") // catching CCE
-  @Override
+  @Override // catching CCE
+  @SuppressWarnings("unchecked")
   public boolean equals(@CheckForNull Object obj) {
     if (obj instanceof Cut) {
       // It might not really be a Cut<C>, but we'll catch a CCE if it's not
@@ -313,7 +313,7 @@ abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializ
 
   private static final class BelowValue<C extends Comparable> extends Cut<C> {
     BelowValue(C endpoint) {
-      super(checkNotNull(endpoint));
+      super(requireNonNull(endpoint));
     }
 
     @Override
@@ -372,8 +372,8 @@ abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializ
       return endpoint;
     }
 
-    @Override
     @CheckForNull
+    @Override
     C greatestValueBelow(DiscreteDomain<C> domain) {
       return domain.previous(endpoint);
     }
@@ -397,7 +397,7 @@ abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializ
 
   private static final class AboveValue<C extends Comparable> extends Cut<C> {
     AboveValue(C endpoint) {
-      super(checkNotNull(endpoint));
+      super(requireNonNull(endpoint));
     }
 
     @Override
@@ -451,8 +451,8 @@ abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializ
       sb.append(endpoint).append(']');
     }
 
-    @Override
     @CheckForNull
+    @Override
     C leastValueAbove(DiscreteDomain<C> domain) {
       return domain.next(endpoint);
     }
diff --git a/guava/src/com/google/common/collect/DenseImmutableTable.java b/guava/src/com/google/common/collect/DenseImmutableTable.java
index 563bd6ef5f..f67ef90e2d 100644
--- a/guava/src/com/google/common/collect/DenseImmutableTable.java
+++ b/guava/src/com/google/common/collect/DenseImmutableTable.java
@@ -26,7 +26,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** A {@code RegularImmutableTable} optimized for dense data. */
 @GwtCompatible
-@Immutable(containerOf = {"R", "C", "V"})
+@Immutable(containerOf = {"C", "R", "V"})
 @ElementTypesAreNonnullByDefault
 final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V> {
   private final ImmutableMap<R, Integer> rowKeyToIndex;
@@ -117,8 +117,8 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
       return size;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
       Integer keyIndex = keyToIndex().get(key);
       return (keyIndex == null) ? null : getValue(keyIndex);
@@ -130,8 +130,8 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
         private int index = -1;
         private final int maxIndex = keyToIndex().size();
 
-        @Override
         @CheckForNull
+        @Override
         protected Entry<K, V> computeNext() {
           for (index++; index < maxIndex; index++) {
             V value = getValue(index);
@@ -158,8 +158,8 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
       return columnKeyToIndex;
     }
 
-    @Override
     @CheckForNull
+    @Override
     V getValue(int keyIndex) {
       return values[rowIndex][keyIndex];
     }
@@ -183,8 +183,8 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
       return rowKeyToIndex;
     }
 
-    @Override
     @CheckForNull
+    @Override
     V getValue(int keyIndex) {
       return values[keyIndex][columnIndex];
     }
@@ -253,8 +253,8 @@ final class DenseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V>
     return ImmutableMap.<R, Map<C, V>>copyOf(rowMap);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
diff --git a/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java b/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java
index 181731cc48..e5eaedbcbe 100644
--- a/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java
@@ -37,14 +37,14 @@ final class DescendingImmutableSortedMultiset<E> extends ImmutableSortedMultiset
     return forward.count(element);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> firstEntry() {
     return forward.lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> lastEntry() {
     return forward.firstEntry();
   }
diff --git a/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java b/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java
index 88c7d6b5cc..0a9eefb847 100644
--- a/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java
+++ b/guava/src/com/google/common/collect/DescendingImmutableSortedSet.java
@@ -65,44 +65,44 @@ final class DescendingImmutableSortedSet<E> extends ImmutableSortedSet<E> {
     return forward.headSet(fromElement, inclusive).descendingSet();
   }
 
-  @Override
   @GwtIncompatible("NavigableSet")
+  @Override
   public ImmutableSortedSet<E> descendingSet() {
     return forward;
   }
 
-  @Override
   @GwtIncompatible("NavigableSet")
+  @Override
   public UnmodifiableIterator<E> descendingIterator() {
     return forward.iterator();
   }
 
-  @Override
   @GwtIncompatible("NavigableSet")
+  @Override
   ImmutableSortedSet<E> createDescendingSet() {
     throw new AssertionError("should never be called");
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E lower(E element) {
     return forward.higher(element);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E floor(E element) {
     return forward.ceiling(element);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E ceiling(E element) {
     return forward.floor(element);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E higher(E element) {
     return forward.lower(element);
   }
diff --git a/guava/src/com/google/common/collect/DescendingMultiset.java b/guava/src/com/google/common/collect/DescendingMultiset.java
index 7db0fbbd49..8bfd959dce 100644
--- a/guava/src/com/google/common/collect/DescendingMultiset.java
+++ b/guava/src/com/google/common/collect/DescendingMultiset.java
@@ -59,14 +59,14 @@ abstract class DescendingMultiset<E extends @Nullable Object> extends Forwarding
     return result;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollFirstEntry() {
     return forwardMultiset().pollLastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollLastEntry() {
     return forwardMultiset().pollFirstEntry();
   }
@@ -102,14 +102,14 @@ abstract class DescendingMultiset<E extends @Nullable Object> extends Forwarding
     return forwardMultiset();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> firstEntry() {
     return forwardMultiset().lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> lastEntry() {
     return forwardMultiset().firstEntry();
   }
diff --git a/guava/src/com/google/common/collect/DiscreteDomain.java b/guava/src/com/google/common/collect/DiscreteDomain.java
index 222ebe5283..a189cfc007 100644
--- a/guava/src/com/google/common/collect/DiscreteDomain.java
+++ b/guava/src/com/google/common/collect/DiscreteDomain.java
@@ -63,15 +63,15 @@ public abstract class DiscreteDomain<C extends Comparable> {
       super(true);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Integer next(Integer value) {
       int i = value;
       return (i == Integer.MAX_VALUE) ? null : i + 1;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Integer previous(Integer value) {
       int i = value;
       return (i == Integer.MIN_VALUE) ? null : i - 1;
@@ -126,15 +126,15 @@ public abstract class DiscreteDomain<C extends Comparable> {
       super(true);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Long next(Long value) {
       long l = value;
       return (l == Long.MAX_VALUE) ? null : l + 1;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Long previous(Long value) {
       long l = value;
       return (l == Long.MIN_VALUE) ? null : l - 1;
@@ -258,10 +258,7 @@ public abstract class DiscreteDomain<C extends Comparable> {
     checkNonnegative(distance, "distance");
     for (long i = 0; i < distance; i++) {
       current = next(current);
-      if (current == null) {
-        throw new IllegalArgumentException(
-            "overflowed computing offset(" + origin + ", " + distance + ")");
-      }
+      checkArgument(current != null, "overflowed computing offset(%s, %s)", origin, distance);
     }
     return current;
   }
diff --git a/guava/src/com/google/common/collect/EnumBiMap.java b/guava/src/com/google/common/collect/EnumBiMap.java
index 97d3c2e7cd..69649c09e7 100644
--- a/guava/src/com/google/common/collect/EnumBiMap.java
+++ b/guava/src/com/google/common/collect/EnumBiMap.java
@@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -106,12 +106,12 @@ public final class EnumBiMap<K extends Enum<K>, V extends Enum<V>> extends Abstr
 
   @Override
   K checkKey(K key) {
-    return checkNotNull(key);
+    return requireNonNull(key);
   }
 
   @Override
   V checkValue(V value) {
-    return checkNotNull(value);
+    return requireNonNull(value);
   }
 
   /**
@@ -126,8 +126,8 @@ public final class EnumBiMap<K extends Enum<K>, V extends Enum<V>> extends Abstr
     Serialization.writeMap(this, stream);
   }
 
-  @SuppressWarnings("unchecked") // reading fields populated by writeObject
-  @GwtIncompatible // java.io.ObjectInputStream
+  @GwtIncompatible // reading fields populated by writeObject
+  @SuppressWarnings("unchecked") // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     keyType = (Class<K>) stream.readObject();
diff --git a/guava/src/com/google/common/collect/EnumHashBiMap.java b/guava/src/com/google/common/collect/EnumHashBiMap.java
index 5fbbb70c63..05e96bbdd3 100644
--- a/guava/src/com/google/common/collect/EnumHashBiMap.java
+++ b/guava/src/com/google/common/collect/EnumHashBiMap.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -85,23 +85,23 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
 
   @Override
   K checkKey(K key) {
-    return checkNotNull(key);
+    return requireNonNull(key);
   }
 
   @CanIgnoreReturnValue
-  @Override
-  @SuppressWarnings("RedundantOverride") // b/192446478: RedundantOverride ignores some annotations.
-  // TODO(b/192446998): Remove this override after tools understand nullness better.
   @CheckForNull
+  @Override // b/192446478: RedundantOverride ignores some annotations.
+  // TODO(b/192446998): Remove this override after tools understand nullness better.
+  @SuppressWarnings("RedundantOverride")
   public V put(K key, @ParametricNullness V value) {
     return super.put(key, value);
   }
 
   @CanIgnoreReturnValue
-  @Override
-  @SuppressWarnings("RedundantOverride") // b/192446478: RedundantOverride ignores some annotations.
-  // TODO(b/192446998): Remove this override after tools understand nullness better.
   @CheckForNull
+  @Override // b/192446478: RedundantOverride ignores some annotations.
+  // TODO(b/192446998): Remove this override after tools understand nullness better.
+  @SuppressWarnings("RedundantOverride")
   public V forcePut(K key, @ParametricNullness V value) {
     return super.forcePut(key, value);
   }
@@ -122,8 +122,8 @@ public final class EnumHashBiMap<K extends Enum<K>, V extends @Nullable Object>
     Serialization.writeMap(this, stream);
   }
 
-  @SuppressWarnings("unchecked") // reading field populated by writeObject
-  @GwtIncompatible // java.io.ObjectInputStream
+  @GwtIncompatible // reading field populated by writeObject
+  @SuppressWarnings("unchecked") // java.io.ObjectInputStream
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
     keyType = (Class<K>) stream.readObject();
diff --git a/guava/src/com/google/common/collect/EnumMultiset.java b/guava/src/com/google/common/collect/EnumMultiset.java
index 778902ede6..39131283e2 100644
--- a/guava/src/com/google/common/collect/EnumMultiset.java
+++ b/guava/src/com/google/common/collect/EnumMultiset.java
@@ -15,9 +15,9 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -108,7 +108,7 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
    * either a NullPointerException or a ClassCastException as appropriate.
    */
   private void checkIsE(Object element) {
-    checkNotNull(element);
+    requireNonNull(element);
     if (!isActuallyE(element)) {
       throw new ClassCastException("Expected an " + type + " but got " + element);
     }
@@ -279,7 +279,7 @@ public final class EnumMultiset<E extends Enum<E>> extends AbstractMultiset<E>
 
   @Override
   public void forEachEntry(ObjIntConsumer<? super E> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     for (int i = 0; i < enumConstants.length; i++) {
       if (counts[i] > 0) {
         action.accept(enumConstants[i], counts[i]);
diff --git a/guava/src/com/google/common/collect/EvictingQueue.java b/guava/src/com/google/common/collect/EvictingQueue.java
index 5667dfa8c0..611dfe153a 100644
--- a/guava/src/com/google/common/collect/EvictingQueue.java
+++ b/guava/src/com/google/common/collect/EvictingQueue.java
@@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -89,8 +89,8 @@ public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serial
    *
    * @return {@code true} always
    */
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean offer(E e) {
     return add(e);
   }
@@ -101,10 +101,10 @@ public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serial
    *
    * @return {@code true} always
    */
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean add(E e) {
-    checkNotNull(e); // check before removing
+    requireNonNull(e); // check before removing
     if (maxSize == 0) {
       return true;
     }
@@ -115,8 +115,8 @@ public final class EvictingQueue<E> extends ForwardingQueue<E> implements Serial
     return true;
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean addAll(Collection<? extends E> collection) {
     int size = collection.size();
     if (size >= maxSize) {
diff --git a/guava/src/com/google/common/collect/FilteredEntryMultimap.java b/guava/src/com/google/common/collect/FilteredEntryMultimap.java
index de946a215f..cc0de6e895 100644
--- a/guava/src/com/google/common/collect/FilteredEntryMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredEntryMultimap.java
@@ -16,10 +16,12 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Collections.unmodifiableSet;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.MoreObjects;
@@ -50,8 +52,8 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
   final Predicate<? super Entry<K, V>> predicate;
 
   FilteredEntryMultimap(Multimap<K, V> unfiltered, Predicate<? super Entry<K, V>> predicate) {
-    this.unfiltered = checkNotNull(unfiltered);
-    this.predicate = checkNotNull(predicate);
+    this.unfiltered = requireNonNull(unfiltered);
+    this.predicate = requireNonNull(predicate);
   }
 
   @Override
@@ -178,8 +180,8 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
       FilteredEntryMultimap.this.clear();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Collection<V> get(@CheckForNull Object key) {
       Collection<V> result = unfiltered.asMap().get(key);
       if (result == null) {
@@ -191,8 +193,8 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
       return result.isEmpty() ? null : result;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Collection<V> remove(@CheckForNull Object key) {
       Collection<V> collection = unfiltered.asMap().get(key);
       if (collection == null) {
@@ -212,9 +214,9 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
       if (result.isEmpty()) {
         return null;
       } else if (unfiltered instanceof SetMultimap) {
-        return Collections.unmodifiableSet(Sets.newLinkedHashSet(result));
+        return unmodifiableSet(Sets.newLinkedHashSet(result));
       } else {
-        return Collections.unmodifiableList(result);
+        return unmodifiableList(result);
       }
     }
 
@@ -259,8 +261,8 @@ class FilteredEntryMultimap<K extends @Nullable Object, V extends @Nullable Obje
             final Iterator<Entry<K, Collection<V>>> backingIterator =
                 unfiltered.asMap().entrySet().iterator();
 
-            @Override
             @CheckForNull
+            @Override
             protected Entry<K, Collection<V>> computeNext() {
               while (backingIterator.hasNext()) {
                 Entry<K, Collection<V>> entry = backingIterator.next();
diff --git a/guava/src/com/google/common/collect/FilteredKeyMultimap.java b/guava/src/com/google/common/collect/FilteredKeyMultimap.java
index 68fad75b14..e90a06ad9d 100644
--- a/guava/src/com/google/common/collect/FilteredKeyMultimap.java
+++ b/guava/src/com/google/common/collect/FilteredKeyMultimap.java
@@ -14,17 +14,16 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static java.util.Collections.emptyList;
 import static java.util.Collections.emptySet;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Predicate;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -46,8 +45,8 @@ class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object
   final Predicate<? super K> keyPredicate;
 
   FilteredKeyMultimap(Multimap<K, V> unfiltered, Predicate<? super K> keyPredicate) {
-    this.unfiltered = checkNotNull(unfiltered);
-    this.keyPredicate = checkNotNull(keyPredicate);
+    this.unfiltered = requireNonNull(unfiltered);
+    this.keyPredicate = requireNonNull(keyPredicate);
   }
 
   @Override
@@ -128,13 +127,13 @@ class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object
 
     @Override
     public boolean addAll(Collection<? extends V> collection) {
-      checkNotNull(collection);
+      requireNonNull(collection);
       throw new IllegalArgumentException("Key does not satisfy predicate: " + key);
     }
 
     @Override
     protected Set<V> delegate() {
-      return Collections.emptySet();
+      return emptySet();
     }
   }
 
@@ -167,14 +166,14 @@ class FilteredKeyMultimap<K extends @Nullable Object, V extends @Nullable Object
     @CanIgnoreReturnValue
     @Override
     public boolean addAll(int index, Collection<? extends V> elements) {
-      checkNotNull(elements);
+      requireNonNull(elements);
       checkPositionIndex(index, 0);
       throw new IllegalArgumentException("Key does not satisfy predicate: " + key);
     }
 
     @Override
     protected List<V> delegate() {
-      return Collections.emptyList();
+      return emptyList();
     }
   }
 
diff --git a/guava/src/com/google/common/collect/FilteredMultimapValues.java b/guava/src/com/google/common/collect/FilteredMultimapValues.java
index ecbfab2a1d..be1f6bcd64 100644
--- a/guava/src/com/google/common/collect/FilteredMultimapValues.java
+++ b/guava/src/com/google/common/collect/FilteredMultimapValues.java
@@ -14,7 +14,9 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Predicates.not;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
@@ -40,7 +42,7 @@ final class FilteredMultimapValues<K extends @Nullable Object, V extends @Nullab
   @Weak private final FilteredMultimap<K, V> multimap;
 
   FilteredMultimapValues(FilteredMultimap<K, V> multimap) {
-    this.multimap = checkNotNull(multimap);
+    this.multimap = requireNonNull(multimap);
   }
 
   @Override
@@ -78,7 +80,7 @@ final class FilteredMultimapValues<K extends @Nullable Object, V extends @Nullab
         multimap.unfiltered().entries(),
         // explicit <Entry<K, V>> is required to build with JDK6
         Predicates.<Entry<K, V>>and(
-            multimap.entryPredicate(), Maps.<V>valuePredicateOnEntries(Predicates.in(c))));
+            multimap.entryPredicate(), Maps.<V>valuePredicateOnEntries(in(c))));
   }
 
   @Override
@@ -87,8 +89,7 @@ final class FilteredMultimapValues<K extends @Nullable Object, V extends @Nullab
         multimap.unfiltered().entries(),
         // explicit <Entry<K, V>> is required to build with JDK6
         Predicates.<Entry<K, V>>and(
-            multimap.entryPredicate(),
-            Maps.<V>valuePredicateOnEntries(Predicates.not(Predicates.in(c)))));
+            multimap.entryPredicate(), Maps.<V>valuePredicateOnEntries(not(in(c)))));
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/FluentIterable.java b/guava/src/com/google/common/collect/FluentIterable.java
index 11bda3bde9..af236309bb 100644
--- a/guava/src/com/google/common/collect/FluentIterable.java
+++ b/guava/src/com/google/common/collect/FluentIterable.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -175,9 +175,9 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
   @Deprecated
   @InlineMe(
       replacement = "checkNotNull(iterable)",
-      staticImports = {"com.google.common.base.Preconditions.checkNotNull"})
+      staticImports = "com.google.common.base.Preconditions.checkNotNull")
   public static <E extends @Nullable Object> FluentIterable<E> from(FluentIterable<E> iterable) {
-    return checkNotNull(iterable);
+    return requireNonNull(iterable);
   }
 
   /**
@@ -278,7 +278,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
   @Beta
   public static <T extends @Nullable Object> FluentIterable<T> concat(
       final Iterable<? extends Iterable<? extends T>> inputs) {
-    checkNotNull(inputs);
+    requireNonNull(inputs);
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
@@ -291,7 +291,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
   private static <T extends @Nullable Object> FluentIterable<T> concatNoDefensiveCopy(
       final Iterable<? extends T>... inputs) {
     for (Iterable<? extends T> input : inputs) {
-      checkNotNull(input);
+      requireNonNull(input);
     }
     return new FluentIterable<T>() {
       @Override
@@ -613,7 +613,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    * <p><b>{@code Stream} equivalent:</b> {@code !stream.findAny().isPresent()}.
    */
   public final boolean isEmpty() {
-    return !getDelegate().iterator().hasNext();
+    return Iterables.isEmpty(getDelegate());
   }
 
   /**
@@ -812,7 +812,7 @@ public abstract class FluentIterable<E extends @Nullable Object> implements Iter
    */
   @CanIgnoreReturnValue
   public final <C extends Collection<? super E>> C copyInto(C collection) {
-    checkNotNull(collection);
+    requireNonNull(collection);
     Iterable<E> iterable = getDelegate();
     if (iterable instanceof Collection) {
       collection.addAll((Collection<E>) iterable);
diff --git a/guava/src/com/google/common/collect/ForwardingBlockingDeque.java b/guava/src/com/google/common/collect/ForwardingBlockingDeque.java
index 49d4bcf6c2..314e487787 100644
--- a/guava/src/com/google/common/collect/ForwardingBlockingDeque.java
+++ b/guava/src/com/google/common/collect/ForwardingBlockingDeque.java
@@ -92,14 +92,14 @@ public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
     return delegate().takeLast();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E pollFirst(long timeout, TimeUnit unit) throws InterruptedException {
     return delegate().pollFirst(timeout, unit);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E pollLast(long timeout, TimeUnit unit) throws InterruptedException {
     return delegate().pollLast(timeout, unit);
   }
@@ -119,8 +119,8 @@ public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
     return delegate().take();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E poll(long timeout, TimeUnit unit) throws InterruptedException {
     return delegate().poll(timeout, unit);
   }
diff --git a/guava/src/com/google/common/collect/ForwardingCollection.java b/guava/src/com/google/common/collect/ForwardingCollection.java
index ca1edc1183..ecc7b5f865 100644
--- a/guava/src/com/google/common/collect/ForwardingCollection.java
+++ b/guava/src/com/google/common/collect/ForwardingCollection.java
@@ -221,7 +221,7 @@ public abstract class ForwardingCollection<E extends @Nullable Object> extends F
    * @since 7.0
    */
   protected boolean standardIsEmpty() {
-    return !iterator().hasNext();
+    return this.isEmpty();
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/ForwardingConcurrentMap.java b/guava/src/com/google/common/collect/ForwardingConcurrentMap.java
index b662b0774a..fdeb097e02 100644
--- a/guava/src/com/google/common/collect/ForwardingConcurrentMap.java
+++ b/guava/src/com/google/common/collect/ForwardingConcurrentMap.java
@@ -48,8 +48,8 @@ public abstract class ForwardingConcurrentMap<K, V> extends ForwardingMap<K, V>
   protected abstract ConcurrentMap<K, V> delegate();
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V putIfAbsent(K key, V value) {
     return delegate().putIfAbsent(key, value);
   }
@@ -61,8 +61,8 @@ public abstract class ForwardingConcurrentMap<K, V> extends ForwardingMap<K, V>
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V replace(K key, V value) {
     return delegate().replace(key, value);
   }
diff --git a/guava/src/com/google/common/collect/ForwardingDeque.java b/guava/src/com/google/common/collect/ForwardingDeque.java
index 571535cab9..8abe48892e 100644
--- a/guava/src/com/google/common/collect/ForwardingDeque.java
+++ b/guava/src/com/google/common/collect/ForwardingDeque.java
@@ -90,28 +90,28 @@ public abstract class ForwardingDeque<E extends @Nullable Object> extends Forwar
     return delegate().offerLast(e);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E peekFirst() {
     return delegate().peekFirst();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E peekLast() {
     return delegate().peekLast();
   }
 
   @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
-  @Override
   @CheckForNull
+  @Override
   public E pollFirst() {
     return delegate().pollFirst();
   }
 
   @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
-  @Override
   @CheckForNull
+  @Override
   public E pollLast() {
     return delegate().pollLast();
   }
diff --git a/guava/src/com/google/common/collect/ForwardingMap.java b/guava/src/com/google/common/collect/ForwardingMap.java
index 315a4fabca..085ab22260 100644
--- a/guava/src/com/google/common/collect/ForwardingMap.java
+++ b/guava/src/com/google/common/collect/ForwardingMap.java
@@ -78,8 +78,8 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V remove(@CheckForNull Object key) {
     return delegate().remove(key);
   }
@@ -99,15 +99,15 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
     return delegate().containsValue(value);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return delegate().get(key);
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
     return delegate().put(key, value);
   }
@@ -274,7 +274,7 @@ public abstract class ForwardingMap<K extends @Nullable Object, V extends @Nulla
    * @since 7.0
    */
   protected boolean standardIsEmpty() {
-    return !entrySet().iterator().hasNext();
+    return this.isEmpty();
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/ForwardingNavigableMap.java b/guava/src/com/google/common/collect/ForwardingNavigableMap.java
index c32468da1d..cb690b8975 100644
--- a/guava/src/com/google/common/collect/ForwardingNavigableMap.java
+++ b/guava/src/com/google/common/collect/ForwardingNavigableMap.java
@@ -16,6 +16,7 @@
 
 package com.google.common.collect;
 
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Maps.keyOrNull;
 
 import com.google.common.annotations.Beta;
@@ -66,8 +67,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
   @Override
   protected abstract NavigableMap<K, V> delegate();
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> lowerEntry(@ParametricNullness K key) {
     return delegate().lowerEntry(key);
   }
@@ -82,8 +83,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return headMap(key, false).lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K lowerKey(@ParametricNullness K key) {
     return delegate().lowerKey(key);
   }
@@ -98,8 +99,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return keyOrNull(lowerEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> floorEntry(@ParametricNullness K key) {
     return delegate().floorEntry(key);
   }
@@ -114,8 +115,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return headMap(key, true).lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K floorKey(@ParametricNullness K key) {
     return delegate().floorKey(key);
   }
@@ -130,8 +131,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return keyOrNull(floorEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> ceilingEntry(@ParametricNullness K key) {
     return delegate().ceilingEntry(key);
   }
@@ -146,8 +147,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return tailMap(key, true).firstEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K ceilingKey(@ParametricNullness K key) {
     return delegate().ceilingKey(key);
   }
@@ -162,8 +163,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return keyOrNull(ceilingEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> higherEntry(@ParametricNullness K key) {
     return delegate().higherEntry(key);
   }
@@ -178,8 +179,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return tailMap(key, false).firstEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K higherKey(@ParametricNullness K key) {
     return delegate().higherKey(key);
   }
@@ -194,8 +195,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return keyOrNull(higherEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> firstEntry() {
     return delegate().firstEntry();
   }
@@ -224,8 +225,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> lastEntry() {
     return delegate().lastEntry();
   }
@@ -253,8 +254,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> pollFirstEntry() {
     return delegate().pollFirstEntry();
   }
@@ -269,8 +270,8 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
     return Iterators.pollNext(entrySet().iterator());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> pollLastEntry() {
     return delegate().pollLastEntry();
   }
@@ -342,9 +343,7 @@ public abstract class ForwardingNavigableMap<K extends @Nullable Object, V exten
 
         @Override
         public void remove() {
-          if (toRemove == null) {
-            throw new IllegalStateException("no calls to next() since the last call to remove()");
-          }
+          checkState(toRemove != null, "no calls to next() since the last call to remove()");
           forward().remove(toRemove.getKey());
           toRemove = null;
         }
diff --git a/guava/src/com/google/common/collect/ForwardingNavigableSet.java b/guava/src/com/google/common/collect/ForwardingNavigableSet.java
index 6822aa87d4..c8f509ddbb 100644
--- a/guava/src/com/google/common/collect/ForwardingNavigableSet.java
+++ b/guava/src/com/google/common/collect/ForwardingNavigableSet.java
@@ -61,8 +61,8 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
   @Override
   protected abstract NavigableSet<E> delegate();
 
-  @Override
   @CheckForNull
+  @Override
   public E lower(@ParametricNullness E e) {
     return delegate().lower(e);
   }
@@ -77,8 +77,8 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
     return Iterators.getNext(headSet(e, false).descendingIterator(), null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E floor(@ParametricNullness E e) {
     return delegate().floor(e);
   }
@@ -93,8 +93,8 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
     return Iterators.getNext(headSet(e, true).descendingIterator(), null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E ceiling(@ParametricNullness E e) {
     return delegate().ceiling(e);
   }
@@ -109,8 +109,8 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
     return Iterators.getNext(tailSet(e, true).iterator(), null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E higher(@ParametricNullness E e) {
     return delegate().higher(e);
   }
@@ -125,8 +125,8 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
     return Iterators.getNext(tailSet(e, false).iterator(), null);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E pollFirst() {
     return delegate().pollFirst();
   }
@@ -141,8 +141,8 @@ public abstract class ForwardingNavigableSet<E extends @Nullable Object>
     return Iterators.pollNext(iterator());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E pollLast() {
     return delegate().pollLast();
   }
diff --git a/guava/src/com/google/common/collect/ForwardingQueue.java b/guava/src/com/google/common/collect/ForwardingQueue.java
index 43c2eaafb5..47c5caf393 100644
--- a/guava/src/com/google/common/collect/ForwardingQueue.java
+++ b/guava/src/com/google/common/collect/ForwardingQueue.java
@@ -63,8 +63,8 @@ public abstract class ForwardingQueue<E extends @Nullable Object> extends Forwar
   }
 
   @CanIgnoreReturnValue // TODO(cpovirk): Consider removing this?
-  @Override
   @CheckForNull
+  @Override
   public E poll() {
     return delegate().poll();
   }
@@ -76,8 +76,8 @@ public abstract class ForwardingQueue<E extends @Nullable Object> extends Forwar
     return delegate().remove();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E peek() {
     return delegate().peek();
   }
diff --git a/guava/src/com/google/common/collect/ForwardingSet.java b/guava/src/com/google/common/collect/ForwardingSet.java
index bc27272b02..159bb46d92 100644
--- a/guava/src/com/google/common/collect/ForwardingSet.java
+++ b/guava/src/com/google/common/collect/ForwardingSet.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
@@ -77,7 +77,7 @@ public abstract class ForwardingSet<E extends @Nullable Object> extends Forwardi
    */
   @Override
   protected boolean standardRemoveAll(Collection<?> collection) {
-    return Sets.removeAllImpl(this, checkNotNull(collection)); // for GWT
+    return Sets.removeAllImpl(this, requireNonNull(collection)); // for GWT
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/ForwardingSortedMap.java b/guava/src/com/google/common/collect/ForwardingSortedMap.java
index e0882abc7a..9f8e64c3c3 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedMap.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedMap.java
@@ -63,8 +63,8 @@ public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends
   @Override
   protected abstract SortedMap<K, V> delegate();
 
-  @Override
   @CheckForNull
+  @Override
   public Comparator<? super K> comparator() {
     return delegate().comparator();
   }
@@ -112,7 +112,7 @@ public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends
   }
 
   // unsafe, but worst case is a CCE or NPE is thrown, which callers will be expecting
-  @SuppressWarnings({"unchecked", "nullness"})
+  @SuppressWarnings({"nullness", "unchecked"})
   static int unsafeCompare(
       @CheckForNull Comparator<?> comparator, @CheckForNull Object o1, @CheckForNull Object o2) {
     if (comparator == null) {
@@ -129,12 +129,12 @@ public abstract class ForwardingSortedMap<K extends @Nullable Object, V extends
    *
    * @since 7.0
    */
-  @Override
   @Beta
+  @Override
   protected boolean standardContainsKey(@CheckForNull Object key) {
     try {
       // any CCE or NPE will be caught
-      @SuppressWarnings({"unchecked", "nullness"})
+      @SuppressWarnings({"nullness", "unchecked"})
       SortedMap<@Nullable Object, V> self = (SortedMap<@Nullable Object, V>) this;
       Object ceilingKey = self.tailMap(key).firstKey();
       return unsafeCompare(comparator(), ceilingKey, key) == 0;
diff --git a/guava/src/com/google/common/collect/ForwardingSortedMultiset.java b/guava/src/com/google/common/collect/ForwardingSortedMultiset.java
index 4626d3193a..e7e82b560d 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedMultiset.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedMultiset.java
@@ -112,8 +112,8 @@ public abstract class ForwardingSortedMultiset<E extends @Nullable Object>
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> firstEntry() {
     return delegate().firstEntry();
   }
@@ -134,8 +134,8 @@ public abstract class ForwardingSortedMultiset<E extends @Nullable Object>
     return Multisets.immutableEntry(entry.getElement(), entry.getCount());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> lastEntry() {
     return delegate().lastEntry();
   }
@@ -157,8 +157,8 @@ public abstract class ForwardingSortedMultiset<E extends @Nullable Object>
     return Multisets.immutableEntry(entry.getElement(), entry.getCount());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollFirstEntry() {
     return delegate().pollFirstEntry();
   }
@@ -181,8 +181,8 @@ public abstract class ForwardingSortedMultiset<E extends @Nullable Object>
     return entry;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollLastEntry() {
     return delegate().pollLastEntry();
   }
diff --git a/guava/src/com/google/common/collect/ForwardingSortedSet.java b/guava/src/com/google/common/collect/ForwardingSortedSet.java
index 32625afd16..d5695a3788 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedSet.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedSet.java
@@ -65,8 +65,8 @@ public abstract class ForwardingSortedSet<E extends @Nullable Object> extends Fo
   @Override
   protected abstract SortedSet<E> delegate();
 
-  @Override
   @CheckForNull
+  @Override
   public Comparator<? super E> comparator() {
     return delegate().comparator();
   }
@@ -105,12 +105,12 @@ public abstract class ForwardingSortedSet<E extends @Nullable Object> extends Fo
    *
    * @since 7.0
    */
-  @Override
   @Beta
+  @Override
   protected boolean standardContains(@CheckForNull Object object) {
     try {
       // any ClassCastExceptions and NullPointerExceptions are caught
-      @SuppressWarnings({"unchecked", "nullness"})
+      @SuppressWarnings({"nullness", "unchecked"})
       SortedSet<@Nullable Object> self = (SortedSet<@Nullable Object>) this;
       Object ceiling = self.tailSet(object).first();
       return unsafeCompare(comparator(), ceiling, object) == 0;
@@ -126,12 +126,12 @@ public abstract class ForwardingSortedSet<E extends @Nullable Object> extends Fo
    *
    * @since 7.0
    */
-  @Override
   @Beta
+  @Override
   protected boolean standardRemove(@CheckForNull Object object) {
     try {
       // any ClassCastExceptions and NullPointerExceptions are caught
-      @SuppressWarnings({"unchecked", "nullness"})
+      @SuppressWarnings({"nullness", "unchecked"})
       SortedSet<@Nullable Object> self = (SortedSet<@Nullable Object>) this;
       Iterator<?> iterator = self.tailSet(object).iterator();
       if (iterator.hasNext()) {
diff --git a/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java b/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java
index b91a68b344..05d64a8742 100644
--- a/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java
+++ b/guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java
@@ -61,8 +61,8 @@ public abstract class ForwardingSortedSetMultimap<
     return delegate().replaceValues(key, values);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Comparator<? super V> valueComparator() {
     return delegate().valueComparator();
   }
diff --git a/guava/src/com/google/common/collect/ForwardingTable.java b/guava/src/com/google/common/collect/ForwardingTable.java
index 4fcb858b72..adf7be43b6 100644
--- a/guava/src/com/google/common/collect/ForwardingTable.java
+++ b/guava/src/com/google/common/collect/ForwardingTable.java
@@ -88,8 +88,8 @@ public abstract class ForwardingTable<
     return delegate().containsValue(value);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     return delegate().get(rowKey, columnKey);
   }
@@ -100,8 +100,8 @@ public abstract class ForwardingTable<
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(
       @ParametricNullness R rowKey, @ParametricNullness C columnKey, @ParametricNullness V value) {
     return delegate().put(rowKey, columnKey, value);
@@ -113,8 +113,8 @@ public abstract class ForwardingTable<
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     return delegate().remove(rowKey, columnKey);
   }
diff --git a/guava/src/com/google/common/collect/GeneralRange.java b/guava/src/com/google/common/collect/GeneralRange.java
index 3d7256ff81..b65d87a04a 100644
--- a/guava/src/com/google/common/collect/GeneralRange.java
+++ b/guava/src/com/google/common/collect/GeneralRange.java
@@ -15,10 +15,10 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.BoundType.CLOSED;
 import static com.google.common.collect.BoundType.OPEN;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
@@ -108,13 +108,13 @@ final class GeneralRange<T extends @Nullable Object> implements Serializable {
       boolean hasUpperBound,
       @CheckForNull T upperEndpoint,
       BoundType upperBoundType) {
-    this.comparator = checkNotNull(comparator);
+    this.comparator = requireNonNull(comparator);
     this.hasLowerBound = hasLowerBound;
     this.hasUpperBound = hasUpperBound;
     this.lowerEndpoint = lowerEndpoint;
-    this.lowerBoundType = checkNotNull(lowerBoundType);
+    this.lowerBoundType = requireNonNull(lowerBoundType);
     this.upperEndpoint = upperEndpoint;
-    this.upperBoundType = checkNotNull(upperBoundType);
+    this.upperBoundType = requireNonNull(upperBoundType);
 
     // Trigger any exception that the comparator would throw for the endpoints.
     /*
@@ -190,7 +190,7 @@ final class GeneralRange<T extends @Nullable Object> implements Serializable {
    */
   @SuppressWarnings("nullness") // TODO(cpovirk): Add casts as needed. Will be noisy and annoying...
   GeneralRange<T> intersect(GeneralRange<T> other) {
-    checkNotNull(other);
+    requireNonNull(other);
     checkArgument(comparator.equals(other.comparator));
 
     boolean hasLowBound = this.hasLowerBound;
@@ -243,8 +243,8 @@ final class GeneralRange<T extends @Nullable Object> implements Serializable {
       return comparator.equals(r.comparator)
           && hasLowerBound == r.hasLowerBound
           && hasUpperBound == r.hasUpperBound
-          && getLowerBoundType().equals(r.getLowerBoundType())
-          && getUpperBoundType().equals(r.getUpperBoundType())
+          && getLowerBoundType() == r.getLowerBoundType()
+          && getUpperBoundType() == r.getUpperBoundType()
           && Objects.equal(getLowerEndpoint(), r.getLowerEndpoint())
           && Objects.equal(getUpperEndpoint(), r.getUpperEndpoint());
     }
diff --git a/guava/src/com/google/common/collect/HashBiMap.java b/guava/src/com/google/common/collect/HashBiMap.java
index b0a5dd50ed..06cd9c4b01 100644
--- a/guava/src/com/google/common/collect/HashBiMap.java
+++ b/guava/src/com/google/common/collect/HashBiMap.java
@@ -15,7 +15,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.Hashing.smearedHash;
 import static java.util.Objects.requireNonNull;
@@ -277,15 +277,15 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     return seekByValue(value, smearedHash(value)) != null;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return Maps.valueOrNull(seekByKey(key, smearedHash(key)));
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(@ParametricNullness K key, @ParametricNullness V value) {
     return put(key, value, false);
   }
@@ -326,8 +326,8 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V forcePut(@ParametricNullness K key, @ParametricNullness V value) {
     return put(key, value, true);
   }
@@ -396,14 +396,14 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
     }
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   private @Nullable BiEntry<K, V>[] createTable(int length) {
     return new @Nullable BiEntry[length];
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V remove(@CheckForNull Object key) {
     BiEntry<K, V> entry = seekByKey(key, smearedHash(key));
     if (entry == null) {
@@ -464,9 +464,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
       if (modCount != expectedModCount) {
         throw new ConcurrentModificationException();
       }
-      if (toRemove == null) {
-        throw new IllegalStateException("no calls to next() since the last call to remove()");
-      }
+      checkState(toRemove != null, "no calls to next() since the last call to remove()");
       delete(toRemove);
       expectedModCount = modCount;
       toRemove = null;
@@ -569,7 +567,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     for (BiEntry<K, V> entry = firstInKeyInsertionOrder;
         entry != null;
         entry = entry.nextInKeyInsertionOrder) {
@@ -579,7 +577,7 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
 
   @Override
   public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     BiEntry<K, V> oldFirst = firstInKeyInsertionOrder;
     clear();
     for (BiEntry<K, V> entry = oldFirst; entry != null; entry = entry.nextInKeyInsertionOrder) {
@@ -616,27 +614,27 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
       return forward().containsValue(value);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K get(@CheckForNull Object value) {
       return Maps.keyOrNull(seekByValue(value, smearedHash(value)));
     }
 
     @CanIgnoreReturnValue
-    @Override
     @CheckForNull
+    @Override
     public K put(@ParametricNullness V value, @ParametricNullness K key) {
       return putInverse(value, key, false);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K forcePut(@ParametricNullness V value, @ParametricNullness K key) {
       return putInverse(value, key, true);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K remove(@CheckForNull Object value) {
       BiEntry<K, V> entry = seekByValue(value, smearedHash(value));
       if (entry == null) {
@@ -742,13 +740,13 @@ public final class HashBiMap<K extends @Nullable Object, V extends @Nullable Obj
 
     @Override
     public void forEach(BiConsumer<? super V, ? super K> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       HashBiMap.this.forEach((k, v) -> action.accept(v, k));
     }
 
     @Override
     public void replaceAll(BiFunction<? super V, ? super K, ? extends K> function) {
-      checkNotNull(function);
+      requireNonNull(function);
       BiEntry<K, V> oldFirst = firstInKeyInsertionOrder;
       clear();
       for (BiEntry<K, V> entry = oldFirst; entry != null; entry = entry.nextInKeyInsertionOrder) {
diff --git a/guava/src/com/google/common/collect/HashMultimap.java b/guava/src/com/google/common/collect/HashMultimap.java
index 9e4c1c2233..ff604b807f 100644
--- a/guava/src/com/google/common/collect/HashMultimap.java
+++ b/guava/src/com/google/common/collect/HashMultimap.java
@@ -16,10 +16,11 @@
 
 package com.google.common.collect;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -105,7 +106,7 @@ public final class HashMultimap<K extends @Nullable Object, V extends @Nullable
 
   private HashMultimap(int expectedKeys, int expectedValuesPerKey) {
     super(Platform.<K, Collection<V>>newHashMapWithExpectedSize(expectedKeys));
-    Preconditions.checkArgument(expectedValuesPerKey >= 0);
+    checkArgument(expectedValuesPerKey >= 0);
     this.expectedValuesPerKey = expectedValuesPerKey;
   }
 
diff --git a/guava/src/com/google/common/collect/ImmutableBiMap.java b/guava/src/com/google/common/collect/ImmutableBiMap.java
index 4c222c1bf9..5a7fc393d8 100644
--- a/guava/src/com/google/common/collect/ImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/ImmutableBiMap.java
@@ -390,8 +390,8 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      * @throws NullPointerException if any key, value, or entry is null
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
@@ -408,16 +408,16 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      * @throws IllegalStateException if this method was already called
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator) {
       super.orderEntriesByValue(valueComparator);
       return this;
     }
 
-    @Override
     @CanIgnoreReturnValue
+    @Override
     Builder<K, V> combine(ImmutableMap.Builder<K, V> builder) {
       super.combine(builder);
       return this;
@@ -488,8 +488,8 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
      * @deprecated This method does not make sense for bimaps and should not be called.
      * @since 31.1
      */
-    @DoNotCall
     @Deprecated
+    @DoNotCall
     @Override
     public ImmutableBiMap<K, V> buildKeepingLast() {
       throw new UnsupportedOperationException("Not supported for bimaps");
@@ -604,10 +604,10 @@ public abstract class ImmutableBiMap<K, V> extends ImmutableBiMapFauxverideShim<
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final V forcePut(K key, V value) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java b/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java
index c59e9fdaba..daf64f1cab 100644
--- a/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java
+++ b/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Primitives;
@@ -172,11 +172,11 @@ public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<?
     return delegate;
   }
 
-  @Override
-  @SuppressWarnings("unchecked") // value could not get in if not a T
   @CheckForNull
+  @Override // value could not get in if not a T
+  @SuppressWarnings("unchecked")
   public <T extends B> T getInstance(Class<T> type) {
-    return (T) delegate.get(checkNotNull(type));
+    return (T) delegate.get(requireNonNull(type));
   }
 
   /**
@@ -186,10 +186,10 @@ public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<?
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public <T extends B> T putInstance(Class<T> type, T value) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableCollection.java b/guava/src/com/google/common/collect/ImmutableCollection.java
index 314f83cce9..45592d8b7b 100644
--- a/guava/src/com/google/common/collect/ImmutableCollection.java
+++ b/guava/src/com/google/common/collect/ImmutableCollection.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -209,7 +209,7 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @SuppressWarnings("nullness")
   public final <T extends @Nullable Object> T[] toArray(T[] other) {
-    checkNotNull(other);
+    requireNonNull(other);
     int size = size();
 
     if (other.length < size) {
@@ -258,8 +258,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean add(E e) {
     throw new UnsupportedOperationException();
   }
@@ -272,8 +272,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean remove(@CheckForNull Object object) {
     throw new UnsupportedOperationException();
   }
@@ -286,8 +286,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean addAll(Collection<? extends E> newElements) {
     throw new UnsupportedOperationException();
   }
@@ -300,8 +300,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean removeAll(Collection<?> oldElements) {
     throw new UnsupportedOperationException();
   }
@@ -314,8 +314,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean removeIf(Predicate<? super E> filter) {
     throw new UnsupportedOperationException();
   }
@@ -327,8 +327,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean retainAll(Collection<?> elementsToKeep) {
     throw new UnsupportedOperationException();
   }
@@ -340,8 +340,8 @@ public abstract class ImmutableCollection<E> extends AbstractCollection<E> imple
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void clear() {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableEnumMap.java b/guava/src/com/google/common/collect/ImmutableEnumMap.java
index d1e10f97d0..b932253cb7 100644
--- a/guava/src/com/google/common/collect/ImmutableEnumMap.java
+++ b/guava/src/com/google/common/collect/ImmutableEnumMap.java
@@ -74,8 +74,8 @@ final class ImmutableEnumMap<K extends Enum<K>, V> extends IteratorBasedImmutabl
     return delegate.containsKey(key);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return delegate.get(key);
   }
diff --git a/guava/src/com/google/common/collect/ImmutableList.java b/guava/src/com/google/common/collect/ImmutableList.java
index bc8166507d..313f78199d 100644
--- a/guava/src/com/google/common/collect/ImmutableList.java
+++ b/guava/src/com/google/common/collect/ImmutableList.java
@@ -18,7 +18,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
@@ -233,7 +232,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @throws NullPointerException if {@code elements} contains a null element
    */
   public static <E> ImmutableList<E> copyOf(Iterable<? extends E> elements) {
-    checkNotNull(elements); // TODO(kevinb): is this here only for GWT?
+    requireNonNull(elements); // TODO(kevinb): is this here only for GWT?
     return (elements instanceof Collection)
         ? copyOf((Collection<? extends E>) elements)
         : copyOf(elements.iterator());
@@ -340,7 +339,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   public static <E> ImmutableList<E> sortedCopyOf(
       Comparator<? super E> comparator, Iterable<? extends E> elements) {
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     @SuppressWarnings("unchecked") // all supported methods are covariant
     E[] array = (E[]) Iterables.toArray(elements);
     checkElementsNotNull(array);
@@ -416,7 +415,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
 
   @Override
   public void forEach(Consumer<? super E> consumer) {
-    checkNotNull(consumer);
+    requireNonNull(consumer);
     int n = size();
     for (int i = 0; i < n; i++) {
       consumer.accept(get(i));
@@ -508,8 +507,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean addAll(int index, Collection<? extends E> newElements) {
     throw new UnsupportedOperationException();
   }
@@ -522,8 +521,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final E set(int index, E element) {
     throw new UnsupportedOperationException();
   }
@@ -535,8 +534,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void add(int index, E element) {
     throw new UnsupportedOperationException();
   }
@@ -549,8 +548,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final E remove(int index) {
     throw new UnsupportedOperationException();
   }
@@ -562,8 +561,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void replaceAll(UnaryOperator<E> operator) {
     throw new UnsupportedOperationException();
   }
@@ -575,8 +574,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void sort(Comparator<? super E> c) {
     throw new UnsupportedOperationException();
   }
@@ -587,8 +586,8 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
    * @since 2.0
    * @deprecated There is no reason to use this; it always returns {@code this}.
    */
-  @InlineMe(replacement = "this")
   @Deprecated
+  @InlineMe(replacement = "this")
   @Override
   public final ImmutableList<E> asList() {
     return this;
@@ -810,7 +809,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
-      checkNotNull(element);
+      requireNonNull(element);
       getReadyToExpandTo(size + 1);
       contents[size++] = element;
       return this;
@@ -855,7 +854,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
     @CanIgnoreReturnValue
     @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
-      checkNotNull(elements);
+      requireNonNull(elements);
       if (elements instanceof Collection) {
         Collection<?> collection = (Collection<?>) elements;
         getReadyToExpandTo(size + collection.size());
@@ -885,7 +884,7 @@ public abstract class ImmutableList<E> extends ImmutableCollection<E>
 
     @CanIgnoreReturnValue
     Builder<E> combine(Builder<E> builder) {
-      checkNotNull(builder);
+      requireNonNull(builder);
       add(builder.contents, builder.size);
       return this;
     }
diff --git a/guava/src/com/google/common/collect/ImmutableListMultimap.java b/guava/src/com/google/common/collect/ImmutableListMultimap.java
index 1acc1fc841..20916430e4 100644
--- a/guava/src/com/google/common/collect/ImmutableListMultimap.java
+++ b/guava/src/com/google/common/collect/ImmutableListMultimap.java
@@ -242,8 +242,8 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
@@ -432,8 +432,8 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final ImmutableList<V> removeAll(@CheckForNull Object key) {
     throw new UnsupportedOperationException();
   }
@@ -446,8 +446,8 @@ public class ImmutableListMultimap<K, V> extends ImmutableMultimap<K, V>
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final ImmutableList<V> replaceValues(K key, Iterable<? extends V> values) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableMap.java b/guava/src/com/google/common/collect/ImmutableMap.java
index b24ed6c732..bfd0ed1cd5 100644
--- a/guava/src/com/google/common/collect/ImmutableMap.java
+++ b/guava/src/com/google/common/collect/ImmutableMap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
@@ -422,7 +421,7 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
       this(ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY);
     }
 
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     Builder(int initialCapacity) {
       this.entries = new @Nullable Entry[initialCapacity];
       this.size = 0;
@@ -484,8 +483,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
      * @throws NullPointerException if any key, value, or entry is null
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       if (entries instanceof Collection) {
         ensureCapacity(size + ((Collection<?>) entries).size());
@@ -506,17 +505,17 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
      * @throws IllegalStateException if this method was already called
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     public Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator) {
       checkState(this.valueComparator == null, "valueComparator was already set");
-      this.valueComparator = checkNotNull(valueComparator, "valueComparator");
+      this.valueComparator = requireNonNull(valueComparator, "valueComparator");
       return this;
     }
 
     @CanIgnoreReturnValue
     Builder<K, V> combine(Builder<K, V> other) {
-      checkNotNull(other);
+      requireNonNull(other);
       ensureCapacity(this.size + other.size);
       System.arraycopy(other.entries, 0, this.entries, this.size, other.size);
       this.size += other.size;
@@ -772,10 +771,10 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final V put(K k, V v) {
     throw new UnsupportedOperationException();
   }
@@ -787,10 +786,10 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final V putIfAbsent(K key, V value) {
     throw new UnsupportedOperationException();
   }
@@ -802,8 +801,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean replace(K key, V oldValue, V newValue) {
     throw new UnsupportedOperationException();
   }
@@ -814,10 +813,10 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
-  @Deprecated
-  @Override
   @CheckForNull
+  @Deprecated
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final V replace(K key, V value) {
     throw new UnsupportedOperationException();
   }
@@ -829,8 +828,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
     throw new UnsupportedOperationException();
   }
@@ -842,8 +841,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final V computeIfPresent(
       K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
     throw new UnsupportedOperationException();
@@ -856,8 +855,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final V compute(
       K key, BiFunction<? super K, ? super @Nullable V, ? extends V> remappingFunction) {
     throw new UnsupportedOperationException();
@@ -870,8 +869,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final V merge(
       K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
     throw new UnsupportedOperationException();
@@ -884,8 +883,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void putAll(Map<? extends K, ? extends V> map) {
     throw new UnsupportedOperationException();
   }
@@ -897,8 +896,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
     throw new UnsupportedOperationException();
   }
@@ -909,10 +908,10 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @throws UnsupportedOperationException always
    * @deprecated Unsupported operation.
    */
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final V remove(@CheckForNull Object o) {
     throw new UnsupportedOperationException();
   }
@@ -924,8 +923,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
     throw new UnsupportedOperationException();
   }
@@ -937,8 +936,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -955,12 +954,12 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
 
   @Override
   public boolean containsValue(@CheckForNull Object value) {
-    return values().contains(value);
+    return this.containsValue(value);
   }
 
   // Overriding to mark it Nullable
-  @Override
   @CheckForNull
+  @Override
   public abstract V get(@CheckForNull Object key);
 
   /**
@@ -968,8 +967,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
    *     href="https://github.com/google/guava#guava-google-core-libraries-for-java">flavor</a>).
    *     Note, however, that Java 8 users can call this method with any version and flavor of Guava.
    */
-  @Override
   @CheckForNull
+  @Override
   public final V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {
     /*
      * Even though it's weird to pass a defaultValue that is null, some callers do so. Those who
@@ -1114,8 +1113,8 @@ public abstract class ImmutableMap<K, V> implements Map<K, V>, Serializable {
       return ImmutableMap.this.containsKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public ImmutableSet<V> get(@CheckForNull Object key) {
       V outerValue = ImmutableMap.this.get(key);
       return (outerValue == null) ? null : ImmutableSet.of(outerValue);
diff --git a/guava/src/com/google/common/collect/ImmutableMapEntry.java b/guava/src/com/google/common/collect/ImmutableMapEntry.java
index ac483d8fd8..13b5262a9d 100644
--- a/guava/src/com/google/common/collect/ImmutableMapEntry.java
+++ b/guava/src/com/google/common/collect/ImmutableMapEntry.java
@@ -92,8 +92,8 @@ class ImmutableMapEntry<K, V> extends ImmutableEntry<K, V> {
       this.nextInKeyBucket = nextInKeyBucket;
     }
 
-    @Override
     @CheckForNull
+    @Override
     final ImmutableMapEntry<K, V> getNextInKeyBucket() {
       return nextInKeyBucket;
     }
@@ -117,8 +117,8 @@ class ImmutableMapEntry<K, V> extends ImmutableEntry<K, V> {
       this.nextInValueBucket = nextInValueBucket;
     }
 
-    @Override
     @CheckForNull
+    @Override
     ImmutableMapEntry<K, V> getNextInValueBucket() {
       return nextInValueBucket;
     }
diff --git a/guava/src/com/google/common/collect/ImmutableMapEntrySet.java b/guava/src/com/google/common/collect/ImmutableMapEntrySet.java
index 6f5503af5c..b0fd79672c 100644
--- a/guava/src/com/google/common/collect/ImmutableMapEntrySet.java
+++ b/guava/src/com/google/common/collect/ImmutableMapEntrySet.java
@@ -52,8 +52,8 @@ abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet.CachingAsList<Ent
       return map;
     }
 
-    @Override
     @GwtIncompatible("not used in GWT")
+    @Override
     int copyIntoArray(@Nullable Object[] dst, int offset) {
       return entries.copyIntoArray(dst, offset);
     }
@@ -103,8 +103,8 @@ abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet.CachingAsList<Ent
     return map().isPartialView();
   }
 
-  @Override
-  @GwtIncompatible // not used in GWT
+  @GwtIncompatible
+  @Override // not used in GWT
   boolean isHashCodeFast() {
     return map().isHashCodeFast();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableMapKeySet.java b/guava/src/com/google/common/collect/ImmutableMapKeySet.java
index d10ee10e7a..fe11d7bedf 100644
--- a/guava/src/com/google/common/collect/ImmutableMapKeySet.java
+++ b/guava/src/com/google/common/collect/ImmutableMapKeySet.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -67,7 +67,7 @@ final class ImmutableMapKeySet<K, V> extends IndexedImmutableSet<K> {
 
   @Override
   public void forEach(Consumer<? super K> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     map.forEach((k, v) -> action.accept(k));
   }
 
diff --git a/guava/src/com/google/common/collect/ImmutableMapValues.java b/guava/src/com/google/common/collect/ImmutableMapValues.java
index 702191c649..1416c9ed10 100644
--- a/guava/src/com/google/common/collect/ImmutableMapValues.java
+++ b/guava/src/com/google/common/collect/ImmutableMapValues.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -97,7 +97,7 @@ final class ImmutableMapValues<K, V> extends ImmutableCollection<V> {
   @GwtIncompatible // serialization
   @Override
   public void forEach(Consumer<? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     map.forEach((k, v) -> action.accept(v));
   }
 
diff --git a/guava/src/com/google/common/collect/ImmutableMultimap.java b/guava/src/com/google/common/collect/ImmutableMultimap.java
index d16e1bc562..bea625cd48 100644
--- a/guava/src/com/google/common/collect/ImmutableMultimap.java
+++ b/guava/src/com/google/common/collect/ImmutableMultimap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.Maps.immutableEntry;
 import static java.util.Objects.requireNonNull;
@@ -192,8 +191,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      *
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       for (Entry<? extends K, ? extends V> entry : entries) {
         put(entry);
@@ -209,9 +208,7 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      */
     @CanIgnoreReturnValue
     public Builder<K, V> putAll(K key, Iterable<? extends V> values) {
-      if (key == null) {
-        throw new NullPointerException("null key in entry: null=" + Iterables.toString(values));
-      }
+      requireNonNull(key, "null key in entry: null=" + Iterables.toString(values));
       Collection<V> valueCollection = builderMap.get(key);
       if (valueCollection != null) {
         for (V value : values) {
@@ -269,7 +266,7 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      */
     @CanIgnoreReturnValue
     public Builder<K, V> orderKeysBy(Comparator<? super K> keyComparator) {
-      this.keyComparator = checkNotNull(keyComparator);
+      this.keyComparator = requireNonNull(keyComparator);
       return this;
     }
 
@@ -280,7 +277,7 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
      */
     @CanIgnoreReturnValue
     public Builder<K, V> orderValuesBy(Comparator<? super V> valueComparator) {
-      this.valueComparator = checkNotNull(valueComparator);
+      this.valueComparator = requireNonNull(valueComparator);
       return this;
     }
 
@@ -366,8 +363,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   // DoNotCall wants this to be final, but we want to override it to return more specific types.
   // Inheritance is closed, and all subtypes are @DoNotCall, so this is safe to suppress.
   @SuppressWarnings("DoNotCall")
@@ -383,8 +380,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   // DoNotCall wants this to be final, but we want to override it to return more specific types.
   // Inheritance is closed, and all subtypes are @DoNotCall, so this is safe to suppress.
   @SuppressWarnings("DoNotCall")
@@ -399,8 +396,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -429,8 +426,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean put(K key, V value) {
     throw new UnsupportedOperationException();
   }
@@ -443,8 +440,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean putAll(K key, Iterable<? extends V> values) {
     throw new UnsupportedOperationException();
   }
@@ -457,8 +454,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean putAll(Multimap<? extends K, ? extends V> multimap) {
     throw new UnsupportedOperationException();
   }
@@ -471,8 +468,8 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
     throw new UnsupportedOperationException();
   }
@@ -625,7 +622,7 @@ public abstract class ImmutableMultimap<K, V> extends BaseImmutableMultimap<K, V
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     asMap()
         .forEach(
             (key, valueCollection) -> valueCollection.forEach(value -> action.accept(key, value)));
diff --git a/guava/src/com/google/common/collect/ImmutableMultiset.java b/guava/src/com/google/common/collect/ImmutableMultiset.java
index c0bff4b173..d5060e085b 100644
--- a/guava/src/com/google/common/collect/ImmutableMultiset.java
+++ b/guava/src/com/google/common/collect/ImmutableMultiset.java
@@ -16,8 +16,8 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
+import static java.util.function.Function.identity;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -67,7 +67,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    * @since 21.0
    */
   public static <E> Collector<E, ?, ImmutableMultiset<E>> toImmutableMultiset() {
-    return CollectCollectors.toImmutableMultiset(Function.identity(), e -> 1);
+    return CollectCollectors.toImmutableMultiset(identity(), e -> 1);
   }
 
   /**
@@ -275,8 +275,8 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final int add(E element, int occurrences) {
     throw new UnsupportedOperationException();
   }
@@ -289,8 +289,8 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final int remove(@CheckForNull Object element, int occurrences) {
     throw new UnsupportedOperationException();
   }
@@ -303,8 +303,8 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final int setCount(E element, int count) {
     throw new UnsupportedOperationException();
   }
@@ -317,8 +317,8 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final boolean setCount(E element, int oldCount, int newCount) {
     throw new UnsupportedOperationException();
   }
@@ -483,7 +483,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
-      contents.add(checkNotNull(element));
+      contents.add(requireNonNull(element));
       return this;
     }
 
@@ -514,7 +514,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      */
     @CanIgnoreReturnValue
     public Builder<E> addCopies(E element, int occurrences) {
-      contents.add(checkNotNull(element), occurrences);
+      contents.add(requireNonNull(element), occurrences);
       return this;
     }
 
@@ -530,7 +530,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
      */
     @CanIgnoreReturnValue
     public Builder<E> setCount(E element, int count) {
-      contents.setCount(checkNotNull(element), count);
+      contents.setCount(requireNonNull(element), count);
       return this;
     }
 
@@ -546,7 +546,7 @@ public abstract class ImmutableMultiset<E> extends ImmutableMultisetGwtSerializa
     public Builder<E> addAll(Iterable<? extends E> elements) {
       if (elements instanceof Multiset) {
         Multiset<? extends E> multiset = Multisets.cast(elements);
-        multiset.forEachEntry((e, n) -> contents.add(checkNotNull(e), n));
+        multiset.forEachEntry((e, n) -> contents.add(requireNonNull(e), n));
       } else {
         super.addAll(elements);
       }
diff --git a/guava/src/com/google/common/collect/ImmutableRangeMap.java b/guava/src/com/google/common/collect/ImmutableRangeMap.java
index e1979ab65f..41f20deba1 100644
--- a/guava/src/com/google/common/collect/ImmutableRangeMap.java
+++ b/guava/src/com/google/common/collect/ImmutableRangeMap.java
@@ -16,7 +16,7 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -121,8 +121,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
      */
     @CanIgnoreReturnValue
     public Builder<K, V> put(Range<K> range, V value) {
-      checkNotNull(range);
-      checkNotNull(value);
+      requireNonNull(range);
+      requireNonNull(value);
       checkArgument(!range.isEmpty(), "Range must not be empty, but was %s", range);
       entries.add(Maps.immutableEntry(range, value));
       return this;
@@ -157,10 +157,11 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
         Range<K> range = entries.get(i).getKey();
         if (i > 0) {
           Range<K> prevRange = entries.get(i - 1).getKey();
-          if (range.isConnected(prevRange) && !range.intersection(prevRange).isEmpty()) {
-            throw new IllegalArgumentException(
-                "Overlapping ranges: range " + prevRange + " overlaps with entry " + range);
-          }
+          checkArgument(
+              !range.isConnected(prevRange) || range.intersection(prevRange).isEmpty(),
+              "Overlapping ranges: range %s overlaps with entry %s",
+              prevRange,
+              range);
         }
         rangesBuilder.add(range);
         valuesBuilder.add(entries.get(i).getValue());
@@ -177,8 +178,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
     this.values = values;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(K key) {
     int index =
         SortedLists.binarySearch(
@@ -195,8 +196,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<Range<K>, V> getEntry(K key) {
     int index =
         SortedLists.binarySearch(
@@ -230,8 +231,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void put(Range<K> range, V value) {
     throw new UnsupportedOperationException();
   }
@@ -243,8 +244,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void putCoalescing(Range<K> range, V value) {
     throw new UnsupportedOperationException();
   }
@@ -256,8 +257,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void putAll(RangeMap<K, V> rangeMap) {
     throw new UnsupportedOperationException();
   }
@@ -269,8 +270,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -282,8 +283,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void remove(Range<K> range) {
     throw new UnsupportedOperationException();
   }
@@ -295,8 +296,8 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void merge(
       Range<K> range,
       @CheckForNull V value,
@@ -326,7 +327,7 @@ public class ImmutableRangeMap<K extends Comparable<?>, V> implements RangeMap<K
 
   @Override
   public ImmutableRangeMap<K, V> subRangeMap(final Range<K> range) {
-    if (checkNotNull(range).isEmpty()) {
+    if (requireNonNull(range).isEmpty()) {
       return ImmutableRangeMap.of();
     } else if (ranges.isEmpty() || range.encloses(span())) {
       return this;
diff --git a/guava/src/com/google/common/collect/ImmutableRangeSet.java b/guava/src/com/google/common/collect/ImmutableRangeSet.java
index f279aae0c5..7f437cf244 100644
--- a/guava/src/com/google/common/collect/ImmutableRangeSet.java
+++ b/guava/src/com/google/common/collect/ImmutableRangeSet.java
@@ -16,7 +16,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_HIGHER;
 import static com.google.common.collect.SortedLists.KeyAbsentBehavior.NEXT_LOWER;
 import static com.google.common.collect.SortedLists.KeyPresentBehavior.ANY_PRESENT;
@@ -85,7 +84,7 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * range.isEmpty()}, this is equivalent to {@link ImmutableRangeSet#of()}.
    */
   public static <C extends Comparable> ImmutableRangeSet<C> of(Range<C> range) {
-    checkNotNull(range);
+    requireNonNull(range);
     if (range.isEmpty()) {
       return of();
     } else if (range.equals(Range.all())) {
@@ -103,7 +102,7 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
 
   /** Returns an immutable copy of the specified {@code RangeSet}. */
   public static <C extends Comparable> ImmutableRangeSet<C> copyOf(RangeSet<C> rangeSet) {
-    checkNotNull(rangeSet);
+    requireNonNull(rangeSet);
     if (rangeSet.isEmpty()) {
       return of();
     } else if (rangeSet.encloses(Range.<C>all())) {
@@ -187,8 +186,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
     return index != -1 && ranges.get(index).encloses(otherRange);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Range<C> rangeContaining(C value) {
     int index =
         SortedLists.binarySearch(
@@ -225,8 +224,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void add(Range<C> range) {
     throw new UnsupportedOperationException();
   }
@@ -238,8 +237,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void addAll(RangeSet<C> other) {
     throw new UnsupportedOperationException();
   }
@@ -251,8 +250,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void addAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
@@ -264,8 +263,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void remove(Range<C> range) {
     throw new UnsupportedOperationException();
   }
@@ -277,8 +276,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void removeAll(RangeSet<C> other) {
     throw new UnsupportedOperationException();
   }
@@ -290,8 +289,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void removeAll(Iterable<Range<C>> other) {
     throw new UnsupportedOperationException();
   }
@@ -524,7 +523,7 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
    *     neither has an upper bound
    */
   public ImmutableSortedSet<C> asSet(DiscreteDomain<C> domain) {
-    checkNotNull(domain);
+    requireNonNull(domain);
     if (isEmpty()) {
       return ImmutableSortedSet.of();
     }
@@ -579,8 +578,8 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
         final Iterator<Range<C>> rangeItr = ranges.iterator();
         Iterator<C> elemItr = Iterators.emptyIterator();
 
-        @Override
         @CheckForNull
+        @Override
         protected C computeNext() {
           while (!elemItr.hasNext()) {
             if (rangeItr.hasNext()) {
@@ -594,15 +593,15 @@ public final class ImmutableRangeSet<C extends Comparable> extends AbstractRange
       };
     }
 
-    @Override
     @GwtIncompatible("NavigableSet")
+    @Override
     public UnmodifiableIterator<C> descendingIterator() {
       return new AbstractIterator<C>() {
         final Iterator<Range<C>> rangeItr = ranges.reverse().iterator();
         Iterator<C> elemItr = Iterators.emptyIterator();
 
-        @Override
         @CheckForNull
+        @Override
         protected C computeNext() {
           while (!elemItr.hasNext()) {
             if (rangeItr.hasNext()) {
diff --git a/guava/src/com/google/common/collect/ImmutableSet.java b/guava/src/com/google/common/collect/ImmutableSet.java
index 73d5b09bf2..2665b26bf8 100644
--- a/guava/src/com/google/common/collect/ImmutableSet.java
+++ b/guava/src/com/google/common/collect/ImmutableSet.java
@@ -17,7 +17,6 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static java.util.Objects.requireNonNull;
 
@@ -75,7 +74,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
    *
    * <p><b>Performance note:</b> the instance returned is a singleton.
    */
-  @SuppressWarnings({"unchecked"}) // fully variant implementation (never actually produces any Es)
+  @SuppressWarnings("unchecked") // fully variant implementation (never actually produces any Es)
   public static <E> ImmutableSet<E> of() {
     return (ImmutableSet<E>) RegularImmutableSet.EMPTY;
   }
@@ -201,7 +200,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
         SetBuilderImpl<E> builder = new RegularSetBuilderImpl<E>(expectedSize);
         for (int i = 0; i < n; i++) {
           @SuppressWarnings("unchecked")
-          E e = (E) checkNotNull(elements[i]);
+          E e = (E) requireNonNull(elements[i]);
           builder = builder.add(e);
         }
         return builder.review().build();
@@ -369,7 +368,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
 
     @Override
     public void forEach(Consumer<? super E> consumer) {
-      checkNotNull(consumer);
+      requireNonNull(consumer);
       int n = size();
       for (int i = 0; i < n; i++) {
         consumer.accept(get(i));
@@ -510,18 +509,18 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
       impl = impl.copy();
     }
 
-    @Override
     @CanIgnoreReturnValue
+    @Override
     public Builder<E> add(E element) {
       requireNonNull(impl); // see the comment on the field
-      checkNotNull(element);
+      requireNonNull(element);
       copyIfNecessary();
       impl = impl.add(element);
       return this;
     }
 
-    @Override
     @CanIgnoreReturnValue
+    @Override
     public Builder<E> add(E... elements) {
       super.add(elements);
       return this;
@@ -535,15 +534,15 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
      * @return this {@code Builder} object
      * @throws NullPointerException if {@code elements} is null or contains a null element
      */
-    @Override
     @CanIgnoreReturnValue
+    @Override
     public Builder<E> addAll(Iterable<? extends E> elements) {
       super.addAll(elements);
       return this;
     }
 
-    @Override
     @CanIgnoreReturnValue
+    @Override
     public Builder<E> addAll(Iterator<? extends E> elements) {
       super.addAll(elements);
       return this;
@@ -739,7 +738,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
 
     @Override
     SetBuilderImpl<E> add(E e) {
-      checkNotNull(e);
+      requireNonNull(e);
       if (hashTable == null) {
         if (distinct == 0) {
           addDedupedElement(e);
@@ -951,7 +950,7 @@ public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements
 
     @Override
     SetBuilderImpl<E> add(E e) {
-      checkNotNull(e);
+      requireNonNull(e);
       if (delegate.add(e)) {
         addDedupedElement(e);
       }
diff --git a/guava/src/com/google/common/collect/ImmutableSetMultimap.java b/guava/src/com/google/common/collect/ImmutableSetMultimap.java
index 52d6e55c34..71a23a406b 100644
--- a/guava/src/com/google/common/collect/ImmutableSetMultimap.java
+++ b/guava/src/com/google/common/collect/ImmutableSetMultimap.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -277,8 +277,8 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
      *
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
@@ -376,7 +376,7 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
   private static <K, V> ImmutableSetMultimap<K, V> copyOf(
       Multimap<? extends K, ? extends V> multimap,
       @CheckForNull Comparator<? super V> valueComparator) {
-    checkNotNull(multimap); // eager for GWT
+    requireNonNull(multimap); // eager for GWT
     if (multimap.isEmpty() && valueComparator == null) {
       return of();
     }
@@ -492,8 +492,8 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final ImmutableSet<V> removeAll(@CheckForNull Object key) {
     throw new UnsupportedOperationException();
   }
@@ -506,8 +506,8 @@ public class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>
    */
   @CanIgnoreReturnValue
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final ImmutableSet<V> replaceValues(K key, Iterable<? extends V> values) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMap.java b/guava/src/com/google/common/collect/ImmutableSortedMap.java
index ab971937d0..25dc81179d 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMap.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMap.java
@@ -17,7 +17,6 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.Maps.keyOrNull;
 import static java.util.Objects.requireNonNull;
@@ -144,7 +143,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
   /** Returns an immutable map containing a single entry. */
   private static <K, V> ImmutableSortedMap<K, V> of(Comparator<? super K> comparator, K k1, V v1) {
     return new ImmutableSortedMap<>(
-        new RegularImmutableSortedSet<K>(ImmutableList.of(k1), checkNotNull(comparator)),
+        new RegularImmutableSortedSet<K>(ImmutableList.of(k1), requireNonNull(comparator)),
         ImmutableList.of(v1));
   }
 
@@ -389,7 +388,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    */
   public static <K, V> ImmutableSortedMap<K, V> copyOf(
       Map<? extends K, ? extends V> map, Comparator<? super K> comparator) {
-    return copyOfInternal(map, checkNotNull(comparator));
+    return copyOfInternal(map, requireNonNull(comparator));
   }
 
   /**
@@ -425,7 +424,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
   public static <K, V> ImmutableSortedMap<K, V> copyOf(
       Iterable<? extends Entry<? extends K, ? extends V>> entries,
       Comparator<? super K> comparator) {
-    return fromEntries(checkNotNull(comparator), false, entries);
+    return fromEntries(requireNonNull(comparator), false, entries);
   }
 
   /**
@@ -627,7 +626,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      */
     @SuppressWarnings("unchecked")
     public Builder(Comparator<? super K> comparator) {
-      this.comparator = checkNotNull(comparator);
+      this.comparator = requireNonNull(comparator);
     }
 
     /**
@@ -678,8 +677,8 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      * @throws NullPointerException if any key, value, or entry is null
      * @since 19.0
      */
-    @CanIgnoreReturnValue
     @Beta
+    @CanIgnoreReturnValue
     @Override
     public Builder<K, V> putAll(Iterable<? extends Entry<? extends K, ? extends V>> entries) {
       super.putAll(entries);
@@ -692,11 +691,11 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      * @since 19.0
      * @deprecated Unsupported by ImmutableSortedMap.Builder.
      */
-    @CanIgnoreReturnValue
     @Beta
-    @Override
+    @CanIgnoreReturnValue
     @Deprecated
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final Builder<K, V> orderEntriesByValue(Comparator<? super V> valueComparator) {
       throw new UnsupportedOperationException("Not available on ImmutableSortedMap.Builder");
     }
@@ -753,8 +752,8 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
      * @since 31.1
      * @deprecated This method is not currently implemented, and may never be.
      */
-    @DoNotCall
     @Deprecated
+    @DoNotCall
     @Override
     public final ImmutableSortedMap<K, V> buildKeepingLast() {
       // TODO(emcmanus): implement
@@ -787,15 +786,15 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     ImmutableList<K> keyList = keySet.asList();
     for (int i = 0; i < size(); i++) {
       action.accept(keyList.get(i), valueList.get(i));
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     int index = keySet.indexOf(key);
     return (index == -1) ? null : valueList.get(index);
@@ -943,7 +942,7 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    */
   @Override
   public ImmutableSortedMap<K, V> headMap(K toKey, boolean inclusive) {
-    return getSubMap(0, keySet.headIndex(checkNotNull(toKey), inclusive));
+    return getSubMap(0, keySet.headIndex(requireNonNull(toKey), inclusive));
   }
 
   /**
@@ -977,8 +976,8 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
   @Override
   public ImmutableSortedMap<K, V> subMap(
       K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
-    checkNotNull(fromKey);
-    checkNotNull(toKey);
+    requireNonNull(fromKey);
+    requireNonNull(toKey);
     checkArgument(
         comparator().compare(fromKey, toKey) <= 0,
         "expected fromKey <= toKey but %s > %s",
@@ -1014,65 +1013,65 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    */
   @Override
   public ImmutableSortedMap<K, V> tailMap(K fromKey, boolean inclusive) {
-    return getSubMap(keySet.tailIndex(checkNotNull(fromKey), inclusive), size());
+    return getSubMap(keySet.tailIndex(requireNonNull(fromKey), inclusive), size());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> lowerEntry(K key) {
     return headMap(key, false).lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K lowerKey(K key) {
     return keyOrNull(lowerEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> floorEntry(K key) {
     return headMap(key, true).lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K floorKey(K key) {
     return keyOrNull(floorEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> ceilingEntry(K key) {
     return tailMap(key, true).firstEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K ceilingKey(K key) {
     return keyOrNull(ceilingEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> higherEntry(K key) {
     return tailMap(key, false).firstEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public K higherKey(K key) {
     return keyOrNull(higherEntry(key));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> firstEntry() {
     return isEmpty() ? null : entrySet().asList().get(0);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<K, V> lastEntry() {
     return isEmpty() ? null : entrySet().asList().get(size() - 1);
   }
@@ -1084,10 +1083,10 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final Entry<K, V> pollFirstEntry() {
     throw new UnsupportedOperationException();
   }
@@ -1099,10 +1098,10 @@ public final class ImmutableSortedMap<K, V> extends ImmutableSortedMapFauxveride
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final Entry<K, V> pollLastEntry() {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java b/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java
index 7b2e4d7552..98b9f5d155 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMapFauxverideShim.java
@@ -41,8 +41,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.
    */
-  @DoNotCall("Use toImmutableSortedMap")
   @Deprecated
+  @DoNotCall("Use toImmutableSortedMap")
   public static <T extends @Nullable Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
@@ -58,8 +58,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMap#toImmutableSortedMap}.
    */
-  @DoNotCall("Use toImmutableSortedMap")
   @Deprecated
+  @DoNotCall("Use toImmutableSortedMap")
   public static <T extends @Nullable Object, K, V>
       Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
           Function<? super T, ? extends K> keyFunction,
@@ -76,8 +76,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMap#naturalOrder}, which offers better type-safety.
    */
-  @DoNotCall("Use naturalOrder")
   @Deprecated
+  @DoNotCall("Use naturalOrder")
   public static <K, V> ImmutableSortedMap.Builder<K, V> builder() {
     throw new UnsupportedOperationException();
   }
@@ -88,8 +88,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @throws UnsupportedOperationException always
    * @deprecated Not supported for ImmutableSortedMap.
    */
-  @DoNotCall("Use naturalOrder (which does not accept an expected size)")
   @Deprecated
+  @DoNotCall("Use naturalOrder (which does not accept an expected size)")
   public static <K, V> ImmutableSortedMap.Builder<K, V> builderWithExpectedSize(int expectedSize) {
     throw new UnsupportedOperationException();
   }
@@ -103,8 +103,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @deprecated <b>Pass a key of type {@code Comparable} to use {@link
    *     ImmutableSortedMap#of(Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass a key of type Comparable")
   @Deprecated
+  @DoNotCall("Pass a key of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1) {
     throw new UnsupportedOperationException();
   }
@@ -118,8 +118,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @deprecated <b>Pass keys of type {@code Comparable} to use {@link
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1, K k2, V v2) {
     throw new UnsupportedOperationException();
   }
@@ -133,8 +133,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    * @deprecated <b>Pass keys of type {@code Comparable} to use {@link
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
     throw new UnsupportedOperationException();
   }
@@ -149,8 +149,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
     throw new UnsupportedOperationException();
   }
@@ -165,8 +165,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
     throw new UnsupportedOperationException();
@@ -182,8 +182,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
     throw new UnsupportedOperationException();
@@ -199,8 +199,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) {
     throw new UnsupportedOperationException();
@@ -216,8 +216,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1,
       V v1,
@@ -248,8 +248,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1,
       V v1,
@@ -282,8 +282,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *     ImmutableSortedMap#of(Comparable, Object, Comparable, Object, Comparable, Object,
    *     Comparable, Object, Comparable, Object)}.</b>
    */
-  @DoNotCall("Pass keys of type Comparable")
   @Deprecated
+  @DoNotCall("Pass keys of type Comparable")
   public static <K, V> ImmutableSortedMap<K, V> of(
       K k1,
       V v1,
@@ -313,8 +313,8 @@ abstract class ImmutableSortedMapFauxverideShim<K, V> extends ImmutableMap<K, V>
    *
    * @deprecated Use {@code ImmutableSortedMap.copyOf(ImmutableMap.ofEntries(...))}.
    */
-  @DoNotCall("ImmutableSortedMap.ofEntries not currently available; use ImmutableSortedMap.copyOf")
   @Deprecated
+  @DoNotCall("ImmutableSortedMap.ofEntries not currently available; use ImmutableSortedMap.copyOf")
   public static <K, V> ImmutableSortedMap<K, V> ofEntries(
       Entry<? extends K, ? extends V>... entries) {
     throw new UnsupportedOperationException();
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMultiset.java b/guava/src/com/google/common/collect/ImmutableSortedMultiset.java
index 0638df04e0..7c25a665d7 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMultiset.java
@@ -15,13 +15,15 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
+import static java.util.function.Function.identity;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.DoNotCall;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -67,7 +69,7 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    */
   public static <E> Collector<E, ?, ImmutableSortedMultiset<E>> toImmutableSortedMultiset(
       Comparator<? super E> comparator) {
-    return toImmutableSortedMultiset(comparator, Function.identity(), e -> 1);
+    return toImmutableSortedMultiset(comparator, identity(), e -> 1);
   }
 
   /**
@@ -86,13 +88,13 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
           Comparator<? super E> comparator,
           Function<? super T, ? extends E> elementFunction,
           ToIntFunction<? super T> countFunction) {
-    checkNotNull(comparator);
-    checkNotNull(elementFunction);
-    checkNotNull(countFunction);
+    requireNonNull(comparator);
+    requireNonNull(elementFunction);
+    requireNonNull(countFunction);
     return Collector.of(
         () -> TreeMultiset.create(comparator),
         (multiset, t) ->
-            multiset.add(checkNotNull(elementFunction.apply(t)), countFunction.applyAsInt(t)),
+            multiset.add(requireNonNull(elementFunction.apply(t)), countFunction.applyAsInt(t)),
         (multiset1, multiset2) -> {
           multiset1.addAll(multiset2);
           return multiset1;
@@ -240,7 +242,7 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    */
   public static <E> ImmutableSortedMultiset<E> copyOf(
       Comparator<? super E> comparator, Iterator<? extends E> elements) {
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     return new Builder<E>(comparator).addAll(elements).build();
   }
 
@@ -268,7 +270,7 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
       }
     }
     elements = Lists.newArrayList(elements); // defensive copy
-    TreeMultiset<E> sortedCopy = TreeMultiset.create(checkNotNull(comparator));
+    TreeMultiset<E> sortedCopy = TreeMultiset.create(requireNonNull(comparator));
     Iterables.addAll(sortedCopy, elements);
     return copyOfSortedEntries(comparator, sortedCopy.entrySet());
   }
@@ -289,7 +291,7 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    */
   public static <E> ImmutableSortedMultiset<E> copyOfSorted(SortedMultiset<E> sortedMultiset) {
     return copyOfSortedEntries(
-        sortedMultiset.comparator(), Lists.newArrayList(sortedMultiset.entrySet()));
+        sortedMultiset.comparator(), new ArrayList<>(sortedMultiset.entrySet()));
   }
 
   private static <E> ImmutableSortedMultiset<E> copyOfSortedEntries(
@@ -354,10 +356,10 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final Entry<E> pollFirstEntry() {
     throw new UnsupportedOperationException();
   }
@@ -371,10 +373,10 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final Entry<E> pollLastEntry() {
     throw new UnsupportedOperationException();
   }
@@ -459,7 +461,7 @@ public abstract class ImmutableSortedMultiset<E> extends ImmutableSortedMultiset
      * ImmutableSortedMultiset#orderedBy(Comparator)}.
      */
     public Builder(Comparator<? super E> comparator) {
-      super(TreeMultiset.<E>create(checkNotNull(comparator)));
+      super(TreeMultiset.<E>create(requireNonNull(comparator)));
     }
 
     /**
diff --git a/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java b/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java
index 94a2f560da..3ae13a3edf 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedMultisetFauxverideShim.java
@@ -50,8 +50,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.
    * @since 21.0
    */
-  @DoNotCall("Use toImmutableSortedMultiset.")
   @Deprecated
+  @DoNotCall("Use toImmutableSortedMultiset.")
   public static <E> Collector<E, ?, ImmutableMultiset<E>> toImmutableMultiset() {
     throw new UnsupportedOperationException();
   }
@@ -65,8 +65,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated Use {@link ImmutableSortedMultiset#toImmutableSortedMultiset}.
    * @since 22.0
    */
-  @DoNotCall("Use toImmutableSortedMultiset.")
   @Deprecated
+  @DoNotCall("Use toImmutableSortedMultiset.")
   public static <T extends @Nullable Object, E>
       Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(
           Function<? super T, ? extends E> elementFunction,
@@ -82,8 +82,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedMultiset#naturalOrder}, which offers better type-safety.
    */
-  @DoNotCall("Use naturalOrder.")
   @Deprecated
+  @DoNotCall("Use naturalOrder.")
   public static <E> ImmutableSortedMultiset.Builder<E> builder() {
     throw new UnsupportedOperationException();
   }
@@ -97,8 +97,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass a parameter of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable)}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
+  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   public static <E> ImmutableSortedMultiset<E> of(E element) {
     throw new UnsupportedOperationException();
   }
@@ -112,8 +112,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
+  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2) {
     throw new UnsupportedOperationException();
   }
@@ -127,8 +127,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
+  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2, E e3) {
     throw new UnsupportedOperationException();
   }
@@ -142,8 +142,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable)}. </b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
+  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2, E e3, E e4) {
     throw new UnsupportedOperationException();
   }
@@ -158,8 +158,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable)} .
    *     </b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
+  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   public static <E> ImmutableSortedMultiset<E> of(E e1, E e2, E e3, E e4, E e5) {
     throw new UnsupportedOperationException();
   }
@@ -174,8 +174,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    *     ImmutableSortedMultiset#of(Comparable, Comparable, Comparable, Comparable, Comparable,
    *     Comparable, Comparable...)} . </b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
+  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   public static <E> ImmutableSortedMultiset<E> of(
       E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
     throw new UnsupportedOperationException();
@@ -190,8 +190,8 @@ abstract class ImmutableSortedMultisetFauxverideShim<E> extends ImmutableMultise
    * @deprecated <b>Pass parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedMultiset#copyOf(Comparable[])}.</b>
    */
-  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   @Deprecated
+  @DoNotCall("Elements must be Comparable. (Or, pass a Comparator to orderedBy or copyOf.)")
   public static <E> ImmutableSortedMultiset<E> copyOf(E[] elements) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableSortedSet.java b/guava/src/com/google/common/collect/ImmutableSortedSet.java
index 695dadc67b..6991f2055a 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedSet.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedSet.java
@@ -17,8 +17,8 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -294,7 +294,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
    */
   public static <E> ImmutableSortedSet<E> copyOf(
       Comparator<? super E> comparator, Iterable<? extends E> elements) {
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     boolean hasSameComparator = SortedIterables.hasSameComparator(comparator, elements);
 
     if (hasSameComparator && (elements instanceof ImmutableSortedSet)) {
@@ -442,7 +442,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
      */
     public Builder(Comparator<? super E> comparator) {
       super(true); // don't construct guts of hash-based set builder
-      this.comparator = checkNotNull(comparator);
+      this.comparator = requireNonNull(comparator);
       this.elements = (E[]) new Object[ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY];
       this.n = 0;
     }
@@ -483,7 +483,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
     @CanIgnoreReturnValue
     @Override
     public Builder<E> add(E element) {
-      checkNotNull(element);
+      requireNonNull(element);
       copyIfNecessary();
       if (n == elements.length) {
         sortAndDedup();
@@ -585,7 +585,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
     // Pretend the comparator can compare anything. If it turns out it can't
     // compare a and b, we should get a CCE or NPE on the subsequent line. Only methods
     // that are spec'd to throw CCE and NPE should call this.
-    @SuppressWarnings({"unchecked", "nullness"})
+    @SuppressWarnings({"nullness", "unchecked"})
     Comparator<@Nullable Object> unsafeComparator = (Comparator<@Nullable Object>) comparator;
     return unsafeComparator.compare(a, b);
   }
@@ -629,7 +629,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
    */
   @Override
   public ImmutableSortedSet<E> headSet(E toElement, boolean inclusive) {
-    return headSetImpl(checkNotNull(toElement), inclusive);
+    return headSetImpl(requireNonNull(toElement), inclusive);
   }
 
   /**
@@ -656,8 +656,8 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   @Override
   public ImmutableSortedSet<E> subSet(
       E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
-    checkNotNull(fromElement);
-    checkNotNull(toElement);
+    requireNonNull(fromElement);
+    requireNonNull(toElement);
     checkArgument(comparator.compare(fromElement, toElement) <= 0);
     return subSetImpl(fromElement, fromInclusive, toElement, toInclusive);
   }
@@ -682,7 +682,7 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
    */
   @Override
   public ImmutableSortedSet<E> tailSet(E fromElement, boolean inclusive) {
-    return tailSetImpl(checkNotNull(fromElement), inclusive);
+    return tailSetImpl(requireNonNull(fromElement), inclusive);
   }
 
   /*
@@ -699,9 +699,9 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   /**
    * @since 12.0
    */
-  @GwtIncompatible // NavigableSet
+  @CheckForNull // NavigableSet
+  @GwtIncompatible
   @Override
-  @CheckForNull
   public E lower(E e) {
     return Iterators.getNext(headSet(e, false).descendingIterator(), null);
   }
@@ -709,8 +709,8 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   /**
    * @since 12.0
    */
-  @Override
   @CheckForNull
+  @Override
   public E floor(E e) {
     return Iterators.getNext(headSet(e, true).descendingIterator(), null);
   }
@@ -718,8 +718,8 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   /**
    * @since 12.0
    */
-  @Override
   @CheckForNull
+  @Override
   public E ceiling(E e) {
     return Iterables.getFirst(tailSet(e, true), null);
   }
@@ -727,9 +727,9 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
   /**
    * @since 12.0
    */
-  @GwtIncompatible // NavigableSet
+  @CheckForNull // NavigableSet
+  @GwtIncompatible
   @Override
-  @CheckForNull
   public E higher(E e) {
     return Iterables.getFirst(tailSet(e, false), null);
   }
@@ -752,11 +752,11 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
-  @Deprecated
-  @GwtIncompatible // NavigableSet
-  @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
+  @Deprecated // NavigableSet
+  @DoNotCall("Always throws UnsupportedOperationException")
+  @GwtIncompatible
+  @Override
   public final E pollFirst() {
     throw new UnsupportedOperationException();
   }
@@ -769,11 +769,11 @@ public abstract class ImmutableSortedSet<E> extends ImmutableSortedSetFauxveride
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
-  @Deprecated
-  @GwtIncompatible // NavigableSet
-  @Override
-  @DoNotCall("Always throws UnsupportedOperationException")
   @CheckForNull
+  @Deprecated // NavigableSet
+  @DoNotCall("Always throws UnsupportedOperationException")
+  @GwtIncompatible
+  @Override
   public final E pollLast() {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java b/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java
index ff3ac12d5e..e73333271e 100644
--- a/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java
+++ b/guava/src/com/google/common/collect/ImmutableSortedSetFauxverideShim.java
@@ -48,8 +48,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated Use {@link ImmutableSortedSet#toImmutableSortedSet}.
    * @since 21.0
    */
-  @DoNotCall("Use toImmutableSortedSet")
   @Deprecated
+  @DoNotCall("Use toImmutableSortedSet")
   public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {
     throw new UnsupportedOperationException();
   }
@@ -62,8 +62,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @throws UnsupportedOperationException always
    * @deprecated Use {@link ImmutableSortedSet#naturalOrder}, which offers better type-safety.
    */
-  @DoNotCall("Use naturalOrder")
   @Deprecated
+  @DoNotCall("Use naturalOrder")
   public static <E> ImmutableSortedSet.Builder<E> builder() {
     throw new UnsupportedOperationException();
   }
@@ -75,8 +75,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @throws UnsupportedOperationException always
    * @deprecated Not supported by ImmutableSortedSet.
    */
-  @DoNotCall("Use naturalOrder (which does not accept an expected size)")
   @Deprecated
+  @DoNotCall("Use naturalOrder (which does not accept an expected size)")
   public static <E> ImmutableSortedSet.Builder<E> builderWithExpectedSize(int expectedSize) {
     throw new UnsupportedOperationException();
   }
@@ -90,8 +90,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass a parameter of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable)}.</b>
    */
-  @DoNotCall("Pass a parameter of type Comparable")
   @Deprecated
+  @DoNotCall("Pass a parameter of type Comparable")
   public static <E> ImmutableSortedSet<E> of(E element) {
     throw new UnsupportedOperationException();
   }
@@ -105,8 +105,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
+  @DoNotCall("Pass parameters of type Comparable")
   public static <E> ImmutableSortedSet<E> of(E e1, E e2) {
     throw new UnsupportedOperationException();
   }
@@ -120,8 +120,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable, Comparable, Comparable)}.</b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
+  @DoNotCall("Pass parameters of type Comparable")
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3) {
     throw new UnsupportedOperationException();
   }
@@ -135,8 +135,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable)}. </b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
+  @DoNotCall("Pass parameters of type Comparable")
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3, E e4) {
     throw new UnsupportedOperationException();
   }
@@ -150,8 +150,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass the parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#of( Comparable, Comparable, Comparable, Comparable, Comparable)}. </b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
+  @DoNotCall("Pass parameters of type Comparable")
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3, E e4, E e5) {
     throw new UnsupportedOperationException();
   }
@@ -166,8 +166,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    *     ImmutableSortedSet#of(Comparable, Comparable, Comparable, Comparable, Comparable,
    *     Comparable, Comparable...)}. </b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
+  @DoNotCall("Pass parameters of type Comparable")
   public static <E> ImmutableSortedSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {
     throw new UnsupportedOperationException();
   }
@@ -181,8 +181,8 @@ abstract class ImmutableSortedSetFauxverideShim<E> extends ImmutableSet.CachingA
    * @deprecated <b>Pass parameters of type {@code Comparable} to use {@link
    *     ImmutableSortedSet#copyOf(Comparable[])}.</b>
    */
-  @DoNotCall("Pass parameters of type Comparable")
   @Deprecated
+  @DoNotCall("Pass parameters of type Comparable")
   public static <E> ImmutableSortedSet<E> copyOf(E[] elements) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/ImmutableTable.java b/guava/src/com/google/common/collect/ImmutableTable.java
index 033c271e6f..0870f1a0bc 100644
--- a/guava/src/com/google/common/collect/ImmutableTable.java
+++ b/guava/src/com/google/common/collect/ImmutableTable.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.MoreObjects;
@@ -151,9 +151,9 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    */
   static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value) {
     return Tables.immutableCell(
-        checkNotNull(rowKey, "rowKey"),
-        checkNotNull(columnKey, "columnKey"),
-        checkNotNull(value, "value"));
+        requireNonNull(rowKey, "rowKey"),
+        requireNonNull(columnKey, "columnKey"),
+        requireNonNull(value, "value"));
   }
 
   /**
@@ -197,14 +197,14 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
     /** Specifies the ordering of the generated table's rows. */
     @CanIgnoreReturnValue
     public Builder<R, C, V> orderRowsBy(Comparator<? super R> rowComparator) {
-      this.rowComparator = checkNotNull(rowComparator, "rowComparator");
+      this.rowComparator = requireNonNull(rowComparator, "rowComparator");
       return this;
     }
 
     /** Specifies the ordering of the generated table's columns. */
     @CanIgnoreReturnValue
     public Builder<R, C, V> orderColumnsBy(Comparator<? super C> columnComparator) {
-      this.columnComparator = checkNotNull(columnComparator, "columnComparator");
+      this.columnComparator = requireNonNull(columnComparator, "columnComparator");
       return this;
     }
 
@@ -225,9 +225,9 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
     @CanIgnoreReturnValue
     public Builder<R, C, V> put(Cell<? extends R, ? extends C, ? extends V> cell) {
       if (cell instanceof Tables.ImmutableCell) {
-        checkNotNull(cell.getRowKey(), "row");
-        checkNotNull(cell.getColumnKey(), "column");
-        checkNotNull(cell.getValue(), "value");
+        requireNonNull(cell.getRowKey(), "row");
+        requireNonNull(cell.getColumnKey(), "column");
+        requireNonNull(cell.getValue(), "value");
         @SuppressWarnings("unchecked") // all supported methods are covariant
         Cell<R, C, V> immutableCell = (Cell<R, C, V>) cell;
         cells.add(immutableCell);
@@ -330,7 +330,7 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    */
   @Override
   public ImmutableMap<R, V> column(C columnKey) {
-    checkNotNull(columnKey, "columnKey");
+    requireNonNull(columnKey, "columnKey");
     return MoreObjects.firstNonNull(
         (ImmutableMap<R, V>) columnMap().get(columnKey), ImmutableMap.<R, V>of());
   }
@@ -356,7 +356,7 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    */
   @Override
   public ImmutableMap<C, V> row(R rowKey) {
-    checkNotNull(rowKey, "rowKey");
+    requireNonNull(rowKey, "rowKey");
     return MoreObjects.firstNonNull(
         (ImmutableMap<C, V>) rowMap().get(rowKey), ImmutableMap.<C, V>of());
   }
@@ -392,8 +392,8 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void clear() {
     throw new UnsupportedOperationException();
   }
@@ -405,10 +405,10 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final V put(R rowKey, C columnKey, V value) {
     throw new UnsupportedOperationException();
   }
@@ -420,8 +420,8 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void putAll(Table<? extends R, ? extends C, ? extends V> table) {
     throw new UnsupportedOperationException();
   }
@@ -433,10 +433,10 @@ public abstract class ImmutableTable<R, C, V> extends AbstractTable<R, C, V>
    * @deprecated Unsupported operation.
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public final V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/IndexedImmutableSet.java b/guava/src/com/google/common/collect/IndexedImmutableSet.java
index 20dfacbab8..434780c9c3 100644
--- a/guava/src/com/google/common/collect/IndexedImmutableSet.java
+++ b/guava/src/com/google/common/collect/IndexedImmutableSet.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -41,15 +41,15 @@ abstract class IndexedImmutableSet<E> extends ImmutableSet.CachingAsList<E> {
 
   @Override
   public void forEach(Consumer<? super E> consumer) {
-    checkNotNull(consumer);
+    requireNonNull(consumer);
     int n = size();
     for (int i = 0; i < n; i++) {
       consumer.accept(get(i));
     }
   }
 
-  @Override
   @GwtIncompatible
+  @Override
   int copyIntoArray(@Nullable Object[] dst, int offset) {
     return asList().copyIntoArray(dst, offset);
   }
diff --git a/guava/src/com/google/common/collect/Interners.java b/guava/src/com/google/common/collect/Interners.java
index 10ae274633..4987662a70 100644
--- a/guava/src/com/google/common/collect/Interners.java
+++ b/guava/src/com/google/common/collect/Interners.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
@@ -158,7 +158,7 @@ public final class Interners {
    * @since 8.0
    */
   public static <E> Function<E, E> asFunction(Interner<E> interner) {
-    return new InternerFunction<>(checkNotNull(interner));
+    return new InternerFunction<>(requireNonNull(interner));
   }
 
   private static class InternerFunction<E> implements Function<E, E> {
diff --git a/guava/src/com/google/common/collect/Iterables.java b/guava/src/com/google/common/collect/Iterables.java
index f86ac443ba..8d2f13f5ee 100644
--- a/guava/src/com/google/common/collect/Iterables.java
+++ b/guava/src/com/google/common/collect/Iterables.java
@@ -17,8 +17,9 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Predicates.instanceOf;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -26,7 +27,6 @@ import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Comparator;
@@ -72,7 +72,7 @@ public final class Iterables {
   /** Returns an unmodifiable view of {@code iterable}. */
   public static <T extends @Nullable Object> Iterable<T> unmodifiableIterable(
       final Iterable<? extends T> iterable) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     if (iterable instanceof UnmodifiableIterable || iterable instanceof ImmutableCollection) {
       @SuppressWarnings("unchecked") // Since it's unmodifiable, the covariant cast is safe
       Iterable<T> result = (Iterable<T>) iterable;
@@ -89,7 +89,7 @@ public final class Iterables {
    */
   @Deprecated
   public static <E> Iterable<E> unmodifiableIterable(ImmutableCollection<E> iterable) {
-    return checkNotNull(iterable);
+    return requireNonNull(iterable);
   }
 
   private static final class UnmodifiableIterable<T extends @Nullable Object>
@@ -110,8 +110,8 @@ public final class Iterables {
       iterable.forEach(action);
     }
 
-    @SuppressWarnings("unchecked") // safe upcast, assuming no one has a crazy Spliterator subclass
-    @Override
+    @Override // safe upcast, assuming no one has a crazy Spliterator subclass
+    @SuppressWarnings("unchecked")
     public Spliterator<T> spliterator() {
       return (Spliterator<T>) iterable.spliterator();
     }
@@ -159,7 +159,7 @@ public final class Iterables {
   @CanIgnoreReturnValue
   public static boolean removeAll(Iterable<?> removeFrom, Collection<?> elementsToRemove) {
     return (removeFrom instanceof Collection)
-        ? ((Collection<?>) removeFrom).removeAll(checkNotNull(elementsToRemove))
+        ? ((Collection<?>) removeFrom).removeAll(requireNonNull(elementsToRemove))
         : Iterators.removeAll(removeFrom.iterator(), elementsToRemove);
   }
 
@@ -176,7 +176,7 @@ public final class Iterables {
   @CanIgnoreReturnValue
   public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsToRetain) {
     return (removeFrom instanceof Collection)
-        ? ((Collection<?>) removeFrom).retainAll(checkNotNull(elementsToRetain))
+        ? ((Collection<?>) removeFrom).retainAll(requireNonNull(elementsToRetain))
         : Iterators.retainAll(removeFrom.iterator(), elementsToRetain);
   }
 
@@ -209,7 +209,7 @@ public final class Iterables {
   @CheckForNull
   static <T extends @Nullable Object> T removeFirstMatching(
       Iterable<T> removeFrom, Predicate<? super T> predicate) {
-    checkNotNull(predicate);
+    requireNonNull(predicate);
     Iterator<T> iterator = removeFrom.iterator();
     while (iterator.hasNext()) {
       T next = iterator.next();
@@ -334,7 +334,7 @@ public final class Iterables {
       Collection<? extends T> c = (Collection<? extends T>) elementsToAdd;
       return addTo.addAll(c);
     }
-    return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());
+    return Iterators.addAll(addTo, requireNonNull(elementsToAdd).iterator());
   }
 
   /**
@@ -376,7 +376,7 @@ public final class Iterables {
    * Stream.generate(() -> iterable).flatMap(Streams::stream)}.
    */
   public static <T extends @Nullable Object> Iterable<T> cycle(final Iterable<T> iterable) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
@@ -390,7 +390,7 @@ public final class Iterables {
 
       @Override
       public String toString() {
-        return iterable.toString() + " (cycled)";
+        return iterable + " (cycled)";
       }
     };
   }
@@ -531,7 +531,7 @@ public final class Iterables {
    */
   public static <T extends @Nullable Object> Iterable<List<T>> partition(
       final Iterable<T> iterable, final int size) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     checkArgument(size > 0);
     return new FluentIterable<List<T>>() {
       @Override
@@ -558,7 +558,7 @@ public final class Iterables {
    */
   public static <T extends @Nullable Object> Iterable<List<@Nullable T>> paddedPartition(
       final Iterable<T> iterable, final int size) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     checkArgument(size > 0);
     return new FluentIterable<List<@Nullable T>>() {
       @Override
@@ -576,8 +576,8 @@ public final class Iterables {
    */
   public static <T extends @Nullable Object> Iterable<T> filter(
       final Iterable<T> unfiltered, final Predicate<? super T> retainIfTrue) {
-    checkNotNull(unfiltered);
-    checkNotNull(retainIfTrue);
+    requireNonNull(unfiltered);
+    requireNonNull(retainIfTrue);
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
@@ -586,7 +586,7 @@ public final class Iterables {
 
       @Override
       public void forEach(Consumer<? super T> action) {
-        checkNotNull(action);
+        requireNonNull(action);
         unfiltered.forEach(
             (@ParametricNullness T a) -> {
               if (retainIfTrue.test(a)) {
@@ -616,12 +616,12 @@ public final class Iterables {
    *     (ImmutableList) stream.filter(NewType.class::isInstance).collect(toImmutableList());}
    * </pre>
    */
-  @SuppressWarnings("unchecked")
-  @GwtIncompatible // Class.isInstance
+  @GwtIncompatible
+  @SuppressWarnings("unchecked") // Class.isInstance
   public static <T> Iterable<T> filter(final Iterable<?> unfiltered, final Class<T> desiredType) {
-    checkNotNull(unfiltered);
-    checkNotNull(desiredType);
-    return (Iterable<T>) filter(unfiltered, Predicates.instanceOf(desiredType));
+    requireNonNull(unfiltered);
+    requireNonNull(desiredType);
+    return (Iterable<T>) filter(unfiltered, instanceOf(desiredType));
   }
 
   /**
@@ -738,8 +738,8 @@ public final class Iterables {
    */
   public static <F extends @Nullable Object, T extends @Nullable Object> Iterable<T> transform(
       final Iterable<F> fromIterable, final Function<? super F, ? extends T> function) {
-    checkNotNull(fromIterable);
-    checkNotNull(function);
+    requireNonNull(fromIterable);
+    requireNonNull(function);
     return new FluentIterable<T>() {
       @Override
       public Iterator<T> iterator() {
@@ -748,7 +748,7 @@ public final class Iterables {
 
       @Override
       public void forEach(Consumer<? super T> action) {
-        checkNotNull(action);
+        requireNonNull(action);
         fromIterable.forEach((F f) -> action.accept(function.apply(f)));
       }
 
@@ -772,7 +772,7 @@ public final class Iterables {
    */
   @ParametricNullness
   public static <T extends @Nullable Object> T get(Iterable<T> iterable, int position) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     return (iterable instanceof List)
         ? ((List<T>) iterable).get(position)
         : Iterators.get(iterable.iterator(), position);
@@ -796,7 +796,7 @@ public final class Iterables {
   @ParametricNullness
   public static <T extends @Nullable Object> T get(
       Iterable<? extends T> iterable, int position, @ParametricNullness T defaultValue) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     Iterators.checkNonnegative(position);
     if (iterable instanceof List) {
       List<? extends T> list = Lists.cast(iterable);
@@ -906,7 +906,7 @@ public final class Iterables {
    */
   public static <T extends @Nullable Object> Iterable<T> skip(
       final Iterable<T> iterable, final int numberToSkip) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     checkArgument(numberToSkip >= 0, "number to skip cannot be negative");
 
     return new FluentIterable<T>() {
@@ -978,7 +978,7 @@ public final class Iterables {
    */
   public static <T extends @Nullable Object> Iterable<T> limit(
       final Iterable<T> iterable, final int limitSize) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     checkArgument(limitSize >= 0, "limit is negative");
     return new FluentIterable<T>() {
       @Override
@@ -1011,7 +1011,7 @@ public final class Iterables {
    */
   public static <T extends @Nullable Object> Iterable<T> consumingIterable(
       final Iterable<T> iterable) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
 
     return new FluentIterable<T>() {
       @Override
@@ -1065,8 +1065,8 @@ public final class Iterables {
   public static <T extends @Nullable Object> Iterable<T> mergeSorted(
       final Iterable<? extends Iterable<? extends T>> iterables,
       final Comparator<? super T> comparator) {
-    checkNotNull(iterables, "iterables");
-    checkNotNull(comparator, "comparator");
+    requireNonNull(iterables, "iterables");
+    requireNonNull(comparator, "comparator");
     Iterable<T> iterable =
         new FluentIterable<T>() {
           @Override
diff --git a/guava/src/com/google/common/collect/Iterators.java b/guava/src/com/google/common/collect/Iterators.java
index 916e513349..ea1bc1c26e 100644
--- a/guava/src/com/google/common/collect/Iterators.java
+++ b/guava/src/com/google/common/collect/Iterators.java
@@ -17,11 +17,13 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkPositionIndex;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Predicates.instanceOf;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
+import static java.util.Collections.unmodifiableList;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -30,7 +32,6 @@ import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.primitives.Ints;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -128,7 +129,7 @@ public final class Iterators {
   /** Returns an unmodifiable view of {@code iterator}. */
   public static <T extends @Nullable Object> UnmodifiableIterator<T> unmodifiableIterator(
       Iterator<? extends T> iterator) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     if (iterator instanceof UnmodifiableIterator) {
       @SuppressWarnings("unchecked") // Since it's unmodifiable, the covariant cast is safe
       UnmodifiableIterator<T> result = (UnmodifiableIterator<T>) iterator;
@@ -157,7 +158,7 @@ public final class Iterators {
   @Deprecated
   public static <T extends @Nullable Object> UnmodifiableIterator<T> unmodifiableIterator(
       UnmodifiableIterator<T> iterator) {
-    return checkNotNull(iterator);
+    return requireNonNull(iterator);
   }
 
   /**
@@ -201,7 +202,7 @@ public final class Iterators {
    */
   @CanIgnoreReturnValue
   public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove) {
-    checkNotNull(elementsToRemove);
+    requireNonNull(elementsToRemove);
     boolean result = false;
     while (removeFrom.hasNext()) {
       if (elementsToRemove.contains(removeFrom.next())) {
@@ -224,7 +225,7 @@ public final class Iterators {
   @CanIgnoreReturnValue
   public static <T extends @Nullable Object> boolean removeIf(
       Iterator<T> removeFrom, Predicate<? super T> predicate) {
-    checkNotNull(predicate);
+    requireNonNull(predicate);
     boolean modified = false;
     while (removeFrom.hasNext()) {
       if (predicate.apply(removeFrom.next())) {
@@ -246,7 +247,7 @@ public final class Iterators {
    */
   @CanIgnoreReturnValue
   public static boolean retainAll(Iterator<?> removeFrom, Collection<?> elementsToRetain) {
-    checkNotNull(elementsToRetain);
+    requireNonNull(elementsToRetain);
     boolean result = false;
     while (removeFrom.hasNext()) {
       if (!elementsToRetain.contains(removeFrom.next())) {
@@ -360,8 +361,8 @@ public final class Iterators {
   @CanIgnoreReturnValue
   public static <T extends @Nullable Object> boolean addAll(
       Collection<T> addTo, Iterator<? extends T> iterator) {
-    checkNotNull(addTo);
-    checkNotNull(iterator);
+    requireNonNull(addTo);
+    requireNonNull(iterator);
     boolean wasModified = false;
     while (iterator.hasNext()) {
       wasModified |= addTo.add(iterator.next());
@@ -398,7 +399,7 @@ public final class Iterators {
    * elements.
    */
   public static <T extends @Nullable Object> Iterator<T> cycle(Iterable<T> iterable) {
-    checkNotNull(iterable);
+    requireNonNull(iterable);
     return new Iterator<T>() {
       Iterator<T> iterator = emptyModifiableIterator();
 
@@ -498,8 +499,8 @@ public final class Iterators {
    */
   public static <T extends @Nullable Object> Iterator<T> concat(
       Iterator<? extends T> a, Iterator<? extends T> b) {
-    checkNotNull(a);
-    checkNotNull(b);
+    requireNonNull(a);
+    requireNonNull(b);
     return concat(consumingForArray(a, b));
   }
 
@@ -513,9 +514,9 @@ public final class Iterators {
    */
   public static <T extends @Nullable Object> Iterator<T> concat(
       Iterator<? extends T> a, Iterator<? extends T> b, Iterator<? extends T> c) {
-    checkNotNull(a);
-    checkNotNull(b);
-    checkNotNull(c);
+    requireNonNull(a);
+    requireNonNull(b);
+    requireNonNull(c);
     return concat(consumingForArray(a, b, c));
   }
 
@@ -533,10 +534,10 @@ public final class Iterators {
       Iterator<? extends T> b,
       Iterator<? extends T> c,
       Iterator<? extends T> d) {
-    checkNotNull(a);
-    checkNotNull(b);
-    checkNotNull(c);
-    checkNotNull(d);
+    requireNonNull(a);
+    requireNonNull(b);
+    requireNonNull(c);
+    requireNonNull(d);
     return concat(consumingForArray(a, b, c, d));
   }
 
@@ -571,8 +572,8 @@ public final class Iterators {
   /** Concats a varargs array of iterators without making a defensive copy of the array. */
   static <T extends @Nullable Object> Iterator<T> concatNoDefensiveCopy(
       Iterator<? extends T>... inputs) {
-    for (Iterator<? extends T> input : checkNotNull(inputs)) {
-      checkNotNull(input);
+    for (Iterator<? extends T> input : requireNonNull(inputs)) {
+      requireNonNull(input);
     }
     return concat(consumingForArray(inputs));
   }
@@ -621,7 +622,7 @@ public final class Iterators {
 
   private static <T extends @Nullable Object> UnmodifiableIterator<List<@Nullable T>> partitionImpl(
       Iterator<T> iterator, int size, boolean pad) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     checkArgument(size > 0);
     return new UnmodifiableIterator<List<@Nullable T>>() {
       @Override
@@ -644,7 +645,7 @@ public final class Iterators {
           array[i] = null; // for GWT
         }
 
-        List<@Nullable T> list = Collections.unmodifiableList(Arrays.asList(array));
+        List<@Nullable T> list = unmodifiableList(Arrays.asList(array));
         // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.
         if (pad || count == size) {
           return list;
@@ -661,11 +662,11 @@ public final class Iterators {
    */
   public static <T extends @Nullable Object> UnmodifiableIterator<T> filter(
       Iterator<T> unfiltered, Predicate<? super T> retainIfTrue) {
-    checkNotNull(unfiltered);
-    checkNotNull(retainIfTrue);
+    requireNonNull(unfiltered);
+    requireNonNull(retainIfTrue);
     return new AbstractIterator<T>() {
-      @Override
       @CheckForNull
+      @Override
       protected T computeNext() {
         while (unfiltered.hasNext()) {
           T element = unfiltered.next();
@@ -682,8 +683,8 @@ public final class Iterators {
    * Returns a view of {@code unfiltered} containing all elements that are of the type {@code
    * desiredType}.
    */
-  @SuppressWarnings("unchecked") // can cast to <T> because non-Ts are removed
-  @GwtIncompatible // Class.isInstance
+  @GwtIncompatible // can cast to <T> because non-Ts are removed
+  @SuppressWarnings("unchecked") // Class.isInstance
   public static <T> UnmodifiableIterator<T> filter(Iterator<?> unfiltered, Class<T> desiredType) {
     return (UnmodifiableIterator<T>) filter(unfiltered, instanceOf(desiredType));
   }
@@ -703,7 +704,7 @@ public final class Iterators {
    */
   public static <T extends @Nullable Object> boolean all(
       Iterator<T> iterator, Predicate<? super T> predicate) {
-    checkNotNull(predicate);
+    requireNonNull(predicate);
     while (iterator.hasNext()) {
       T element = iterator.next();
       if (!predicate.apply(element)) {
@@ -725,8 +726,8 @@ public final class Iterators {
   @ParametricNullness
   public static <T extends @Nullable Object> T find(
       Iterator<T> iterator, Predicate<? super T> predicate) {
-    checkNotNull(iterator);
-    checkNotNull(predicate);
+    requireNonNull(iterator);
+    requireNonNull(predicate);
     while (iterator.hasNext()) {
       T t = iterator.next();
       if (predicate.apply(t)) {
@@ -750,8 +751,8 @@ public final class Iterators {
       Iterator<? extends T> iterator,
       Predicate<? super T> predicate,
       @CheckForNull T defaultValue) {
-    checkNotNull(iterator);
-    checkNotNull(predicate);
+    requireNonNull(iterator);
+    requireNonNull(predicate);
     while (iterator.hasNext()) {
       T t = iterator.next();
       if (predicate.apply(t)) {
@@ -773,8 +774,8 @@ public final class Iterators {
    * @since 11.0
    */
   public static <T> Optional<T> tryFind(Iterator<T> iterator, Predicate<? super T> predicate) {
-    checkNotNull(iterator);
-    checkNotNull(predicate);
+    requireNonNull(iterator);
+    requireNonNull(predicate);
     while (iterator.hasNext()) {
       T t = iterator.next();
       if (predicate.apply(t)) {
@@ -800,7 +801,7 @@ public final class Iterators {
    */
   public static <T extends @Nullable Object> int indexOf(
       Iterator<T> iterator, Predicate<? super T> predicate) {
-    checkNotNull(predicate, "predicate");
+    requireNonNull(predicate, "predicate");
     for (int i = 0; iterator.hasNext(); i++) {
       T current = iterator.next();
       if (predicate.apply(current)) {
@@ -820,10 +821,10 @@ public final class Iterators {
    */
   public static <F extends @Nullable Object, T extends @Nullable Object> Iterator<T> transform(
       Iterator<F> fromIterator, Function<? super F, ? extends T> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     return new TransformedIterator<F, T>(fromIterator) {
-      @ParametricNullness
       @Override
+      @ParametricNullness
       T transform(@ParametricNullness F from) {
         return function.apply(from);
       }
@@ -933,7 +934,7 @@ public final class Iterators {
    */
   @CanIgnoreReturnValue
   public static int advance(Iterator<?> iterator, int numberToAdvance) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     checkArgument(numberToAdvance >= 0, "numberToAdvance must be nonnegative");
 
     int i;
@@ -955,7 +956,7 @@ public final class Iterators {
    */
   public static <T extends @Nullable Object> Iterator<T> limit(
       Iterator<T> iterator, int limitSize) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     checkArgument(limitSize >= 0, "limit is negative");
     return new Iterator<T>() {
       private int count;
@@ -994,7 +995,7 @@ public final class Iterators {
    * @since 2.0
    */
   public static <T extends @Nullable Object> Iterator<T> consumingIterator(Iterator<T> iterator) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     return new UnmodifiableIterator<T>() {
       @Override
       public boolean hasNext() {
@@ -1035,7 +1036,7 @@ public final class Iterators {
 
   /** Clears the iterator using its remove method. */
   static void clear(Iterator<?> iterator) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     while (iterator.hasNext()) {
       iterator.next();
       iterator.remove();
@@ -1070,8 +1071,8 @@ public final class Iterators {
     int end = offset + length;
 
     // Technically we should give a slightly more descriptive error on overflow
-    Preconditions.checkPositionIndexes(offset, end, array.length);
-    Preconditions.checkPositionIndex(index, length);
+    checkPositionIndexes(offset, end, array.length);
+    checkPositionIndex(index, length);
     if (length == 0) {
       return emptyListIterator();
     }
@@ -1137,7 +1138,7 @@ public final class Iterators {
    */
   public static <T extends @Nullable Object> UnmodifiableIterator<T> forEnumeration(
       Enumeration<T> enumeration) {
-    checkNotNull(enumeration);
+    requireNonNull(enumeration);
     return new UnmodifiableIterator<T>() {
       @Override
       public boolean hasNext() {
@@ -1159,7 +1160,7 @@ public final class Iterators {
    * you have a {@link Collection}), or {@code Iterators.asEnumeration(collection.iterator())}.
    */
   public static <T extends @Nullable Object> Enumeration<T> asEnumeration(Iterator<T> iterator) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     return new Enumeration<T>() {
       @Override
       public boolean hasMoreElements() {
@@ -1182,7 +1183,7 @@ public final class Iterators {
     @CheckForNull private E peekedElement;
 
     public PeekingImpl(Iterator<? extends E> iterator) {
-      this.iterator = checkNotNull(iterator);
+      this.iterator = requireNonNull(iterator);
     }
 
     @Override
@@ -1278,7 +1279,7 @@ public final class Iterators {
   @Deprecated
   public static <T extends @Nullable Object> PeekingIterator<T> peekingIterator(
       PeekingIterator<T> iterator) {
-    return checkNotNull(iterator);
+    return requireNonNull(iterator);
   }
 
   /**
@@ -1296,8 +1297,8 @@ public final class Iterators {
   @Beta
   public static <T extends @Nullable Object> UnmodifiableIterator<T> mergeSorted(
       Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> comparator) {
-    checkNotNull(iterators, "iterators");
-    checkNotNull(comparator, "comparator");
+    requireNonNull(iterators, "iterators");
+    requireNonNull(comparator, "comparator");
 
     return new MergingIterator<>(iterators, comparator);
   }
@@ -1369,7 +1370,7 @@ public final class Iterators {
 
     ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator) {
       iterator = emptyIterator();
-      topMetaIterator = checkNotNull(metaIterator);
+      topMetaIterator = requireNonNull(metaIterator);
     }
 
     // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.
@@ -1387,7 +1388,7 @@ public final class Iterators {
 
     @Override
     public boolean hasNext() {
-      while (!checkNotNull(iterator).hasNext()) {
+      while (!requireNonNull(iterator).hasNext()) {
         // this weird checkNotNull positioning appears required by our tests, which expect
         // both hasNext and next to throw NPE if an input iterator is null.
 
@@ -1436,9 +1437,7 @@ public final class Iterators {
 
     @Override
     public void remove() {
-      if (toRemove == null) {
-        throw new IllegalStateException("no calls to next() since the last call to remove()");
-      }
+      checkState(toRemove != null, "no calls to next() since the last call to remove()");
       toRemove.remove();
       toRemove = null;
     }
diff --git a/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java b/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java
index f126fdea3b..e97a6f428d 100644
--- a/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java
@@ -104,8 +104,8 @@ final class JdkBackedImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return forwardDelegate.get(key);
   }
diff --git a/guava/src/com/google/common/collect/JdkBackedImmutableMap.java b/guava/src/com/google/common/collect/JdkBackedImmutableMap.java
index 222c4deb8a..35125aa510 100644
--- a/guava/src/com/google/common/collect/JdkBackedImmutableMap.java
+++ b/guava/src/com/google/common/collect/JdkBackedImmutableMap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.RegularImmutableMap.makeImmutable;
 import static java.util.Objects.requireNonNull;
 
@@ -99,8 +98,8 @@ final class JdkBackedImmutableMap<K, V> extends ImmutableMap<K, V> {
     return entries.size();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return delegateMap.get(key);
   }
@@ -112,7 +111,7 @@ final class JdkBackedImmutableMap<K, V> extends ImmutableMap<K, V> {
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     entries.forEach(e -> action.accept(e.getKey(), e.getValue()));
   }
 
diff --git a/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java b/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java
index faf22b3431..80347a7283 100644
--- a/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java
+++ b/guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Ints;
@@ -44,7 +44,7 @@ final class JdkBackedImmutableMultiset<E> extends ImmutableMultiset<E> {
       Entry<E> entry = entriesArray[i];
       int count = entry.getCount();
       size += count;
-      E element = checkNotNull(entry.getElement());
+      E element = requireNonNull(entry.getElement());
       delegateMap.put(element, count);
       if (!(entry instanceof Multisets.ImmutableEntry)) {
         entriesArray[i] = Multisets.immutableEntry(element, count);
diff --git a/guava/src/com/google/common/collect/LinkedHashMultimap.java b/guava/src/com/google/common/collect/LinkedHashMultimap.java
index f97693ca6c..94661be502 100644
--- a/guava/src/com/google/common/collect/LinkedHashMultimap.java
+++ b/guava/src/com/google/common/collect/LinkedHashMultimap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static java.util.Objects.requireNonNull;
@@ -451,7 +450,7 @@ public final class LinkedHashMultimap<K extends @Nullable Object, V extends @Nul
 
     @Override
     public void forEach(Consumer<? super V> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       for (ValueSetLink<K, V> entry = firstEntry;
           entry != ValueSet.this;
           entry = entry.getSuccessorInValueSet()) {
diff --git a/guava/src/com/google/common/collect/LinkedListMultimap.java b/guava/src/com/google/common/collect/LinkedListMultimap.java
index a69243469c..545729c959 100644
--- a/guava/src/com/google/common/collect/LinkedListMultimap.java
+++ b/guava/src/com/google/common/collect/LinkedListMultimap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.Collections.unmodifiableList;
@@ -684,7 +683,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
      * to call getCopy and removeAllNodes only with a true K, then we could check containsKey first.
      * But that check wouldn't eliminate the warnings.)
      */
-    @SuppressWarnings({"unchecked", "nullness"})
+    @SuppressWarnings({"nullness", "unchecked"})
     K castKey = (K) key;
     List<V> oldValues = getCopy(castKey);
     removeAllNodes(castKey);
@@ -838,7 +837,7 @@ public class LinkedListMultimap<K extends @Nullable Object, V extends @Nullable
 
       @Override
       public void forEach(Consumer<? super Entry<K, V>> action) {
-        checkNotNull(action);
+        requireNonNull(action);
         for (Node<K, V> node = head; node != null; node = node.next) {
           action.accept(node);
         }
diff --git a/guava/src/com/google/common/collect/Lists.java b/guava/src/com/google/common/collect/Lists.java
index e7f3817fd0..a3de77bcbb 100644
--- a/guava/src/com/google/common/collect/Lists.java
+++ b/guava/src/com/google/common/collect/Lists.java
@@ -18,12 +18,12 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -99,10 +99,10 @@ public final class Lists {
    * (...))}, or for creating an empty list then calling {@link Collections#addAll}. This method is
    * not actually very useful and will likely be deprecated in the future.
    */
-  @SafeVarargs
   @GwtCompatible(serializable = true)
+  @SafeVarargs
   public static <E extends @Nullable Object> ArrayList<E> newArrayList(E... elements) {
-    checkNotNull(elements); // for GWT
+    requireNonNull(elements); // for GWT
     // Avoid integer overflow when a large array is passed in
     int capacity = computeArrayListCapacity(elements.length);
     ArrayList<E> list = new ArrayList<>(capacity);
@@ -125,7 +125,7 @@ public final class Lists {
   @GwtCompatible(serializable = true)
   public static <E extends @Nullable Object> ArrayList<E> newArrayList(
       Iterable<? extends E> elements) {
-    checkNotNull(elements); // for GWT
+    requireNonNull(elements); // for GWT
     // Let ArrayList's sizing logic work, if possible
     return (elements instanceof Collection)
         ? new ArrayList<>((Collection<? extends E>) elements)
@@ -324,7 +324,7 @@ public final class Lists {
 
     OnePlusArrayList(@ParametricNullness E first, E[] rest) {
       this.first = first;
-      this.rest = checkNotNull(rest);
+      this.rest = requireNonNull(rest);
     }
 
     @Override
@@ -355,7 +355,7 @@ public final class Lists {
     TwoPlusArrayList(@ParametricNullness E first, @ParametricNullness E second, E[] rest) {
       this.first = first;
       this.second = second;
-      this.rest = checkNotNull(rest);
+      this.rest = requireNonNull(rest);
     }
 
     @Override
@@ -549,8 +549,8 @@ public final class Lists {
     final Function<? super F, ? extends T> function;
 
     TransformingSequentialList(List<F> fromList, Function<? super F, ? extends T> function) {
-      this.fromList = checkNotNull(fromList);
-      this.function = checkNotNull(function);
+      this.fromList = requireNonNull(fromList);
+      this.function = requireNonNull(function);
     }
 
     /**
@@ -580,7 +580,7 @@ public final class Lists {
 
     @Override
     public boolean removeIf(Predicate<? super T> filter) {
-      checkNotNull(filter);
+      requireNonNull(filter);
       return fromList.removeIf(element -> filter.test(function.apply(element)));
     }
 
@@ -601,8 +601,8 @@ public final class Lists {
     final Function<? super F, ? extends T> function;
 
     TransformingRandomAccessList(List<F> fromList, Function<? super F, ? extends T> function) {
-      this.fromList = checkNotNull(fromList);
-      this.function = checkNotNull(function);
+      this.fromList = requireNonNull(fromList);
+      this.function = requireNonNull(function);
     }
 
     @Override
@@ -638,7 +638,7 @@ public final class Lists {
 
     @Override
     public boolean removeIf(Predicate<? super T> filter) {
-      checkNotNull(filter);
+      requireNonNull(filter);
       return fromList.removeIf(element -> filter.test(function.apply(element)));
     }
 
@@ -672,7 +672,7 @@ public final class Lists {
    * @throws IllegalArgumentException if {@code partitionSize} is nonpositive
    */
   public static <T extends @Nullable Object> List<List<T>> partition(List<T> list, int size) {
-    checkNotNull(list);
+    requireNonNull(list);
     checkArgument(size > 0);
     return (list instanceof RandomAccess)
         ? new RandomAccessPartition<>(list, size)
@@ -720,7 +720,7 @@ public final class Lists {
    * @since 7.0
    */
   public static ImmutableList<Character> charactersOf(String string) {
-    return new StringAsImmutableList(checkNotNull(string));
+    return new StringAsImmutableList(requireNonNull(string));
   }
 
   /**
@@ -734,7 +734,7 @@ public final class Lists {
    */
   @Beta
   public static List<Character> charactersOf(CharSequence sequence) {
-    return new CharSequenceAsList(checkNotNull(sequence));
+    return new CharSequenceAsList(requireNonNull(sequence));
   }
 
   @SuppressWarnings("serial") // serialized using ImmutableList serialization
@@ -829,7 +829,7 @@ public final class Lists {
     private final List<T> forwardList;
 
     ReverseList(List<T> forwardList) {
-      this.forwardList = checkNotNull(forwardList);
+      this.forwardList = requireNonNull(forwardList);
     }
 
     List<T> getForwardList() {
@@ -990,7 +990,7 @@ public final class Lists {
 
   /** An implementation of {@link List#equals(Object)}. */
   static boolean equalsImpl(List<?> thisList, @CheckForNull Object other) {
-    if (other == checkNotNull(thisList)) {
+    if (other == requireNonNull(thisList)) {
       return true;
     }
     if (!(other instanceof List)) {
@@ -1128,7 +1128,7 @@ public final class Lists {
     final List<E> backingList;
 
     AbstractListWrapper(List<E> backingList) {
-      this.backingList = checkNotNull(backingList);
+      this.backingList = requireNonNull(backingList);
     }
 
     @Override
diff --git a/guava/src/com/google/common/collect/MapMaker.java b/guava/src/com/google/common/collect/MapMaker.java
index a2612c1bd2..a637b61fbd 100644
--- a/guava/src/com/google/common/collect/MapMaker.java
+++ b/guava/src/com/google/common/collect/MapMaker.java
@@ -15,8 +15,8 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -121,7 +121,7 @@ public final class MapMaker {
   @GwtIncompatible // To be supported
   MapMaker keyEquivalence(Equivalence<Object> equivalence) {
     checkState(keyEquivalence == null, "key equivalence was already set to %s", keyEquivalence);
-    keyEquivalence = checkNotNull(equivalence);
+    keyEquivalence = requireNonNull(equivalence);
     this.useCustomMap = true;
     return this;
   }
@@ -208,7 +208,7 @@ public final class MapMaker {
 
   MapMaker setKeyStrength(Strength strength) {
     checkState(keyStrength == null, "Key strength was already set to %s", keyStrength);
-    keyStrength = checkNotNull(strength);
+    keyStrength = requireNonNull(strength);
     if (strength != Strength.STRONG) {
       // STRONG could be used during deserialization.
       useCustomMap = true;
@@ -254,7 +254,7 @@ public final class MapMaker {
 
   MapMaker setValueStrength(Strength strength) {
     checkState(valueStrength == null, "Value strength was already set to %s", valueStrength);
-    valueStrength = checkNotNull(strength);
+    valueStrength = requireNonNull(strength);
     if (strength != Strength.STRONG) {
       // STRONG could be used during deserialization.
       useCustomMap = true;
diff --git a/guava/src/com/google/common/collect/MapMakerInternalMap.java b/guava/src/com/google/common/collect/MapMakerInternalMap.java
index 5e7daa50da..636cb9dea0 100644
--- a/guava/src/com/google/common/collect/MapMakerInternalMap.java
+++ b/guava/src/com/google/common/collect/MapMakerInternalMap.java
@@ -14,8 +14,9 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
@@ -239,9 +240,8 @@ class MapMakerInternalMap<
         && builder.getValueStrength() == Strength.STRONG) {
       return new MapMakerInternalMap<>(builder, WeakKeyDummyValueEntry.Helper.<K>instance());
     }
-    if (builder.getValueStrength() == Strength.WEAK) {
-      throw new IllegalArgumentException("Map cannot have both weak and dummy values");
-    }
+    checkArgument(
+        builder.getValueStrength() != Strength.WEAK, "Map cannot have both weak and dummy values");
     throw new AssertionError();
   }
 
@@ -583,8 +583,6 @@ class MapMakerInternalMap<
       return Dummy.VALUE;
     }
 
-    void setValue(Dummy value) {}
-
     StrongKeyDummyValueEntry<K> copy(StrongKeyDummyValueEntry<K> newNext) {
       return new StrongKeyDummyValueEntry<K>(this.key, this.hash, newNext);
     }
@@ -687,8 +685,6 @@ class MapMakerInternalMap<
       return Dummy.VALUE;
     }
 
-    void setValue(Dummy value) {}
-
     WeakKeyDummyValueEntry<K> copy(
         ReferenceQueue<K> queueForKeys, WeakKeyDummyValueEntry<K> newNext) {
       return new WeakKeyDummyValueEntry<K>(queueForKeys, getKey(), this.hash, newNext);
@@ -2008,8 +2004,8 @@ class MapMakerInternalMap<
       return this;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public StrongKeyStrongValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {
       return (StrongKeyStrongValueEntry<K, V>) entry;
     }
@@ -2038,8 +2034,8 @@ class MapMakerInternalMap<
       return queueForValues;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public StrongKeyWeakValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {
       return (StrongKeyWeakValueEntry<K, V>) entry;
     }
@@ -2096,8 +2092,8 @@ class MapMakerInternalMap<
       return this;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public StrongKeyDummyValueEntry<K> castForTesting(InternalEntry<K, Dummy, ?> entry) {
       return (StrongKeyDummyValueEntry<K>) entry;
     }
@@ -2126,8 +2122,8 @@ class MapMakerInternalMap<
       return queueForKeys;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public WeakKeyStrongValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {
       return (WeakKeyStrongValueEntry<K, V>) entry;
     }
@@ -2171,8 +2167,8 @@ class MapMakerInternalMap<
       return queueForValues;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public WeakKeyWeakValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {
       return (WeakKeyWeakValueEntry<K, V>) entry;
     }
@@ -2236,8 +2232,8 @@ class MapMakerInternalMap<
       return queueForKeys;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public WeakKeyDummyValueEntry<K> castForTesting(InternalEntry<K, Dummy, ?> entry) {
       return (WeakKeyDummyValueEntry<K>) entry;
     }
@@ -2401,8 +2397,8 @@ class MapMakerInternalMap<
   @CanIgnoreReturnValue
   @Override
   public V put(K key, V value) {
-    checkNotNull(key);
-    checkNotNull(value);
+    requireNonNull(key);
+    requireNonNull(value);
     int hash = hash(key);
     return segmentFor(hash).put(key, hash, value, false);
   }
@@ -2410,8 +2406,8 @@ class MapMakerInternalMap<
   @CanIgnoreReturnValue
   @Override
   public V putIfAbsent(K key, V value) {
-    checkNotNull(key);
-    checkNotNull(value);
+    requireNonNull(key);
+    requireNonNull(value);
     int hash = hash(key);
     return segmentFor(hash).put(key, hash, value, true);
   }
@@ -2446,8 +2442,8 @@ class MapMakerInternalMap<
   @CanIgnoreReturnValue
   @Override
   public boolean replace(K key, @Nullable V oldValue, V newValue) {
-    checkNotNull(key);
-    checkNotNull(newValue);
+    requireNonNull(key);
+    requireNonNull(newValue);
     if (oldValue == null) {
       return false;
     }
@@ -2458,8 +2454,8 @@ class MapMakerInternalMap<
   @CanIgnoreReturnValue
   @Override
   public V replace(K key, V value) {
-    checkNotNull(key);
-    checkNotNull(value);
+    requireNonNull(key);
+    requireNonNull(value);
     int hash = hash(key);
     return segmentFor(hash).replace(key, hash, value);
   }
diff --git a/guava/src/com/google/common/collect/Maps.java b/guava/src/com/google/common/collect/Maps.java
index 64ea2892df..3a558f5643 100644
--- a/guava/src/com/google/common/collect/Maps.java
+++ b/guava/src/com/google/common/collect/Maps.java
@@ -17,11 +17,12 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Predicates.compose;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
+import static java.util.Collections.unmodifiableSet;
+import static java.util.Collections.unmodifiableSortedMap;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -31,7 +32,6 @@ import com.google.common.base.Converter;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
-import com.google.common.base.Preconditions;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.MapDifference.ValueDifference;
@@ -94,15 +94,15 @@ public final class Maps {
 
   private enum EntryFunction implements Function<Entry<?, ?>, @Nullable Object> {
     KEY {
-      @Override
       @CheckForNull
+      @Override
       public Object apply(Entry<?, ?> entry) {
         return entry.getKey();
       }
     },
     VALUE {
-      @Override
       @CheckForNull
+      @Override
       public Object apply(Entry<?, ?> entry) {
         return entry.getValue();
       }
@@ -420,7 +420,7 @@ public final class Maps {
    */
   public static <K extends Enum<K>, V extends @Nullable Object> EnumMap<K, V> newEnumMap(
       Class<K> type) {
-    return new EnumMap<>(checkNotNull(type));
+    return new EnumMap<>(requireNonNull(type));
   }
 
   /**
@@ -537,7 +537,7 @@ public final class Maps {
       Map<? extends K, ? extends V> left,
       Map<? extends K, ? extends V> right,
       Equivalence<? super V> valueEquivalence) {
-    Preconditions.checkNotNull(valueEquivalence);
+    requireNonNull(valueEquivalence);
 
     Map<K, V> onlyOnLeft = newLinkedHashMap();
     Map<K, V> onlyOnRight = new LinkedHashMap<>(right); // will whittle it down
@@ -567,8 +567,8 @@ public final class Maps {
   public static <K extends @Nullable Object, V extends @Nullable Object>
       SortedMapDifference<K, V> difference(
           SortedMap<K, ? extends V> left, Map<? extends K, ? extends V> right) {
-    checkNotNull(left);
-    checkNotNull(right);
+    requireNonNull(left);
+    requireNonNull(right);
     Comparator<? super K> comparator = orNaturalOrder(left.comparator());
     SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);
     SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);
@@ -629,7 +629,7 @@ public final class Maps {
   private static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> unmodifiableMap(
       Map<K, ? extends V> map) {
     if (map instanceof SortedMap) {
-      return Collections.unmodifiableSortedMap((SortedMap<K, ? extends V>) map);
+      return unmodifiableSortedMap((SortedMap<K, ? extends V>) map);
     } else {
       return Collections.unmodifiableMap(map);
     }
@@ -909,8 +909,8 @@ public final class Maps {
     }
 
     AsMapView(Set<K> set, Function<? super K, V> function) {
-      this.set = checkNotNull(set);
-      this.function = checkNotNull(function);
+      this.set = requireNonNull(set);
+      this.function = requireNonNull(function);
     }
 
     @Override
@@ -933,14 +933,14 @@ public final class Maps {
       return backingSet().contains(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
-      return getOrDefault(key, null);
+      return this.get(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {
       if (Collections2.safeContains(backingSet(), key)) {
         @SuppressWarnings("unchecked") // unsafe, but Javadoc warns about it
@@ -951,8 +951,8 @@ public final class Maps {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object key) {
       if (backingSet().remove(key)) {
         @SuppressWarnings("unchecked") // unsafe, but Javadoc warns about it
@@ -987,7 +987,7 @@ public final class Maps {
 
     @Override
     public void forEach(BiConsumer<? super K, ? super V> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       // avoids allocation of entries
       backingSet().forEach(k -> action.accept(k, function.apply(k)));
     }
@@ -1015,8 +1015,8 @@ public final class Maps {
       return (SortedSet<K>) super.backingSet();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return backingSet().comparator();
     }
@@ -1067,8 +1067,8 @@ public final class Maps {
     private final Function<? super K, V> function;
 
     NavigableAsMapView(NavigableSet<K> ks, Function<? super K, V> vFunction) {
-      this.set = checkNotNull(ks);
-      this.function = checkNotNull(vFunction);
+      this.set = requireNonNull(ks);
+      this.function = requireNonNull(vFunction);
     }
 
     @Override
@@ -1090,20 +1090,20 @@ public final class Maps {
       return asMap(set.tailSet(fromKey, inclusive), function);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return set.comparator();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
-      return getOrDefault(key, null);
+      return this.get(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {
       if (Collections2.safeContains(set, key)) {
         @SuppressWarnings("unchecked") // unsafe, but Javadoc warns about it
@@ -1308,7 +1308,7 @@ public final class Maps {
    */
   public static <K, V> ImmutableMap<K, V> toMap(
       Iterator<K> keys, Function<? super K, V> valueFunction) {
-    checkNotNull(valueFunction);
+    requireNonNull(valueFunction);
     ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();
     while (keys.hasNext()) {
       K key = keys.next();
@@ -1385,7 +1385,7 @@ public final class Maps {
   @CanIgnoreReturnValue
   public static <K, V> ImmutableMap<K, V> uniqueIndex(
       Iterator<V> values, Function<? super V, K> keyFunction) {
-    checkNotNull(keyFunction);
+    requireNonNull(keyFunction);
     ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();
     while (values.hasNext()) {
       V value = values.next();
@@ -1476,7 +1476,7 @@ public final class Maps {
    */
   static <K extends @Nullable Object, V extends @Nullable Object>
       Set<Entry<K, V>> unmodifiableEntrySet(Set<Entry<K, V>> entrySet) {
-    return new UnmodifiableEntrySet<>(Collections.unmodifiableSet(entrySet));
+    return new UnmodifiableEntrySet<>(unmodifiableSet(entrySet));
   }
 
   /**
@@ -1490,7 +1490,7 @@ public final class Maps {
    */
   static <K extends @Nullable Object, V extends @Nullable Object> Entry<K, V> unmodifiableEntry(
       final Entry<? extends K, ? extends V> entry) {
-    checkNotNull(entry);
+    requireNonNull(entry);
     return new AbstractMapEntry<K, V>() {
       @Override
       @ParametricNullness
@@ -1604,7 +1604,7 @@ public final class Maps {
     private final BiMap<A, B> bimap;
 
     BiMapConverter(BiMap<A, B> bimap) {
-      this.bimap = checkNotNull(bimap);
+      this.bimap = requireNonNull(bimap);
     }
 
     @Override
@@ -1717,8 +1717,8 @@ public final class Maps {
       return unmodifiableMap;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V forcePut(@ParametricNullness K key, @ParametricNullness V value) {
       throw new UnsupportedOperationException();
     }
@@ -1728,8 +1728,8 @@ public final class Maps {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V putIfAbsent(K key, V value) {
       throw new UnsupportedOperationException();
     }
@@ -1744,8 +1744,8 @@ public final class Maps {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V replace(K key, V value) {
       throw new UnsupportedOperationException();
     }
@@ -1785,7 +1785,7 @@ public final class Maps {
     @Override
     public Set<V> values() {
       Set<V> result = values;
-      return (result == null) ? values = Collections.unmodifiableSet(delegate.values()) : result;
+      return (result == null) ? values = unmodifiableSet(delegate.values()) : result;
     }
 
     private static final long serialVersionUID = 0;
@@ -2115,7 +2115,7 @@ public final class Maps {
   /** Views a function as an entry transformer that ignores the entry key. */
   static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
       EntryTransformer<K, V1, V2> asEntryTransformer(final Function<? super V1, V2> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     return new EntryTransformer<K, V1, V2>() {
       @Override
       @ParametricNullness
@@ -2128,7 +2128,7 @@ public final class Maps {
   static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
       Function<V1, V2> asValueToValueFunction(
           final EntryTransformer<? super K, V1, V2> transformer, @ParametricNullness final K key) {
-    checkNotNull(transformer);
+    requireNonNull(transformer);
     return new Function<V1, V2>() {
       @Override
       @ParametricNullness
@@ -2142,7 +2142,7 @@ public final class Maps {
   static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
       Function<Entry<K, V1>, V2> asEntryToValueFunction(
           final EntryTransformer<? super K, ? super V1, V2> transformer) {
-    checkNotNull(transformer);
+    requireNonNull(transformer);
     return new Function<Entry<K, V1>, V2>() {
       @Override
       @ParametricNullness
@@ -2156,8 +2156,8 @@ public final class Maps {
   static <V2 extends @Nullable Object, K extends @Nullable Object, V1 extends @Nullable Object>
       Entry<K, V2> transformEntry(
           final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry) {
-    checkNotNull(transformer);
-    checkNotNull(entry);
+    requireNonNull(transformer);
+    requireNonNull(entry);
     return new AbstractMapEntry<K, V2>() {
       @Override
       @ParametricNullness
@@ -2177,7 +2177,7 @@ public final class Maps {
   static <K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
       Function<Entry<K, V1>, Entry<K, V2>> asEntryToEntryFunction(
           final EntryTransformer<? super K, ? super V1, V2> transformer) {
-    checkNotNull(transformer);
+    requireNonNull(transformer);
     return new Function<Entry<K, V1>, Entry<K, V2>>() {
       @Override
       public Entry<K, V2> apply(final Entry<K, V1> entry) {
@@ -2194,8 +2194,8 @@ public final class Maps {
 
     TransformedEntriesMap(
         Map<K, V1> fromMap, EntryTransformer<? super K, ? super V1, V2> transformer) {
-      this.fromMap = checkNotNull(fromMap);
-      this.transformer = checkNotNull(transformer);
+      this.fromMap = requireNonNull(fromMap);
+      this.transformer = requireNonNull(transformer);
     }
 
     @Override
@@ -2208,16 +2208,16 @@ public final class Maps {
       return fromMap.containsKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V2 get(@CheckForNull Object key) {
-      return getOrDefault(key, null);
+      return this.get(key);
     }
 
     // safe as long as the user followed the <b>Warning</b> in the javadoc
-    @SuppressWarnings("unchecked")
-    @Override
     @CheckForNull
+    @Override
+    @SuppressWarnings("unchecked")
     public V2 getOrDefault(@CheckForNull Object key, @CheckForNull V2 defaultValue) {
       V1 value = fromMap.get(key);
       if (value != null || fromMap.containsKey(key)) {
@@ -2228,9 +2228,9 @@ public final class Maps {
     }
 
     // safe as long as the user followed the <b>Warning</b> in the javadoc
-    @SuppressWarnings("unchecked")
-    @Override
     @CheckForNull
+    @Override
+    @SuppressWarnings("unchecked")
     public V2 remove(@CheckForNull Object key) {
       return fromMap.containsKey(key)
           // The cast is safe because of the containsKey check.
@@ -2262,7 +2262,7 @@ public final class Maps {
 
     @Override
     public void forEach(BiConsumer<? super K, ? super V2> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       // avoids creating new Entry<K, V2> objects
       fromMap.forEach((k, v1) -> action.accept(k, transformer.transformEntry(k, v1)));
     }
@@ -2286,8 +2286,8 @@ public final class Maps {
       super(fromMap, transformer);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return fromMap().comparator();
     }
@@ -2330,14 +2330,14 @@ public final class Maps {
       super(fromMap, transformer);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> ceilingEntry(@ParametricNullness K key) {
       return transformEntry(fromMap().ceilingEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K ceilingKey(@ParametricNullness K key) {
       return fromMap().ceilingKey(key);
     }
@@ -2352,20 +2352,20 @@ public final class Maps {
       return transformEntries(fromMap().descendingMap(), transformer);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> firstEntry() {
       return transformEntry(fromMap().firstEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> floorEntry(@ParametricNullness K key) {
       return transformEntry(fromMap().floorEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K floorKey(@ParametricNullness K key) {
       return fromMap().floorKey(key);
     }
@@ -2380,32 +2380,32 @@ public final class Maps {
       return transformEntries(fromMap().headMap(toKey, inclusive), transformer);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> higherEntry(@ParametricNullness K key) {
       return transformEntry(fromMap().higherEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K higherKey(@ParametricNullness K key) {
       return fromMap().higherKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> lastEntry() {
       return transformEntry(fromMap().lastEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> lowerEntry(@ParametricNullness K key) {
       return transformEntry(fromMap().lowerEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K lowerKey(@ParametricNullness K key) {
       return fromMap().lowerKey(key);
     }
@@ -2415,14 +2415,14 @@ public final class Maps {
       return fromMap().navigableKeySet();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> pollFirstEntry() {
       return transformEntry(fromMap().pollFirstEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V2> pollLastEntry() {
       return transformEntry(fromMap().pollLastEntry());
     }
@@ -2498,11 +2498,11 @@ public final class Maps {
    */
   public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterKeys(
       Map<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
-    checkNotNull(keyPredicate);
+    requireNonNull(keyPredicate);
     Predicate<Entry<K, ?>> entryPredicate = keyPredicateOnEntries(keyPredicate);
     return (unfiltered instanceof AbstractFilteredMap)
         ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)
-        : new FilteredKeyMap<K, V>(checkNotNull(unfiltered), keyPredicate, entryPredicate);
+        : new FilteredKeyMap<K, V>(requireNonNull(unfiltered), keyPredicate, entryPredicate);
   }
 
   /**
@@ -2599,7 +2599,7 @@ public final class Maps {
    */
   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterKeys(
       BiMap<K, V> unfiltered, final Predicate<? super K> keyPredicate) {
-    checkNotNull(keyPredicate);
+    requireNonNull(keyPredicate);
     return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));
   }
 
@@ -2754,10 +2754,10 @@ public final class Maps {
    */
   public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterEntries(
       Map<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
-    checkNotNull(entryPredicate);
+    requireNonNull(entryPredicate);
     return (unfiltered instanceof AbstractFilteredMap)
         ? filterFiltered((AbstractFilteredMap<K, V>) unfiltered, entryPredicate)
-        : new FilteredEntryMap<K, V>(checkNotNull(unfiltered), entryPredicate);
+        : new FilteredEntryMap<K, V>(requireNonNull(unfiltered), entryPredicate);
   }
 
   /**
@@ -2789,10 +2789,10 @@ public final class Maps {
   public static <K extends @Nullable Object, V extends @Nullable Object>
       SortedMap<K, V> filterEntries(
           SortedMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
-    checkNotNull(entryPredicate);
+    requireNonNull(entryPredicate);
     return (unfiltered instanceof FilteredEntrySortedMap)
         ? filterFiltered((FilteredEntrySortedMap<K, V>) unfiltered, entryPredicate)
-        : new FilteredEntrySortedMap<K, V>(checkNotNull(unfiltered), entryPredicate);
+        : new FilteredEntrySortedMap<K, V>(requireNonNull(unfiltered), entryPredicate);
   }
 
   /**
@@ -2825,10 +2825,10 @@ public final class Maps {
   public static <K extends @Nullable Object, V extends @Nullable Object>
       NavigableMap<K, V> filterEntries(
           NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
-    checkNotNull(entryPredicate);
+    requireNonNull(entryPredicate);
     return (unfiltered instanceof FilteredEntryNavigableMap)
         ? filterFiltered((FilteredEntryNavigableMap<K, V>) unfiltered, entryPredicate)
-        : new FilteredEntryNavigableMap<K, V>(checkNotNull(unfiltered), entryPredicate);
+        : new FilteredEntryNavigableMap<K, V>(requireNonNull(unfiltered), entryPredicate);
   }
 
   /**
@@ -2860,8 +2860,8 @@ public final class Maps {
    */
   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterEntries(
       BiMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
-    checkNotNull(unfiltered);
-    checkNotNull(entryPredicate);
+    requireNonNull(unfiltered);
+    requireNonNull(entryPredicate);
     return (unfiltered instanceof FilteredEntryBiMap)
         ? filterFiltered((FilteredEntryBiMap<K, V>) unfiltered, entryPredicate)
         : new FilteredEntryBiMap<K, V>(unfiltered, entryPredicate);
@@ -2926,13 +2926,13 @@ public final class Maps {
     boolean apply(@CheckForNull Object key, @ParametricNullness V value) {
       // This method is called only when the key is in the map (or about to be added to the map),
       // implying that key is a K.
-      @SuppressWarnings({"unchecked", "nullness"})
+      @SuppressWarnings({"nullness", "unchecked"})
       K k = (K) key;
       return predicate.apply(Maps.immutableEntry(k, value));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(@ParametricNullness K key, @ParametricNullness V value) {
       checkArgument(apply(key, value));
       return unfiltered.put(key, value);
@@ -2951,8 +2951,8 @@ public final class Maps {
       return unfiltered.containsKey(key) && apply(key, unfiltered.get(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
       V value = unfiltered.get(key);
       return ((value != null) && apply(key, value)) ? value : null;
@@ -2960,11 +2960,11 @@ public final class Maps {
 
     @Override
     public boolean isEmpty() {
-      return entrySet().isEmpty();
+      return this.isEmpty();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object key) {
       return containsKey(key) ? unfiltered.remove(key) : null;
     }
@@ -3218,8 +3218,8 @@ public final class Maps {
 
     @WeakOuter
     class SortedKeySet extends KeySet implements SortedSet<K> {
-      @Override
       @CheckForNull
+      @Override
       public Comparator<? super K> comparator() {
         return sortedMap().comparator();
       }
@@ -3253,8 +3253,8 @@ public final class Maps {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return sortedMap().comparator();
     }
@@ -3313,13 +3313,13 @@ public final class Maps {
 
     FilteredEntryNavigableMap(
         NavigableMap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
-      this.unfiltered = checkNotNull(unfiltered);
+      this.unfiltered = requireNonNull(unfiltered);
       this.entryPredicate = entryPredicate;
       this.filteredDelegate = new FilteredEntryMap<>(unfiltered, entryPredicate);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return unfiltered.comparator();
     }
@@ -3364,8 +3364,8 @@ public final class Maps {
       return !Iterables.any(unfiltered.entrySet(), entryPredicate);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
       return filteredDelegate.get(key);
     }
@@ -3375,14 +3375,14 @@ public final class Maps {
       return filteredDelegate.containsKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(@ParametricNullness K key, @ParametricNullness V value) {
       return filteredDelegate.put(key, value);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object key) {
       return filteredDelegate.remove(key);
     }
@@ -3402,14 +3402,14 @@ public final class Maps {
       return filteredDelegate.entrySet();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> pollFirstEntry() {
       return Iterables.removeFirstMatching(unfiltered.entrySet(), entryPredicate);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> pollLastEntry() {
       return Iterables.removeFirstMatching(unfiltered.descendingMap().entrySet(), entryPredicate);
     }
@@ -3471,8 +3471,8 @@ public final class Maps {
       return (BiMap<K, V>) unfiltered;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V forcePut(@ParametricNullness K key, @ParametricNullness V value) {
       checkArgument(apply(key, value));
       return unfiltered().forcePut(key, value);
@@ -3520,7 +3520,7 @@ public final class Maps {
   @GwtIncompatible // NavigableMap
   public static <K extends @Nullable Object, V extends @Nullable Object>
       NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> map) {
-    checkNotNull(map);
+    requireNonNull(map);
     if (map instanceof UnmodifiableNavigableMap) {
       @SuppressWarnings("unchecked") // covariant
       NavigableMap<K, V> result = (NavigableMap<K, V>) map;
@@ -3553,77 +3553,77 @@ public final class Maps {
 
     @Override
     protected SortedMap<K, V> delegate() {
-      return Collections.unmodifiableSortedMap(delegate);
+      return unmodifiableSortedMap(delegate);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> lowerEntry(@ParametricNullness K key) {
       return unmodifiableOrNull(delegate.lowerEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K lowerKey(@ParametricNullness K key) {
       return delegate.lowerKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> floorEntry(@ParametricNullness K key) {
       return unmodifiableOrNull(delegate.floorEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K floorKey(@ParametricNullness K key) {
       return delegate.floorKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> ceilingEntry(@ParametricNullness K key) {
       return unmodifiableOrNull(delegate.ceilingEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K ceilingKey(@ParametricNullness K key) {
       return delegate.ceilingKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> higherEntry(@ParametricNullness K key) {
       return unmodifiableOrNull(delegate.higherEntry(key));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K higherKey(@ParametricNullness K key) {
       return delegate.higherKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> firstEntry() {
       return unmodifiableOrNull(delegate.firstEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> lastEntry() {
       return unmodifiableOrNull(delegate.lastEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public final Entry<K, V> pollFirstEntry() {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public final Entry<K, V> pollLastEntry() {
       throw new UnsupportedOperationException();
     }
@@ -3633,8 +3633,8 @@ public final class Maps {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V putIfAbsent(K key, V value) {
       throw new UnsupportedOperationException();
     }
@@ -3649,8 +3649,8 @@ public final class Maps {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V replace(K key, V value) {
       throw new UnsupportedOperationException();
     }
@@ -3896,7 +3896,7 @@ public final class Maps {
    */
   @CheckForNull
   static <V extends @Nullable Object> V safeGet(Map<?, V> map, @CheckForNull Object key) {
-    checkNotNull(map);
+    requireNonNull(map);
     try {
       return map.get(key);
     } catch (ClassCastException | NullPointerException e) {
@@ -3909,7 +3909,7 @@ public final class Maps {
    * {@code NullPointerException}.
    */
   static boolean safeContainsKey(Map<?, ?> map, @CheckForNull Object key) {
-    checkNotNull(map);
+    requireNonNull(map);
     try {
       return map.containsKey(key);
     } catch (ClassCastException | NullPointerException e) {
@@ -3923,7 +3923,7 @@ public final class Maps {
    */
   @CheckForNull
   static <V extends @Nullable Object> V safeRemove(Map<?, V> map, @CheckForNull Object key) {
-    checkNotNull(map);
+    requireNonNull(map);
     try {
       return map.remove(key);
     } catch (ClassCastException | NullPointerException e) {
@@ -4018,7 +4018,7 @@ public final class Maps {
     @Weak final Map<K, V> map;
 
     KeySet(Map<K, V> map) {
-      this.map = checkNotNull(map);
+      this.map = requireNonNull(map);
     }
 
     Map<K, V> map() {
@@ -4032,7 +4032,7 @@ public final class Maps {
 
     @Override
     public void forEach(Consumer<? super K> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       // avoids entry allocation for those maps that allocate entries on iteration
       map.forEach((k, v) -> action.accept(k));
     }
@@ -4088,8 +4088,8 @@ public final class Maps {
       return (SortedMap<K, V>) super.map();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       return map().comparator();
     }
@@ -4134,38 +4134,38 @@ public final class Maps {
       return (NavigableMap<K, V>) map;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K lower(@ParametricNullness K e) {
       return map().lowerKey(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K floor(@ParametricNullness K e) {
       return map().floorKey(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K ceiling(@ParametricNullness K e) {
       return map().ceilingKey(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K higher(@ParametricNullness K e) {
       return map().higherKey(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K pollFirst() {
       return keyOrNull(map().pollFirstEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K pollLast() {
       return keyOrNull(map().pollLastEntry());
     }
@@ -4220,7 +4220,7 @@ public final class Maps {
     @Weak final Map<K, V> map;
 
     Values(Map<K, V> map) {
-      this.map = checkNotNull(map);
+      this.map = requireNonNull(map);
     }
 
     final Map<K, V> map() {
@@ -4234,7 +4234,7 @@ public final class Maps {
 
     @Override
     public void forEach(Consumer<? super V> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       // avoids allocation of entries for those maps that generate fresh entries on iteration
       map.forEach((k, v) -> action.accept(v));
     }
@@ -4257,7 +4257,7 @@ public final class Maps {
     @Override
     public boolean removeAll(Collection<?> c) {
       try {
-        return super.removeAll(checkNotNull(c));
+        return super.removeAll(requireNonNull(c));
       } catch (UnsupportedOperationException e) {
         Set<K> toRemove = Sets.newHashSet();
         for (Entry<K, V> entry : map().entrySet()) {
@@ -4272,7 +4272,7 @@ public final class Maps {
     @Override
     public boolean retainAll(Collection<?> c) {
       try {
-        return super.retainAll(checkNotNull(c));
+        return super.retainAll(requireNonNull(c));
       } catch (UnsupportedOperationException e) {
         Set<K> toRetain = Sets.newHashSet();
         for (Entry<K, V> entry : map().entrySet()) {
@@ -4351,7 +4351,7 @@ public final class Maps {
     @Override
     public boolean removeAll(Collection<?> c) {
       try {
-        return super.removeAll(checkNotNull(c));
+        return super.removeAll(requireNonNull(c));
       } catch (UnsupportedOperationException e) {
         // if the iterators don't support remove
         return Sets.removeAllImpl(this, c.iterator());
@@ -4361,7 +4361,7 @@ public final class Maps {
     @Override
     public boolean retainAll(Collection<?> c) {
       try {
-        return super.retainAll(checkNotNull(c));
+        return super.retainAll(requireNonNull(c));
       } catch (UnsupportedOperationException e) {
         // if the iterators don't support remove
         Set<@Nullable Object> keys = Sets.newHashSetWithExpectedSize(c.size());
@@ -4393,8 +4393,8 @@ public final class Maps {
 
     @CheckForNull private transient Comparator<? super K> comparator;
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Comparator<? super K> comparator() {
       Comparator<? super K> result = comparator;
       if (result == null) {
@@ -4424,74 +4424,74 @@ public final class Maps {
       return forward().firstKey();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> lowerEntry(@ParametricNullness K key) {
       return forward().higherEntry(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K lowerKey(@ParametricNullness K key) {
       return forward().higherKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> floorEntry(@ParametricNullness K key) {
       return forward().ceilingEntry(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K floorKey(@ParametricNullness K key) {
       return forward().ceilingKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> ceilingEntry(@ParametricNullness K key) {
       return forward().floorEntry(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K ceilingKey(@ParametricNullness K key) {
       return forward().floorKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> higherEntry(@ParametricNullness K key) {
       return forward().lowerEntry(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K higherKey(@ParametricNullness K key) {
       return forward().lowerKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> firstEntry() {
       return forward().lastEntry();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> lastEntry() {
       return forward().firstEntry();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> pollFirstEntry() {
       return forward().pollLastEntry();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<K, V> pollLastEntry() {
       return forward().pollFirstEntry();
     }
@@ -4639,6 +4639,6 @@ public final class Maps {
     } else if (range.hasUpperBound()) {
       return map.headMap(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);
     }
-    return checkNotNull(map);
+    return requireNonNull(map);
   }
 }
diff --git a/guava/src/com/google/common/collect/MinMaxPriorityQueue.java b/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
index 181b3fbb50..1f0820e864 100644
--- a/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
+++ b/guava/src/com/google/common/collect/MinMaxPriorityQueue.java
@@ -17,7 +17,6 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
@@ -175,7 +174,7 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
     private int maximumSize = Integer.MAX_VALUE;
 
     private Builder(Comparator<B> comparator) {
-      this.comparator = checkNotNull(comparator);
+      this.comparator = requireNonNull(comparator);
     }
 
     /**
@@ -287,7 +286,7 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
   @CanIgnoreReturnValue
   @Override
   public boolean offer(E element) {
-    checkNotNull(element);
+    requireNonNull(element);
     modCount++;
     int insertIndex = size++;
 
@@ -300,8 +299,8 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public E poll() {
     return isEmpty() ? null : removeAndGet(0);
   }
@@ -315,8 +314,8 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
     return (E) requireNonNull(queue[index]);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E peek() {
     return isEmpty() ? null : elementData(0);
   }
@@ -409,9 +408,9 @@ public final class MinMaxPriorityQueue<E> extends AbstractQueue<E> {
    * down to replace the element at {@code index}. This fact is used by iterator.remove so as to
    * visit elements during a traversal once and only once.
    */
-  @VisibleForTesting
   @CanIgnoreReturnValue
   @CheckForNull
+  @VisibleForTesting
   MoveDesc<E> removeAt(int index) {
     checkPositionIndex(index, size);
     modCount++;
diff --git a/guava/src/com/google/common/collect/MoreCollectors.java b/guava/src/com/google/common/collect/MoreCollectors.java
index 5a84a4628e..0043f2b17e 100644
--- a/guava/src/com/google/common/collect/MoreCollectors.java
+++ b/guava/src/com/google/common/collect/MoreCollectors.java
@@ -16,8 +16,8 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.ArrayList;
@@ -115,7 +115,7 @@ public final class MoreCollectors {
     }
 
     void add(Object o) {
-      checkNotNull(o);
+      requireNonNull(o);
       if (element == null) {
         this.element = o;
       } else if (extras.isEmpty()) {
diff --git a/guava/src/com/google/common/collect/Multimap.java b/guava/src/com/google/common/collect/Multimap.java
index 0f8385191c..7b5518ea66 100644
--- a/guava/src/com/google/common/collect/Multimap.java
+++ b/guava/src/com/google/common/collect/Multimap.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -341,7 +341,7 @@ public interface Multimap<K extends @Nullable Object, V extends @Nullable Object
    * @since 21.0
    */
   default void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     entries().forEach(entry -> action.accept(entry.getKey(), entry.getValue()));
   }
 
diff --git a/guava/src/com/google/common/collect/MultimapBuilder.java b/guava/src/com/google/common/collect/MultimapBuilder.java
index 3d6278aaec..7e03733d9d 100644
--- a/guava/src/com/google/common/collect/MultimapBuilder.java
+++ b/guava/src/com/google/common/collect/MultimapBuilder.java
@@ -16,8 +16,8 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Supplier;
@@ -155,7 +155,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    */
   public static <K0 extends @Nullable Object> MultimapBuilderWithKeys<K0> treeKeys(
       Comparator<K0> comparator) {
-    checkNotNull(comparator);
+    requireNonNull(comparator);
     return new MultimapBuilderWithKeys<K0>() {
       @Override
       <K extends K0, V extends @Nullable Object> Map<K, Collection<V>> createMap() {
@@ -170,10 +170,10 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
    * @since 16.0
    */
   public static <K0 extends Enum<K0>> MultimapBuilderWithKeys<K0> enumKeys(Class<K0> keyClass) {
-    checkNotNull(keyClass);
+    requireNonNull(keyClass);
     return new MultimapBuilderWithKeys<K0>() {
-      @SuppressWarnings("unchecked")
       @Override
+      @SuppressWarnings("unchecked")
       <K extends K0, V extends @Nullable Object> Map<K, Collection<V>> createMap() {
         // K must actually be K0, since enums are effectively final
         // (their subclasses are inaccessible)
@@ -245,7 +245,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     private final Comparator<? super V> comparator;
 
     TreeSetSupplier(Comparator<? super V> comparator) {
-      this.comparator = checkNotNull(comparator);
+      this.comparator = requireNonNull(comparator);
     }
 
     @Override
@@ -259,7 +259,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
     private final Class<V> clazz;
 
     EnumSetSupplier(Class<V> clazz) {
-      this.clazz = checkNotNull(clazz);
+      this.clazz = requireNonNull(clazz);
     }
 
     @Override
@@ -377,7 +377,7 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
      */
     public <V0 extends @Nullable Object> SortedSetMultimapBuilder<K0, V0> treeSetValues(
         Comparator<V0> comparator) {
-      checkNotNull(comparator, "comparator");
+      requireNonNull(comparator, "comparator");
       return new SortedSetMultimapBuilder<K0, V0>() {
         @Override
         public <K extends K0, V extends V0> SortedSetMultimap<K, V> build() {
@@ -389,13 +389,13 @@ public abstract class MultimapBuilder<K0 extends @Nullable Object, V0 extends @N
 
     /** Uses an {@link EnumSet} to store value collections. */
     public <V0 extends Enum<V0>> SetMultimapBuilder<K0, V0> enumSetValues(Class<V0> valueClass) {
-      checkNotNull(valueClass, "valueClass");
+      requireNonNull(valueClass, "valueClass");
       return new SetMultimapBuilder<K0, V0>() {
         @Override
         public <K extends K0, V extends V0> SetMultimap<K, V> build() {
           // V must actually be V0, since enums are effectively final
           // (their subclasses are inaccessible)
-          @SuppressWarnings({"unchecked", "rawtypes"})
+          @SuppressWarnings({"rawtypes", "unchecked"})
           Supplier<Set<V>> factory = (Supplier) new EnumSetSupplier<V0>(valueClass);
           return Multimaps.newSetMultimap(MultimapBuilderWithKeys.this.<K, V>createMap(), factory);
         }
diff --git a/guava/src/com/google/common/collect/Multimaps.java b/guava/src/com/google/common/collect/Multimaps.java
index 1c3f8cc4a6..818c4f359f 100644
--- a/guava/src/com/google/common/collect/Multimaps.java
+++ b/guava/src/com/google/common/collect/Multimaps.java
@@ -20,6 +20,11 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
+import static java.util.Collections.unmodifiableCollection;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Collections.unmodifiableSet;
+import static java.util.Collections.unmodifiableSortedSet;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -40,7 +45,6 @@ import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.AbstractCollection;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -218,7 +222,7 @@ public final class Multimaps {
 
     CustomMultimap(Map<K, Collection<V>> map, Supplier<? extends Collection<V>> factory) {
       super(map);
-      this.factory = checkNotNull(factory);
+      this.factory = requireNonNull(factory);
     }
 
     @Override
@@ -242,13 +246,13 @@ public final class Multimaps {
       if (collection instanceof NavigableSet) {
         return Sets.unmodifiableNavigableSet((NavigableSet<E>) collection);
       } else if (collection instanceof SortedSet) {
-        return Collections.unmodifiableSortedSet((SortedSet<E>) collection);
+        return unmodifiableSortedSet((SortedSet<E>) collection);
       } else if (collection instanceof Set) {
-        return Collections.unmodifiableSet((Set<E>) collection);
+        return unmodifiableSet((Set<E>) collection);
       } else if (collection instanceof List) {
-        return Collections.unmodifiableList((List<E>) collection);
+        return unmodifiableList((List<E>) collection);
       } else {
-        return Collections.unmodifiableCollection(collection);
+        return unmodifiableCollection(collection);
       }
     }
 
@@ -335,7 +339,7 @@ public final class Multimaps {
 
     CustomListMultimap(Map<K, Collection<V>> map, Supplier<? extends List<V>> factory) {
       super(map);
-      this.factory = checkNotNull(factory);
+      this.factory = requireNonNull(factory);
     }
 
     @Override
@@ -417,7 +421,7 @@ public final class Multimaps {
 
     CustomSetMultimap(Map<K, Collection<V>> map, Supplier<? extends Set<V>> factory) {
       super(map);
-      this.factory = checkNotNull(factory);
+      this.factory = requireNonNull(factory);
     }
 
     @Override
@@ -441,9 +445,9 @@ public final class Multimaps {
       if (collection instanceof NavigableSet) {
         return Sets.unmodifiableNavigableSet((NavigableSet<E>) collection);
       } else if (collection instanceof SortedSet) {
-        return Collections.unmodifiableSortedSet((SortedSet<E>) collection);
+        return unmodifiableSortedSet((SortedSet<E>) collection);
       } else {
-        return Collections.unmodifiableSet((Set<E>) collection);
+        return unmodifiableSet((Set<E>) collection);
       }
     }
 
@@ -524,7 +528,7 @@ public final class Multimaps {
 
     CustomSortedSetMultimap(Map<K, Collection<V>> map, Supplier<? extends SortedSet<V>> factory) {
       super(map);
-      this.factory = checkNotNull(factory);
+      this.factory = requireNonNull(factory);
       valueComparator = factory.get().comparator();
     }
 
@@ -543,8 +547,8 @@ public final class Multimaps {
       return factory.get();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super V> valueComparator() {
       return valueComparator;
     }
@@ -587,7 +591,7 @@ public final class Multimaps {
   @CanIgnoreReturnValue
   public static <K extends @Nullable Object, V extends @Nullable Object, M extends Multimap<K, V>>
       M invertFrom(Multimap<? extends V, ? extends K> source, M dest) {
-    checkNotNull(dest);
+    requireNonNull(dest);
     for (Map.Entry<? extends V, ? extends K> entry : source.entries()) {
       dest.put(entry.getValue(), entry.getKey());
     }
@@ -658,7 +662,7 @@ public final class Multimaps {
    */
   @Deprecated
   public static <K, V> Multimap<K, V> unmodifiableMultimap(ImmutableMultimap<K, V> delegate) {
-    return checkNotNull(delegate);
+    return requireNonNull(delegate);
   }
 
   private static class UnmodifiableMultimap<K extends @Nullable Object, V extends @Nullable Object>
@@ -671,7 +675,7 @@ public final class Multimaps {
     @LazyInit @CheckForNull transient Map<K, Collection<V>> map;
 
     UnmodifiableMultimap(final Multimap<K, V> delegate) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
@@ -690,7 +694,7 @@ public final class Multimaps {
       if (result == null) {
         result =
             map =
-                Collections.unmodifiableMap(
+                unmodifiableMap(
                     Maps.transformValues(
                         delegate.asMap(),
                         new Function<Collection<V>, Collection<V>>() {
@@ -714,7 +718,7 @@ public final class Multimaps {
 
     @Override
     public void forEach(BiConsumer<? super K, ? super V> consumer) {
-      delegate.forEach(checkNotNull(consumer));
+      delegate.forEach(requireNonNull(consumer));
     }
 
     @Override
@@ -735,7 +739,7 @@ public final class Multimaps {
     public Set<K> keySet() {
       Set<K> result = keySet;
       if (result == null) {
-        keySet = result = Collections.unmodifiableSet(delegate.keySet());
+        keySet = result = unmodifiableSet(delegate.keySet());
       }
       return result;
     }
@@ -774,7 +778,7 @@ public final class Multimaps {
     public Collection<V> values() {
       Collection<V> result = values;
       if (result == null) {
-        values = result = Collections.unmodifiableCollection(delegate.values());
+        values = result = unmodifiableCollection(delegate.values());
       }
       return result;
     }
@@ -796,7 +800,7 @@ public final class Multimaps {
 
     @Override
     public List<V> get(@ParametricNullness K key) {
-      return Collections.unmodifiableList(delegate().get(key));
+      return unmodifiableList(delegate().get(key));
     }
 
     @Override
@@ -830,7 +834,7 @@ public final class Multimaps {
        * Note that this doesn't return a SortedSet when delegate is a
        * SortedSetMultiset, unlike (SortedSet<V>) super.get().
        */
-      return Collections.unmodifiableSet(delegate().get(key));
+      return unmodifiableSet(delegate().get(key));
     }
 
     @Override
@@ -865,7 +869,7 @@ public final class Multimaps {
 
     @Override
     public SortedSet<V> get(@ParametricNullness K key) {
-      return Collections.unmodifiableSortedSet(delegate().get(key));
+      return unmodifiableSortedSet(delegate().get(key));
     }
 
     @Override
@@ -878,8 +882,8 @@ public final class Multimaps {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super V> valueComparator() {
       return delegate().valueComparator();
     }
@@ -930,7 +934,7 @@ public final class Multimaps {
   @Deprecated
   public static <K, V> SetMultimap<K, V> unmodifiableSetMultimap(
       ImmutableSetMultimap<K, V> delegate) {
-    return checkNotNull(delegate);
+    return requireNonNull(delegate);
   }
 
   /**
@@ -1009,7 +1013,7 @@ public final class Multimaps {
   @Deprecated
   public static <K, V> ListMultimap<K, V> unmodifiableListMultimap(
       ImmutableListMultimap<K, V> delegate) {
-    return checkNotNull(delegate);
+    return requireNonNull(delegate);
   }
 
   /**
@@ -1023,13 +1027,13 @@ public final class Multimaps {
   private static <V extends @Nullable Object> Collection<V> unmodifiableValueCollection(
       Collection<V> collection) {
     if (collection instanceof SortedSet) {
-      return Collections.unmodifiableSortedSet((SortedSet<V>) collection);
+      return unmodifiableSortedSet((SortedSet<V>) collection);
     } else if (collection instanceof Set) {
-      return Collections.unmodifiableSet((Set<V>) collection);
+      return unmodifiableSet((Set<V>) collection);
     } else if (collection instanceof List) {
-      return Collections.unmodifiableList((List<V>) collection);
+      return unmodifiableList((List<V>) collection);
     }
-    return Collections.unmodifiableCollection(collection);
+    return unmodifiableCollection(collection);
   }
 
   /**
@@ -1045,7 +1049,7 @@ public final class Multimaps {
     if (entries instanceof Set) {
       return Maps.unmodifiableEntrySet((Set<Entry<K, V>>) entries);
     }
-    return new Maps.UnmodifiableEntries<>(Collections.unmodifiableCollection(entries));
+    return new Maps.UnmodifiableEntries<>(unmodifiableCollection(entries));
   }
 
   /**
@@ -1130,7 +1134,7 @@ public final class Multimaps {
     final Map<K, V> map;
 
     MapMultimap(Map<K, V> map) {
-      this.map = checkNotNull(map);
+      this.map = requireNonNull(map);
     }
 
     @Override
@@ -1324,7 +1328,7 @@ public final class Multimaps {
           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
       Multimap<K, V2> transformValues(
           Multimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);
     return transformEntries(fromMultimap, transformer);
   }
@@ -1373,7 +1377,7 @@ public final class Multimaps {
           K extends @Nullable Object, V1 extends @Nullable Object, V2 extends @Nullable Object>
       ListMultimap<K, V2> transformValues(
           ListMultimap<K, V1> fromMultimap, final Function<? super V1, V2> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     EntryTransformer<K, V1, V2> transformer = Maps.asEntryTransformer(function);
     return transformEntries(fromMultimap, transformer);
   }
@@ -1500,8 +1504,8 @@ public final class Multimaps {
     TransformedEntriesMultimap(
         Multimap<K, V1> fromMultimap,
         final EntryTransformer<? super K, ? super V1, V2> transformer) {
-      this.fromMultimap = checkNotNull(fromMultimap);
-      this.transformer = checkNotNull(transformer);
+      this.fromMultimap = requireNonNull(fromMultimap);
+      this.transformer = requireNonNull(transformer);
     }
 
     Collection<V2> transform(@ParametricNullness K key, Collection<V1> values) {
@@ -1581,14 +1585,14 @@ public final class Multimaps {
       throw new UnsupportedOperationException();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public boolean remove(@CheckForNull Object key, @CheckForNull Object value) {
       return get((K) key).remove(value);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Collection<V2> removeAll(@CheckForNull Object key) {
       return transform((K) key, fromMultimap.removeAll(key));
     }
@@ -1629,8 +1633,8 @@ public final class Multimaps {
       return transform(key, fromMultimap.get(key));
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public List<V2> removeAll(@CheckForNull Object key) {
       return transform((K) key, fromMultimap.removeAll(key));
     }
@@ -1719,7 +1723,7 @@ public final class Multimaps {
    */
   public static <K, V> ImmutableListMultimap<K, V> index(
       Iterator<V> values, Function<? super V, K> keyFunction) {
-    checkNotNull(keyFunction);
+    requireNonNull(keyFunction);
     ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
     while (values.hasNext()) {
       V value = values.next();
@@ -1766,7 +1770,7 @@ public final class Multimaps {
 
     @Override
     public void forEach(Consumer<? super K> consumer) {
-      checkNotNull(consumer);
+      requireNonNull(consumer);
       multimap.entries().forEach(entry -> consumer.accept(entry.getKey()));
     }
 
@@ -1878,7 +1882,7 @@ public final class Multimaps {
     @Weak private final Multimap<K, V> multimap;
 
     AsMap(Multimap<K, V> multimap) {
-      this.multimap = checkNotNull(multimap);
+      this.multimap = requireNonNull(multimap);
     }
 
     @Override
@@ -1926,15 +1930,15 @@ public final class Multimaps {
       }
     }
 
-    @SuppressWarnings("unchecked")
-    @Override
     @CheckForNull
+    @Override
+    @SuppressWarnings("unchecked")
     public Collection<V> get(@CheckForNull Object key) {
       return containsKey(key) ? multimap.get((K) key) : null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Collection<V> remove(@CheckForNull Object key) {
       return containsKey(key) ? multimap.removeAll(key) : null;
     }
@@ -2180,13 +2184,13 @@ public final class Multimaps {
   public static <K extends @Nullable Object, V extends @Nullable Object>
       Multimap<K, V> filterEntries(
           Multimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
-    checkNotNull(entryPredicate);
+    requireNonNull(entryPredicate);
     if (unfiltered instanceof SetMultimap) {
       return filterEntries((SetMultimap<K, V>) unfiltered, entryPredicate);
     }
     return (unfiltered instanceof FilteredMultimap)
         ? filterFiltered((FilteredMultimap<K, V>) unfiltered, entryPredicate)
-        : new FilteredEntryMultimap<K, V>(checkNotNull(unfiltered), entryPredicate);
+        : new FilteredEntryMultimap<K, V>(requireNonNull(unfiltered), entryPredicate);
   }
 
   /**
@@ -2217,10 +2221,10 @@ public final class Multimaps {
   public static <K extends @Nullable Object, V extends @Nullable Object>
       SetMultimap<K, V> filterEntries(
           SetMultimap<K, V> unfiltered, Predicate<? super Entry<K, V>> entryPredicate) {
-    checkNotNull(entryPredicate);
+    requireNonNull(entryPredicate);
     return (unfiltered instanceof FilteredSetMultimap)
         ? filterFiltered((FilteredSetMultimap<K, V>) unfiltered, entryPredicate)
-        : new FilteredEntrySetMultimap<K, V>(checkNotNull(unfiltered), entryPredicate);
+        : new FilteredEntrySetMultimap<K, V>(requireNonNull(unfiltered), entryPredicate);
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/Multiset.java b/guava/src/com/google/common/collect/Multiset.java
index ca56a74531..38662dbac8 100644
--- a/guava/src/com/google/common/collect/Multiset.java
+++ b/guava/src/com/google/common/collect/Multiset.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -341,7 +341,7 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    */
   @Beta
   default void forEachEntry(ObjIntConsumer<? super E> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     entrySet().forEach(entry -> action.accept(entry.getElement(), entry.getCount()));
   }
 
@@ -462,7 +462,7 @@ public interface Multiset<E extends @Nullable Object> extends Collection<E> {
    */
   @Override
   default void forEach(Consumer<? super E> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     entrySet()
         .forEach(
             entry -> {
diff --git a/guava/src/com/google/common/collect/Multisets.java b/guava/src/com/google/common/collect/Multisets.java
index 71fe614347..1e9e4dba1a 100644
--- a/guava/src/com/google/common/collect/Multisets.java
+++ b/guava/src/com/google/common/collect/Multisets.java
@@ -17,9 +17,9 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.CollectPreconditions.checkRemove;
+import static java.util.Collections.unmodifiableSet;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -106,7 +106,7 @@ public final class Multisets {
       Multiset<E> result = (Multiset<E>) multiset;
       return result;
     }
-    return new UnmodifiableMultiset<E>(checkNotNull(multiset));
+    return new UnmodifiableMultiset<E>(requireNonNull(multiset));
   }
 
   /**
@@ -117,7 +117,7 @@ public final class Multisets {
    */
   @Deprecated
   public static <E> Multiset<E> unmodifiableMultiset(ImmutableMultiset<E> multiset) {
-    return checkNotNull(multiset);
+    return requireNonNull(multiset);
   }
 
   static class UnmodifiableMultiset<E extends @Nullable Object> extends ForwardingMultiset<E>
@@ -128,8 +128,8 @@ public final class Multisets {
       this.delegate = delegate;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     protected Multiset<E> delegate() {
       // This is safe because all non-covariant methods are overridden
       return (Multiset<E>) delegate;
@@ -149,14 +149,14 @@ public final class Multisets {
 
     @CheckForNull transient Set<Multiset.Entry<E>> entrySet;
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Set<Multiset.Entry<E>> entrySet() {
       Set<Multiset.Entry<E>> es = entrySet;
       return (es == null)
           // Safe because the returned set is made unmodifiable and Entry
           // itself is readonly
-          ? entrySet = (Set) Collections.unmodifiableSet(delegate.entrySet())
+          ? entrySet = (Set) unmodifiableSet(delegate.entrySet())
           : es;
     }
 
@@ -233,7 +233,7 @@ public final class Multisets {
   public static <E extends @Nullable Object> SortedMultiset<E> unmodifiableSortedMultiset(
       SortedMultiset<E> sortedMultiset) {
     // it's in its own file so it can be emulated for GWT
-    return new UnmodifiableSortedMultiset<E>(checkNotNull(sortedMultiset));
+    return new UnmodifiableSortedMultiset<E>(requireNonNull(sortedMultiset));
   }
 
   /**
@@ -322,8 +322,8 @@ public final class Multisets {
     final Predicate<? super E> predicate;
 
     FilteredMultiset(Multiset<E> unfiltered, Predicate<? super E> predicate) {
-      this.unfiltered = checkNotNull(unfiltered);
-      this.predicate = checkNotNull(predicate);
+      this.unfiltered = requireNonNull(unfiltered);
+      this.predicate = requireNonNull(predicate);
     }
 
     @Override
@@ -414,8 +414,8 @@ public final class Multisets {
   @Beta
   public static <E extends @Nullable Object> Multiset<E> union(
       final Multiset<? extends E> multiset1, final Multiset<? extends E> multiset2) {
-    checkNotNull(multiset1);
-    checkNotNull(multiset2);
+    requireNonNull(multiset1);
+    requireNonNull(multiset2);
 
     return new ViewMultiset<E>() {
       @Override
@@ -449,8 +449,8 @@ public final class Multisets {
         final Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();
         // TODO(lowasser): consider making the entries live views
         return new AbstractIterator<Entry<E>>() {
-          @Override
           @CheckForNull
+          @Override
           protected Entry<E> computeNext() {
             if (iterator1.hasNext()) {
               Entry<? extends E> entry1 = iterator1.next();
@@ -486,8 +486,8 @@ public final class Multisets {
    */
   public static <E extends @Nullable Object> Multiset<E> intersection(
       final Multiset<E> multiset1, final Multiset<?> multiset2) {
-    checkNotNull(multiset1);
-    checkNotNull(multiset2);
+    requireNonNull(multiset1);
+    requireNonNull(multiset2);
 
     return new ViewMultiset<E>() {
       @Override
@@ -511,8 +511,8 @@ public final class Multisets {
         final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
         // TODO(lowasser): consider making the entries live views
         return new AbstractIterator<Entry<E>>() {
-          @Override
           @CheckForNull
+          @Override
           protected Entry<E> computeNext() {
             while (iterator1.hasNext()) {
               Entry<E> entry1 = iterator1.next();
@@ -544,8 +544,8 @@ public final class Multisets {
   @Beta
   public static <E extends @Nullable Object> Multiset<E> sum(
       final Multiset<? extends E> multiset1, final Multiset<? extends E> multiset2) {
-    checkNotNull(multiset1);
-    checkNotNull(multiset2);
+    requireNonNull(multiset1);
+    requireNonNull(multiset2);
 
     // TODO(lowasser): consider making the entries live views
     return new ViewMultiset<E>() {
@@ -584,8 +584,8 @@ public final class Multisets {
         final Iterator<? extends Entry<? extends E>> iterator1 = multiset1.entrySet().iterator();
         final Iterator<? extends Entry<? extends E>> iterator2 = multiset2.entrySet().iterator();
         return new AbstractIterator<Entry<E>>() {
-          @Override
           @CheckForNull
+          @Override
           protected Entry<E> computeNext() {
             if (iterator1.hasNext()) {
               Entry<? extends E> entry1 = iterator1.next();
@@ -622,8 +622,8 @@ public final class Multisets {
   @Beta
   public static <E extends @Nullable Object> Multiset<E> difference(
       final Multiset<E> multiset1, final Multiset<?> multiset2) {
-    checkNotNull(multiset1);
-    checkNotNull(multiset2);
+    requireNonNull(multiset1);
+    requireNonNull(multiset2);
 
     // TODO(lowasser): consider making the entries live views
     return new ViewMultiset<E>() {
@@ -642,8 +642,8 @@ public final class Multisets {
       Iterator<E> elementIterator() {
         final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
         return new AbstractIterator<E>() {
-          @Override
           @CheckForNull
+          @Override
           protected E computeNext() {
             while (iterator1.hasNext()) {
               Entry<E> entry1 = iterator1.next();
@@ -661,8 +661,8 @@ public final class Multisets {
       Iterator<Entry<E>> entryIterator() {
         final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();
         return new AbstractIterator<Entry<E>>() {
-          @Override
           @CheckForNull
+          @Override
           protected Entry<E> computeNext() {
             while (iterator1.hasNext()) {
               Entry<E> entry1 = iterator1.next();
@@ -692,8 +692,8 @@ public final class Multisets {
    */
   @CanIgnoreReturnValue
   public static boolean containsOccurrences(Multiset<?> superMultiset, Multiset<?> subMultiset) {
-    checkNotNull(superMultiset);
-    checkNotNull(subMultiset);
+    requireNonNull(superMultiset);
+    requireNonNull(subMultiset);
     for (Entry<?> entry : subMultiset.entrySet()) {
       int superCount = superMultiset.count(entry.getElement());
       if (superCount < entry.getCount()) {
@@ -728,8 +728,8 @@ public final class Multisets {
   /** Delegate implementation which cares about the element type. */
   private static <E extends @Nullable Object> boolean retainOccurrencesImpl(
       Multiset<E> multisetToModify, Multiset<?> occurrencesToRetain) {
-    checkNotNull(multisetToModify);
-    checkNotNull(occurrencesToRetain);
+    requireNonNull(multisetToModify);
+    requireNonNull(occurrencesToRetain);
     // Avoiding ConcurrentModificationExceptions is tricky.
     Iterator<Entry<E>> entryIterator = multisetToModify.entrySet().iterator();
     boolean changed = false;
@@ -776,8 +776,8 @@ public final class Multisets {
     if (occurrencesToRemove instanceof Multiset) {
       return removeOccurrences(multisetToModify, (Multiset<?>) occurrencesToRemove);
     } else {
-      checkNotNull(multisetToModify);
-      checkNotNull(occurrencesToRemove);
+      requireNonNull(multisetToModify);
+      requireNonNull(occurrencesToRemove);
       boolean changed = false;
       for (Object o : occurrencesToRemove) {
         changed |= multisetToModify.remove(o);
@@ -811,8 +811,8 @@ public final class Multisets {
   @CanIgnoreReturnValue
   public static boolean removeOccurrences(
       Multiset<?> multisetToModify, Multiset<?> occurrencesToRemove) {
-    checkNotNull(multisetToModify);
-    checkNotNull(occurrencesToRemove);
+    requireNonNull(multisetToModify);
+    requireNonNull(occurrencesToRemove);
 
     boolean changed = false;
     Iterator<? extends Entry<?>> entryIterator = multisetToModify.entrySet().iterator();
@@ -902,8 +902,8 @@ public final class Multisets {
   /** An implementation of {@link Multiset#addAll}. */
   static <E extends @Nullable Object> boolean addAllImpl(
       Multiset<E> self, Collection<? extends E> elements) {
-    checkNotNull(self);
-    checkNotNull(elements);
+    requireNonNull(self);
+    requireNonNull(elements);
     if (elements instanceof Multiset) {
       return addAllImpl(self, cast(elements));
     } else if (elements.isEmpty()) {
@@ -935,7 +935,7 @@ public final class Multisets {
 
   /** An implementation of {@link Multiset#retainAll}. */
   static boolean retainAllImpl(Multiset<?> self, Collection<?> elementsToRetain) {
-    checkNotNull(elementsToRetain);
+    requireNonNull(elementsToRetain);
     Collection<?> collection =
         (elementsToRetain instanceof Multiset)
             ? ((Multiset<?>) elementsToRetain).elementSet()
@@ -1045,8 +1045,8 @@ public final class Multisets {
     }
 
     // GWT compiler warning; see contains().
-    @SuppressWarnings("cast")
     @Override
+    @SuppressWarnings("cast")
     public boolean remove(@CheckForNull Object object) {
       if (object instanceof Multiset.Entry) {
         Entry<?> entry = (Entry<?>) object;
@@ -1055,7 +1055,7 @@ public final class Multisets {
         if (entryCount != 0) {
           // Safe as long as we never add a new entry, which we won't.
           // (Presumably it can still throw CCE/NPE but only if the underlying Multiset does.)
-          @SuppressWarnings({"unchecked", "nullness"})
+          @SuppressWarnings({"nullness", "unchecked"})
           Multiset<@Nullable Object> multiset = (Multiset<@Nullable Object>) multiset();
           return multiset.setCount(element, entryCount, 0);
         }
diff --git a/guava/src/com/google/common/collect/MutableClassToInstanceMap.java b/guava/src/com/google/common/collect/MutableClassToInstanceMap.java
index 83fbe94472..cbef0fdc1e 100644
--- a/guava/src/com/google/common/collect/MutableClassToInstanceMap.java
+++ b/guava/src/com/google/common/collect/MutableClassToInstanceMap.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Primitives;
@@ -71,7 +71,7 @@ public final class MutableClassToInstanceMap<B> extends ForwardingMap<Class<? ex
   private final Map<Class<? extends B>, B> delegate;
 
   private MutableClassToInstanceMap(Map<Class<? extends B>, B> delegate) {
-    this.delegate = checkNotNull(delegate);
+    this.delegate = requireNonNull(delegate);
   }
 
   @Override
@@ -144,9 +144,9 @@ public final class MutableClassToInstanceMap<B> extends ForwardingMap<Class<? ex
     };
   }
 
-  @Override
   @CanIgnoreReturnValue
   @CheckForNull
+  @Override
   public B put(Class<? extends B> key, B value) {
     return super.put(key, cast(key, value));
   }
@@ -161,14 +161,14 @@ public final class MutableClassToInstanceMap<B> extends ForwardingMap<Class<? ex
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public <T extends B> T putInstance(Class<T> type, T value) {
     return cast(type, put(type, value));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public <T extends B> T getInstance(Class<T> type) {
     return cast(type, get(type));
   }
diff --git a/guava/src/com/google/common/collect/NaturalOrdering.java b/guava/src/com/google/common/collect/NaturalOrdering.java
index 8cb8aef9a0..f85c460186 100644
--- a/guava/src/com/google/common/collect/NaturalOrdering.java
+++ b/guava/src/com/google/common/collect/NaturalOrdering.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
@@ -25,7 +25,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that uses the natural order of the values. */
 @GwtCompatible(serializable = true)
-@SuppressWarnings({"unchecked", "rawtypes"}) // TODO(kevinb): the right way to explain this??
+@SuppressWarnings({"rawtypes", "unchecked"}) // TODO(kevinb): the right way to explain this??
 @ElementTypesAreNonnullByDefault
 final class NaturalOrdering extends Ordering<Comparable<?>> implements Serializable {
   static final NaturalOrdering INSTANCE = new NaturalOrdering();
@@ -35,8 +35,8 @@ final class NaturalOrdering extends Ordering<Comparable<?>> implements Serializa
 
   @Override
   public int compare(Comparable<?> left, Comparable<?> right) {
-    checkNotNull(left); // for GWT
-    checkNotNull(right);
+    requireNonNull(left); // for GWT
+    requireNonNull(right);
     return ((Comparable<Object>) left).compareTo(right);
   }
 
diff --git a/guava/src/com/google/common/collect/NullnessCasts.java b/guava/src/com/google/common/collect/NullnessCasts.java
index 4f894dbd31..a59d66c70c 100644
--- a/guava/src/com/google/common/collect/NullnessCasts.java
+++ b/guava/src/com/google/common/collect/NullnessCasts.java
@@ -57,9 +57,9 @@ final class NullnessCasts {
   }
 
   /** Returns {@code null} as any type, even one that does not include {@code null}. */
-  @SuppressWarnings({"nullness", "TypeParameterUnusedInFormals", "ReturnMissingNullable"})
-  // The warnings are legitimate. Each time we use this method, we document why.
   @ParametricNullness
+  // The warnings are legitimate. Each time we use this method, we document why.
+  @SuppressWarnings({"nullness", "ReturnMissingNullable", "TypeParameterUnusedInFormals"})
   static <T extends @Nullable Object> T unsafeNull() {
     return null;
   }
diff --git a/guava/src/com/google/common/collect/NullsFirstOrdering.java b/guava/src/com/google/common/collect/NullsFirstOrdering.java
index ce8be2fa3c..e6c69349ae 100644
--- a/guava/src/com/google/common/collect/NullsFirstOrdering.java
+++ b/guava/src/com/google/common/collect/NullsFirstOrdering.java
@@ -53,8 +53,8 @@ final class NullsFirstOrdering<T extends @Nullable Object> extends Ordering<@Nul
     return ordering.reverse().nullsLast();
   }
 
-  @SuppressWarnings("unchecked") // still need the right way to explain this
-  @Override
+  @Override // still need the right way to explain this
+  @SuppressWarnings("unchecked")
   public <S extends T> Ordering<@Nullable S> nullsFirst() {
     return (Ordering<@Nullable S>) this;
   }
diff --git a/guava/src/com/google/common/collect/NullsLastOrdering.java b/guava/src/com/google/common/collect/NullsLastOrdering.java
index 6f8f74cdd6..6665d598d6 100644
--- a/guava/src/com/google/common/collect/NullsLastOrdering.java
+++ b/guava/src/com/google/common/collect/NullsLastOrdering.java
@@ -58,8 +58,8 @@ final class NullsLastOrdering<T extends @Nullable Object> extends Ordering<@Null
     return ordering.<S>nullsFirst();
   }
 
-  @SuppressWarnings("unchecked") // still need the right way to explain this
-  @Override
+  @Override // still need the right way to explain this
+  @SuppressWarnings("unchecked")
   public <S extends T> Ordering<@Nullable S> nullsLast() {
     return (Ordering<@Nullable S>) this;
   }
diff --git a/guava/src/com/google/common/collect/ObjectArrays.java b/guava/src/com/google/common/collect/ObjectArrays.java
index d3b048da7e..7c8ce6f6cc 100644
--- a/guava/src/com/google/common/collect/ObjectArrays.java
+++ b/guava/src/com/google/common/collect/ObjectArrays.java
@@ -17,6 +17,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -225,9 +226,7 @@ public final class ObjectArrays {
   // creation cost.
   @CanIgnoreReturnValue
   static Object checkElementNotNull(Object element, int index) {
-    if (element == null) {
-      throw new NullPointerException("at index " + index);
-    }
+    requireNonNull(element, "at index " + index);
     return element;
   }
 }
diff --git a/guava/src/com/google/common/collect/Ordering.java b/guava/src/com/google/common/collect/Ordering.java
index 4f52e7b547..10fccd6809 100644
--- a/guava/src/com/google/common/collect/Ordering.java
+++ b/guava/src/com/google/common/collect/Ordering.java
@@ -16,8 +16,10 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.VisibleForTesting;
@@ -191,10 +193,10 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    *
    * @deprecated no need to use this
    */
-  @GwtCompatible(serializable = true)
   @Deprecated
+  @GwtCompatible(serializable = true)
   public static <T extends @Nullable Object> Ordering<T> from(Ordering<T> ordering) {
-    return checkNotNull(ordering);
+    return requireNonNull(ordering);
   }
 
   /**
@@ -470,7 +472,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    */
   @GwtCompatible(serializable = true)
   public <U extends T> Ordering<U> compound(Comparator<? super U> secondaryComparator) {
-    return new CompoundOrdering<U>(this, checkNotNull(secondaryComparator));
+    return new CompoundOrdering<U>(this, requireNonNull(secondaryComparator));
   }
 
   /**
@@ -746,7 +748,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
         if (array.length > k) {
           array = Arrays.copyOf(array, k);
         }
-        return Collections.unmodifiableList(Arrays.asList(array));
+        return unmodifiableList(Arrays.asList(array));
       }
     }
     return leastOf(iterable.iterator(), k);
@@ -769,11 +771,11 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
    * @since 14.0
    */
   public <E extends T> List<E> leastOf(Iterator<E> iterator, int k) {
-    checkNotNull(iterator);
+    requireNonNull(iterator);
     checkNonnegative(k, "k");
 
     if (k == 0 || !iterator.hasNext()) {
-      return Collections.emptyList();
+      return emptyList();
     } else if (k >= Integer.MAX_VALUE / 2) {
       // k is really large; just do a straightforward sorted-copy-and-sublist
       ArrayList<E> list = Lists.newArrayList(iterator);
@@ -782,7 +784,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
         list.subList(k, list.size()).clear();
       }
       list.trimToSize();
-      return Collections.unmodifiableList(list);
+      return unmodifiableList(list);
     } else {
       TopKSelector<E> selector = TopKSelector.least(k, this);
       selector.offerAll(iterator);
@@ -851,7 +853,7 @@ public abstract class Ordering<T extends @Nullable Object> implements Comparator
     @SuppressWarnings("unchecked") // does not escape, and contains only E's
     E[] array = (E[]) Iterables.toArray(elements);
     Arrays.sort(array, this);
-    return Lists.newArrayList(Arrays.asList(array));
+    return new ArrayList<>(Arrays.asList(array));
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/Queues.java b/guava/src/com/google/common/collect/Queues.java
index a140102fd6..547364456b 100644
--- a/guava/src/com/google/common/collect/Queues.java
+++ b/guava/src/com/google/common/collect/Queues.java
@@ -14,10 +14,11 @@
 
 package com.google.common.collect;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -303,7 +304,7 @@ public final class Queues {
       long timeout,
       TimeUnit unit)
       throws InterruptedException {
-    Preconditions.checkNotNull(buffer);
+    requireNonNull(buffer);
     /*
      * This code performs one System.nanoTime() more than necessary, and in return, the time to
      * execute Queue#drainTo is not added *on top* of waiting for the timeout (which could make
@@ -375,7 +376,7 @@ public final class Queues {
       int numElements,
       long timeout,
       TimeUnit unit) {
-    Preconditions.checkNotNull(buffer);
+    requireNonNull(buffer);
     long deadline = System.nanoTime() + unit.toNanos(timeout);
     int added = 0;
     boolean interrupted = false;
diff --git a/guava/src/com/google/common/collect/Range.java b/guava/src/com/google/common/collect/Range.java
index 2a5d464dc2..e0ba0430ed 100644
--- a/guava/src/com/google/common/collect/Range.java
+++ b/guava/src/com/google/common/collect/Range.java
@@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Equivalence;
@@ -217,8 +217,8 @@ public final class Range<C extends Comparable> extends RangeGwtSerializationDepe
    */
   public static <C extends Comparable<?>> Range<C> range(
       C lower, BoundType lowerType, C upper, BoundType upperType) {
-    checkNotNull(lowerType);
-    checkNotNull(upperType);
+    requireNonNull(lowerType);
+    requireNonNull(upperType);
 
     Cut<C> lowerBound =
         (lowerType == BoundType.OPEN) ? Cut.aboveValue(lower) : Cut.belowValue(lower);
@@ -329,7 +329,7 @@ public final class Range<C extends Comparable> extends RangeGwtSerializationDepe
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> encloseAll(Iterable<C> values) {
-    checkNotNull(values);
+    requireNonNull(values);
     if (values instanceof SortedSet) {
       SortedSet<C> set = (SortedSet<C>) values;
       Comparator<?> comparator = set.comparator();
@@ -338,10 +338,10 @@ public final class Range<C extends Comparable> extends RangeGwtSerializationDepe
       }
     }
     Iterator<C> valueIterator = values.iterator();
-    C min = checkNotNull(valueIterator.next());
+    C min = requireNonNull(valueIterator.next());
     C max = min;
     while (valueIterator.hasNext()) {
-      C value = checkNotNull(valueIterator.next());
+      C value = requireNonNull(valueIterator.next());
       min = Ordering.natural().min(min, value);
       max = Ordering.natural().max(max, value);
     }
@@ -352,13 +352,14 @@ public final class Range<C extends Comparable> extends RangeGwtSerializationDepe
   final Cut<C> upperBound;
 
   private Range(Cut<C> lowerBound, Cut<C> upperBound) {
-    this.lowerBound = checkNotNull(lowerBound);
-    this.upperBound = checkNotNull(upperBound);
-    if (lowerBound.compareTo(upperBound) > 0
-        || lowerBound == Cut.<C>aboveAll()
-        || upperBound == Cut.<C>belowAll()) {
-      throw new IllegalArgumentException("Invalid range: " + toString(lowerBound, upperBound));
-    }
+    this.lowerBound = requireNonNull(lowerBound);
+    this.upperBound = requireNonNull(upperBound);
+    checkArgument(
+        lowerBound.compareTo(upperBound) <= 0
+            && lowerBound != Cut.<C>aboveAll()
+            && upperBound != Cut.<C>belowAll(),
+        "Invalid range: %s",
+        toString(lowerBound, upperBound));
   }
 
   /** Returns {@code true} if this range has a lower endpoint. */
@@ -432,7 +433,7 @@ public final class Range<C extends Comparable> extends RangeGwtSerializationDepe
    * returns {@code false}.
    */
   public boolean contains(C value) {
-    checkNotNull(value);
+    requireNonNull(value);
     // let this throw CCE if there is some trickery going on
     return lowerBound.isLessThan(value) && !upperBound.isLessThan(value);
   }
@@ -598,11 +599,12 @@ public final class Range<C extends Comparable> extends RangeGwtSerializationDepe
      * than "less than or equal to" because of *handwave* the difference between "endpoints of
      * inclusive ranges" and "Cuts."
      */
-    if (lowerBound.compareTo(otherRange.upperBound) < 0
-        && otherRange.lowerBound.compareTo(upperBound) < 0) {
-      throw new IllegalArgumentException(
-          "Ranges have a nonempty intersection: " + this + ", " + otherRange);
-    }
+    checkArgument(
+        lowerBound.compareTo(otherRange.upperBound) >= 0
+            || otherRange.lowerBound.compareTo(upperBound) >= 0,
+        "Ranges have a nonempty intersection: %s, %s",
+        this,
+        otherRange);
 
     boolean isThisFirst = this.lowerBound.compareTo(otherRange.lowerBound) < 0;
     Range<C> firstRange = isThisFirst ? this : otherRange;
@@ -660,7 +662,7 @@ public final class Range<C extends Comparable> extends RangeGwtSerializationDepe
    * </ul>
    */
   public Range<C> canonical(DiscreteDomain<C> domain) {
-    checkNotNull(domain);
+    requireNonNull(domain);
     Cut<C> lower = lowerBound.canonical(domain);
     Cut<C> upper = upperBound.canonical(domain);
     return (lower == lowerBound && upper == upperBound) ? this : create(lower, upper);
diff --git a/guava/src/com/google/common/collect/RegularContiguousSet.java b/guava/src/com/google/common/collect/RegularContiguousSet.java
index 787606eb1f..7af9ef3c9e 100644
--- a/guava/src/com/google/common/collect/RegularContiguousSet.java
+++ b/guava/src/com/google/common/collect/RegularContiguousSet.java
@@ -16,7 +16,6 @@ package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.BoundType.CLOSED;
 import static java.util.Objects.requireNonNull;
 
@@ -83,8 +82,8 @@ final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C>
     return new AbstractSequentialIterator<C>(first()) {
       final C last = last();
 
-      @Override
       @CheckForNull
+      @Override
       protected C computeNext(C previous) {
         return equalsOrThrow(previous, last) ? null : domain.next(previous);
       }
@@ -97,8 +96,8 @@ final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C>
     return new AbstractSequentialIterator<C>(last()) {
       final C first = first();
 
-      @Override
       @CheckForNull
+      @Override
       protected C computeNext(C previous) {
         return equalsOrThrow(previous, first) ? null : domain.previous(previous);
       }
@@ -176,7 +175,7 @@ final class RegularContiguousSet<C extends Comparable> extends ContiguousSet<C>
 
   @Override
   public ContiguousSet<C> intersection(ContiguousSet<C> other) {
-    checkNotNull(other);
+    requireNonNull(other);
     checkArgument(this.domain.equals(other.domain));
     if (other.isEmpty()) {
       return other;
diff --git a/guava/src/com/google/common/collect/RegularImmutableAsList.java b/guava/src/com/google/common/collect/RegularImmutableAsList.java
index 0e3fe4ec8f..ab376bae7a 100644
--- a/guava/src/com/google/common/collect/RegularImmutableAsList.java
+++ b/guava/src/com/google/common/collect/RegularImmutableAsList.java
@@ -53,8 +53,8 @@ class RegularImmutableAsList<E> extends ImmutableAsList<E> {
     return delegateList;
   }
 
-  @SuppressWarnings("unchecked") // safe covariant cast!
-  @Override
+  @Override // safe covariant cast!
+  @SuppressWarnings("unchecked")
   public UnmodifiableListIterator<E> listIterator(int index) {
     return (UnmodifiableListIterator<E>) delegateList.listIterator(index);
   }
@@ -71,8 +71,8 @@ class RegularImmutableAsList<E> extends ImmutableAsList<E> {
     return delegateList.copyIntoArray(dst, offset);
   }
 
-  @Override
   @CheckForNull
+  @Override
   Object[] internalArray() {
     return delegateList.internalArray();
   }
diff --git a/guava/src/com/google/common/collect/RegularImmutableBiMap.java b/guava/src/com/google/common/collect/RegularImmutableBiMap.java
index b8bca95804..5bf7039442 100644
--- a/guava/src/com/google/common/collect/RegularImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/RegularImmutableBiMap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
@@ -141,8 +140,8 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return RegularImmutableMap.get(key, keyTable, mask);
   }
@@ -161,7 +160,7 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     for (Entry<K, V> entry : entries) {
       action.accept(entry.getKey(), entry.getValue());
     }
@@ -212,12 +211,12 @@ class RegularImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
 
     @Override
     public void forEach(BiConsumer<? super V, ? super K> action) {
-      checkNotNull(action);
+      requireNonNull(action);
       RegularImmutableBiMap.this.forEach((k, v) -> action.accept(v, k));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K get(@CheckForNull Object value) {
       if (value == null || valueTable == null) {
         return null;
diff --git a/guava/src/com/google/common/collect/RegularImmutableList.java b/guava/src/com/google/common/collect/RegularImmutableList.java
index 397147d70d..8c54eb983b 100644
--- a/guava/src/com/google/common/collect/RegularImmutableList.java
+++ b/guava/src/com/google/common/collect/RegularImmutableList.java
@@ -77,8 +77,8 @@ class RegularImmutableList<E> extends ImmutableList<E> {
     return (E) array[index];
   }
 
-  @SuppressWarnings("unchecked")
   @Override
+  @SuppressWarnings("unchecked")
   public UnmodifiableListIterator<E> listIterator(int index) {
     // for performance
     // The fake cast to E is safe because the creation methods only allow E's
diff --git a/guava/src/com/google/common/collect/RegularImmutableMap.java b/guava/src/com/google/common/collect/RegularImmutableMap.java
index f0f2031b94..44bcb0ae48 100644
--- a/guava/src/com/google/common/collect/RegularImmutableMap.java
+++ b/guava/src/com/google/common/collect/RegularImmutableMap.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
@@ -252,8 +251,8 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
 
   static class BucketOverflowException extends Exception {}
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return get(key, table, mask);
   }
@@ -287,7 +286,7 @@ final class RegularImmutableMap<K, V> extends ImmutableMap<K, V> {
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     for (Entry<K, V> entry : entries) {
       action.accept(entry.getKey(), entry.getValue());
     }
diff --git a/guava/src/com/google/common/collect/RegularImmutableMultiset.java b/guava/src/com/google/common/collect/RegularImmutableMultiset.java
index 47dffa1772..0c90d17b63 100644
--- a/guava/src/com/google/common/collect/RegularImmutableMultiset.java
+++ b/guava/src/com/google/common/collect/RegularImmutableMultiset.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.VisibleForTesting;
@@ -42,14 +42,14 @@ class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
 
   static <E> ImmutableMultiset<E> create(Collection<? extends Entry<? extends E>> entries) {
     int distinct = entries.size();
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     ImmutableEntry<E>[] entryArray = new ImmutableEntry[distinct];
     if (distinct == 0) {
       return new RegularImmutableMultiset<>(entryArray, EMPTY_ARRAY, 0, 0, ImmutableSet.of());
     }
     int tableSize = Hashing.closedTableSize(distinct, MAX_LOAD_FACTOR);
     int mask = tableSize - 1;
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     @Nullable ImmutableEntry<E>[] hashTable = new @Nullable ImmutableEntry[tableSize];
 
     int index = 0;
@@ -58,7 +58,7 @@ class RegularImmutableMultiset<E> extends ImmutableMultiset<E> {
     for (Entry<? extends E> entryWithWildcard : entries) {
       @SuppressWarnings("unchecked") // safe because we only read from it
       Entry<E> entry = (Entry<E>) entryWithWildcard;
-      E element = checkNotNull(entry.getElement());
+      E element = requireNonNull(entry.getElement());
       int count = entry.getCount();
       int hash = element.hashCode();
       int bucket = Hashing.smear(hash) & mask;
diff --git a/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java b/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java
index 4b7ba87427..ddca39613d 100644
--- a/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java
@@ -14,9 +14,9 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.collect.BoundType.CLOSED;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
@@ -70,20 +70,20 @@ final class RegularImmutableSortedMultiset<E> extends ImmutableSortedMultiset<E>
 
   @Override
   public void forEachEntry(ObjIntConsumer<? super E> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     for (int i = 0; i < length; i++) {
       action.accept(elementSet.asList().get(i), getCount(i));
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> firstEntry() {
     return isEmpty() ? null : getEntry(0);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> lastEntry() {
     return isEmpty() ? null : getEntry(length - 1);
   }
@@ -107,13 +107,13 @@ final class RegularImmutableSortedMultiset<E> extends ImmutableSortedMultiset<E>
 
   @Override
   public ImmutableSortedMultiset<E> headMultiset(E upperBound, BoundType boundType) {
-    return getSubMultiset(0, elementSet.headIndex(upperBound, checkNotNull(boundType) == CLOSED));
+    return getSubMultiset(0, elementSet.headIndex(upperBound, requireNonNull(boundType) == CLOSED));
   }
 
   @Override
   public ImmutableSortedMultiset<E> tailMultiset(E lowerBound, BoundType boundType) {
     return getSubMultiset(
-        elementSet.tailIndex(lowerBound, checkNotNull(boundType) == CLOSED), length);
+        elementSet.tailIndex(lowerBound, requireNonNull(boundType) == CLOSED), length);
   }
 
   ImmutableSortedMultiset<E> getSubMultiset(int from, int to) {
diff --git a/guava/src/com/google/common/collect/RegularImmutableSortedSet.java b/guava/src/com/google/common/collect/RegularImmutableSortedSet.java
index fa17e67916..851999b004 100644
--- a/guava/src/com/google/common/collect/RegularImmutableSortedSet.java
+++ b/guava/src/com/google/common/collect/RegularImmutableSortedSet.java
@@ -16,7 +16,8 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.binarySearch;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -39,7 +40,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Louis Wasserman
  */
 @GwtCompatible(serializable = true, emulated = true)
-@SuppressWarnings({"serial", "rawtypes"})
+@SuppressWarnings({"rawtypes", "serial"})
 @ElementTypesAreNonnullByDefault
 final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
   static final RegularImmutableSortedSet<Comparable> NATURAL_EMPTY_SET =
@@ -52,8 +53,8 @@ final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
     this.elements = elements;
   }
 
-  @Override
   @CheckForNull
+  @Override
   Object[] internalArray() {
     return elements.internalArray();
   }
@@ -156,7 +157,7 @@ final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
   }
 
   private int unsafeBinarySearch(Object key) throws ClassCastException {
-    return Collections.binarySearch(elements, key, unsafeComparator());
+    return binarySearch(elements, key, unsafeComparator());
   }
 
   @Override
@@ -222,29 +223,29 @@ final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
     return elements.get(size() - 1);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E lower(E element) {
     int index = headIndex(element, false) - 1;
     return (index == -1) ? null : elements.get(index);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E floor(E element) {
     int index = headIndex(element, true) - 1;
     return (index == -1) ? null : elements.get(index);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E ceiling(E element) {
     int index = tailIndex(element, true);
     return (index == size()) ? null : elements.get(index);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E higher(E element) {
     int index = tailIndex(element, false);
     return (index == size()) ? null : elements.get(index);
@@ -256,7 +257,7 @@ final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
   }
 
   int headIndex(E toElement, boolean inclusive) {
-    int index = Collections.binarySearch(elements, checkNotNull(toElement), comparator());
+    int index = binarySearch(elements, requireNonNull(toElement), comparator());
     if (index >= 0) {
       return inclusive ? index + 1 : index;
     } else {
@@ -276,7 +277,7 @@ final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
   }
 
   int tailIndex(E fromElement, boolean inclusive) {
-    int index = Collections.binarySearch(elements, checkNotNull(fromElement), comparator());
+    int index = binarySearch(elements, requireNonNull(fromElement), comparator());
     if (index >= 0) {
       return inclusive ? index : index + 1;
     } else {
@@ -310,7 +311,7 @@ final class RegularImmutableSortedSet<E> extends ImmutableSortedSet<E> {
     }
     int position;
     try {
-      position = Collections.binarySearch(elements, target, unsafeComparator());
+      position = binarySearch(elements, target, unsafeComparator());
     } catch (ClassCastException e) {
       return -1;
     }
diff --git a/guava/src/com/google/common/collect/RegularImmutableTable.java b/guava/src/com/google/common/collect/RegularImmutableTable.java
index b8f4dd28ea..fe72b3c458 100644
--- a/guava/src/com/google/common/collect/RegularImmutableTable.java
+++ b/guava/src/com/google/common/collect/RegularImmutableTable.java
@@ -15,7 +15,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.j2objc.annotations.WeakOuter;
@@ -100,7 +100,7 @@ abstract class RegularImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
       List<Cell<R, C, V>> cells,
       @CheckForNull Comparator<? super R> rowComparator,
       @CheckForNull Comparator<? super C> columnComparator) {
-    checkNotNull(cells);
+    requireNonNull(cells);
     if (rowComparator != null || columnComparator != null) {
       /*
        * This sorting logic leads to a cellSet() ordering that may not be expected and that isn't
diff --git a/guava/src/com/google/common/collect/ReverseNaturalOrdering.java b/guava/src/com/google/common/collect/ReverseNaturalOrdering.java
index f0c40cb612..bc08d88505 100644
--- a/guava/src/com/google/common/collect/ReverseNaturalOrdering.java
+++ b/guava/src/com/google/common/collect/ReverseNaturalOrdering.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
@@ -24,14 +24,14 @@ import java.util.Iterator;
 
 /** An ordering that uses the reverse of the natural order of the values. */
 @GwtCompatible(serializable = true)
-@SuppressWarnings({"unchecked", "rawtypes"}) // TODO(kevinb): the right way to explain this??
+@SuppressWarnings({"rawtypes", "unchecked"}) // TODO(kevinb): the right way to explain this??
 @ElementTypesAreNonnullByDefault
 final class ReverseNaturalOrdering extends Ordering<Comparable<?>> implements Serializable {
   static final ReverseNaturalOrdering INSTANCE = new ReverseNaturalOrdering();
 
   @Override
   public int compare(Comparable<?> left, Comparable<?> right) {
-    checkNotNull(left); // right null is caught later
+    requireNonNull(left); // right null is caught later
     if (left == right) {
       return 0;
     }
diff --git a/guava/src/com/google/common/collect/ReverseOrdering.java b/guava/src/com/google/common/collect/ReverseOrdering.java
index 6c1e74dd73..e3d5907416 100644
--- a/guava/src/com/google/common/collect/ReverseOrdering.java
+++ b/guava/src/com/google/common/collect/ReverseOrdering.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
@@ -32,7 +32,7 @@ final class ReverseOrdering<T extends @Nullable Object> extends Ordering<T>
   final Ordering<? super T> forwardOrder;
 
   ReverseOrdering(Ordering<? super T> forwardOrder) {
-    this.forwardOrder = checkNotNull(forwardOrder);
+    this.forwardOrder = requireNonNull(forwardOrder);
   }
 
   @Override
@@ -40,8 +40,8 @@ final class ReverseOrdering<T extends @Nullable Object> extends Ordering<T>
     return forwardOrder.compare(b, a);
   }
 
-  @SuppressWarnings("unchecked") // how to explain?
-  @Override
+  @Override // how to explain?
+  @SuppressWarnings("unchecked")
   public <S extends T> Ordering<S> reverse() {
     return (Ordering<S>) forwardOrder;
   }
diff --git a/guava/src/com/google/common/collect/Sets.java b/guava/src/com/google/common/collect/Sets.java
index abb6558910..9856fffa6d 100644
--- a/guava/src/com/google/common/collect/Sets.java
+++ b/guava/src/com/google/common/collect/Sets.java
@@ -17,8 +17,10 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static java.util.Collections.disjoint;
+import static java.util.Collections.unmodifiableSortedSet;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -84,7 +86,7 @@ public final class Sets {
 
     @Override
     public boolean retainAll(Collection<?> c) {
-      return super.retainAll(checkNotNull(c)); // GWT compatibility
+      return super.retainAll(requireNonNull(c)); // GWT compatibility
     }
   }
 
@@ -414,7 +416,7 @@ public final class Sets {
    */
   public static <E extends @Nullable Object> TreeSet<E> newTreeSet(
       Comparator<? super E> comparator) {
-    return new TreeSet<E>(checkNotNull(comparator));
+    return new TreeSet<E>(requireNonNull(comparator));
   }
 
   /**
@@ -498,7 +500,7 @@ public final class Sets {
    */
   public static <E extends Enum<E>> EnumSet<E> complementOf(
       Collection<E> collection, Class<E> type) {
-    checkNotNull(collection);
+    requireNonNull(collection);
     return (collection instanceof EnumSet)
         ? EnumSet.complementOf((EnumSet<E>) collection)
         : makeComplementByHand(collection, type);
@@ -593,8 +595,8 @@ public final class Sets {
      */
     @CanIgnoreReturnValue
     @Deprecated
-    @Override
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final boolean add(@ParametricNullness E e) {
       throw new UnsupportedOperationException();
     }
@@ -607,8 +609,8 @@ public final class Sets {
      */
     @CanIgnoreReturnValue
     @Deprecated
-    @Override
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final boolean remove(@CheckForNull Object object) {
       throw new UnsupportedOperationException();
     }
@@ -621,8 +623,8 @@ public final class Sets {
      */
     @CanIgnoreReturnValue
     @Deprecated
-    @Override
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final boolean addAll(Collection<? extends E> newElements) {
       throw new UnsupportedOperationException();
     }
@@ -635,8 +637,8 @@ public final class Sets {
      */
     @CanIgnoreReturnValue
     @Deprecated
-    @Override
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final boolean removeAll(Collection<?> oldElements) {
       throw new UnsupportedOperationException();
     }
@@ -649,8 +651,8 @@ public final class Sets {
      */
     @CanIgnoreReturnValue
     @Deprecated
-    @Override
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final boolean removeIf(java.util.function.Predicate<? super E> filter) {
       throw new UnsupportedOperationException();
     }
@@ -663,8 +665,8 @@ public final class Sets {
      */
     @CanIgnoreReturnValue
     @Deprecated
-    @Override
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final boolean retainAll(Collection<?> elementsToKeep) {
       throw new UnsupportedOperationException();
     }
@@ -676,8 +678,8 @@ public final class Sets {
      * @deprecated Unsupported operation.
      */
     @Deprecated
-    @Override
     @DoNotCall("Always throws UnsupportedOperationException")
+    @Override
     public final void clear() {
       throw new UnsupportedOperationException();
     }
@@ -703,8 +705,8 @@ public final class Sets {
    */
   public static <E extends @Nullable Object> SetView<E> union(
       final Set<? extends E> set1, final Set<? extends E> set2) {
-    checkNotNull(set1, "set1");
-    checkNotNull(set2, "set2");
+    requireNonNull(set1, "set1");
+    requireNonNull(set2, "set2");
 
     return new SetView<E>() {
       @Override
@@ -729,8 +731,8 @@ public final class Sets {
           final Iterator<? extends E> itr1 = set1.iterator();
           final Iterator<? extends E> itr2 = set2.iterator();
 
-          @Override
           @CheckForNull
+          @Override
           protected E computeNext() {
             if (itr1.hasNext()) {
               return itr1.next();
@@ -805,8 +807,8 @@ public final class Sets {
    */
   public static <E extends @Nullable Object> SetView<E> intersection(
       final Set<E> set1, final Set<?> set2) {
-    checkNotNull(set1, "set1");
-    checkNotNull(set2, "set2");
+    requireNonNull(set1, "set1");
+    requireNonNull(set2, "set2");
 
     return new SetView<E>() {
       @Override
@@ -814,8 +816,8 @@ public final class Sets {
         return new AbstractIterator<E>() {
           final Iterator<E> itr = set1.iterator();
 
-          @Override
           @CheckForNull
+          @Override
           protected E computeNext() {
             while (itr.hasNext()) {
               E e = itr.next();
@@ -851,7 +853,7 @@ public final class Sets {
 
       @Override
       public boolean isEmpty() {
-        return Collections.disjoint(set2, set1);
+        return disjoint(set2, set1);
       }
 
       @Override
@@ -878,8 +880,8 @@ public final class Sets {
    */
   public static <E extends @Nullable Object> SetView<E> difference(
       final Set<E> set1, final Set<?> set2) {
-    checkNotNull(set1, "set1");
-    checkNotNull(set2, "set2");
+    requireNonNull(set1, "set1");
+    requireNonNull(set2, "set2");
 
     return new SetView<E>() {
       @Override
@@ -887,8 +889,8 @@ public final class Sets {
         return new AbstractIterator<E>() {
           final Iterator<E> itr = set1.iterator();
 
-          @Override
           @CheckForNull
+          @Override
           protected E computeNext() {
             while (itr.hasNext()) {
               E e = itr.next();
@@ -947,8 +949,8 @@ public final class Sets {
    */
   public static <E extends @Nullable Object> SetView<E> symmetricDifference(
       final Set<? extends E> set1, final Set<? extends E> set2) {
-    checkNotNull(set1, "set1");
-    checkNotNull(set2, "set2");
+    requireNonNull(set1, "set1");
+    requireNonNull(set2, "set2");
 
     return new SetView<E>() {
       @Override
@@ -956,8 +958,8 @@ public final class Sets {
         final Iterator<? extends E> itr1 = set1.iterator();
         final Iterator<? extends E> itr2 = set2.iterator();
         return new AbstractIterator<E>() {
-          @Override
           @CheckForNull
+          @Override
           public E computeNext() {
             while (itr1.hasNext()) {
               E elem1 = itr1.next();
@@ -1044,7 +1046,7 @@ public final class Sets {
       return new FilteredSet<E>((Set<E>) filtered.unfiltered, combinedPredicate);
     }
 
-    return new FilteredSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));
+    return new FilteredSet<E>(requireNonNull(unfiltered), requireNonNull(predicate));
   }
 
   /**
@@ -1081,7 +1083,7 @@ public final class Sets {
       return new FilteredSortedSet<E>((SortedSet<E>) filtered.unfiltered, combinedPredicate);
     }
 
-    return new FilteredSortedSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));
+    return new FilteredSortedSet<E>(requireNonNull(unfiltered), requireNonNull(predicate));
   }
 
   /**
@@ -1120,7 +1122,7 @@ public final class Sets {
       return new FilteredNavigableSet<E>((NavigableSet<E>) filtered.unfiltered, combinedPredicate);
     }
 
-    return new FilteredNavigableSet<E>(checkNotNull(unfiltered), checkNotNull(predicate));
+    return new FilteredNavigableSet<E>(requireNonNull(unfiltered), requireNonNull(predicate));
   }
 
   private static class FilteredSet<E extends @Nullable Object> extends FilteredCollection<E>
@@ -1147,8 +1149,8 @@ public final class Sets {
       super(unfiltered, predicate);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super E> comparator() {
       return ((SortedSet<E>) unfiltered).comparator();
     }
@@ -1200,38 +1202,38 @@ public final class Sets {
       return (NavigableSet<E>) unfiltered;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E lower(@ParametricNullness E e) {
       return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E floor(@ParametricNullness E e) {
       return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E ceiling(@ParametricNullness E e) {
       return Iterables.find(unfiltered().tailSet(e, true), predicate, null);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E higher(@ParametricNullness E e) {
       return Iterables.find(unfiltered().tailSet(e, false), predicate, null);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollFirst() {
       return Iterables.removeFirstMatching(unfiltered(), predicate);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollLast() {
       return Iterables.removeFirstMatching(unfiltered().descendingSet(), predicate);
     }
@@ -1671,8 +1673,8 @@ public final class Sets {
         return new AbstractIterator<Set<E>>() {
           final BitSet bits = new BitSet(index.size());
 
-          @Override
           @CheckForNull
+          @Override
           protected Set<E> computeNext() {
             if (bits.isEmpty()) {
               bits.set(0, size);
@@ -1714,8 +1716,8 @@ public final class Sets {
                 return new AbstractIterator<E>() {
                   int i = -1;
 
-                  @Override
                   @CheckForNull
+                  @Override
                   protected E computeNext() {
                     i = copy.nextSetBit(i + 1);
                     if (i == -1) {
@@ -1803,8 +1805,8 @@ public final class Sets {
     private final SortedSet<E> unmodifiableDelegate;
 
     UnmodifiableNavigableSet(NavigableSet<E> delegate) {
-      this.delegate = checkNotNull(delegate);
-      this.unmodifiableDelegate = Collections.unmodifiableSortedSet(delegate);
+      this.delegate = requireNonNull(delegate);
+      this.unmodifiableDelegate = unmodifiableSortedSet(delegate);
     }
 
     @Override
@@ -1834,38 +1836,38 @@ public final class Sets {
       delegate.forEach(action);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E lower(@ParametricNullness E e) {
       return delegate.lower(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E floor(@ParametricNullness E e) {
       return delegate.floor(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E ceiling(@ParametricNullness E e) {
       return delegate.ceiling(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E higher(@ParametricNullness E e) {
       return delegate.higher(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollFirst() {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollLast() {
       throw new UnsupportedOperationException();
     }
@@ -1971,7 +1973,7 @@ public final class Sets {
   }
 
   static boolean removeAllImpl(Set<?> set, Collection<?> collection) {
-    checkNotNull(collection); // for GWT
+    requireNonNull(collection); // for GWT
     if (collection instanceof Multiset) {
       collection = ((Multiset<?>) collection).elementSet();
     }
@@ -2002,38 +2004,38 @@ public final class Sets {
       return forward;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E lower(@ParametricNullness E e) {
       return forward.higher(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E floor(@ParametricNullness E e) {
       return forward.ceiling(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E ceiling(@ParametricNullness E e) {
       return forward.floor(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E higher(@ParametricNullness E e) {
       return forward.lower(e);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollFirst() {
       return forward.pollLast();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollLast() {
       return forward.pollFirst();
     }
@@ -2082,8 +2084,8 @@ public final class Sets {
       return standardTailSet(fromElement);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     public Comparator<? super E> comparator() {
       Comparator<? super E> forwardComparator = forward.comparator();
       if (forwardComparator == null) {
@@ -2171,6 +2173,6 @@ public final class Sets {
     } else if (range.hasUpperBound()) {
       return set.headSet(range.upperEndpoint(), range.upperBoundType() == BoundType.CLOSED);
     }
-    return checkNotNull(set);
+    return requireNonNull(set);
   }
 }
diff --git a/guava/src/com/google/common/collect/SingletonImmutableBiMap.java b/guava/src/com/google/common/collect/SingletonImmutableBiMap.java
index c5fb2b2989..976d7dbb6e 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableBiMap.java
@@ -16,8 +16,8 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.concurrent.LazyInit;
@@ -52,8 +52,8 @@ final class SingletonImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
     this.inverse = inverse;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object key) {
     return singleKey.equals(key) ? singleValue : null;
   }
@@ -65,7 +65,7 @@ final class SingletonImmutableBiMap<K, V> extends ImmutableBiMap<K, V> {
 
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action).accept(singleKey, singleValue);
+    requireNonNull(action).accept(singleKey, singleValue);
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/SingletonImmutableList.java b/guava/src/com/google/common/collect/SingletonImmutableList.java
index a7ac8b30e2..fb8c6488ea 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableList.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableList.java
@@ -16,11 +16,12 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkElementIndex;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Collections.singleton;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
-import java.util.Collections;
 import java.util.Spliterator;
 
 /**
@@ -36,12 +37,12 @@ final class SingletonImmutableList<E> extends ImmutableList<E> {
   final transient E element;
 
   SingletonImmutableList(E element) {
-    this.element = checkNotNull(element);
+    this.element = requireNonNull(element);
   }
 
   @Override
   public E get(int index) {
-    Preconditions.checkElementIndex(index, 1);
+    checkElementIndex(index, 1);
     return element;
   }
 
@@ -52,7 +53,7 @@ final class SingletonImmutableList<E> extends ImmutableList<E> {
 
   @Override
   public Spliterator<E> spliterator() {
-    return Collections.singleton(element).spliterator();
+    return singleton(element).spliterator();
   }
 
   @Override
@@ -62,7 +63,7 @@ final class SingletonImmutableList<E> extends ImmutableList<E> {
 
   @Override
   public ImmutableList<E> subList(int fromIndex, int toIndex) {
-    Preconditions.checkPositionIndexes(fromIndex, toIndex, 1);
+    checkPositionIndexes(fromIndex, toIndex, 1);
     return (fromIndex == toIndex) ? ImmutableList.<E>of() : this;
   }
 
diff --git a/guava/src/com/google/common/collect/SingletonImmutableSet.java b/guava/src/com/google/common/collect/SingletonImmutableSet.java
index 088cb802f2..32d0d8a9de 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableSet.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableSet.java
@@ -16,8 +16,9 @@
 
 package com.google.common.collect;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
 import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -37,7 +38,7 @@ final class SingletonImmutableSet<E> extends ImmutableSet<E> {
   final transient E element;
 
   SingletonImmutableSet(E element) {
-    this.element = Preconditions.checkNotNull(element);
+    this.element = requireNonNull(element);
   }
 
   @Override
diff --git a/guava/src/com/google/common/collect/SingletonImmutableTable.java b/guava/src/com/google/common/collect/SingletonImmutableTable.java
index cfaeadb41d..3868a7ceb2 100644
--- a/guava/src/com/google/common/collect/SingletonImmutableTable.java
+++ b/guava/src/com/google/common/collect/SingletonImmutableTable.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
@@ -34,9 +34,9 @@ class SingletonImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
   final V singleValue;
 
   SingletonImmutableTable(R rowKey, C columnKey, V value) {
-    this.singleRowKey = checkNotNull(rowKey);
-    this.singleColumnKey = checkNotNull(columnKey);
-    this.singleValue = checkNotNull(value);
+    this.singleRowKey = requireNonNull(rowKey);
+    this.singleColumnKey = requireNonNull(columnKey);
+    this.singleValue = requireNonNull(value);
   }
 
   SingletonImmutableTable(Cell<R, C, V> cell) {
@@ -45,7 +45,7 @@ class SingletonImmutableTable<R, C, V> extends ImmutableTable<R, C, V> {
 
   @Override
   public ImmutableMap<R, V> column(C columnKey) {
-    checkNotNull(columnKey);
+    requireNonNull(columnKey);
     return containsColumn(columnKey)
         ? ImmutableMap.of(singleRowKey, singleValue)
         : ImmutableMap.<R, V>of();
diff --git a/guava/src/com/google/common/collect/SortedIterables.java b/guava/src/com/google/common/collect/SortedIterables.java
index 68b231a381..a732640c39 100644
--- a/guava/src/com/google/common/collect/SortedIterables.java
+++ b/guava/src/com/google/common/collect/SortedIterables.java
@@ -14,7 +14,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
@@ -36,8 +36,8 @@ final class SortedIterables {
    * {@code comparator}.
    */
   public static boolean hasSameComparator(Comparator<?> comparator, Iterable<?> elements) {
-    checkNotNull(comparator);
-    checkNotNull(elements);
+    requireNonNull(comparator);
+    requireNonNull(elements);
     Comparator<?> comparator2;
     if (elements instanceof SortedSet) {
       comparator2 = comparator((SortedSet<?>) elements);
diff --git a/guava/src/com/google/common/collect/SortedLists.java b/guava/src/com/google/common/collect/SortedLists.java
index 0ebaab20f9..599d58a7cc 100644
--- a/guava/src/com/google/common/collect/SortedLists.java
+++ b/guava/src/com/google/common/collect/SortedLists.java
@@ -14,11 +14,12 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -205,7 +206,7 @@ final class SortedLists {
       E e,
       KeyPresentBehavior presentBehavior,
       KeyAbsentBehavior absentBehavior) {
-    checkNotNull(e);
+    requireNonNull(e);
     return binarySearch(list, e, Ordering.natural(), presentBehavior, absentBehavior);
   }
 
@@ -221,7 +222,7 @@ final class SortedLists {
       K key,
       KeyPresentBehavior presentBehavior,
       KeyAbsentBehavior absentBehavior) {
-    checkNotNull(key);
+    requireNonNull(key);
     return binarySearch(
         list, keyFunction, key, Ordering.natural(), presentBehavior, absentBehavior);
   }
@@ -273,12 +274,12 @@ final class SortedLists {
       Comparator<? super E> comparator,
       KeyPresentBehavior presentBehavior,
       KeyAbsentBehavior absentBehavior) {
-    checkNotNull(comparator);
-    checkNotNull(list);
-    checkNotNull(presentBehavior);
-    checkNotNull(absentBehavior);
+    requireNonNull(comparator);
+    requireNonNull(list);
+    requireNonNull(presentBehavior);
+    requireNonNull(absentBehavior);
     if (!(list instanceof RandomAccess)) {
-      list = Lists.newArrayList(list);
+      list = new ArrayList<>(list);
     }
     // TODO(lowasser): benchmark when it's best to do a linear search
 
diff --git a/guava/src/com/google/common/collect/SortedMultisets.java b/guava/src/com/google/common/collect/SortedMultisets.java
index f602a42a11..20ea66a033 100644
--- a/guava/src/com/google/common/collect/SortedMultisets.java
+++ b/guava/src/com/google/common/collect/SortedMultisets.java
@@ -102,26 +102,26 @@ final class SortedMultisets {
       super(multiset);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E lower(@ParametricNullness E e) {
       return getElementOrNull(multiset().headMultiset(e, OPEN).lastEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E floor(@ParametricNullness E e) {
       return getElementOrNull(multiset().headMultiset(e, CLOSED).lastEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E ceiling(@ParametricNullness E e) {
       return getElementOrNull(multiset().tailMultiset(e, CLOSED).firstEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E higher(@ParametricNullness E e) {
       return getElementOrNull(multiset().tailMultiset(e, OPEN).firstEntry());
     }
@@ -136,14 +136,14 @@ final class SortedMultisets {
       return descendingSet().iterator();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollFirst() {
       return getElementOrNull(multiset().pollFirstEntry());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollLast() {
       return getElementOrNull(multiset().pollLastEntry());
     }
diff --git a/guava/src/com/google/common/collect/SparseImmutableTable.java b/guava/src/com/google/common/collect/SparseImmutableTable.java
index 44881fde7f..2105b7965b 100644
--- a/guava/src/com/google/common/collect/SparseImmutableTable.java
+++ b/guava/src/com/google/common/collect/SparseImmutableTable.java
@@ -24,7 +24,7 @@ import java.util.Map.Entry;
 
 /** A {@code RegularImmutableTable} optimized for sparse data. */
 @GwtCompatible
-@Immutable(containerOf = {"R", "C", "V"})
+@Immutable(containerOf = {"C", "R", "V"})
 @ElementTypesAreNonnullByDefault
 final class SparseImmutableTable<R, C, V> extends RegularImmutableTable<R, C, V> {
   static final ImmutableTable<Object, Object, Object> EMPTY =
diff --git a/guava/src/com/google/common/collect/StandardRowSortedTable.java b/guava/src/com/google/common/collect/StandardRowSortedTable.java
index bea5b7bb3a..cb7d54e264 100644
--- a/guava/src/com/google/common/collect/StandardRowSortedTable.java
+++ b/guava/src/com/google/common/collect/StandardRowSortedTable.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Supplier;
@@ -103,8 +103,8 @@ class StandardRowSortedTable<R, C, V> extends StandardTable<R, C, V>
       return new Maps.SortedKeySet<>(this);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super R> comparator() {
       return sortedBackingMap().comparator();
     }
@@ -121,22 +121,22 @@ class StandardRowSortedTable<R, C, V> extends StandardTable<R, C, V>
 
     @Override
     public SortedMap<R, Map<C, V>> headMap(R toKey) {
-      checkNotNull(toKey);
+      requireNonNull(toKey);
       return new StandardRowSortedTable<R, C, V>(sortedBackingMap().headMap(toKey), factory)
           .rowMap();
     }
 
     @Override
     public SortedMap<R, Map<C, V>> subMap(R fromKey, R toKey) {
-      checkNotNull(fromKey);
-      checkNotNull(toKey);
+      requireNonNull(fromKey);
+      requireNonNull(toKey);
       return new StandardRowSortedTable<R, C, V>(sortedBackingMap().subMap(fromKey, toKey), factory)
           .rowMap();
     }
 
     @Override
     public SortedMap<R, Map<C, V>> tailMap(R fromKey) {
-      checkNotNull(fromKey);
+      requireNonNull(fromKey);
       return new StandardRowSortedTable<R, C, V>(sortedBackingMap().tailMap(fromKey), factory)
           .rowMap();
     }
diff --git a/guava/src/com/google/common/collect/StandardTable.java b/guava/src/com/google/common/collect/StandardTable.java
index 06defb0eb8..fbe7880304 100644
--- a/guava/src/com/google/common/collect/StandardTable.java
+++ b/guava/src/com/google/common/collect/StandardTable.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Predicates.alwaysTrue;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.in;
@@ -106,8 +105,8 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     return value != null && super.containsValue(value);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     return (rowKey == null || columnKey == null) ? null : super.get(rowKey, columnKey);
   }
@@ -143,18 +142,18 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V put(R rowKey, C columnKey, V value) {
-    checkNotNull(rowKey);
-    checkNotNull(columnKey);
-    checkNotNull(value);
+    requireNonNull(rowKey);
+    requireNonNull(columnKey);
+    requireNonNull(value);
     return getOrCreate(rowKey).put(columnKey, value);
   }
 
   @CanIgnoreReturnValue
-  @Override
   @CheckForNull
+  @Override
   public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
     if ((rowKey == null) || (columnKey == null)) {
       return null;
@@ -317,7 +316,7 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     final R rowKey;
 
     Row(R rowKey) {
-      this.rowKey = checkNotNull(rowKey);
+      this.rowKey = requireNonNull(rowKey);
     }
 
     @CheckForNull Map<C, V> backingRowMap;
@@ -348,26 +347,26 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return (key != null && backingRowMap != null) && Maps.safeContainsKey(backingRowMap, key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
       updateBackingRowMapField();
       return (key != null && backingRowMap != null) ? Maps.safeGet(backingRowMap, key) : null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(C key, V value) {
-      checkNotNull(key);
-      checkNotNull(value);
+      requireNonNull(key);
+      requireNonNull(value);
       if (backingRowMap != null && !backingRowMap.isEmpty()) {
         return backingRowMap.put(key, value);
       }
       return StandardTable.this.put(rowKey, key, value);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object key) {
       updateBackingRowMapField();
       if (backingRowMap == null) {
@@ -437,7 +436,7 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
 
         @Override
         public V setValue(V value) {
-          return super.setValue(checkNotNull(value));
+          return super.setValue(requireNonNull(value));
         }
 
         @Override
@@ -463,17 +462,17 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     final C columnKey;
 
     Column(C columnKey) {
-      this.columnKey = checkNotNull(columnKey);
+      this.columnKey = requireNonNull(columnKey);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(R key, V value) {
       return StandardTable.this.put(key, columnKey, value);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
       return StandardTable.this.get(key, columnKey);
     }
@@ -483,8 +482,8 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return StandardTable.this.contains(key, columnKey);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object key) {
       return StandardTable.this.remove(key, columnKey);
     }
@@ -569,8 +568,8 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     private class EntrySetIterator extends AbstractIterator<Entry<R, V>> {
       final Iterator<Entry<R, Map<C, V>>> iterator = backingMap.entrySet().iterator();
 
-      @Override
       @CheckForNull
+      @Override
       protected Entry<R, V> computeNext() {
         while (iterator.hasNext()) {
           final Entry<R, Map<C, V>> entry = iterator.next();
@@ -604,7 +603,7 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
                  * behavior change relative to the old code, so it didn't seem worth risking.)
                  */
                 return uncheckedCastNullableTToT(
-                    entry.getValue().put(columnKey, checkNotNull(value)));
+                    entry.getValue().put(columnKey, requireNonNull(value)));
               }
             }
             return new EntryImpl();
@@ -723,7 +722,7 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
 
     @Override
     public boolean removeAll(Collection<?> c) {
-      checkNotNull(c);
+      requireNonNull(c);
       boolean changed = false;
       Iterator<Map<C, V>> iterator = backingMap.values().iterator();
       while (iterator.hasNext()) {
@@ -742,7 +741,7 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
 
     @Override
     public boolean retainAll(Collection<?> c) {
-      checkNotNull(c);
+      requireNonNull(c);
       boolean changed = false;
       Iterator<Map<C, V>> iterator = backingMap.values().iterator();
       while (iterator.hasNext()) {
@@ -775,8 +774,8 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     final Iterator<Map<C, V>> mapIterator = backingMap.values().iterator();
     Iterator<Entry<C, V>> entryIterator = Iterators.emptyIterator();
 
-    @Override
     @CheckForNull
+    @Override
     protected C computeNext() {
       while (true) {
         if (entryIterator.hasNext()) {
@@ -825,16 +824,16 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
     }
 
     // performing cast only when key is in backing map and has the correct type
-    @SuppressWarnings("unchecked")
-    @Override
     @CheckForNull
+    @Override
+    @SuppressWarnings("unchecked")
     public Map<C, V> get(@CheckForNull Object key) {
       // requireNonNull is safe because of the containsRow check.
       return containsRow(key) ? row((R) requireNonNull(key)) : null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map<C, V> remove(@CheckForNull Object key) {
       return (key == null) ? null : backingMap.remove(key);
     }
@@ -899,9 +898,9 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
   private class ColumnMap extends ViewCachingAbstractMap<C, Map<R, V>> {
     // The cast to C occurs only when the key is in the map, implying that it
     // has the correct type.
-    @SuppressWarnings("unchecked")
-    @Override
     @CheckForNull
+    @Override
+    @SuppressWarnings("unchecked")
     public Map<R, V> get(@CheckForNull Object key) {
       // requireNonNull is safe because of the containsColumn check.
       return containsColumn(key) ? column((C) requireNonNull(key)) : null;
@@ -912,8 +911,8 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
       return containsColumn(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map<R, V> remove(@CheckForNull Object key) {
       return containsColumn(key) ? removeColumn(key) : null;
     }
@@ -986,13 +985,13 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
          * circumstances, it attempts to call columnKeySet().iterator().remove,
          * which is unsupported.
          */
-        checkNotNull(c);
+        requireNonNull(c);
         return Sets.removeAllImpl(this, c.iterator());
       }
 
       @Override
       public boolean retainAll(Collection<?> c) {
-        checkNotNull(c);
+        requireNonNull(c);
         boolean changed = false;
         for (C columnKey : Lists.newArrayList(columnKeySet().iterator())) {
           if (!c.contains(Maps.immutableEntry(columnKey, column(columnKey)))) {
@@ -1023,7 +1022,7 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
 
       @Override
       public boolean removeAll(Collection<?> c) {
-        checkNotNull(c);
+        requireNonNull(c);
         boolean changed = false;
         for (C columnKey : Lists.newArrayList(columnKeySet().iterator())) {
           if (c.contains(column(columnKey))) {
@@ -1036,7 +1035,7 @@ class StandardTable<R, C, V> extends AbstractTable<R, C, V> implements Serializa
 
       @Override
       public boolean retainAll(Collection<?> c) {
-        checkNotNull(c);
+        requireNonNull(c);
         boolean changed = false;
         for (C columnKey : Lists.newArrayList(columnKeySet().iterator())) {
           if (!c.contains(column(columnKey))) {
diff --git a/guava/src/com/google/common/collect/Streams.java b/guava/src/com/google/common/collect/Streams.java
index cd7a07c342..a7b3a685d1 100644
--- a/guava/src/com/google/common/collect/Streams.java
+++ b/guava/src/com/google/common/collect/Streams.java
@@ -16,7 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static java.lang.Math.min;
 import static java.util.Objects.requireNonNull;
@@ -317,9 +316,9 @@ public final class Streams {
   public static <A extends @Nullable Object, B extends @Nullable Object, R extends @Nullable Object>
       Stream<R> zip(
           Stream<A> streamA, Stream<B> streamB, BiFunction<? super A, ? super B, R> function) {
-    checkNotNull(streamA);
-    checkNotNull(streamB);
-    checkNotNull(function);
+    requireNonNull(streamA);
+    requireNonNull(streamB);
+    requireNonNull(function);
     boolean isParallel = streamA.isParallel() || streamB.isParallel(); // same as Stream.concat
     Spliterator<A> splitrA = streamA.spliterator();
     Spliterator<B> splitrB = streamB.spliterator();
@@ -379,7 +378,7 @@ public final class Streams {
   @Beta
   public static <A extends @Nullable Object, B extends @Nullable Object> void forEachPair(
       Stream<A> streamA, Stream<B> streamB, BiConsumer<? super A, ? super B> consumer) {
-    checkNotNull(consumer);
+    requireNonNull(consumer);
 
     if (streamA.isParallel() || streamB.isParallel()) {
       zip(streamA, streamB, TemporaryPair::new).forEach(pair -> consumer.accept(pair.a, pair.b));
@@ -427,8 +426,8 @@ public final class Streams {
    */
   public static <T extends @Nullable Object, R extends @Nullable Object> Stream<R> mapWithIndex(
       Stream<T> stream, FunctionWithIndex<? super T, ? extends R> function) {
-    checkNotNull(stream);
-    checkNotNull(function);
+    requireNonNull(stream);
+    requireNonNull(function);
     boolean isParallel = stream.isParallel();
     Spliterator<T> fromSpliterator = stream.spliterator();
 
@@ -510,8 +509,8 @@ public final class Streams {
    */
   public static <R extends @Nullable Object> Stream<R> mapWithIndex(
       IntStream stream, IntFunctionWithIndex<R> function) {
-    checkNotNull(stream);
-    checkNotNull(function);
+    requireNonNull(stream);
+    requireNonNull(function);
     boolean isParallel = stream.isParallel();
     Spliterator.OfInt fromSpliterator = stream.spliterator();
 
@@ -589,8 +588,8 @@ public final class Streams {
    */
   public static <R extends @Nullable Object> Stream<R> mapWithIndex(
       LongStream stream, LongFunctionWithIndex<R> function) {
-    checkNotNull(stream);
-    checkNotNull(function);
+    requireNonNull(stream);
+    requireNonNull(function);
     boolean isParallel = stream.isParallel();
     Spliterator.OfLong fromSpliterator = stream.spliterator();
 
@@ -668,8 +667,8 @@ public final class Streams {
    */
   public static <R extends @Nullable Object> Stream<R> mapWithIndex(
       DoubleStream stream, DoubleFunctionWithIndex<R> function) {
-    checkNotNull(stream);
-    checkNotNull(function);
+    requireNonNull(stream);
+    requireNonNull(function);
     boolean isParallel = stream.isParallel();
     Spliterator.OfDouble fromSpliterator = stream.spliterator();
 
@@ -752,8 +751,8 @@ public final class Streams {
 
     abstract S createSplit(F from, long i);
 
-    @Override
     @CheckForNull
+    @Override
     public S trySplit() {
       Spliterator<?> splitOrNull = fromSpliterator.trySplit();
       if (splitOrNull == null) {
diff --git a/guava/src/com/google/common/collect/Synchronized.java b/guava/src/com/google/common/collect/Synchronized.java
index 29fe61a89b..76ab3484cc 100644
--- a/guava/src/com/google/common/collect/Synchronized.java
+++ b/guava/src/com/google/common/collect/Synchronized.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -81,7 +81,7 @@ final class Synchronized {
     final Object mutex;
 
     SynchronizedObject(Object delegate, @CheckForNull Object mutex) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
       this.mutex = (mutex == null) ? this : mutex;
     }
 
@@ -126,8 +126,8 @@ final class Synchronized {
       super(delegate, mutex);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     Collection<E> delegate() {
       return (Collection<E>) super.delegate();
     }
@@ -313,8 +313,8 @@ final class Synchronized {
       return (SortedSet<E>) super.delegate();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super E> comparator() {
       synchronized (mutex) {
         return delegate().comparator();
@@ -599,8 +599,8 @@ final class Synchronized {
     @CheckForNull transient Map<K, Collection<V>> asMap;
     @CheckForNull transient Multiset<K> keys;
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     Multimap<K, V> delegate() {
       return (Multimap<K, V>) super.delegate();
     }
@@ -919,8 +919,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super V> valueComparator() {
       synchronized (mutex) {
         return delegate().valueComparator();
@@ -1071,8 +1071,8 @@ final class Synchronized {
       super(delegate, mutex);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     Map<K, V> delegate() {
       return (Map<K, V>) super.delegate();
     }
@@ -1115,16 +1115,16 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
       synchronized (mutex) {
         return delegate().get(key);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V getOrDefault(@CheckForNull Object key, @CheckForNull V defaultValue) {
       synchronized (mutex) {
         return delegate().getOrDefault(key, defaultValue);
@@ -1148,16 +1148,16 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(K key, V value) {
       synchronized (mutex) {
         return delegate().put(key, value);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V putIfAbsent(K key, V value) {
       synchronized (mutex) {
         return delegate().putIfAbsent(key, value);
@@ -1171,8 +1171,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V replace(K key, V value) {
       synchronized (mutex) {
         return delegate().replace(key, value);
@@ -1224,8 +1224,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object key) {
       synchronized (mutex) {
         return delegate().remove(key);
@@ -1293,8 +1293,8 @@ final class Synchronized {
       return (SortedMap<K, V>) super.delegate();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Comparator<? super K> comparator() {
       synchronized (mutex) {
         return delegate().comparator();
@@ -1374,8 +1374,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V forcePut(K key, V value) {
       synchronized (mutex) {
         return delegate().forcePut(key, value);
@@ -1404,8 +1404,8 @@ final class Synchronized {
       super(delegate, mutex);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Collection<V> get(@CheckForNull Object key) {
       synchronized (mutex) {
         Collection<V> collection = super.get(key);
@@ -1436,7 +1436,7 @@ final class Synchronized {
     @Override
     public boolean containsValue(@CheckForNull Object o) {
       // values() and its contains() method are both synchronized.
-      return values().contains(o);
+      return this.containsValue(o);
     }
 
     private static final long serialVersionUID = 0;
@@ -1475,8 +1475,8 @@ final class Synchronized {
       return (NavigableSet<E>) super.delegate();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E ceiling(E e) {
       synchronized (mutex) {
         return delegate().ceiling(e);
@@ -1502,8 +1502,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E floor(E e) {
       synchronized (mutex) {
         return delegate().floor(e);
@@ -1522,32 +1522,32 @@ final class Synchronized {
       return headSet(toElement, false);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E higher(E e) {
       synchronized (mutex) {
         return delegate().higher(e);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E lower(E e) {
       synchronized (mutex) {
         return delegate().lower(e);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollFirst() {
       synchronized (mutex) {
         return delegate().pollFirst();
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollLast() {
       synchronized (mutex) {
         return delegate().pollLast();
@@ -1620,16 +1620,16 @@ final class Synchronized {
       return (NavigableMap<K, V>) super.delegate();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> ceilingEntry(K key) {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().ceilingEntry(key), mutex);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K ceilingKey(K key) {
       synchronized (mutex) {
         return delegate().ceilingKey(key);
@@ -1660,24 +1660,24 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> firstEntry() {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().firstEntry(), mutex);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> floorEntry(K key) {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().floorEntry(key), mutex);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K floorKey(K key) {
       synchronized (mutex) {
         return delegate().floorKey(key);
@@ -1696,40 +1696,40 @@ final class Synchronized {
       return headMap(toKey, false);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> higherEntry(K key) {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().higherEntry(key), mutex);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K higherKey(K key) {
       synchronized (mutex) {
         return delegate().higherKey(key);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> lastEntry() {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().lastEntry(), mutex);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> lowerEntry(K key) {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().lowerEntry(key), mutex);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public K lowerKey(K key) {
       synchronized (mutex) {
         return delegate().lowerKey(key);
@@ -1753,16 +1753,16 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> pollFirstEntry() {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().pollFirstEntry(), mutex);
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Map.Entry<K, V> pollLastEntry() {
       synchronized (mutex) {
         return nullableSynchronizedEntry(delegate().pollLastEntry(), mutex);
@@ -1797,8 +1797,8 @@ final class Synchronized {
     private static final long serialVersionUID = 0;
   }
 
-  @GwtIncompatible // works but is needed only for NavigableMap
-  @CheckForNull
+  @CheckForNull // works but is needed only for NavigableMap
+  @GwtIncompatible
   private static <K extends @Nullable Object, V extends @Nullable Object>
       Map.Entry<K, V> nullableSynchronizedEntry(
           @CheckForNull Map.Entry<K, V> entry, @CheckForNull Object mutex) {
@@ -1816,8 +1816,8 @@ final class Synchronized {
       super(delegate, mutex);
     }
 
-    @SuppressWarnings("unchecked") // guaranteed by the constructor
-    @Override
+    @Override // guaranteed by the constructor
+    @SuppressWarnings("unchecked")
     Map.Entry<K, V> delegate() {
       return (Map.Entry<K, V>) super.delegate();
     }
@@ -1890,16 +1890,16 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E peek() {
       synchronized (mutex) {
         return delegate().peek();
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E poll() {
       synchronized (mutex) {
         return delegate().poll();
@@ -1974,16 +1974,16 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollFirst() {
       synchronized (mutex) {
         return delegate().pollFirst();
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E pollLast() {
       synchronized (mutex) {
         return delegate().pollLast();
@@ -2004,16 +2004,16 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E peekFirst() {
       synchronized (mutex) {
         return delegate().peekFirst();
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E peekLast() {
       synchronized (mutex) {
         return delegate().peekLast();
@@ -2071,8 +2071,8 @@ final class Synchronized {
       super(delegate, mutex);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     Table<R, C, V> delegate() {
       return (Table<R, C, V>) super.delegate();
     }
@@ -2105,8 +2105,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
       synchronized (mutex) {
         return delegate().get(rowKey, columnKey);
@@ -2134,8 +2134,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(R rowKey, C columnKey, V value) {
       synchronized (mutex) {
         return delegate().put(rowKey, columnKey, value);
@@ -2149,8 +2149,8 @@ final class Synchronized {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
       synchronized (mutex) {
         return delegate().remove(rowKey, columnKey);
diff --git a/guava/src/com/google/common/collect/TableCollectors.java b/guava/src/com/google/common/collect/TableCollectors.java
index 16fcb16696..bd54dac85a 100644
--- a/guava/src/com/google/common/collect/TableCollectors.java
+++ b/guava/src/com/google/common/collect/TableCollectors.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.Tables.AbstractCell;
@@ -38,9 +38,9 @@ final class TableCollectors {
           Function<? super T, ? extends R> rowFunction,
           Function<? super T, ? extends C> columnFunction,
           Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(rowFunction, "rowFunction");
-    checkNotNull(columnFunction, "columnFunction");
-    checkNotNull(valueFunction, "valueFunction");
+    requireNonNull(rowFunction, "rowFunction");
+    requireNonNull(columnFunction, "columnFunction");
+    requireNonNull(valueFunction, "valueFunction");
     return Collector.of(
         (Supplier<ImmutableTable.Builder<R, C, V>>) ImmutableTable.Builder::new,
         (builder, t) ->
@@ -56,10 +56,10 @@ final class TableCollectors {
           Function<? super T, ? extends V> valueFunction,
           BinaryOperator<V> mergeFunction) {
 
-    checkNotNull(rowFunction, "rowFunction");
-    checkNotNull(columnFunction, "columnFunction");
-    checkNotNull(valueFunction, "valueFunction");
-    checkNotNull(mergeFunction, "mergeFunction");
+    requireNonNull(rowFunction, "rowFunction");
+    requireNonNull(columnFunction, "columnFunction");
+    requireNonNull(valueFunction, "valueFunction");
+    requireNonNull(mergeFunction, "mergeFunction");
 
     /*
      * No mutable Table exactly matches the insertion order behavior of ImmutableTable.Builder, but
@@ -112,11 +112,11 @@ final class TableCollectors {
           java.util.function.Function<? super T, ? extends V> valueFunction,
           BinaryOperator<V> mergeFunction,
           java.util.function.Supplier<I> tableSupplier) {
-    checkNotNull(rowFunction);
-    checkNotNull(columnFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(mergeFunction);
-    checkNotNull(tableSupplier);
+    requireNonNull(rowFunction);
+    requireNonNull(columnFunction);
+    requireNonNull(valueFunction);
+    requireNonNull(mergeFunction);
+    requireNonNull(tableSupplier);
     return Collector.of(
         tableSupplier,
         (table, input) ->
@@ -169,9 +169,9 @@ final class TableCollectors {
     private V value;
 
     MutableCell(R row, C column, V value) {
-      this.row = checkNotNull(row, "row");
-      this.column = checkNotNull(column, "column");
-      this.value = checkNotNull(value, "value");
+      this.row = requireNonNull(row, "row");
+      this.column = requireNonNull(column, "column");
+      this.value = requireNonNull(value, "value");
     }
 
     @Override
@@ -190,8 +190,8 @@ final class TableCollectors {
     }
 
     void merge(V value, BinaryOperator<V> mergeFunction) {
-      checkNotNull(value, "value");
-      this.value = checkNotNull(mergeFunction.apply(this.value, value), "mergeFunction.apply");
+      requireNonNull(value, "value");
+      this.value = requireNonNull(mergeFunction.apply(this.value, value), "mergeFunction.apply");
     }
   }
 
@@ -203,7 +203,7 @@ final class TableCollectors {
           @ParametricNullness C column,
           @ParametricNullness V value,
           BinaryOperator<V> mergeFunction) {
-    checkNotNull(value);
+    requireNonNull(value);
     V oldValue = table.get(row, column);
     if (oldValue == null) {
       table.put(row, column, value);
diff --git a/guava/src/com/google/common/collect/Tables.java b/guava/src/com/google/common/collect/Tables.java
index 9c58611d41..f0ebda0edd 100644
--- a/guava/src/com/google/common/collect/Tables.java
+++ b/guava/src/com/google/common/collect/Tables.java
@@ -17,8 +17,13 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
+import static java.util.Collections.unmodifiableCollection;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Collections.unmodifiableSet;
+import static java.util.Collections.unmodifiableSortedMap;
+import static java.util.Collections.unmodifiableSortedSet;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -28,7 +33,6 @@ import com.google.common.base.Supplier;
 import com.google.common.collect.Table.Cell;
 import java.io.Serializable;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
@@ -222,7 +226,7 @@ public final class Tables {
     final Table<R, C, V> original;
 
     TransposeTable(Table<R, C, V> original) {
-      this.original = checkNotNull(original);
+      this.original = requireNonNull(original);
     }
 
     @Override
@@ -265,14 +269,14 @@ public final class Tables {
       return original.containsValue(value);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
       return original.get(columnKey, rowKey);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(
         @ParametricNullness C rowKey,
         @ParametricNullness R columnKey,
@@ -285,8 +289,8 @@ public final class Tables {
       original.putAll(transpose(table));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
       return original.remove(columnKey, rowKey);
     }
@@ -325,14 +329,14 @@ public final class Tables {
           }
         };
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     Iterator<Cell<C, R, V>> cellIterator() {
       return Iterators.transform(original.cellSet().iterator(), (Function) TRANSPOSE_CELL);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings("unchecked")
     Spliterator<Cell<C, R, V>> cellSpliterator() {
       return CollectSpliterators.map(original.cellSet().spliterator(), (Function) TRANSPOSE_CELL);
     }
@@ -380,7 +384,7 @@ public final class Tables {
   public static <R, C, V> Table<R, C, V> newCustomTable(
       Map<R, Map<C, V>> backingMap, Supplier<? extends Map<C, V>> factory) {
     checkArgument(backingMap.isEmpty());
-    checkNotNull(factory);
+    requireNonNull(factory);
     // TODO(jlevy): Wrap factory to validate that the supplied maps are empty?
     return new StandardTable<>(backingMap, factory);
   }
@@ -427,8 +431,8 @@ public final class Tables {
     final Function<? super V1, V2> function;
 
     TransformedTable(Table<R, C, V1> fromTable, Function<? super V1, V2> function) {
-      this.fromTable = checkNotNull(fromTable);
-      this.function = checkNotNull(function);
+      this.fromTable = requireNonNull(fromTable);
+      this.function = requireNonNull(function);
     }
 
     @Override
@@ -436,8 +440,8 @@ public final class Tables {
       return fromTable.contains(rowKey, columnKey);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V2 get(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
       // The function is passed a null input only when the table contains a null
       // value.
@@ -457,8 +461,8 @@ public final class Tables {
       fromTable.clear();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V2 put(
         @ParametricNullness R rowKey,
         @ParametricNullness C columnKey,
@@ -471,8 +475,8 @@ public final class Tables {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V2 remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
       return contains(rowKey, columnKey)
           // The cast is safe because of the contains() check.
@@ -573,18 +577,18 @@ public final class Tables {
     final Table<? extends R, ? extends C, ? extends V> delegate;
 
     UnmodifiableTable(Table<? extends R, ? extends C, ? extends V> delegate) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
-    @SuppressWarnings("unchecked") // safe, covariant cast
-    @Override
+    @Override // safe, covariant cast
+    @SuppressWarnings("unchecked")
     protected Table<R, C, V> delegate() {
       return (Table<R, C, V>) delegate;
     }
 
     @Override
     public Set<Cell<R, C, V>> cellSet() {
-      return Collections.unmodifiableSet(super.cellSet());
+      return unmodifiableSet(super.cellSet());
     }
 
     @Override
@@ -594,22 +598,22 @@ public final class Tables {
 
     @Override
     public Map<R, V> column(@ParametricNullness C columnKey) {
-      return Collections.unmodifiableMap(super.column(columnKey));
+      return unmodifiableMap(super.column(columnKey));
     }
 
     @Override
     public Set<C> columnKeySet() {
-      return Collections.unmodifiableSet(super.columnKeySet());
+      return unmodifiableSet(super.columnKeySet());
     }
 
     @Override
     public Map<C, Map<R, V>> columnMap() {
       Function<Map<R, V>, Map<R, V>> wrapper = unmodifiableWrapper();
-      return Collections.unmodifiableMap(Maps.transformValues(super.columnMap(), wrapper));
+      return unmodifiableMap(Maps.transformValues(super.columnMap(), wrapper));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(
         @ParametricNullness R rowKey,
         @ParametricNullness C columnKey,
@@ -622,31 +626,31 @@ public final class Tables {
       throw new UnsupportedOperationException();
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {
       throw new UnsupportedOperationException();
     }
 
     @Override
     public Map<C, V> row(@ParametricNullness R rowKey) {
-      return Collections.unmodifiableMap(super.row(rowKey));
+      return unmodifiableMap(super.row(rowKey));
     }
 
     @Override
     public Set<R> rowKeySet() {
-      return Collections.unmodifiableSet(super.rowKeySet());
+      return unmodifiableSet(super.rowKeySet());
     }
 
     @Override
     public Map<R, Map<C, V>> rowMap() {
       Function<Map<C, V>, Map<C, V>> wrapper = unmodifiableWrapper();
-      return Collections.unmodifiableMap(Maps.transformValues(super.rowMap(), wrapper));
+      return unmodifiableMap(Maps.transformValues(super.rowMap(), wrapper));
     }
 
     @Override
     public Collection<V> values() {
-      return Collections.unmodifiableCollection(super.values());
+      return unmodifiableCollection(super.values());
     }
 
     private static final long serialVersionUID = 0;
@@ -692,12 +696,12 @@ public final class Tables {
     @Override
     public SortedMap<R, Map<C, V>> rowMap() {
       Function<Map<C, V>, Map<C, V>> wrapper = unmodifiableWrapper();
-      return Collections.unmodifiableSortedMap(Maps.transformValues(delegate().rowMap(), wrapper));
+      return unmodifiableSortedMap(Maps.transformValues(delegate().rowMap(), wrapper));
     }
 
     @Override
     public SortedSet<R> rowKeySet() {
-      return Collections.unmodifiableSortedSet(delegate().rowKeySet());
+      return unmodifiableSortedSet(delegate().rowKeySet());
     }
 
     private static final long serialVersionUID = 0;
@@ -713,7 +717,7 @@ public final class Tables {
       new Function<Map<Object, Object>, Map<Object, Object>>() {
         @Override
         public Map<Object, Object> apply(Map<Object, Object> input) {
-          return Collections.unmodifiableMap(input);
+          return unmodifiableMap(input);
         }
       };
 
diff --git a/guava/src/com/google/common/collect/TopKSelector.java b/guava/src/com/google/common/collect/TopKSelector.java
index 45f9ca58fb..13298b4705 100644
--- a/guava/src/com/google/common/collect/TopKSelector.java
+++ b/guava/src/com/google/common/collect/TopKSelector.java
@@ -17,14 +17,14 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.math.IntMath;
 import java.math.RoundingMode;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
@@ -119,7 +119,7 @@ final class TopKSelector<T extends @Nullable Object> {
   @CheckForNull private T threshold;
 
   private TopKSelector(Comparator<? super T> comparator, int k) {
-    this.comparator = checkNotNull(comparator, "comparator");
+    this.comparator = requireNonNull(comparator, "comparator");
     this.k = k;
     checkArgument(k >= 0, "k (%s) must be >= 0", k);
     checkArgument(k <= Integer.MAX_VALUE / 2, "k (%s) must be <= Integer.MAX_VALUE / 2", k);
@@ -281,6 +281,6 @@ final class TopKSelector<T extends @Nullable Object> {
       threshold = buffer[k - 1];
     }
     // we have to support null elements, so no ImmutableList for us
-    return Collections.unmodifiableList(Arrays.asList(Arrays.copyOf(buffer, bufferSize)));
+    return unmodifiableList(Arrays.asList(Arrays.copyOf(buffer, bufferSize)));
   }
 }
diff --git a/guava/src/com/google/common/collect/TransformedIterator.java b/guava/src/com/google/common/collect/TransformedIterator.java
index 2456cecde9..f195596027 100644
--- a/guava/src/com/google/common/collect/TransformedIterator.java
+++ b/guava/src/com/google/common/collect/TransformedIterator.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Iterator;
@@ -35,7 +35,7 @@ abstract class TransformedIterator<F extends @Nullable Object, T extends @Nullab
   final Iterator<? extends F> backingIterator;
 
   TransformedIterator(Iterator<? extends F> backingIterator) {
-    this.backingIterator = checkNotNull(backingIterator);
+    this.backingIterator = requireNonNull(backingIterator);
   }
 
   @ParametricNullness
diff --git a/guava/src/com/google/common/collect/TreeBasedTable.java b/guava/src/com/google/common/collect/TreeBasedTable.java
index 9ef210a54a..b1717fdc4a 100644
--- a/guava/src/com/google/common/collect/TreeBasedTable.java
+++ b/guava/src/com/google/common/collect/TreeBasedTable.java
@@ -17,7 +17,6 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -105,8 +104,8 @@ public class TreeBasedTable<R, C, V> extends StandardRowSortedTable<R, C, V> {
    */
   public static <R, C, V> TreeBasedTable<R, C, V> create(
       Comparator<? super R> rowComparator, Comparator<? super C> columnComparator) {
-    checkNotNull(rowComparator);
-    checkNotNull(columnComparator);
+    requireNonNull(rowComparator);
+    requireNonNull(columnComparator);
     return new TreeBasedTable<>(rowComparator, columnComparator);
   }
 
@@ -214,19 +213,19 @@ public class TreeBasedTable<R, C, V> extends StandardRowSortedTable<R, C, V> {
 
     @Override
     public SortedMap<C, V> subMap(C fromKey, C toKey) {
-      checkArgument(rangeContains(checkNotNull(fromKey)) && rangeContains(checkNotNull(toKey)));
+      checkArgument(rangeContains(requireNonNull(fromKey)) && rangeContains(requireNonNull(toKey)));
       return new TreeRow(rowKey, fromKey, toKey);
     }
 
     @Override
     public SortedMap<C, V> headMap(C toKey) {
-      checkArgument(rangeContains(checkNotNull(toKey)));
+      checkArgument(rangeContains(requireNonNull(toKey)));
       return new TreeRow(rowKey, lowerBound, toKey);
     }
 
     @Override
     public SortedMap<C, V> tailMap(C fromKey) {
-      checkArgument(rangeContains(checkNotNull(fromKey)));
+      checkArgument(rangeContains(requireNonNull(fromKey)));
       return new TreeRow(rowKey, fromKey, upperBound);
     }
 
@@ -257,8 +256,8 @@ public class TreeBasedTable<R, C, V> extends StandardRowSortedTable<R, C, V> {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     SortedMap<C, V> computeBackingRowMap() {
       updateWholeRowField();
       SortedMap<C, V> map = wholeRow;
@@ -289,10 +288,10 @@ public class TreeBasedTable<R, C, V> extends StandardRowSortedTable<R, C, V> {
       return rangeContains(key) && super.containsKey(key);
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V put(C key, V value) {
-      checkArgument(rangeContains(checkNotNull(key)));
+      checkArgument(rangeContains(requireNonNull(key)));
       return super.put(key, value);
     }
   }
@@ -323,8 +322,8 @@ public class TreeBasedTable<R, C, V> extends StandardRowSortedTable<R, C, V> {
     return new AbstractIterator<C>() {
       @CheckForNull C lastValue;
 
-      @Override
       @CheckForNull
+      @Override
       protected C computeNext() {
         while (merged.hasNext()) {
           C next = merged.next();
diff --git a/guava/src/com/google/common/collect/TreeMultimap.java b/guava/src/com/google/common/collect/TreeMultimap.java
index b6adb40e8f..a830a84a3d 100644
--- a/guava/src/com/google/common/collect/TreeMultimap.java
+++ b/guava/src/com/google/common/collect/TreeMultimap.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -93,7 +93,7 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
    */
   public static <K extends @Nullable Object, V extends @Nullable Object> TreeMultimap<K, V> create(
       Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {
-    return new TreeMultimap<>(checkNotNull(keyComparator), checkNotNull(valueComparator));
+    return new TreeMultimap<>(requireNonNull(keyComparator), requireNonNull(valueComparator));
   }
 
   /**
@@ -164,8 +164,8 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
   /**
    * @since 14.0 (present with return type {@code SortedSet} since 2.0)
    */
-  @Override
-  @GwtIncompatible // NavigableSet
+  @GwtIncompatible
+  @Override // NavigableSet
   public NavigableSet<V> get(@ParametricNullness K key) {
     return (NavigableSet<V>) super.get(key);
   }
@@ -214,8 +214,8 @@ public class TreeMultimap<K extends @Nullable Object, V extends @Nullable Object
   @SuppressWarnings("unchecked") // reading data stored by writeObject
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
-    keyComparator = checkNotNull((Comparator<? super K>) stream.readObject());
-    valueComparator = checkNotNull((Comparator<? super V>) stream.readObject());
+    keyComparator = requireNonNull((Comparator<? super K>) stream.readObject());
+    valueComparator = requireNonNull((Comparator<? super V>) stream.readObject());
     setMap(new TreeMap<K, Collection<V>>(keyComparator));
     Serialization.populateMultimap(this, stream);
   }
diff --git a/guava/src/com/google/common/collect/TreeMultiset.java b/guava/src/com/google/common/collect/TreeMultiset.java
index 23cbca83e8..b9d98e84e1 100644
--- a/guava/src/com/google/common/collect/TreeMultiset.java
+++ b/guava/src/com/google/common/collect/TreeMultiset.java
@@ -17,7 +17,6 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
@@ -533,7 +532,7 @@ public final class TreeMultiset<E extends @Nullable Object> extends AbstractSort
 
   @Override
   public void forEachEntry(ObjIntConsumer<? super E> action) {
-    checkNotNull(action);
+    requireNonNull(action);
     for (AvlNode<E> node = firstNode();
         node != header && node != null && !range.tooHigh(node.getElement());
         node = node.succ()) {
diff --git a/guava/src/com/google/common/collect/TreeRangeMap.java b/guava/src/com/google/common/collect/TreeRangeMap.java
index 60e7bf3df8..46abbcbc47 100644
--- a/guava/src/com/google/common/collect/TreeRangeMap.java
+++ b/guava/src/com/google/common/collect/TreeRangeMap.java
@@ -17,10 +17,10 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Predicates.compose;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
+import static java.util.Collections.emptyMap;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -30,7 +30,6 @@ import com.google.common.base.Predicate;
 import com.google.common.collect.Maps.IteratorBasedAbstractMap;
 import java.util.AbstractMap;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -103,15 +102,15 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V get(K key) {
     Entry<Range<K>, V> entry = getEntry(key);
     return (entry == null) ? null : entry.getValue();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<Range<K>, V> getEntry(K key) {
     Entry<Cut<K>, RangeMapEntry<K, V>> mapEntry =
         entriesByLowerBound.floorEntry(Cut.belowValue(key));
@@ -125,7 +124,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
   @Override
   public void put(Range<K> range, V value) {
     if (!range.isEmpty()) {
-      checkNotNull(value);
+      requireNonNull(value);
       remove(range);
       entriesByLowerBound.put(range.lowerBound, new RangeMapEntry<K, V>(range, value));
     }
@@ -139,7 +138,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
       return;
     }
 
-    Range<K> coalescedRange = coalescedRange(range, checkNotNull(value));
+    Range<K> coalescedRange = coalescedRange(range, requireNonNull(value));
     put(coalescedRange, value);
   }
 
@@ -152,9 +151,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
 
     Entry<Cut<K>, RangeMapEntry<K, V>> higherEntry =
         entriesByLowerBound.floorEntry(range.upperBound);
-    coalescedRange = coalesce(coalescedRange, value, higherEntry);
-
-    return coalescedRange;
+    return coalesce(coalescedRange, value, higherEntry);
   }
 
   /** Returns the range that spans the given range and entry, if the entry can be coalesced. */
@@ -270,8 +267,8 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
       Range<K> range,
       @CheckForNull V value,
       BiFunction<? super V, ? super @Nullable V, ? extends @Nullable V> remappingFunction) {
-    checkNotNull(range);
-    checkNotNull(remappingFunction);
+    requireNonNull(range);
+    requireNonNull(remappingFunction);
 
     if (range.isEmpty()) {
       return;
@@ -344,8 +341,8 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
       return get(key) != null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(@CheckForNull Object key) {
       if (key instanceof Range) {
         Range<?> range = (Range<?>) key;
@@ -385,14 +382,14 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
   @SuppressWarnings("ConstantCaseForConstants") // This RangeMap is immutable.
   private static final RangeMap<Comparable<?>, Object> EMPTY_SUB_RANGE_MAP =
       new RangeMap<Comparable<?>, Object>() {
-        @Override
         @CheckForNull
+        @Override
         public Object get(Comparable<?> key) {
           return null;
         }
 
-        @Override
         @CheckForNull
+        @Override
         public Entry<Range<Comparable<?>>, Object> getEntry(Comparable<?> key) {
           return null;
         }
@@ -404,24 +401,23 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
 
         @Override
         public void put(Range<Comparable<?>> range, Object value) {
-          checkNotNull(range);
+          requireNonNull(range);
           throw new IllegalArgumentException(
               "Cannot insert range " + range + " into an empty subRangeMap");
         }
 
         @Override
         public void putCoalescing(Range<Comparable<?>> range, Object value) {
-          checkNotNull(range);
+          requireNonNull(range);
           throw new IllegalArgumentException(
               "Cannot insert range " + range + " into an empty subRangeMap");
         }
 
         @Override
         public void putAll(RangeMap<Comparable<?>, Object> rangeMap) {
-          if (!rangeMap.asMapOfRanges().isEmpty()) {
-            throw new IllegalArgumentException(
-                "Cannot putAll(nonEmptyRangeMap) into an empty subRangeMap");
-          }
+          checkArgument(
+              rangeMap.asMapOfRanges().isEmpty(),
+              "Cannot putAll(nonEmptyRangeMap) into an empty subRangeMap");
         }
 
         @Override
@@ -429,7 +425,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
 
         @Override
         public void remove(Range<Comparable<?>> range) {
-          checkNotNull(range);
+          requireNonNull(range);
         }
 
         @Override
@@ -438,24 +434,24 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
             @CheckForNull Object value,
             BiFunction<? super Object, ? super @Nullable Object, ? extends @Nullable Object>
                 remappingFunction) {
-          checkNotNull(range);
+          requireNonNull(range);
           throw new IllegalArgumentException(
               "Cannot merge range " + range + " into an empty subRangeMap");
         }
 
         @Override
         public Map<Range<Comparable<?>>, Object> asMapOfRanges() {
-          return Collections.emptyMap();
+          return emptyMap();
         }
 
         @Override
         public Map<Range<Comparable<?>>, Object> asDescendingMapOfRanges() {
-          return Collections.emptyMap();
+          return emptyMap();
         }
 
         @Override
         public RangeMap<Comparable<?>, Object> subRangeMap(Range<Comparable<?>> range) {
-          checkNotNull(range);
+          requireNonNull(range);
           return this;
         }
       };
@@ -468,14 +464,14 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
       this.subRange = subRange;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V get(K key) {
       return subRange.contains(key) ? TreeRangeMap.this.get(key) : null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Entry<Range<K>, V> getEntry(K key) {
       if (subRange.contains(key)) {
         Entry<Range<K>, V> entry = TreeRangeMap.this.getEntry(key);
@@ -528,7 +524,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
         return;
       }
 
-      Range<K> coalescedRange = coalescedRange(range, checkNotNull(value));
+      Range<K> coalescedRange = coalescedRange(range, requireNonNull(value));
       // only coalesce ranges within the subRange
       put(coalescedRange.intersection(subRange), value);
     }
@@ -603,8 +599,8 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
                   .iterator();
           return new AbstractIterator<Entry<Range<K>, V>>() {
 
-            @Override
             @CheckForNull
+            @Override
             protected Entry<Range<K>, V> computeNext() {
               if (backingItr.hasNext()) {
                 RangeMapEntry<K, V> entry = backingItr.next();
@@ -646,8 +642,8 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
         return get(key) != null;
       }
 
-      @Override
       @CheckForNull
+      @Override
       public V get(@CheckForNull Object key) {
         try {
           if (key instanceof Range) {
@@ -680,8 +676,8 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
         return null;
       }
 
-      @Override
       @CheckForNull
+      @Override
       public V remove(@CheckForNull Object key) {
         V value = get(key);
         if (value != null) {
@@ -752,7 +748,7 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
 
           @Override
           public boolean isEmpty() {
-            return !iterator().hasNext();
+            return this.isEmpty();
           }
         };
       }
@@ -768,8 +764,8 @@ public final class TreeRangeMap<K extends Comparable, V> implements RangeMap<K,
             entriesByLowerBound.tailMap(cutToStart, true).values().iterator();
         return new AbstractIterator<Entry<Range<K>, V>>() {
 
-          @Override
           @CheckForNull
+          @Override
           protected Entry<Range<K>, V> computeNext() {
             while (backingItr.hasNext()) {
               RangeMapEntry<K, V> entry = backingItr.next();
diff --git a/guava/src/com/google/common/collect/TreeRangeSet.java b/guava/src/com/google/common/collect/TreeRangeSet.java
index 7ba71139eb..aa008f44d9 100644
--- a/guava/src/com/google/common/collect/TreeRangeSet.java
+++ b/guava/src/com/google/common/collect/TreeRangeSet.java
@@ -15,7 +15,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -118,10 +118,10 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Range<C> rangeContaining(C value) {
-    checkNotNull(value);
+    requireNonNull(value);
     Entry<Cut<C>, Range<C>> floorEntry = rangesByLowerBound.floorEntry(Cut.belowValue(value));
     if (floorEntry != null && floorEntry.getValue().contains(value)) {
       return floorEntry.getValue();
@@ -133,7 +133,7 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
 
   @Override
   public boolean intersects(Range<C> range) {
-    checkNotNull(range);
+    requireNonNull(range);
     Entry<Cut<C>, Range<C>> ceilingEntry = rangesByLowerBound.ceilingEntry(range.lowerBound);
     if (ceilingEntry != null
         && ceilingEntry.getValue().isConnected(range)
@@ -148,14 +148,14 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
 
   @Override
   public boolean encloses(Range<C> range) {
-    checkNotNull(range);
+    requireNonNull(range);
     Entry<Cut<C>, Range<C>> floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
     return floorEntry != null && floorEntry.getValue().encloses(range);
   }
 
   @CheckForNull
   private Range<C> rangeEnclosing(Range<C> range) {
-    checkNotNull(range);
+    requireNonNull(range);
     Entry<Cut<C>, Range<C>> floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
     return (floorEntry != null && floorEntry.getValue().encloses(range))
         ? floorEntry.getValue()
@@ -178,7 +178,7 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
 
   @Override
   public void add(Range<C> rangeToAdd) {
-    checkNotNull(rangeToAdd);
+    requireNonNull(rangeToAdd);
 
     if (rangeToAdd.isEmpty()) {
       return;
@@ -225,7 +225,7 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
 
   @Override
   public void remove(Range<C> rangeToRemove) {
-    checkNotNull(rangeToRemove);
+    requireNonNull(rangeToRemove);
 
     if (rangeToRemove.isEmpty()) {
       return;
@@ -341,8 +341,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
       return get(key) != null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Range<C> get(@CheckForNull Object key) {
       if (key instanceof Cut) {
         try {
@@ -387,8 +387,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
         }
       }
       return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
-        @Override
         @CheckForNull
+        @Override
         protected Entry<Cut<C>, Range<C>> computeNext() {
           if (!backingItr.hasNext()) {
             return endOfData();
@@ -421,8 +421,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
         backingItr.next();
       }
       return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
-        @Override
         @CheckForNull
+        @Override
         protected Entry<Cut<C>, Range<C>> computeNext() {
           if (!backingItr.hasNext()) {
             return endOfData();
@@ -542,8 +542,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
       return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
         Cut<C> nextComplementRangeLowerBound = firstComplementRangeLowerBound;
 
-        @Override
         @CheckForNull
+        @Override
         protected Entry<Cut<C>, Range<C>> computeNext() {
           if (complementLowerBoundWindow.upperBound.isLessThan(nextComplementRangeLowerBound)
               || nextComplementRangeLowerBound == Cut.<C>aboveAll()) {
@@ -603,8 +603,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
       return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
         Cut<C> nextComplementRangeUpperBound = firstComplementRangeUpperBound;
 
-        @Override
         @CheckForNull
+        @Override
         protected Entry<Cut<C>, Range<C>> computeNext() {
           if (nextComplementRangeUpperBound == Cut.<C>belowAll()) {
             return endOfData();
@@ -631,8 +631,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
       return Iterators.size(entryIterator());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Range<C> get(@CheckForNull Object key) {
       if (key instanceof Cut) {
         try {
@@ -703,9 +703,9 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
         Range<Cut<C>> lowerBoundWindow,
         Range<C> restriction,
         NavigableMap<Cut<C>, Range<C>> rangesByLowerBound) {
-      this.lowerBoundWindow = checkNotNull(lowerBoundWindow);
-      this.restriction = checkNotNull(restriction);
-      this.rangesByLowerBound = checkNotNull(rangesByLowerBound);
+      this.lowerBoundWindow = requireNonNull(lowerBoundWindow);
+      this.restriction = requireNonNull(restriction);
+      this.rangesByLowerBound = requireNonNull(rangesByLowerBound);
       this.rangesByUpperBound = new RangesByUpperBound<>(rangesByLowerBound);
     }
 
@@ -749,8 +749,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
       return get(key) != null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Range<C> get(@CheckForNull Object key) {
       if (key instanceof Cut) {
         try {
@@ -805,8 +805,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
           Ordering.natural()
               .min(lowerBoundWindow.upperBound, Cut.belowValue(restriction.upperBound));
       return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
-        @Override
         @CheckForNull
+        @Override
         protected Entry<Cut<C>, Range<C>> computeNext() {
           if (!completeRangeItr.hasNext()) {
             return endOfData();
@@ -839,8 +839,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
               .values()
               .iterator();
       return new AbstractIterator<Entry<Cut<C>, Range<C>>>() {
-        @Override
         @CheckForNull
+        @Override
         protected Entry<Cut<C>, Range<C>> computeNext() {
           if (!completeRangeItr.hasNext()) {
             return endOfData();
@@ -889,8 +889,8 @@ public class TreeRangeSet<C extends Comparable<?>> extends AbstractRangeSet<C>
       return false;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Range<C> rangeContaining(C value) {
       if (!restriction.contains(value)) {
         return null;
diff --git a/guava/src/com/google/common/collect/TreeTraverser.java b/guava/src/com/google/common/collect/TreeTraverser.java
index b5d2a4293f..178291fb3a 100644
--- a/guava/src/com/google/common/collect/TreeTraverser.java
+++ b/guava/src/com/google/common/collect/TreeTraverser.java
@@ -16,7 +16,7 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -91,7 +91,7 @@ public abstract class TreeTraverser<T> {
   @Deprecated
   public static <T> TreeTraverser<T> using(
       final Function<T, ? extends Iterable<T>> nodeToChildrenFunction) {
-    checkNotNull(nodeToChildrenFunction);
+    requireNonNull(nodeToChildrenFunction);
     return new TreeTraverser<T>() {
       @Override
       public Iterable<T> children(T root) {
@@ -115,7 +115,7 @@ public abstract class TreeTraverser<T> {
    */
   @Deprecated
   public final FluentIterable<T> preOrderTraversal(final T root) {
-    checkNotNull(root);
+    requireNonNull(root);
     return new FluentIterable<T>() {
       @Override
       public UnmodifiableIterator<T> iterator() {
@@ -124,7 +124,7 @@ public abstract class TreeTraverser<T> {
 
       @Override
       public void forEach(Consumer<? super T> action) {
-        checkNotNull(action);
+        requireNonNull(action);
         new Consumer<T>() {
           @Override
           public void accept(T t) {
@@ -145,7 +145,7 @@ public abstract class TreeTraverser<T> {
 
     PreOrderIterator(T root) {
       this.stack = new ArrayDeque<>();
-      stack.addLast(Iterators.singletonIterator(checkNotNull(root)));
+      stack.addLast(Iterators.singletonIterator(requireNonNull(root)));
     }
 
     @Override
@@ -156,7 +156,7 @@ public abstract class TreeTraverser<T> {
     @Override
     public T next() {
       Iterator<T> itr = stack.getLast(); // throws NSEE if empty
-      T result = checkNotNull(itr.next());
+      T result = requireNonNull(itr.next());
       if (!itr.hasNext()) {
         stack.removeLast();
       }
@@ -180,7 +180,7 @@ public abstract class TreeTraverser<T> {
    */
   @Deprecated
   public final FluentIterable<T> postOrderTraversal(final T root) {
-    checkNotNull(root);
+    requireNonNull(root);
     return new FluentIterable<T>() {
       @Override
       public UnmodifiableIterator<T> iterator() {
@@ -189,7 +189,7 @@ public abstract class TreeTraverser<T> {
 
       @Override
       public void forEach(Consumer<? super T> action) {
-        checkNotNull(action);
+        requireNonNull(action);
         new Consumer<T>() {
           @Override
           public void accept(T t) {
@@ -210,8 +210,8 @@ public abstract class TreeTraverser<T> {
     final Iterator<T> childIterator;
 
     PostOrderNode(T root, Iterator<T> childIterator) {
-      this.root = checkNotNull(root);
-      this.childIterator = checkNotNull(childIterator);
+      this.root = requireNonNull(root);
+      this.childIterator = requireNonNull(childIterator);
     }
   }
 
@@ -223,8 +223,8 @@ public abstract class TreeTraverser<T> {
       stack.addLast(expand(root));
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected T computeNext() {
       while (!stack.isEmpty()) {
         PostOrderNode<T> top = stack.getLast();
@@ -256,7 +256,7 @@ public abstract class TreeTraverser<T> {
    */
   @Deprecated
   public final FluentIterable<T> breadthFirstTraversal(final T root) {
-    checkNotNull(root);
+    requireNonNull(root);
     return new FluentIterable<T>() {
       @Override
       public UnmodifiableIterator<T> iterator() {
diff --git a/guava/src/com/google/common/collect/UnmodifiableIterator.java b/guava/src/com/google/common/collect/UnmodifiableIterator.java
index 03e52aa203..eda2d8a082 100644
--- a/guava/src/com/google/common/collect/UnmodifiableIterator.java
+++ b/guava/src/com/google/common/collect/UnmodifiableIterator.java
@@ -44,8 +44,8 @@ public abstract class UnmodifiableIterator<E extends @Nullable Object> implement
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void remove() {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/UnmodifiableListIterator.java b/guava/src/com/google/common/collect/UnmodifiableListIterator.java
index f3d3b921b7..a4e2a2b2fc 100644
--- a/guava/src/com/google/common/collect/UnmodifiableListIterator.java
+++ b/guava/src/com/google/common/collect/UnmodifiableListIterator.java
@@ -41,8 +41,8 @@ public abstract class UnmodifiableListIterator<E extends @Nullable Object>
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void add(@ParametricNullness E e) {
     throw new UnsupportedOperationException();
   }
@@ -54,8 +54,8 @@ public abstract class UnmodifiableListIterator<E extends @Nullable Object>
    * @deprecated Unsupported operation.
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public final void set(@ParametricNullness E e) {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java b/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java
index 31f3c71977..3553cd2f84 100644
--- a/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java
+++ b/guava/src/com/google/common/collect/UnmodifiableSortedMultiset.java
@@ -71,26 +71,26 @@ final class UnmodifiableSortedMultiset<E extends @Nullable Object> extends Unmod
     return result;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> firstEntry() {
     return delegate().firstEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> lastEntry() {
     return delegate().lastEntry();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollFirstEntry() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public Entry<E> pollLastEntry() {
     throw new UnsupportedOperationException();
   }
diff --git a/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java b/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java
index dbe6e35680..428d1b46f5 100644
--- a/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java
+++ b/guava/src/com/google/common/escape/ArrayBasedCharEscaper.java
@@ -14,7 +14,7 @@
 
 package com.google.common.escape;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
@@ -84,7 +84,7 @@ public abstract class ArrayBasedCharEscaper extends CharEscaper {
    */
   protected ArrayBasedCharEscaper(ArrayBasedEscaperMap escaperMap, char safeMin, char safeMax) {
 
-    checkNotNull(escaperMap); // GWT specific check (do not optimize)
+    requireNonNull(escaperMap); // GWT specific check (do not optimize)
     this.replacements = escaperMap.getReplacementArray();
     this.replacementsLength = replacements.length;
     if (safeMax < safeMin) {
@@ -103,7 +103,7 @@ public abstract class ArrayBasedCharEscaper extends CharEscaper {
    */
   @Override
   public final String escape(String s) {
-    checkNotNull(s); // GWT specific check (do not optimize).
+    requireNonNull(s); // GWT specific check (do not optimize).
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       if ((c < replacementsLength && replacements[c] != null) || c > safeMax || c < safeMin) {
@@ -120,8 +120,8 @@ public abstract class ArrayBasedCharEscaper extends CharEscaper {
    *
    * @return the replacement characters, or {@code null} if no escaping was required
    */
-  @Override
   @CheckForNull
+  @Override
   protected final char[] escape(char c) {
     if (c < replacementsLength) {
       char[] chars = replacements[c];
diff --git a/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java b/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java
index efc77d058b..a162759677 100644
--- a/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java
+++ b/guava/src/com/google/common/escape/ArrayBasedEscaperMap.java
@@ -14,7 +14,7 @@
 
 package com.google.common.escape;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.VisibleForTesting;
@@ -66,7 +66,7 @@ public final class ArrayBasedEscaperMap {
   // original character value.
   @VisibleForTesting
   static char[][] createReplacementArray(Map<Character, String> map) {
-    checkNotNull(map); // GWT specific check (do not optimize)
+    requireNonNull(map); // GWT specific check (do not optimize)
     if (map.isEmpty()) {
       return EMPTY_REPLACEMENT_ARRAY;
     }
diff --git a/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java b/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java
index 355faaa10d..8cd359f92f 100644
--- a/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java
+++ b/guava/src/com/google/common/escape/ArrayBasedUnicodeEscaper.java
@@ -14,7 +14,7 @@
 
 package com.google.common.escape;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
@@ -97,7 +97,7 @@ public abstract class ArrayBasedUnicodeEscaper extends UnicodeEscaper {
       int safeMin,
       int safeMax,
       @Nullable String unsafeReplacement) {
-    checkNotNull(escaperMap); // GWT specific check (do not optimize)
+    requireNonNull(escaperMap); // GWT specific check (do not optimize)
     this.replacements = escaperMap.getReplacementArray();
     this.replacementsLength = replacements.length;
     if (safeMax < safeMin) {
@@ -141,7 +141,7 @@ public abstract class ArrayBasedUnicodeEscaper extends UnicodeEscaper {
    */
   @Override
   public final String escape(String s) {
-    checkNotNull(s); // GWT specific check (do not optimize)
+    requireNonNull(s); // GWT specific check (do not optimize)
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       if ((c < replacementsLength && replacements[c] != null)
@@ -160,8 +160,8 @@ public abstract class ArrayBasedUnicodeEscaper extends UnicodeEscaper {
    *
    * @return the replacement characters, or {@code null} if no escaping was required
    */
-  @Override
   @CheckForNull
+  @Override
   protected final char[] escape(int cp) {
     if (cp < replacementsLength) {
       char[] chars = replacements[cp];
diff --git a/guava/src/com/google/common/escape/CharEscaper.java b/guava/src/com/google/common/escape/CharEscaper.java
index 136240ec63..b9f8bc69c5 100644
--- a/guava/src/com/google/common/escape/CharEscaper.java
+++ b/guava/src/com/google/common/escape/CharEscaper.java
@@ -14,7 +14,7 @@
 
 package com.google.common.escape;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
@@ -54,7 +54,7 @@ public abstract class CharEscaper extends Escaper {
    */
   @Override
   public String escape(String string) {
-    checkNotNull(string); // GWT specific check (do not optimize)
+    requireNonNull(string); // GWT specific check (do not optimize)
     // Inlineable fast-path loop which hands off to escapeSlow() only if needed
     int length = string.length();
     for (int index = 0; index < length; index++) {
diff --git a/guava/src/com/google/common/escape/CharEscaperBuilder.java b/guava/src/com/google/common/escape/CharEscaperBuilder.java
index 97528cb569..3509ed3c43 100644
--- a/guava/src/com/google/common/escape/CharEscaperBuilder.java
+++ b/guava/src/com/google/common/escape/CharEscaperBuilder.java
@@ -14,7 +14,7 @@
 
 package com.google.common.escape;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -65,8 +65,8 @@ public final class CharEscaperBuilder {
       return s;
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected char[] escape(char c) {
       return c < replaceLength ? replacements[c] : null;
     }
@@ -86,7 +86,7 @@ public final class CharEscaperBuilder {
   /** Add a new mapping from an index to an object to the escaping. */
   @CanIgnoreReturnValue
   public CharEscaperBuilder addEscape(char c, String r) {
-    map.put(c, checkNotNull(r));
+    map.put(c, requireNonNull(r));
     if (c > max) {
       max = c;
     }
@@ -96,7 +96,7 @@ public final class CharEscaperBuilder {
   /** Add multiple mappings at once for a particular index. */
   @CanIgnoreReturnValue
   public CharEscaperBuilder addEscapes(char[] cs, String r) {
-    checkNotNull(r);
+    requireNonNull(r);
     for (char c : cs) {
       addEscape(c, r);
     }
diff --git a/guava/src/com/google/common/escape/Escapers.java b/guava/src/com/google/common/escape/Escapers.java
index acfb82ce29..c13b4d93f9 100644
--- a/guava/src/com/google/common/escape/Escapers.java
+++ b/guava/src/com/google/common/escape/Escapers.java
@@ -14,7 +14,7 @@
 
 package com.google.common.escape;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -48,11 +48,11 @@ public final class Escapers {
       new CharEscaper() {
         @Override
         public String escape(String string) {
-          return checkNotNull(string);
+          return requireNonNull(string);
         }
 
-        @Override
         @CheckForNull
+        @Override
         protected char[] escape(char c) {
           // TODO: Fix tests not to call this directly and make it throw an error.
           return null;
@@ -142,7 +142,7 @@ public final class Escapers {
      */
     @CanIgnoreReturnValue
     public Builder addEscape(char c, String replacement) {
-      checkNotNull(replacement);
+      requireNonNull(replacement);
       // This can replace an existing character (the builder is re-usable).
       replacementMap.put(c, replacement);
       return this;
@@ -155,8 +155,8 @@ public final class Escapers {
         private final char[] replacementChars =
             unsafeReplacement != null ? unsafeReplacement.toCharArray() : null;
 
-        @Override
         @CheckForNull
+        @Override
         protected char[] escapeUnsafe(char c) {
           return replacementChars;
         }
@@ -179,7 +179,7 @@ public final class Escapers {
    * @throws IllegalArgumentException if escaper is not a UnicodeEscaper or a CharEscaper
    */
   static UnicodeEscaper asUnicodeEscaper(Escaper escaper) {
-    checkNotNull(escaper);
+    requireNonNull(escaper);
     if (escaper instanceof UnicodeEscaper) {
       return (UnicodeEscaper) escaper;
     } else if (escaper instanceof CharEscaper) {
@@ -227,8 +227,8 @@ public final class Escapers {
   /** Private helper to wrap a CharEscaper as a UnicodeEscaper. */
   private static UnicodeEscaper wrap(CharEscaper escaper) {
     return new UnicodeEscaper() {
-      @Override
       @CheckForNull
+      @Override
       protected char[] escape(int cp) {
         // If a code point maps to a single character, just escape that.
         if (cp < Character.MIN_SUPPLEMENTARY_CODE_POINT) {
diff --git a/guava/src/com/google/common/escape/UnicodeEscaper.java b/guava/src/com/google/common/escape/UnicodeEscaper.java
index 280915c755..f1aa9ff0d8 100644
--- a/guava/src/com/google/common/escape/UnicodeEscaper.java
+++ b/guava/src/com/google/common/escape/UnicodeEscaper.java
@@ -14,7 +14,8 @@
 
 package com.google.common.escape;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import javax.annotation.CheckForNull;
@@ -100,7 +101,7 @@ public abstract class UnicodeEscaper extends Escaper {
    */
   @Override
   public String escape(String string) {
-    checkNotNull(string);
+    requireNonNull(string);
     int end = string.length();
     int index = nextEscapeIndex(string, 0, end);
     return index == end ? string : escapeSlow(string, index);
@@ -165,9 +166,7 @@ public abstract class UnicodeEscaper extends Escaper {
 
     while (index < end) {
       int cp = codePointAt(s, index, end);
-      if (cp < 0) {
-        throw new IllegalArgumentException("Trailing high surrogate at end of input");
-      }
+      checkArgument(cp >= 0, "Trailing high surrogate at end of input");
       // It is possible for this to return null because nextEscapeIndex() may
       // (for performance reasons) yield some false positives but it must never
       // give false negatives.
@@ -244,7 +243,7 @@ public abstract class UnicodeEscaper extends Escaper {
    *     surrogate character at the end of the sequence
    */
   protected static int codePointAt(CharSequence seq, int index, int end) {
-    checkNotNull(seq);
+    requireNonNull(seq);
     if (index < end) {
       char c1 = seq.charAt(index++);
       if (c1 < Character.MIN_HIGH_SURROGATE || c1 > Character.MAX_LOW_SURROGATE) {
diff --git a/guava/src/com/google/common/eventbus/DeadEvent.java b/guava/src/com/google/common/eventbus/DeadEvent.java
index 2cdb23f712..bfeb7d1866 100644
--- a/guava/src/com/google/common/eventbus/DeadEvent.java
+++ b/guava/src/com/google/common/eventbus/DeadEvent.java
@@ -14,7 +14,7 @@
 
 package com.google.common.eventbus;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.base.MoreObjects;
 
@@ -40,8 +40,8 @@ public class DeadEvent {
    * @param event the event that could not be delivered.
    */
   public DeadEvent(Object source, Object event) {
-    this.source = checkNotNull(source);
-    this.event = checkNotNull(event);
+    this.source = requireNonNull(source);
+    this.event = requireNonNull(event);
   }
 
   /**
diff --git a/guava/src/com/google/common/eventbus/Dispatcher.java b/guava/src/com/google/common/eventbus/Dispatcher.java
index ff1ae2a197..ebbacd4077 100644
--- a/guava/src/com/google/common/eventbus/Dispatcher.java
+++ b/guava/src/com/google/common/eventbus/Dispatcher.java
@@ -14,7 +14,7 @@
 
 package com.google.common.eventbus;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.Queues;
 import java.util.Iterator;
@@ -95,8 +95,8 @@ abstract class Dispatcher {
 
     @Override
     void dispatch(Object event, Iterator<Subscriber> subscribers) {
-      checkNotNull(event);
-      checkNotNull(subscribers);
+      requireNonNull(event);
+      requireNonNull(subscribers);
       Queue<Event> queueForThread = queue.get();
       queueForThread.offer(new Event(event, subscribers));
 
@@ -154,7 +154,7 @@ abstract class Dispatcher {
 
     @Override
     void dispatch(Object event, Iterator<Subscriber> subscribers) {
-      checkNotNull(event);
+      requireNonNull(event);
       while (subscribers.hasNext()) {
         queue.add(new EventWithSubscriber(event, subscribers.next()));
       }
@@ -182,7 +182,7 @@ abstract class Dispatcher {
 
     @Override
     void dispatch(Object event, Iterator<Subscriber> subscribers) {
-      checkNotNull(event);
+      requireNonNull(event);
       while (subscribers.hasNext()) {
         subscribers.next().dispatchEvent(event);
       }
diff --git a/guava/src/com/google/common/eventbus/EventBus.java b/guava/src/com/google/common/eventbus/EventBus.java
index 4afc197756..e601b4cd3d 100644
--- a/guava/src/com/google/common/eventbus/EventBus.java
+++ b/guava/src/com/google/common/eventbus/EventBus.java
@@ -14,7 +14,7 @@
 
 package com.google.common.eventbus;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.base.MoreObjects;
 import com.google.common.util.concurrent.MoreExecutors;
@@ -197,10 +197,10 @@ public class EventBus {
       Executor executor,
       Dispatcher dispatcher,
       SubscriberExceptionHandler exceptionHandler) {
-    this.identifier = checkNotNull(identifier);
-    this.executor = checkNotNull(executor);
-    this.dispatcher = checkNotNull(dispatcher);
-    this.exceptionHandler = checkNotNull(exceptionHandler);
+    this.identifier = requireNonNull(identifier);
+    this.executor = requireNonNull(executor);
+    this.dispatcher = requireNonNull(dispatcher);
+    this.exceptionHandler = requireNonNull(exceptionHandler);
   }
 
   /**
@@ -219,8 +219,8 @@ public class EventBus {
 
   /** Handles the given exception thrown by a subscriber with the given context. */
   void handleSubscriberException(Throwable e, SubscriberExceptionContext context) {
-    checkNotNull(e);
-    checkNotNull(context);
+    requireNonNull(e);
+    requireNonNull(context);
     try {
       exceptionHandler.handleException(e, context);
     } catch (Throwable e2) {
diff --git a/guava/src/com/google/common/eventbus/Subscriber.java b/guava/src/com/google/common/eventbus/Subscriber.java
index 71ee197c9b..cc12268a8f 100644
--- a/guava/src/com/google/common/eventbus/Subscriber.java
+++ b/guava/src/com/google/common/eventbus/Subscriber.java
@@ -14,7 +14,7 @@
 
 package com.google.common.eventbus;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.j2objc.annotations.Weak;
@@ -56,7 +56,7 @@ class Subscriber {
 
   private Subscriber(EventBus bus, Object target, Method method) {
     this.bus = bus;
-    this.target = checkNotNull(target);
+    this.target = requireNonNull(target);
     this.method = method;
     method.setAccessible(true);
 
@@ -82,7 +82,7 @@ class Subscriber {
   @VisibleForTesting
   void invokeSubscriberMethod(Object event) throws InvocationTargetException {
     try {
-      method.invoke(target, checkNotNull(event));
+      method.invoke(target, requireNonNull(event));
     } catch (IllegalArgumentException e) {
       throw new Error("Method rejected target/argument: " + event, e);
     } catch (IllegalAccessException e) {
diff --git a/guava/src/com/google/common/eventbus/SubscriberExceptionContext.java b/guava/src/com/google/common/eventbus/SubscriberExceptionContext.java
index 5a5e879d78..270d4ce95b 100644
--- a/guava/src/com/google/common/eventbus/SubscriberExceptionContext.java
+++ b/guava/src/com/google/common/eventbus/SubscriberExceptionContext.java
@@ -14,7 +14,7 @@
 
 package com.google.common.eventbus;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import java.lang.reflect.Method;
 
@@ -39,10 +39,10 @@ public class SubscriberExceptionContext {
    */
   SubscriberExceptionContext(
       EventBus eventBus, Object event, Object subscriber, Method subscriberMethod) {
-    this.eventBus = checkNotNull(eventBus);
-    this.event = checkNotNull(event);
-    this.subscriber = checkNotNull(subscriber);
-    this.subscriberMethod = checkNotNull(subscriberMethod);
+    this.eventBus = requireNonNull(eventBus);
+    this.event = requireNonNull(event);
+    this.subscriber = requireNonNull(subscriber);
+    this.subscriberMethod = requireNonNull(subscriberMethod);
   }
 
   /**
diff --git a/guava/src/com/google/common/eventbus/SubscriberRegistry.java b/guava/src/com/google/common/eventbus/SubscriberRegistry.java
index 46e982016c..17bbeb3ebe 100644
--- a/guava/src/com/google/common/eventbus/SubscriberRegistry.java
+++ b/guava/src/com/google/common/eventbus/SubscriberRegistry.java
@@ -15,8 +15,8 @@
 package com.google.common.eventbus;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
@@ -69,7 +69,7 @@ final class SubscriberRegistry {
   @Weak private final EventBus bus;
 
   SubscriberRegistry(EventBus bus) {
-    this.bus = checkNotNull(bus);
+    this.bus = requireNonNull(bus);
   }
 
   /** Registers all subscriber methods on the given listener object. */
@@ -222,8 +222,8 @@ final class SubscriberRegistry {
           .build(
               new CacheLoader<Class<?>, ImmutableSet<Class<?>>>() {
                 // <Class<?>> is actually needed to compile
-                @SuppressWarnings("RedundantTypeArguments")
                 @Override
+                @SuppressWarnings("RedundantTypeArguments")
                 public ImmutableSet<Class<?>> load(Class<?> concreteClass) {
                   return ImmutableSet.<Class<?>>copyOf(
                       TypeToken.of(concreteClass).getTypes().rawTypes());
diff --git a/guava/src/com/google/common/graph/AbstractBaseGraph.java b/guava/src/com/google/common/graph/AbstractBaseGraph.java
index 797468b7aa..5943a326c7 100644
--- a/guava/src/com/google/common/graph/AbstractBaseGraph.java
+++ b/guava/src/com/google/common/graph/AbstractBaseGraph.java
@@ -17,9 +17,9 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterators;
@@ -83,8 +83,8 @@ abstract class AbstractBaseGraph<N> implements BaseGraph<N> {
       // Mostly safe: We check contains(u) before calling successors(u), so we perform unsafe
       // operations only in weird cases like checking for an EndpointPair<ArrayList> in a
       // Graph<LinkedList>.
-      @SuppressWarnings("unchecked")
       @Override
+      @SuppressWarnings("unchecked")
       public boolean contains(@CheckForNull Object obj) {
         if (!(obj instanceof EndpointPair)) {
           return false;
@@ -104,7 +104,7 @@ abstract class AbstractBaseGraph<N> implements BaseGraph<N> {
 
   @Override
   public Set<EndpointPair<N>> incidentEdges(N node) {
-    checkNotNull(node);
+    requireNonNull(node);
     checkArgument(nodes().contains(node), "Node %s is not an element of this graph.", node);
     return new IncidentEdgeSet<N>(this, node) {
       @Override
@@ -152,14 +152,14 @@ abstract class AbstractBaseGraph<N> implements BaseGraph<N> {
 
   @Override
   public boolean hasEdgeConnecting(N nodeU, N nodeV) {
-    checkNotNull(nodeU);
-    checkNotNull(nodeV);
+    requireNonNull(nodeU);
+    requireNonNull(nodeV);
     return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);
   }
 
   @Override
   public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
-    checkNotNull(endpoints);
+    requireNonNull(endpoints);
     if (!isOrderingCompatible(endpoints)) {
       return false;
     }
@@ -173,7 +173,7 @@ abstract class AbstractBaseGraph<N> implements BaseGraph<N> {
    * with the directionality of this graph.
    */
   protected final void validateEndpoints(EndpointPair<?> endpoints) {
-    checkNotNull(endpoints);
+    requireNonNull(endpoints);
     checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);
   }
 
diff --git a/guava/src/com/google/common/graph/AbstractDirectedNetworkConnections.java b/guava/src/com/google/common/graph/AbstractDirectedNetworkConnections.java
index ac452d4d61..237f40a5db 100644
--- a/guava/src/com/google/common/graph/AbstractDirectedNetworkConnections.java
+++ b/guava/src/com/google/common/graph/AbstractDirectedNetworkConnections.java
@@ -16,10 +16,10 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.Graphs.checkNonNegative;
 import static com.google.common.graph.Graphs.checkPositive;
+import static java.util.Collections.unmodifiableSet;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.Iterables;
@@ -28,7 +28,6 @@ import com.google.common.collect.Sets;
 import com.google.common.collect.UnmodifiableIterator;
 import com.google.common.math.IntMath;
 import java.util.AbstractSet;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.CheckForNull;
@@ -51,8 +50,8 @@ abstract class AbstractDirectedNetworkConnections<N, E> implements NetworkConnec
   private int selfLoopCount;
 
   AbstractDirectedNetworkConnections(Map<E, N> inEdgeMap, Map<E, N> outEdgeMap, int selfLoopCount) {
-    this.inEdgeMap = checkNotNull(inEdgeMap);
-    this.outEdgeMap = checkNotNull(outEdgeMap);
+    this.inEdgeMap = requireNonNull(inEdgeMap);
+    this.outEdgeMap = requireNonNull(outEdgeMap);
     this.selfLoopCount = checkNonNegative(selfLoopCount);
     checkState(selfLoopCount <= inEdgeMap.size() && selfLoopCount <= outEdgeMap.size());
   }
@@ -88,12 +87,12 @@ abstract class AbstractDirectedNetworkConnections<N, E> implements NetworkConnec
 
   @Override
   public Set<E> inEdges() {
-    return Collections.unmodifiableSet(inEdgeMap.keySet());
+    return unmodifiableSet(inEdgeMap.keySet());
   }
 
   @Override
   public Set<E> outEdges() {
-    return Collections.unmodifiableSet(outEdgeMap.keySet());
+    return unmodifiableSet(outEdgeMap.keySet());
   }
 
   @Override
@@ -123,8 +122,8 @@ abstract class AbstractDirectedNetworkConnections<N, E> implements NetworkConnec
 
   @Override
   public void addInEdge(E edge, N node, boolean isSelfLoop) {
-    checkNotNull(edge);
-    checkNotNull(node);
+    requireNonNull(edge);
+    requireNonNull(node);
 
     if (isSelfLoop) {
       checkPositive(++selfLoopCount);
@@ -135,8 +134,8 @@ abstract class AbstractDirectedNetworkConnections<N, E> implements NetworkConnec
 
   @Override
   public void addOutEdge(E edge, N node) {
-    checkNotNull(edge);
-    checkNotNull(node);
+    requireNonNull(edge);
+    requireNonNull(node);
 
     N previousNode = outEdgeMap.put(edge, node);
     checkState(previousNode == null);
diff --git a/guava/src/com/google/common/graph/AbstractNetwork.java b/guava/src/com/google/common/graph/AbstractNetwork.java
index d6bf4c36c6..24971d79f8 100644
--- a/guava/src/com/google/common/graph/AbstractNetwork.java
+++ b/guava/src/com/google/common/graph/AbstractNetwork.java
@@ -17,10 +17,10 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
 import static com.google.common.graph.GraphConstants.MULTIPLE_EDGES_CONNECTING;
 import static java.util.Collections.unmodifiableSet;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
@@ -89,8 +89,8 @@ public abstract class AbstractNetwork<N, E> implements Network<N, E> {
           // Mostly safe: We check contains(u) before calling successors(u), so we perform unsafe
           // operations only in weird cases like checking for an EndpointPair<ArrayList> in a
           // Network<LinkedList>.
-          @SuppressWarnings("unchecked")
           @Override
+          @SuppressWarnings("unchecked")
           public boolean contains(@CheckForNull Object obj) {
             if (!(obj instanceof EndpointPair)) {
               return false;
@@ -206,8 +206,8 @@ public abstract class AbstractNetwork<N, E> implements Network<N, E> {
     return edgeConnecting(endpoints.nodeU(), endpoints.nodeV());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E edgeConnectingOrNull(N nodeU, N nodeV) {
     Set<E> edgesConnecting = edgesConnecting(nodeU, nodeV);
     switch (edgesConnecting.size()) {
@@ -220,8 +220,8 @@ public abstract class AbstractNetwork<N, E> implements Network<N, E> {
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E edgeConnectingOrNull(EndpointPair<N> endpoints) {
     validateEndpoints(endpoints);
     return edgeConnectingOrNull(endpoints.nodeU(), endpoints.nodeV());
@@ -229,14 +229,14 @@ public abstract class AbstractNetwork<N, E> implements Network<N, E> {
 
   @Override
   public boolean hasEdgeConnecting(N nodeU, N nodeV) {
-    checkNotNull(nodeU);
-    checkNotNull(nodeV);
+    requireNonNull(nodeU);
+    requireNonNull(nodeV);
     return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);
   }
 
   @Override
   public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
-    checkNotNull(endpoints);
+    requireNonNull(endpoints);
     if (!isOrderingCompatible(endpoints)) {
       return false;
     }
@@ -248,7 +248,7 @@ public abstract class AbstractNetwork<N, E> implements Network<N, E> {
    * the directionality of this graph.
    */
   protected final void validateEndpoints(EndpointPair<?> endpoints) {
-    checkNotNull(endpoints);
+    requireNonNull(endpoints);
     checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);
   }
 
diff --git a/guava/src/com/google/common/graph/AbstractUndirectedNetworkConnections.java b/guava/src/com/google/common/graph/AbstractUndirectedNetworkConnections.java
index 8f736d7baa..01f93b0c01 100644
--- a/guava/src/com/google/common/graph/AbstractUndirectedNetworkConnections.java
+++ b/guava/src/com/google/common/graph/AbstractUndirectedNetworkConnections.java
@@ -16,11 +16,10 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Collections.unmodifiableSet;
 import static java.util.Objects.requireNonNull;
 
-import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.CheckForNull;
@@ -38,7 +37,7 @@ abstract class AbstractUndirectedNetworkConnections<N, E> implements NetworkConn
   final Map<E, N> incidentEdgeMap;
 
   AbstractUndirectedNetworkConnections(Map<E, N> incidentEdgeMap) {
-    this.incidentEdgeMap = checkNotNull(incidentEdgeMap);
+    this.incidentEdgeMap = requireNonNull(incidentEdgeMap);
   }
 
   @Override
@@ -53,7 +52,7 @@ abstract class AbstractUndirectedNetworkConnections<N, E> implements NetworkConn
 
   @Override
   public Set<E> incidentEdges() {
-    return Collections.unmodifiableSet(incidentEdgeMap.keySet());
+    return unmodifiableSet(incidentEdgeMap.keySet());
   }
 
   @Override
@@ -72,8 +71,8 @@ abstract class AbstractUndirectedNetworkConnections<N, E> implements NetworkConn
     return requireNonNull(incidentEdgeMap.get(edge));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public N removeInEdge(E edge, boolean isSelfLoop) {
     if (!isSelfLoop) {
       return removeOutEdge(edge);
diff --git a/guava/src/com/google/common/graph/DirectedGraphConnections.java b/guava/src/com/google/common/graph/DirectedGraphConnections.java
index 0feb973f3f..ea9c131257 100644
--- a/guava/src/com/google/common/graph/DirectedGraphConnections.java
+++ b/guava/src/com/google/common/graph/DirectedGraphConnections.java
@@ -17,12 +17,13 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.INNER_CAPACITY;
 import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;
 import static com.google.common.graph.Graphs.checkNonNegative;
 import static com.google.common.graph.Graphs.checkPositive;
+import static java.util.Collections.unmodifiableSet;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.base.Function;
 import com.google.common.collect.AbstractIterator;
@@ -31,7 +32,6 @@ import com.google.common.collect.Iterators;
 import com.google.common.collect.UnmodifiableIterator;
 import java.util.AbstractSet;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -74,7 +74,7 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
     final N node;
 
     NodeConnection(N node) {
-      this.node = checkNotNull(node);
+      this.node = requireNonNull(node);
     }
 
     static final class Pred<N> extends NodeConnection<N> {
@@ -144,7 +144,7 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
       @CheckForNull List<NodeConnection<N>> orderedNodeConnections,
       int predecessorCount,
       int successorCount) {
-    this.adjacentNodeValues = checkNotNull(adjacentNodeValues);
+    this.adjacentNodeValues = requireNonNull(adjacentNodeValues);
     this.orderedNodeConnections = orderedNodeConnections;
     this.predecessorCount = checkNonNegative(predecessorCount);
     this.successorCount = checkNonNegative(successorCount);
@@ -178,8 +178,8 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
 
   static <N, V> DirectedGraphConnections<N, V> ofImmutable(
       N thisNode, Iterable<EndpointPair<N>> incidentEdges, Function<N, V> successorNodeToValueFn) {
-    checkNotNull(thisNode);
-    checkNotNull(successorNodeToValueFn);
+    requireNonNull(thisNode);
+    requireNonNull(successorNodeToValueFn);
 
     Map<N, Object> adjacentNodeValues = new HashMap<>();
     ImmutableList.Builder<NodeConnection<N>> orderedNodeConnectionsBuilder =
@@ -234,7 +234,7 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
   @Override
   public Set<N> adjacentNodes() {
     if (orderedNodeConnections == null) {
-      return Collections.unmodifiableSet(adjacentNodeValues.keySet());
+      return unmodifiableSet(adjacentNodeValues.keySet());
     } else {
       return new AbstractSet<N>() {
         @Override
@@ -242,8 +242,8 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
           Iterator<NodeConnection<N>> nodeConnections = orderedNodeConnections.iterator();
           Set<N> seenNodes = new HashSet<>();
           return new AbstractIterator<N>() {
-            @Override
             @CheckForNull
+            @Override
             protected N computeNext() {
               while (nodeConnections.hasNext()) {
                 NodeConnection<N> nodeConnection = nodeConnections.next();
@@ -278,8 +278,8 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
         if (orderedNodeConnections == null) {
           Iterator<Entry<N, Object>> entries = adjacentNodeValues.entrySet().iterator();
           return new AbstractIterator<N>() {
-            @Override
             @CheckForNull
+            @Override
             protected N computeNext() {
               while (entries.hasNext()) {
                 Entry<N, Object> entry = entries.next();
@@ -293,8 +293,8 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
         } else {
           Iterator<NodeConnection<N>> nodeConnections = orderedNodeConnections.iterator();
           return new AbstractIterator<N>() {
-            @Override
             @CheckForNull
+            @Override
             protected N computeNext() {
               while (nodeConnections.hasNext()) {
                 NodeConnection<N> nodeConnection = nodeConnections.next();
@@ -328,8 +328,8 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
         if (orderedNodeConnections == null) {
           Iterator<Entry<N, Object>> entries = adjacentNodeValues.entrySet().iterator();
           return new AbstractIterator<N>() {
-            @Override
             @CheckForNull
+            @Override
             protected N computeNext() {
               while (entries.hasNext()) {
                 Entry<N, Object> entry = entries.next();
@@ -343,8 +343,8 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
         } else {
           Iterator<NodeConnection<N>> nodeConnections = orderedNodeConnections.iterator();
           return new AbstractIterator<N>() {
-            @Override
             @CheckForNull
+            @Override
             protected N computeNext() {
               while (nodeConnections.hasNext()) {
                 NodeConnection<N> nodeConnection = nodeConnections.next();
@@ -372,7 +372,7 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
 
   @Override
   public Iterator<EndpointPair<N>> incidentEdgeIterator(N thisNode) {
-    checkNotNull(thisNode);
+    requireNonNull(thisNode);
 
     Iterator<EndpointPair<N>> resultWithDoubleSelfLoop;
     if (orderedNodeConnections == null) {
@@ -399,8 +399,8 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
 
     AtomicBoolean alreadySeenSelfLoop = new AtomicBoolean(false);
     return new AbstractIterator<EndpointPair<N>>() {
-      @Override
       @CheckForNull
+      @Override
       protected EndpointPair<N> computeNext() {
         while (resultWithDoubleSelfLoop.hasNext()) {
           EndpointPair<N> edge = resultWithDoubleSelfLoop.next();
@@ -417,11 +417,11 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
     };
   }
 
-  @SuppressWarnings("unchecked")
-  @Override
   @CheckForNull
+  @Override
+  @SuppressWarnings("unchecked")
   public V value(N node) {
-    checkNotNull(node);
+    requireNonNull(node);
     Object value = adjacentNodeValues.get(node);
     if (value == PRED) {
       return null;
@@ -432,10 +432,10 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
     return (V) value;
   }
 
-  @SuppressWarnings("unchecked")
   @Override
+  @SuppressWarnings("unchecked")
   public void removePredecessor(N node) {
-    checkNotNull(node);
+    requireNonNull(node);
 
     Object previousValue = adjacentNodeValues.get(node);
     boolean removedPredecessor;
@@ -459,11 +459,11 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
     }
   }
 
-  @SuppressWarnings("unchecked")
-  @Override
   @CheckForNull
+  @Override
+  @SuppressWarnings("unchecked")
   public V removeSuccessor(Object node) {
-    checkNotNull(node);
+    requireNonNull(node);
     Object previousValue = adjacentNodeValues.get(node);
     Object removedValue;
 
@@ -523,9 +523,9 @@ final class DirectedGraphConnections<N, V> implements GraphConnections<N, V> {
     }
   }
 
-  @SuppressWarnings("unchecked")
-  @Override
   @CheckForNull
+  @Override
+  @SuppressWarnings("unchecked")
   public V addSuccessor(N node, V value) {
     Object previousValue = adjacentNodeValues.put(node, value);
     Object previousSuccessor;
diff --git a/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java b/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java
index bd0e546f26..341c91248d 100644
--- a/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java
+++ b/guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java
@@ -19,14 +19,13 @@ package com.google.common.graph;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.INNER_CAPACITY;
 import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;
+import static java.util.Collections.unmodifiableSet;
 
 import com.google.common.collect.HashMultiset;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Multiset;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.lang.ref.Reference;
 import java.lang.ref.SoftReference;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
@@ -56,15 +55,14 @@ final class DirectedMultiNetworkConnections<N, E> extends AbstractDirectedNetwor
 
   static <N, E> DirectedMultiNetworkConnections<N, E> ofImmutable(
       Map<E, N> inEdges, Map<E, N> outEdges, int selfLoopCount) {
-    return new DirectedMultiNetworkConnections<>(
-        ImmutableMap.copyOf(inEdges), ImmutableMap.copyOf(outEdges), selfLoopCount);
+    return new DirectedMultiNetworkConnections<>(inEdges, outEdges, selfLoopCount);
   }
 
   @CheckForNull @LazyInit private transient Reference<Multiset<N>> predecessorsReference;
 
   @Override
   public Set<N> predecessors() {
-    return Collections.unmodifiableSet(predecessorsMultiset().elementSet());
+    return unmodifiableSet(predecessorsMultiset().elementSet());
   }
 
   private Multiset<N> predecessorsMultiset() {
@@ -80,7 +78,7 @@ final class DirectedMultiNetworkConnections<N, E> extends AbstractDirectedNetwor
 
   @Override
   public Set<N> successors() {
-    return Collections.unmodifiableSet(successorsMultiset().elementSet());
+    return unmodifiableSet(successorsMultiset().elementSet());
   }
 
   private Multiset<N> successorsMultiset() {
diff --git a/guava/src/com/google/common/graph/DirectedNetworkConnections.java b/guava/src/com/google/common/graph/DirectedNetworkConnections.java
index 9d70c790ee..65f1a80e3b 100644
--- a/guava/src/com/google/common/graph/DirectedNetworkConnections.java
+++ b/guava/src/com/google/common/graph/DirectedNetworkConnections.java
@@ -17,11 +17,11 @@
 package com.google.common.graph;
 
 import static com.google.common.graph.GraphConstants.EXPECTED_DEGREE;
+import static java.util.Collections.unmodifiableSet;
 
 import com.google.common.collect.BiMap;
 import com.google.common.collect.HashBiMap;
 import com.google.common.collect.ImmutableBiMap;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 
@@ -53,12 +53,12 @@ final class DirectedNetworkConnections<N, E> extends AbstractDirectedNetworkConn
 
   @Override
   public Set<N> predecessors() {
-    return Collections.unmodifiableSet(((BiMap<E, N>) inEdgeMap).values());
+    return unmodifiableSet(((BiMap<E, N>) inEdgeMap).values());
   }
 
   @Override
   public Set<N> successors() {
-    return Collections.unmodifiableSet(((BiMap<E, N>) outEdgeMap).values());
+    return unmodifiableSet(((BiMap<E, N>) outEdgeMap).values());
   }
 
   @Override
diff --git a/guava/src/com/google/common/graph/EdgesConnecting.java b/guava/src/com/google/common/graph/EdgesConnecting.java
index 797970ba29..b91f0f840c 100644
--- a/guava/src/com/google/common/graph/EdgesConnecting.java
+++ b/guava/src/com/google/common/graph/EdgesConnecting.java
@@ -16,7 +16,7 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterators;
@@ -41,8 +41,8 @@ final class EdgesConnecting<E> extends AbstractSet<E> {
   private final Object targetNode;
 
   EdgesConnecting(Map<?, E> nodeToEdgeMap, Object targetNode) {
-    this.nodeToOutEdge = checkNotNull(nodeToEdgeMap);
-    this.targetNode = checkNotNull(targetNode);
+    this.nodeToOutEdge = requireNonNull(nodeToEdgeMap);
+    this.targetNode = requireNonNull(targetNode);
   }
 
   @Override
diff --git a/guava/src/com/google/common/graph/ElementOrder.java b/guava/src/com/google/common/graph/ElementOrder.java
index b5985a280b..a7357297ae 100644
--- a/guava/src/com/google/common/graph/ElementOrder.java
+++ b/guava/src/com/google/common/graph/ElementOrder.java
@@ -16,8 +16,8 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.MoreObjects;
@@ -73,7 +73,7 @@ public final class ElementOrder<T> {
   }
 
   private ElementOrder(Type type, @CheckForNull Comparator<T> comparator) {
-    this.type = checkNotNull(type);
+    this.type = requireNonNull(type);
     this.comparator = comparator;
     checkState((type == Type.SORTED) == (comparator != null));
   }
@@ -140,7 +140,7 @@ public final class ElementOrder<T> {
    * determined by {@code comparator}.
    */
   public static <S> ElementOrder<S> sorted(Comparator<S> comparator) {
-    return new ElementOrder<>(Type.SORTED, checkNotNull(comparator));
+    return new ElementOrder<>(Type.SORTED, requireNonNull(comparator));
   }
 
   /** Returns the type of ordering used. */
diff --git a/guava/src/com/google/common/graph/EndpointPair.java b/guava/src/com/google/common/graph/EndpointPair.java
index fe2397c6b9..82e0137b2a 100644
--- a/guava/src/com/google/common/graph/EndpointPair.java
+++ b/guava/src/com/google/common/graph/EndpointPair.java
@@ -16,8 +16,8 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.GraphConstants.NOT_AVAILABLE_ON_UNDIRECTED;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Objects;
@@ -38,15 +38,15 @@ import javax.annotation.CheckForNull;
  * @since 20.0
  */
 @Beta
-@Immutable(containerOf = {"N"})
+@Immutable(containerOf = "N")
 @ElementTypesAreNonnullByDefault
 public abstract class EndpointPair<N> implements Iterable<N> {
   private final N nodeU;
   private final N nodeV;
 
   private EndpointPair(N nodeU, N nodeV) {
-    this.nodeU = checkNotNull(nodeU);
-    this.nodeV = checkNotNull(nodeV);
+    this.nodeU = requireNonNull(nodeU);
+    this.nodeV = requireNonNull(nodeV);
   }
 
   /** Returns an {@link EndpointPair} representing the endpoints of a directed edge. */
diff --git a/guava/src/com/google/common/graph/EndpointPairIterator.java b/guava/src/com/google/common/graph/EndpointPairIterator.java
index 7096dbe3da..b501236378 100644
--- a/guava/src/com/google/common/graph/EndpointPairIterator.java
+++ b/guava/src/com/google/common/graph/EndpointPairIterator.java
@@ -74,8 +74,8 @@ abstract class EndpointPairIterator<N> extends AbstractIterator<EndpointPair<N>>
       super(graph);
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected EndpointPair<N> computeNext() {
       while (true) {
         if (successorIterator.hasNext()) {
@@ -124,8 +124,8 @@ abstract class EndpointPairIterator<N> extends AbstractIterator<EndpointPair<N>>
       this.visitedNodes = Sets.newHashSetWithExpectedSize(graph.nodes().size() + 1);
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected EndpointPair<N> computeNext() {
       while (true) {
         /*
diff --git a/guava/src/com/google/common/graph/ForwardingNetwork.java b/guava/src/com/google/common/graph/ForwardingNetwork.java
index 9f1c6e7702..dc0e010253 100644
--- a/guava/src/com/google/common/graph/ForwardingNetwork.java
+++ b/guava/src/com/google/common/graph/ForwardingNetwork.java
@@ -142,14 +142,14 @@ abstract class ForwardingNetwork<N, E> extends AbstractNetwork<N, E> {
     return delegate().edgeConnecting(endpoints);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E edgeConnectingOrNull(N nodeU, N nodeV) {
     return delegate().edgeConnectingOrNull(nodeU, nodeV);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E edgeConnectingOrNull(EndpointPair<N> endpoints) {
     return delegate().edgeConnectingOrNull(endpoints);
   }
diff --git a/guava/src/com/google/common/graph/ForwardingValueGraph.java b/guava/src/com/google/common/graph/ForwardingValueGraph.java
index fcd5d28bc3..871ecfb1b5 100644
--- a/guava/src/com/google/common/graph/ForwardingValueGraph.java
+++ b/guava/src/com/google/common/graph/ForwardingValueGraph.java
@@ -116,14 +116,14 @@ abstract class ForwardingValueGraph<N, V> extends AbstractValueGraph<N, V> {
     return delegate().edgeValue(endpoints);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V edgeValueOrDefault(N nodeU, N nodeV, @CheckForNull V defaultValue) {
     return delegate().edgeValueOrDefault(nodeU, nodeV, defaultValue);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V edgeValueOrDefault(EndpointPair<N> endpoints, @CheckForNull V defaultValue) {
     return delegate().edgeValueOrDefault(endpoints, defaultValue);
   }
diff --git a/guava/src/com/google/common/graph/GraphBuilder.java b/guava/src/com/google/common/graph/GraphBuilder.java
index 8c0871b467..66acd65ac7 100644
--- a/guava/src/com/google/common/graph/GraphBuilder.java
+++ b/guava/src/com/google/common/graph/GraphBuilder.java
@@ -17,8 +17,8 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.Graphs.checkNonNegative;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Optional;
@@ -140,7 +140,7 @@ public final class GraphBuilder<N> extends AbstractGraphBuilder<N> {
    */
   public <N1 extends N> GraphBuilder<N1> nodeOrder(ElementOrder<N1> nodeOrder) {
     GraphBuilder<N1> newBuilder = cast();
-    newBuilder.nodeOrder = checkNotNull(nodeOrder);
+    newBuilder.nodeOrder = requireNonNull(nodeOrder);
     return newBuilder;
   }
 
@@ -165,7 +165,7 @@ public final class GraphBuilder<N> extends AbstractGraphBuilder<N> {
             + " ElementOrder.unordered() and ElementOrder.stable().",
         incidentEdgeOrder);
     GraphBuilder<N1> newBuilder = cast();
-    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);
+    newBuilder.incidentEdgeOrder = requireNonNull(incidentEdgeOrder);
     return newBuilder;
   }
 
diff --git a/guava/src/com/google/common/graph/Graphs.java b/guava/src/com/google/common/graph/Graphs.java
index 6ab9f56615..7576fe0374 100644
--- a/guava/src/com/google/common/graph/Graphs.java
+++ b/guava/src/com/google/common/graph/Graphs.java
@@ -374,14 +374,14 @@ public final class Graphs {
       return delegate().edgeValue(transpose(endpoints));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V edgeValueOrDefault(N nodeU, N nodeV, @CheckForNull V defaultValue) {
       return delegate().edgeValueOrDefault(nodeV, nodeU, defaultValue); // transpose
     }
 
-    @Override
     @CheckForNull
+    @Override
     public V edgeValueOrDefault(EndpointPair<N> endpoints, @CheckForNull V defaultValue) {
       return delegate().edgeValueOrDefault(transpose(endpoints), defaultValue);
     }
@@ -455,14 +455,14 @@ public final class Graphs {
       return delegate().edgeConnecting(transpose(endpoints));
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E edgeConnectingOrNull(N nodeU, N nodeV) {
       return delegate().edgeConnectingOrNull(nodeV, nodeU); // transpose
     }
 
-    @Override
     @CheckForNull
+    @Override
     public E edgeConnectingOrNull(EndpointPair<N> endpoints) {
       return delegate().edgeConnectingOrNull(transpose(endpoints));
     }
diff --git a/guava/src/com/google/common/graph/ImmutableGraph.java b/guava/src/com/google/common/graph/ImmutableGraph.java
index f829e96999..79fa24f7fc 100644
--- a/guava/src/com/google/common/graph/ImmutableGraph.java
+++ b/guava/src/com/google/common/graph/ImmutableGraph.java
@@ -16,7 +16,7 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
@@ -44,7 +44,7 @@ import com.google.errorprone.annotations.Immutable;
  * @since 20.0
  */
 @Beta
-@Immutable(containerOf = {"N"})
+@Immutable(containerOf = "N")
 @ElementTypesAreNonnullByDefault
 public class ImmutableGraph<N> extends ForwardingGraph<N> {
   @SuppressWarnings("Immutable") // The backing graph must be immutable.
@@ -70,7 +70,7 @@ public class ImmutableGraph<N> extends ForwardingGraph<N> {
    */
   @Deprecated
   public static <N> ImmutableGraph<N> copyOf(ImmutableGraph<N> graph) {
-    return checkNotNull(graph);
+    return requireNonNull(graph);
   }
 
   @Override
diff --git a/guava/src/com/google/common/graph/ImmutableNetwork.java b/guava/src/com/google/common/graph/ImmutableNetwork.java
index c29f8a3928..cd4bfb8f57 100644
--- a/guava/src/com/google/common/graph/ImmutableNetwork.java
+++ b/guava/src/com/google/common/graph/ImmutableNetwork.java
@@ -16,7 +16,7 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
@@ -44,7 +44,7 @@ import java.util.Map;
  * @since 20.0
  */
 @Beta
-@Immutable(containerOf = {"N", "E"})
+@Immutable(containerOf = {"E", "N"})
 @SuppressWarnings("Immutable") // Extends StandardNetwork but uses ImmutableMaps.
 @ElementTypesAreNonnullByDefault
 public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
@@ -68,7 +68,7 @@ public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
    */
   @Deprecated
   public static <N, E> ImmutableNetwork<N, E> copyOf(ImmutableNetwork<N, E> network) {
-    return checkNotNull(network);
+    return requireNonNull(network);
   }
 
   @Override
diff --git a/guava/src/com/google/common/graph/ImmutableValueGraph.java b/guava/src/com/google/common/graph/ImmutableValueGraph.java
index eb17067fca..e80b391ca8 100644
--- a/guava/src/com/google/common/graph/ImmutableValueGraph.java
+++ b/guava/src/com/google/common/graph/ImmutableValueGraph.java
@@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -65,7 +64,7 @@ public final class ImmutableValueGraph<N, V> extends StandardValueGraph<N, V> {
    */
   @Deprecated
   public static <N, V> ImmutableValueGraph<N, V> copyOf(ImmutableValueGraph<N, V> graph) {
-    return checkNotNull(graph);
+    return requireNonNull(graph);
   }
 
   @Override
diff --git a/guava/src/com/google/common/graph/MapIteratorCache.java b/guava/src/com/google/common/graph/MapIteratorCache.java
index 05cdde8c3f..35f97d98a9 100644
--- a/guava/src/com/google/common/graph/MapIteratorCache.java
+++ b/guava/src/com/google/common/graph/MapIteratorCache.java
@@ -16,7 +16,7 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.UnmodifiableIterator;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -57,14 +57,14 @@ class MapIteratorCache<K, V> {
   @CheckForNull private transient volatile Entry<K, V> cacheEntry;
 
   MapIteratorCache(Map<K, V> backingMap) {
-    this.backingMap = checkNotNull(backingMap);
+    this.backingMap = requireNonNull(backingMap);
   }
 
   @CanIgnoreReturnValue
   @CheckForNull
   final V put(K key, V value) {
-    checkNotNull(key);
-    checkNotNull(value);
+    requireNonNull(key);
+    requireNonNull(value);
     clearCache();
     return backingMap.put(key, value);
   }
@@ -72,7 +72,7 @@ class MapIteratorCache<K, V> {
   @CanIgnoreReturnValue
   @CheckForNull
   final V remove(Object key) {
-    checkNotNull(key);
+    requireNonNull(key);
     clearCache();
     return backingMap.remove(key);
   }
@@ -84,7 +84,7 @@ class MapIteratorCache<K, V> {
 
   @CheckForNull
   V get(Object key) {
-    checkNotNull(key);
+    requireNonNull(key);
     V value = getIfCached(key);
     // TODO(b/192579700): Use a ternary once it no longer confuses our nullness checker.
     if (value == null) {
@@ -96,7 +96,7 @@ class MapIteratorCache<K, V> {
 
   @CheckForNull
   final V getWithoutCaching(Object key) {
-    checkNotNull(key);
+    requireNonNull(key);
     return backingMap.get(key);
   }
 
diff --git a/guava/src/com/google/common/graph/MapRetrievalCache.java b/guava/src/com/google/common/graph/MapRetrievalCache.java
index ada78f2841..7d5f1c2316 100644
--- a/guava/src/com/google/common/graph/MapRetrievalCache.java
+++ b/guava/src/com/google/common/graph/MapRetrievalCache.java
@@ -16,7 +16,7 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import java.util.Map;
 import javax.annotation.CheckForNull;
@@ -37,11 +37,11 @@ final class MapRetrievalCache<K, V> extends MapIteratorCache<K, V> {
     super(backingMap);
   }
 
-  @SuppressWarnings("unchecked") // Safe because we only cast if key is found in map.
+  @CheckForNull // Safe because we only cast if key is found in map.
   @Override
-  @CheckForNull
+  @SuppressWarnings("unchecked")
   V get(Object key) {
-    checkNotNull(key);
+    requireNonNull(key);
     V value = getIfCached(key);
     if (value != null) {
       return value;
@@ -56,8 +56,8 @@ final class MapRetrievalCache<K, V> extends MapIteratorCache<K, V> {
 
   // Internal methods (package-visible, but treat as only subclass-visible)
 
-  @Override
   @CheckForNull
+  @Override
   V getIfCached(@CheckForNull Object key) {
     V value = super.getIfCached(key);
     if (value != null) {
diff --git a/guava/src/com/google/common/graph/MultiEdgesConnecting.java b/guava/src/com/google/common/graph/MultiEdgesConnecting.java
index 620f986a55..8faaf83229 100644
--- a/guava/src/com/google/common/graph/MultiEdgesConnecting.java
+++ b/guava/src/com/google/common/graph/MultiEdgesConnecting.java
@@ -16,7 +16,7 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.UnmodifiableIterator;
@@ -42,16 +42,16 @@ abstract class MultiEdgesConnecting<E> extends AbstractSet<E> {
   private final Object targetNode;
 
   MultiEdgesConnecting(Map<E, ?> outEdgeToNode, Object targetNode) {
-    this.outEdgeToNode = checkNotNull(outEdgeToNode);
-    this.targetNode = checkNotNull(targetNode);
+    this.outEdgeToNode = requireNonNull(outEdgeToNode);
+    this.targetNode = requireNonNull(targetNode);
   }
 
   @Override
   public UnmodifiableIterator<E> iterator() {
     Iterator<? extends Entry<E, ?>> entries = outEdgeToNode.entrySet().iterator();
     return new AbstractIterator<E>() {
-      @Override
       @CheckForNull
+      @Override
       protected E computeNext() {
         while (entries.hasNext()) {
           Entry<E, ?> entry = entries.next();
diff --git a/guava/src/com/google/common/graph/NetworkBuilder.java b/guava/src/com/google/common/graph/NetworkBuilder.java
index 968944493c..85c0f90622 100644
--- a/guava/src/com/google/common/graph/NetworkBuilder.java
+++ b/guava/src/com/google/common/graph/NetworkBuilder.java
@@ -16,8 +16,8 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.Graphs.checkNonNegative;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Optional;
@@ -166,7 +166,7 @@ public final class NetworkBuilder<N, E> extends AbstractGraphBuilder<N> {
    */
   public <N1 extends N> NetworkBuilder<N1, E> nodeOrder(ElementOrder<N1> nodeOrder) {
     NetworkBuilder<N1, E> newBuilder = cast();
-    newBuilder.nodeOrder = checkNotNull(nodeOrder);
+    newBuilder.nodeOrder = requireNonNull(nodeOrder);
     return newBuilder;
   }
 
@@ -177,7 +177,7 @@ public final class NetworkBuilder<N, E> extends AbstractGraphBuilder<N> {
    */
   public <E1 extends E> NetworkBuilder<N, E1> edgeOrder(ElementOrder<E1> edgeOrder) {
     NetworkBuilder<N, E1> newBuilder = cast();
-    newBuilder.edgeOrder = checkNotNull(edgeOrder);
+    newBuilder.edgeOrder = requireNonNull(edgeOrder);
     return newBuilder;
   }
 
diff --git a/guava/src/com/google/common/graph/StandardMutableNetwork.java b/guava/src/com/google/common/graph/StandardMutableNetwork.java
index c58b6d3909..795881b820 100644
--- a/guava/src/com/google/common/graph/StandardMutableNetwork.java
+++ b/guava/src/com/google/common/graph/StandardMutableNetwork.java
@@ -17,7 +17,6 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.PARALLEL_EDGES_NOT_ALLOWED;
 import static com.google.common.graph.GraphConstants.REUSING_EDGE;
@@ -49,10 +48,10 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
     super(builder);
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean addNode(N node) {
-    checkNotNull(node, "node");
+    requireNonNull(node, "node");
 
     if (containsNode(node)) {
       return false;
@@ -74,12 +73,12 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
     return connections;
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean addEdge(N nodeU, N nodeV, E edge) {
-    checkNotNull(nodeU, "nodeU");
-    checkNotNull(nodeV, "nodeV");
-    checkNotNull(edge, "edge");
+    requireNonNull(nodeU, "nodeU");
+    requireNonNull(nodeV, "nodeV");
+    requireNonNull(edge, "edge");
 
     if (containsEdge(edge)) {
       EndpointPair<N> existingIncidentNodes = incidentNodes(edge);
@@ -118,17 +117,17 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
     return true;
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean addEdge(EndpointPair<N> endpoints, E edge) {
     validateEndpoints(endpoints);
     return addEdge(endpoints.nodeU(), endpoints.nodeV(), edge);
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean removeNode(N node) {
-    checkNotNull(node, "node");
+    requireNonNull(node, "node");
 
     NetworkConnections<N, E> connections = nodeConnections.get(node);
     if (connections == null) {
@@ -144,10 +143,10 @@ final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
     return true;
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean removeEdge(E edge) {
-    checkNotNull(edge, "edge");
+    requireNonNull(edge, "edge");
 
     N nodeU = edgeToReferenceNode.get(edge);
     if (nodeU == null) {
diff --git a/guava/src/com/google/common/graph/StandardMutableValueGraph.java b/guava/src/com/google/common/graph/StandardMutableValueGraph.java
index 0ea641a5b1..f9a28f1ecb 100644
--- a/guava/src/com/google/common/graph/StandardMutableValueGraph.java
+++ b/guava/src/com/google/common/graph/StandardMutableValueGraph.java
@@ -17,7 +17,6 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.SELF_LOOPS_NOT_ALLOWED;
 import static com.google.common.graph.Graphs.checkNonNegative;
@@ -57,10 +56,10 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
     return incidentEdgeOrder;
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean addNode(N node) {
-    checkNotNull(node, "node");
+    requireNonNull(node, "node");
 
     if (containsNode(node)) {
       return false;
@@ -82,13 +81,13 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
     return connections;
   }
 
-  @Override
   @CanIgnoreReturnValue
   @CheckForNull
+  @Override
   public V putEdgeValue(N nodeU, N nodeV, V value) {
-    checkNotNull(nodeU, "nodeU");
-    checkNotNull(nodeV, "nodeV");
-    checkNotNull(value, "value");
+    requireNonNull(nodeU, "nodeU");
+    requireNonNull(nodeV, "nodeV");
+    requireNonNull(value, "value");
 
     if (!allowsSelfLoops()) {
       checkArgument(!nodeU.equals(nodeV), SELF_LOOPS_NOT_ALLOWED, nodeU);
@@ -110,18 +109,18 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
     return previousValue;
   }
 
-  @Override
   @CanIgnoreReturnValue
   @CheckForNull
+  @Override
   public V putEdgeValue(EndpointPair<N> endpoints, V value) {
     validateEndpoints(endpoints);
     return putEdgeValue(endpoints.nodeU(), endpoints.nodeV(), value);
   }
 
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public boolean removeNode(N node) {
-    checkNotNull(node, "node");
+    requireNonNull(node, "node");
 
     GraphConnections<N, V> connections = nodeConnections.get(node);
     if (connections == null) {
@@ -155,12 +154,12 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
     return true;
   }
 
-  @Override
   @CanIgnoreReturnValue
   @CheckForNull
+  @Override
   public V removeEdge(N nodeU, N nodeV) {
-    checkNotNull(nodeU, "nodeU");
-    checkNotNull(nodeV, "nodeV");
+    requireNonNull(nodeU, "nodeU");
+    requireNonNull(nodeV, "nodeV");
 
     GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);
     GraphConnections<N, V> connectionsV = nodeConnections.get(nodeV);
@@ -176,9 +175,9 @@ final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
     return previousValue;
   }
 
-  @Override
   @CanIgnoreReturnValue
   @CheckForNull
+  @Override
   public V removeEdge(EndpointPair<N> endpoints) {
     validateEndpoints(endpoints);
     return removeEdge(endpoints.nodeU(), endpoints.nodeV());
diff --git a/guava/src/com/google/common/graph/StandardNetwork.java b/guava/src/com/google/common/graph/StandardNetwork.java
index 2aa103f996..cfc33fba62 100644
--- a/guava/src/com/google/common/graph/StandardNetwork.java
+++ b/guava/src/com/google/common/graph/StandardNetwork.java
@@ -17,7 +17,6 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.GraphConstants.DEFAULT_EDGE_COUNT;
 import static com.google.common.graph.GraphConstants.DEFAULT_NODE_COUNT;
 import static com.google.common.graph.GraphConstants.EDGE_NOT_IN_GRAPH;
@@ -179,7 +178,7 @@ class StandardNetwork<N, E> extends AbstractNetwork<N, E> {
   final NetworkConnections<N, E> checkedConnections(N node) {
     NetworkConnections<N, E> connections = nodeConnections.get(node);
     if (connections == null) {
-      checkNotNull(node);
+      requireNonNull(node);
       throw new IllegalArgumentException(String.format(NODE_NOT_IN_GRAPH, node));
     }
     return connections;
@@ -188,7 +187,7 @@ class StandardNetwork<N, E> extends AbstractNetwork<N, E> {
   final N checkedReferenceNode(E edge) {
     N referenceNode = edgeToReferenceNode.get(edge);
     if (referenceNode == null) {
-      checkNotNull(edge);
+      requireNonNull(edge);
       throw new IllegalArgumentException(String.format(EDGE_NOT_IN_GRAPH, edge));
     }
     return referenceNode;
diff --git a/guava/src/com/google/common/graph/StandardValueGraph.java b/guava/src/com/google/common/graph/StandardValueGraph.java
index ab3ae582b5..fc102e8ca7 100644
--- a/guava/src/com/google/common/graph/StandardValueGraph.java
+++ b/guava/src/com/google/common/graph/StandardValueGraph.java
@@ -16,9 +16,9 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.GraphConstants.DEFAULT_NODE_COUNT;
 import static com.google.common.graph.Graphs.checkNonNegative;
+import static java.util.Objects.requireNonNull;
 
 import java.util.Iterator;
 import java.util.Map;
@@ -130,24 +130,24 @@ class StandardValueGraph<N, V> extends AbstractValueGraph<N, V> {
 
   @Override
   public boolean hasEdgeConnecting(N nodeU, N nodeV) {
-    return hasEdgeConnectingInternal(checkNotNull(nodeU), checkNotNull(nodeV));
+    return hasEdgeConnectingInternal(requireNonNull(nodeU), requireNonNull(nodeV));
   }
 
   @Override
   public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
-    checkNotNull(endpoints);
+    requireNonNull(endpoints);
     return isOrderingCompatible(endpoints)
         && hasEdgeConnectingInternal(endpoints.nodeU(), endpoints.nodeV());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V edgeValueOrDefault(N nodeU, N nodeV, @CheckForNull V defaultValue) {
-    return edgeValueOrDefaultInternal(checkNotNull(nodeU), checkNotNull(nodeV), defaultValue);
+    return edgeValueOrDefaultInternal(requireNonNull(nodeU), requireNonNull(nodeV), defaultValue);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V edgeValueOrDefault(EndpointPair<N> endpoints, @CheckForNull V defaultValue) {
     validateEndpoints(endpoints);
     return edgeValueOrDefaultInternal(endpoints.nodeU(), endpoints.nodeV(), defaultValue);
@@ -161,7 +161,7 @@ class StandardValueGraph<N, V> extends AbstractValueGraph<N, V> {
   private final GraphConnections<N, V> checkedConnections(N node) {
     GraphConnections<N, V> connections = nodeConnections.get(node);
     if (connections == null) {
-      checkNotNull(node);
+      requireNonNull(node);
       throw new IllegalArgumentException("Node " + node + " is not an element of this graph.");
     }
     return connections;
diff --git a/guava/src/com/google/common/graph/Traverser.java b/guava/src/com/google/common/graph/Traverser.java
index fb594b4403..1bc06d9f64 100644
--- a/guava/src/com/google/common/graph/Traverser.java
+++ b/guava/src/com/google/common/graph/Traverser.java
@@ -17,7 +17,6 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
@@ -69,7 +68,7 @@ public abstract class Traverser<N> {
   private final SuccessorsFunction<N> successorFunction;
 
   private Traverser(SuccessorsFunction<N> successorFunction) {
-    this.successorFunction = checkNotNull(successorFunction);
+    this.successorFunction = requireNonNull(successorFunction);
   }
 
   /**
@@ -384,8 +383,8 @@ public abstract class Traverser<N> {
     static <N> Traversal<N> inGraph(SuccessorsFunction<N> graph) {
       Set<N> visited = new HashSet<>();
       return new Traversal<N>(graph) {
-        @Override
         @CheckForNull
+        @Override
         N visitNext(Deque<Iterator<? extends N>> horizon) {
           Iterator<? extends N> top = horizon.getFirst();
           while (top.hasNext()) {
@@ -416,7 +415,7 @@ public abstract class Traverser<N> {
         N visitNext(Deque<Iterator<? extends N>> horizon) {
           Iterator<? extends N> top = horizon.getFirst();
           if (top.hasNext()) {
-            return checkNotNull(top.next());
+            return requireNonNull(top.next());
           }
           horizon.removeFirst();
           return null;
@@ -442,8 +441,8 @@ public abstract class Traverser<N> {
       Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
       horizon.add(startNodes);
       return new AbstractIterator<N>() {
-        @Override
         @CheckForNull
+        @Override
         protected N computeNext() {
           do {
             N next = visitNext(horizon);
@@ -467,8 +466,8 @@ public abstract class Traverser<N> {
       Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
       horizon.add(startNodes);
       return new AbstractIterator<N>() {
-        @Override
         @CheckForNull
+        @Override
         protected N computeNext() {
           for (N next = visitNext(horizon); next != null; next = visitNext(horizon)) {
             Iterator<? extends N> successors = successorFunction.successors(next).iterator();
diff --git a/guava/src/com/google/common/graph/UndirectedGraphConnections.java b/guava/src/com/google/common/graph/UndirectedGraphConnections.java
index 4eeb2328fe..14d9b8ea03 100644
--- a/guava/src/com/google/common/graph/UndirectedGraphConnections.java
+++ b/guava/src/com/google/common/graph/UndirectedGraphConnections.java
@@ -16,13 +16,12 @@
 
 package com.google.common.graph;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.GraphConstants.INNER_CAPACITY;
 import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;
+import static java.util.Collections.unmodifiableSet;
+import static java.util.Objects.requireNonNull;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterators;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -42,7 +41,7 @@ final class UndirectedGraphConnections<N, V> implements GraphConnections<N, V> {
   private final Map<N, V> adjacentNodeValues;
 
   private UndirectedGraphConnections(Map<N, V> adjacentNodeValues) {
-    this.adjacentNodeValues = checkNotNull(adjacentNodeValues);
+    this.adjacentNodeValues = requireNonNull(adjacentNodeValues);
   }
 
   static <N, V> UndirectedGraphConnections<N, V> of(ElementOrder<N> incidentEdgeOrder) {
@@ -59,12 +58,12 @@ final class UndirectedGraphConnections<N, V> implements GraphConnections<N, V> {
   }
 
   static <N, V> UndirectedGraphConnections<N, V> ofImmutable(Map<N, V> adjacentNodeValues) {
-    return new UndirectedGraphConnections<>(ImmutableMap.copyOf(adjacentNodeValues));
+    return new UndirectedGraphConnections<>(adjacentNodeValues);
   }
 
   @Override
   public Set<N> adjacentNodes() {
-    return Collections.unmodifiableSet(adjacentNodeValues.keySet());
+    return unmodifiableSet(adjacentNodeValues.keySet());
   }
 
   @Override
@@ -84,8 +83,8 @@ final class UndirectedGraphConnections<N, V> implements GraphConnections<N, V> {
         (N incidentNode) -> EndpointPair.unordered(thisNode, incidentNode));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V value(N node) {
     return adjacentNodeValues.get(node);
   }
@@ -96,8 +95,8 @@ final class UndirectedGraphConnections<N, V> implements GraphConnections<N, V> {
     V unused = removeSuccessor(node);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V removeSuccessor(N node) {
     return adjacentNodeValues.remove(node);
   }
@@ -108,8 +107,8 @@ final class UndirectedGraphConnections<N, V> implements GraphConnections<N, V> {
     V unused = addSuccessor(node, value);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public V addSuccessor(N node, V value) {
     return adjacentNodeValues.put(node, value);
   }
diff --git a/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java b/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java
index 6caac3b715..29e0d29544 100644
--- a/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java
+++ b/guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java
@@ -19,14 +19,13 @@ package com.google.common.graph;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.INNER_CAPACITY;
 import static com.google.common.graph.GraphConstants.INNER_LOAD_FACTOR;
+import static java.util.Collections.unmodifiableSet;
 
 import com.google.common.collect.HashMultiset;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Multiset;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.lang.ref.Reference;
 import java.lang.ref.SoftReference;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
@@ -53,14 +52,14 @@ final class UndirectedMultiNetworkConnections<N, E>
   }
 
   static <N, E> UndirectedMultiNetworkConnections<N, E> ofImmutable(Map<E, N> incidentEdges) {
-    return new UndirectedMultiNetworkConnections<>(ImmutableMap.copyOf(incidentEdges));
+    return new UndirectedMultiNetworkConnections<>(incidentEdges);
   }
 
   @CheckForNull @LazyInit private transient Reference<Multiset<N>> adjacentNodesReference;
 
   @Override
   public Set<N> adjacentNodes() {
-    return Collections.unmodifiableSet(adjacentNodesMultiset().elementSet());
+    return unmodifiableSet(adjacentNodesMultiset().elementSet());
   }
 
   private Multiset<N> adjacentNodesMultiset() {
@@ -82,8 +81,8 @@ final class UndirectedMultiNetworkConnections<N, E>
     };
   }
 
-  @Override
   @CheckForNull
+  @Override
   public N removeInEdge(E edge, boolean isSelfLoop) {
     if (!isSelfLoop) {
       return removeOutEdge(edge);
diff --git a/guava/src/com/google/common/graph/UndirectedNetworkConnections.java b/guava/src/com/google/common/graph/UndirectedNetworkConnections.java
index f11f98867c..f8aa0ec66c 100644
--- a/guava/src/com/google/common/graph/UndirectedNetworkConnections.java
+++ b/guava/src/com/google/common/graph/UndirectedNetworkConnections.java
@@ -17,11 +17,11 @@
 package com.google.common.graph;
 
 import static com.google.common.graph.GraphConstants.EXPECTED_DEGREE;
+import static java.util.Collections.unmodifiableSet;
 
 import com.google.common.collect.BiMap;
 import com.google.common.collect.HashBiMap;
 import com.google.common.collect.ImmutableBiMap;
-import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 
@@ -50,7 +50,7 @@ final class UndirectedNetworkConnections<N, E> extends AbstractUndirectedNetwork
 
   @Override
   public Set<N> adjacentNodes() {
-    return Collections.unmodifiableSet(((BiMap<E, N>) incidentEdgeMap).values());
+    return unmodifiableSet(((BiMap<E, N>) incidentEdgeMap).values());
   }
 
   @Override
diff --git a/guava/src/com/google/common/graph/ValueGraphBuilder.java b/guava/src/com/google/common/graph/ValueGraphBuilder.java
index ce146c3255..df50b71019 100644
--- a/guava/src/com/google/common/graph/ValueGraphBuilder.java
+++ b/guava/src/com/google/common/graph/ValueGraphBuilder.java
@@ -17,8 +17,8 @@
 package com.google.common.graph;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.graph.Graphs.checkNonNegative;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Optional;
@@ -144,7 +144,7 @@ public final class ValueGraphBuilder<N, V> extends AbstractGraphBuilder<N> {
    */
   public <N1 extends N> ValueGraphBuilder<N1, V> nodeOrder(ElementOrder<N1> nodeOrder) {
     ValueGraphBuilder<N1, V> newBuilder = cast();
-    newBuilder.nodeOrder = checkNotNull(nodeOrder);
+    newBuilder.nodeOrder = requireNonNull(nodeOrder);
     return newBuilder;
   }
 
@@ -170,7 +170,7 @@ public final class ValueGraphBuilder<N, V> extends AbstractGraphBuilder<N> {
             + " ElementOrder.unordered() and ElementOrder.stable().",
         incidentEdgeOrder);
     ValueGraphBuilder<N1, V> newBuilder = cast();
-    newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);
+    newBuilder.incidentEdgeOrder = requireNonNull(incidentEdgeOrder);
     return newBuilder;
   }
   /**
diff --git a/guava/src/com/google/common/hash/AbstractByteHasher.java b/guava/src/com/google/common/hash/AbstractByteHasher.java
index 9f7e041909..49d96cbc0c 100644
--- a/guava/src/com/google/common/hash/AbstractByteHasher.java
+++ b/guava/src/com/google/common/hash/AbstractByteHasher.java
@@ -14,8 +14,8 @@
 
 package com.google.common.hash;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.primitives.Chars;
 import com.google.common.primitives.Ints;
@@ -81,7 +81,7 @@ abstract class AbstractByteHasher extends AbstractHasher {
 
   @Override
   public Hasher putBytes(byte[] bytes) {
-    checkNotNull(bytes);
+    requireNonNull(bytes);
     update(bytes);
     return this;
   }
diff --git a/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java b/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java
index 820fe963bf..941c8c38ef 100644
--- a/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java
+++ b/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java
@@ -15,7 +15,7 @@
 package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
@@ -38,7 +38,7 @@ abstract class AbstractCompositeHashFunction extends AbstractHashFunction {
 
   AbstractCompositeHashFunction(HashFunction... functions) {
     for (HashFunction function : functions) {
-      checkNotNull(function);
+      requireNonNull(function);
     }
     this.functions = functions;
   }
diff --git a/guava/src/com/google/common/hash/AbstractHasher.java b/guava/src/com/google/common/hash/AbstractHasher.java
index c72e05be05..9afd67b475 100644
--- a/guava/src/com/google/common/hash/AbstractHasher.java
+++ b/guava/src/com/google/common/hash/AbstractHasher.java
@@ -14,7 +14,8 @@
 
 package com.google.common.hash;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
+
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
@@ -64,7 +65,7 @@ abstract class AbstractHasher implements Hasher {
 
   @Override
   public Hasher putBytes(byte[] bytes, int off, int len) {
-    Preconditions.checkPositionIndexes(off, off + len, bytes.length);
+    checkPositionIndexes(off, off + len, bytes.length);
     for (int i = 0; i < len; i++) {
       putByte(bytes[off + i]);
     }
diff --git a/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java b/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java
index 4969e35b22..8b579410df 100644
--- a/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java
+++ b/guava/src/com/google/common/hash/AbstractNonStreamingHashFunction.java
@@ -14,7 +14,8 @@
 
 package com.google.common.hash;
 
-import com.google.common.base.Preconditions;
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.errorprone.annotations.Immutable;
 import java.io.ByteArrayOutputStream;
 import java.nio.ByteBuffer;
@@ -39,7 +40,7 @@ abstract class AbstractNonStreamingHashFunction extends AbstractHashFunction {
 
   @Override
   public Hasher newHasher(int expectedInputSize) {
-    Preconditions.checkArgument(expectedInputSize >= 0);
+    checkArgument(expectedInputSize >= 0);
     return new BufferingHasher(expectedInputSize);
   }
 
diff --git a/guava/src/com/google/common/hash/BloomFilter.java b/guava/src/com/google/common/hash/BloomFilter.java
index 889ab5049c..1e4a370dbb 100644
--- a/guava/src/com/google/common/hash/BloomFilter.java
+++ b/guava/src/com/google/common/hash/BloomFilter.java
@@ -15,7 +15,7 @@
 package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.VisibleForTesting;
@@ -124,10 +124,10 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
     checkArgument(numHashFunctions > 0, "numHashFunctions (%s) must be > 0", numHashFunctions);
     checkArgument(
         numHashFunctions <= 255, "numHashFunctions (%s) must be <= 255", numHashFunctions);
-    this.bits = checkNotNull(bits);
+    this.bits = requireNonNull(bits);
     this.numHashFunctions = numHashFunctions;
-    this.funnel = checkNotNull(funnel);
-    this.strategy = checkNotNull(strategy);
+    this.funnel = requireNonNull(funnel);
+    this.strategy = requireNonNull(strategy);
   }
 
   /**
@@ -233,7 +233,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @since 15.0
    */
   public boolean isCompatible(BloomFilter<T> that) {
-    checkNotNull(that);
+    requireNonNull(that);
     return this != that
         && this.numHashFunctions == that.numHashFunctions
         && this.bitSize() == that.bitSize()
@@ -251,7 +251,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    * @since 15.0
    */
   public void putAll(BloomFilter<T> that) {
-    checkNotNull(that);
+    requireNonNull(that);
     checkArgument(this != that, "Cannot combine a BloomFilter with itself.");
     checkArgument(
         this.numHashFunctions == that.numHashFunctions,
@@ -346,7 +346,7 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    */
   public static <T extends @Nullable Object> Collector<T, ?, BloomFilter<T>> toBloomFilter(
       Funnel<? super T> funnel, long expectedInsertions, double fpp) {
-    checkNotNull(funnel);
+    requireNonNull(funnel);
     checkArgument(
         expectedInsertions >= 0, "Expected insertions (%s) must be >= 0", expectedInsertions);
     checkArgument(fpp > 0.0, "False positive probability (%s) must be > 0.0", fpp);
@@ -416,12 +416,12 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
   @VisibleForTesting
   static <T extends @Nullable Object> BloomFilter<T> create(
       Funnel<? super T> funnel, long expectedInsertions, double fpp, Strategy strategy) {
-    checkNotNull(funnel);
+    requireNonNull(funnel);
     checkArgument(
         expectedInsertions >= 0, "Expected insertions (%s) must be >= 0", expectedInsertions);
     checkArgument(fpp > 0.0, "False positive probability (%s) must be > 0.0", fpp);
     checkArgument(fpp < 1.0, "False positive probability (%s) must be < 1.0", fpp);
-    checkNotNull(strategy);
+    requireNonNull(strategy);
 
     if (expectedInsertions == 0) {
       expectedInsertions = 1;
@@ -593,8 +593,8 @@ public final class BloomFilter<T extends @Nullable Object> implements Predicate<
    */
   public static <T extends @Nullable Object> BloomFilter<T> readFrom(
       InputStream in, Funnel<? super T> funnel) throws IOException {
-    checkNotNull(in, "InputStream");
-    checkNotNull(funnel, "Funnel");
+    requireNonNull(in, "InputStream");
+    requireNonNull(funnel, "Funnel");
     int strategyOrdinal = -1;
     int numHashFunctions = -1;
     int dataLength = -1;
diff --git a/guava/src/com/google/common/hash/ChecksumHashFunction.java b/guava/src/com/google/common/hash/ChecksumHashFunction.java
index 159adbb819..36cb70961e 100644
--- a/guava/src/com/google/common/hash/ChecksumHashFunction.java
+++ b/guava/src/com/google/common/hash/ChecksumHashFunction.java
@@ -15,7 +15,7 @@
 package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
@@ -35,10 +35,10 @@ final class ChecksumHashFunction extends AbstractHashFunction implements Seriali
 
   ChecksumHashFunction(
       ImmutableSupplier<? extends Checksum> checksumSupplier, int bits, String toString) {
-    this.checksumSupplier = checkNotNull(checksumSupplier);
+    this.checksumSupplier = requireNonNull(checksumSupplier);
     checkArgument(bits == 32 || bits == 64, "bits (%s) must be either 32 or 64", bits);
     this.bits = bits;
-    this.toString = checkNotNull(toString);
+    this.toString = requireNonNull(toString);
   }
 
   @Override
@@ -61,7 +61,7 @@ final class ChecksumHashFunction extends AbstractHashFunction implements Seriali
     private final Checksum checksum;
 
     private ChecksumHasher(Checksum checksum) {
-      this.checksum = checkNotNull(checksum);
+      this.checksum = requireNonNull(checksum);
     }
 
     @Override
diff --git a/guava/src/com/google/common/hash/Crc32cHashFunction.java b/guava/src/com/google/common/hash/Crc32cHashFunction.java
index 8e17e6538c..9466baadf0 100644
--- a/guava/src/com/google/common/hash/Crc32cHashFunction.java
+++ b/guava/src/com/google/common/hash/Crc32cHashFunction.java
@@ -14,6 +14,8 @@
 
 package com.google.common.hash;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 
@@ -81,10 +83,8 @@ final class Crc32cHashFunction extends AbstractHashFunction {
 
     @Override
     protected void process(ByteBuffer bb) {
-      if (finished) {
-        throw new IllegalStateException(
-            "The behavior of calling any method after calling hash() is undefined.");
-      }
+      checkState(
+          !finished, "The behavior of calling any method after calling hash() is undefined.");
       while (bb.remaining() >= 16) {
         crc0 = computeForWord(crc0);
         crc1 = computeForWord(crc1);
diff --git a/guava/src/com/google/common/hash/Fingerprint2011.java b/guava/src/com/google/common/hash/Fingerprint2011.java
index 1b01e00924..ff5ee5088e 100644
--- a/guava/src/com/google/common/hash/Fingerprint2011.java
+++ b/guava/src/com/google/common/hash/Fingerprint2011.java
@@ -192,7 +192,6 @@ final class Fingerprint2011 extends AbstractNonStreamingHashFunction {
     }
 
     hash = shiftMix(hash) * mul;
-    hash = shiftMix(hash);
-    return hash;
+    return shiftMix(hash);
   }
 }
diff --git a/guava/src/com/google/common/hash/Funnels.java b/guava/src/com/google/common/hash/Funnels.java
index b8e63d504d..57d7d6e55a 100644
--- a/guava/src/com/google/common/hash/Funnels.java
+++ b/guava/src/com/google/common/hash/Funnels.java
@@ -14,8 +14,9 @@
 
 package com.google.common.hash;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.Beta;
-import com.google.common.base.Preconditions;
 import java.io.OutputStream;
 import java.io.Serializable;
 import java.nio.charset.Charset;
@@ -91,7 +92,7 @@ public final class Funnels {
     private final Charset charset;
 
     StringCharsetFunnel(Charset charset) {
-      this.charset = Preconditions.checkNotNull(charset);
+      this.charset = requireNonNull(charset);
     }
 
     @Override
@@ -176,7 +177,7 @@ public final class Funnels {
     private final Funnel<E> elementFunnel;
 
     SequentialFunnel(Funnel<E> elementFunnel) {
-      this.elementFunnel = Preconditions.checkNotNull(elementFunnel);
+      this.elementFunnel = requireNonNull(elementFunnel);
     }
 
     @Override
@@ -247,7 +248,7 @@ public final class Funnels {
     final PrimitiveSink sink;
 
     SinkAsStream(PrimitiveSink sink) {
-      this.sink = Preconditions.checkNotNull(sink);
+      this.sink = requireNonNull(sink);
     }
 
     @Override
diff --git a/guava/src/com/google/common/hash/HashCode.java b/guava/src/com/google/common/hash/HashCode.java
index fde2a86d64..21d1c56583 100644
--- a/guava/src/com/google/common/hash/HashCode.java
+++ b/guava/src/com/google/common/hash/HashCode.java
@@ -15,10 +15,10 @@
 package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
-import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.UnsignedInts;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -84,7 +84,7 @@ public abstract class HashCode {
   @CanIgnoreReturnValue
   public int writeBytesTo(byte[] dest, int offset, int maxLength) {
     maxLength = Ints.min(maxLength, bits() / 8);
-    Preconditions.checkPositionIndexes(offset, offset + maxLength, dest.length);
+    checkPositionIndexes(offset, offset + maxLength, dest.length);
     writeBytesToImpl(dest, offset, maxLength);
     return maxLength;
   }
@@ -252,7 +252,7 @@ public abstract class HashCode {
     final byte[] bytes;
 
     BytesHashCode(byte[] bytes) {
-      this.bytes = checkNotNull(bytes);
+      this.bytes = requireNonNull(bytes);
     }
 
     @Override
diff --git a/guava/src/com/google/common/hash/Hasher.java b/guava/src/com/google/common/hash/Hasher.java
index b3f24fa282..1799298436 100644
--- a/guava/src/com/google/common/hash/Hasher.java
+++ b/guava/src/com/google/common/hash/Hasher.java
@@ -136,7 +136,7 @@ public interface Hasher extends PrimitiveSink {
    * @deprecated This returns {@link Object#hashCode()}; you almost certainly mean to call {@code
    *     hash().asInt()}.
    */
-  @Override
   @Deprecated
+  @Override
   int hashCode();
 }
diff --git a/guava/src/com/google/common/hash/Hashing.java b/guava/src/com/google/common/hash/Hashing.java
index 16e6bc87e7..eb02329b28 100644
--- a/guava/src/com/google/common/hash/Hashing.java
+++ b/guava/src/com/google/common/hash/Hashing.java
@@ -15,7 +15,7 @@
 package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.errorprone.annotations.Immutable;
 import java.security.Key;
@@ -295,7 +295,7 @@ public final class Hashing {
    * @since 20.0
    */
   public static HashFunction hmacMd5(byte[] key) {
-    return hmacMd5(new SecretKeySpec(checkNotNull(key), "HmacMD5"));
+    return hmacMd5(new SecretKeySpec(requireNonNull(key), "HmacMD5"));
   }
 
   /**
@@ -319,7 +319,7 @@ public final class Hashing {
    * @since 20.0
    */
   public static HashFunction hmacSha1(byte[] key) {
-    return hmacSha1(new SecretKeySpec(checkNotNull(key), "HmacSHA1"));
+    return hmacSha1(new SecretKeySpec(requireNonNull(key), "HmacSHA1"));
   }
 
   /**
@@ -343,7 +343,7 @@ public final class Hashing {
    * @since 20.0
    */
   public static HashFunction hmacSha256(byte[] key) {
-    return hmacSha256(new SecretKeySpec(checkNotNull(key), "HmacSHA256"));
+    return hmacSha256(new SecretKeySpec(requireNonNull(key), "HmacSHA256"));
   }
 
   /**
@@ -367,7 +367,7 @@ public final class Hashing {
    * @since 20.0
    */
   public static HashFunction hmacSha512(byte[] key) {
-    return hmacSha512(new SecretKeySpec(checkNotNull(key), "HmacSHA512"));
+    return hmacSha512(new SecretKeySpec(requireNonNull(key), "HmacSHA512"));
   }
 
   private static String hmacToString(String methodName, Key key) {
@@ -657,7 +657,7 @@ public final class Hashing {
    * @since 19.0
    */
   public static HashFunction concatenating(Iterable<HashFunction> hashFunctions) {
-    checkNotNull(hashFunctions);
+    requireNonNull(hashFunctions);
     // We can't use Iterables.toArray() here because there's no hash->collect dependency
     List<HashFunction> list = new ArrayList<>();
     for (HashFunction hashFunction : hashFunctions) {
diff --git a/guava/src/com/google/common/hash/HashingInputStream.java b/guava/src/com/google/common/hash/HashingInputStream.java
index bf9464ce55..4e5f90e69d 100644
--- a/guava/src/com/google/common/hash/HashingInputStream.java
+++ b/guava/src/com/google/common/hash/HashingInputStream.java
@@ -14,7 +14,7 @@
 
 package com.google.common.hash;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -40,16 +40,16 @@ public final class HashingInputStream extends FilterInputStream {
    * <p>The {@link InputStream} should not be read from before or after the hand-off.
    */
   public HashingInputStream(HashFunction hashFunction, InputStream in) {
-    super(checkNotNull(in));
-    this.hasher = checkNotNull(hashFunction.newHasher());
+    super(requireNonNull(in));
+    this.hasher = requireNonNull(hashFunction.newHasher());
   }
 
   /**
    * Reads the next byte of data from the underlying input stream and updates the hasher with the
    * byte read.
    */
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public int read() throws IOException {
     int b = in.read();
     if (b != -1) {
@@ -62,8 +62,8 @@ public final class HashingInputStream extends FilterInputStream {
    * Reads the specified bytes of data from the underlying input stream and updates the hasher with
    * the bytes read.
    */
-  @Override
   @CanIgnoreReturnValue
+  @Override
   public int read(byte[] bytes, int off, int len) throws IOException {
     int numOfBytesRead = in.read(bytes, off, len);
     if (numOfBytesRead != -1) {
diff --git a/guava/src/com/google/common/hash/HashingOutputStream.java b/guava/src/com/google/common/hash/HashingOutputStream.java
index f138bba150..8faec61972 100644
--- a/guava/src/com/google/common/hash/HashingOutputStream.java
+++ b/guava/src/com/google/common/hash/HashingOutputStream.java
@@ -14,7 +14,7 @@
 
 package com.google.common.hash;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import java.io.FilterOutputStream;
@@ -43,8 +43,8 @@ public final class HashingOutputStream extends FilterOutputStream {
   // be (optionally) be combined with another if needed (with something like
   // MultiplexingOutputStream).
   public HashingOutputStream(HashFunction hashFunction, OutputStream out) {
-    super(checkNotNull(out));
-    this.hasher = checkNotNull(hashFunction.newHasher());
+    super(requireNonNull(out));
+    this.hasher = requireNonNull(hashFunction.newHasher());
   }
 
   @Override
diff --git a/guava/src/com/google/common/hash/MacHashFunction.java b/guava/src/com/google/common/hash/MacHashFunction.java
index 6d53a54c39..acf601a73a 100644
--- a/guava/src/com/google/common/hash/MacHashFunction.java
+++ b/guava/src/com/google/common/hash/MacHashFunction.java
@@ -14,8 +14,8 @@
 
 package com.google.common.hash;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
@@ -45,8 +45,8 @@ final class MacHashFunction extends AbstractHashFunction {
 
   MacHashFunction(String algorithmName, Key key, String toString) {
     this.prototype = getMac(algorithmName, key);
-    this.key = checkNotNull(key);
-    this.toString = checkNotNull(toString);
+    this.key = requireNonNull(key);
+    this.toString = requireNonNull(toString);
     this.bits = prototype.getMacLength() * Byte.SIZE;
     this.supportsClone = supportsClone(prototype);
   }
@@ -124,7 +124,7 @@ final class MacHashFunction extends AbstractHashFunction {
     @Override
     protected void update(ByteBuffer bytes) {
       checkNotDone();
-      checkNotNull(bytes);
+      requireNonNull(bytes);
       mac.update(bytes);
     }
 
diff --git a/guava/src/com/google/common/hash/MessageDigestHashFunction.java b/guava/src/com/google/common/hash/MessageDigestHashFunction.java
index 43fc087f28..48d2e44c4e 100644
--- a/guava/src/com/google/common/hash/MessageDigestHashFunction.java
+++ b/guava/src/com/google/common/hash/MessageDigestHashFunction.java
@@ -15,8 +15,8 @@
 package com.google.common.hash;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
@@ -45,12 +45,12 @@ final class MessageDigestHashFunction extends AbstractHashFunction implements Se
   MessageDigestHashFunction(String algorithmName, String toString) {
     this.prototype = getMessageDigest(algorithmName);
     this.bytes = prototype.getDigestLength();
-    this.toString = checkNotNull(toString);
+    this.toString = requireNonNull(toString);
     this.supportsClone = supportsClone(prototype);
   }
 
   MessageDigestHashFunction(String algorithmName, int bytes, String toString) {
-    this.toString = checkNotNull(toString);
+    this.toString = requireNonNull(toString);
     this.prototype = getMessageDigest(algorithmName);
     int maxLength = prototype.getDigestLength();
     checkArgument(
diff --git a/guava/src/com/google/common/hash/Murmur3_32HashFunction.java b/guava/src/com/google/common/hash/Murmur3_32HashFunction.java
index a47184be58..62ed61b1aa 100644
--- a/guava/src/com/google/common/hash/Murmur3_32HashFunction.java
+++ b/guava/src/com/google/common/hash/Murmur3_32HashFunction.java
@@ -148,8 +148,8 @@ final class Murmur3_32HashFunction extends AbstractHashFunction implements Seria
     return fmix(h1, Chars.BYTES * input.length());
   }
 
-  @SuppressWarnings("deprecation") // need to use Charsets for Android tests to pass
-  @Override
+  @Override // need to use Charsets for Android tests to pass
+  @SuppressWarnings("deprecation")
   public HashCode hashString(CharSequence input, Charset charset) {
     if (Charsets.UTF_8.equals(charset)) {
       int utf16Length = input.length();
@@ -252,8 +252,7 @@ final class Murmur3_32HashFunction extends AbstractHashFunction implements Seria
   private static int mixH1(int h1, int k1) {
     h1 ^= k1;
     h1 = Integer.rotateLeft(h1, 13);
-    h1 = h1 * 5 + 0xe6546b64;
-    return h1;
+    return h1 * 5 + 0xe6546b64;
   }
 
   // Finalization mix - force all bits of a hash block to avalanche
@@ -346,8 +345,8 @@ final class Murmur3_32HashFunction extends AbstractHashFunction implements Seria
       return this;
     }
 
-    @SuppressWarnings("deprecation") // need to use Charsets for Android tests to pass
-    @Override
+    @Override // need to use Charsets for Android tests to pass
+    @SuppressWarnings("deprecation")
     public Hasher putString(CharSequence input, Charset charset) {
       if (Charsets.UTF_8.equals(charset)) {
         int utf16Length = input.length();
diff --git a/guava/src/com/google/common/io/AppendableWriter.java b/guava/src/com/google/common/io/AppendableWriter.java
index d9aab342f2..aaca67d1b8 100644
--- a/guava/src/com/google/common/io/AppendableWriter.java
+++ b/guava/src/com/google/common/io/AppendableWriter.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import java.io.Closeable;
@@ -43,7 +43,7 @@ class AppendableWriter extends Writer {
    * @param target target to which to append output
    */
   AppendableWriter(Appendable target) {
-    this.target = checkNotNull(target);
+    this.target = requireNonNull(target);
   }
 
   /*
@@ -70,14 +70,14 @@ class AppendableWriter extends Writer {
 
   @Override
   public void write(String str) throws IOException {
-    checkNotNull(str);
+    requireNonNull(str);
     checkNotClosed();
     target.append(str);
   }
 
   @Override
   public void write(String str, int off, int len) throws IOException {
-    checkNotNull(str);
+    requireNonNull(str);
     checkNotClosed();
     // tricky: append takes start, end pair...
     target.append(str, off, off + len);
diff --git a/guava/src/com/google/common/io/BaseEncoding.java b/guava/src/com/google/common/io/BaseEncoding.java
index 9eb3a859d9..fc0c56a920 100644
--- a/guava/src/com/google/common/io/BaseEncoding.java
+++ b/guava/src/com/google/common/io/BaseEncoding.java
@@ -15,7 +15,6 @@
 package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.math.IntMath.divide;
@@ -23,6 +22,7 @@ import static com.google.common.math.IntMath.log2;
 import static java.math.RoundingMode.CEILING;
 import static java.math.RoundingMode.FLOOR;
 import static java.math.RoundingMode.UNNECESSARY;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -177,7 +177,7 @@ public abstract class BaseEncoding {
    */
   @GwtIncompatible // ByteSink,CharSink
   public final ByteSink encodingSink(CharSink encodedSink) {
-    checkNotNull(encodedSink);
+    requireNonNull(encodedSink);
     return new ByteSink() {
       @Override
       public OutputStream openStream() throws IOException {
@@ -247,7 +247,7 @@ public abstract class BaseEncoding {
    */
   @GwtIncompatible // ByteSource,CharSource
   public final ByteSource decodingSource(CharSource encodedSource) {
-    checkNotNull(encodedSource);
+    requireNonNull(encodedSource);
     return new ByteSource() {
       @Override
       public InputStream openStream() throws IOException {
@@ -267,7 +267,7 @@ public abstract class BaseEncoding {
   abstract int decodeTo(byte[] target, CharSequence chars) throws DecodingException;
 
   CharSequence trimTrailingPadding(CharSequence chars) {
-    return checkNotNull(chars);
+    return requireNonNull(chars);
   }
 
   // Modified encoding generators
@@ -429,8 +429,8 @@ public abstract class BaseEncoding {
     private final boolean[] validPadding;
 
     Alphabet(String name, char[] chars) {
-      this.name = checkNotNull(name);
-      this.chars = checkNotNull(chars);
+      this.name = requireNonNull(name);
+      this.chars = requireNonNull(chars);
       try {
         this.bitsPerChar = log2(chars.length, UNNECESSARY);
       } catch (ArithmeticException e) {
@@ -572,7 +572,7 @@ public abstract class BaseEncoding {
     }
 
     StandardBaseEncoding(Alphabet alphabet, @CheckForNull Character paddingChar) {
-      this.alphabet = checkNotNull(alphabet);
+      this.alphabet = requireNonNull(alphabet);
       checkArgument(
           paddingChar == null || !alphabet.matches(paddingChar),
           "Padding character %s was already in alphabet",
@@ -588,7 +588,7 @@ public abstract class BaseEncoding {
     @GwtIncompatible // Writer,OutputStream
     @Override
     public OutputStream encodingStream(Writer out) {
-      checkNotNull(out);
+      requireNonNull(out);
       return new OutputStream() {
         int bitBuffer = 0;
         int bitBufferLength = 0;
@@ -632,7 +632,7 @@ public abstract class BaseEncoding {
 
     @Override
     void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {
-      checkNotNull(target);
+      requireNonNull(target);
       checkPositionIndexes(off, off + len, bytes.length);
       for (int i = 0; i < len; i += alphabet.bytesPerChunk) {
         encodeChunkTo(target, bytes, off + i, Math.min(alphabet.bytesPerChunk, len - i));
@@ -640,7 +640,7 @@ public abstract class BaseEncoding {
     }
 
     void encodeChunkTo(Appendable target, byte[] bytes, int off, int len) throws IOException {
-      checkNotNull(target);
+      requireNonNull(target);
       checkPositionIndexes(off, off + len, bytes.length);
       checkArgument(len <= alphabet.bytesPerChunk);
       long bitBuffer = 0;
@@ -671,7 +671,7 @@ public abstract class BaseEncoding {
 
     @Override
     CharSequence trimTrailingPadding(CharSequence chars) {
-      checkNotNull(chars);
+      requireNonNull(chars);
       if (paddingChar == null) {
         return chars;
       }
@@ -687,7 +687,7 @@ public abstract class BaseEncoding {
 
     @Override
     public boolean canDecode(CharSequence chars) {
-      checkNotNull(chars);
+      requireNonNull(chars);
       chars = trimTrailingPadding(chars);
       if (!alphabet.isValidPaddingStartPosition(chars.length())) {
         return false;
@@ -702,7 +702,7 @@ public abstract class BaseEncoding {
 
     @Override
     int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
-      checkNotNull(target);
+      requireNonNull(target);
       chars = trimTrailingPadding(chars);
       if (!alphabet.isValidPaddingStartPosition(chars.length())) {
         throw new DecodingException("Invalid input length " + chars.length());
@@ -725,10 +725,10 @@ public abstract class BaseEncoding {
       return bytesWritten;
     }
 
-    @Override
-    @GwtIncompatible // Reader,InputStream
+    @GwtIncompatible
+    @Override // Reader,InputStream
     public InputStream decodingStream(Reader reader) {
-      checkNotNull(reader);
+      requireNonNull(reader);
       return new InputStream() {
         int bitBuffer = 0;
         int bitBufferLength = 0;
@@ -859,7 +859,7 @@ public abstract class BaseEncoding {
     @Override
     public String toString() {
       StringBuilder builder = new StringBuilder("BaseEncoding.");
-      builder.append(alphabet.toString());
+      builder.append(alphabet);
       if (8 % alphabet.bitsPerChar != 0) {
         if (paddingChar == null) {
           builder.append(".omitPadding()");
@@ -904,7 +904,7 @@ public abstract class BaseEncoding {
 
     @Override
     void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {
-      checkNotNull(target);
+      requireNonNull(target);
       checkPositionIndexes(off, off + len, bytes.length);
       for (int i = 0; i < len; ++i) {
         int b = bytes[off + i] & 0xFF;
@@ -915,7 +915,7 @@ public abstract class BaseEncoding {
 
     @Override
     int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
-      checkNotNull(target);
+      requireNonNull(target);
       if (chars.length() % 2 == 1) {
         throw new DecodingException("Invalid input length " + chars.length());
       }
@@ -945,7 +945,7 @@ public abstract class BaseEncoding {
 
     @Override
     void encodeTo(Appendable target, byte[] bytes, int off, int len) throws IOException {
-      checkNotNull(target);
+      requireNonNull(target);
       checkPositionIndexes(off, off + len, bytes.length);
       int i = off;
       for (int remaining = len; remaining >= 3; remaining -= 3) {
@@ -962,7 +962,7 @@ public abstract class BaseEncoding {
 
     @Override
     int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
-      checkNotNull(target);
+      requireNonNull(target);
       chars = trimTrailingPadding(chars);
       if (!alphabet.isValidPaddingStartPosition(chars.length())) {
         throw new DecodingException("Invalid input length " + chars.length());
@@ -992,8 +992,8 @@ public abstract class BaseEncoding {
 
   @GwtIncompatible
   static Reader ignoringReader(Reader delegate, String toIgnore) {
-    checkNotNull(delegate);
-    checkNotNull(toIgnore);
+    requireNonNull(delegate);
+    requireNonNull(toIgnore);
     return new Reader() {
       @Override
       public int read() throws IOException {
@@ -1018,8 +1018,8 @@ public abstract class BaseEncoding {
 
   static Appendable separatingAppendable(
       Appendable delegate, String separator, int afterEveryChars) {
-    checkNotNull(delegate);
-    checkNotNull(separator);
+    requireNonNull(delegate);
+    requireNonNull(separator);
     checkArgument(afterEveryChars > 0);
     return new Appendable() {
       int charsUntilSeparator = afterEveryChars;
@@ -1079,8 +1079,8 @@ public abstract class BaseEncoding {
     private final int afterEveryChars;
 
     SeparatedBaseEncoding(BaseEncoding delegate, String separator, int afterEveryChars) {
-      this.delegate = checkNotNull(delegate);
-      this.separator = checkNotNull(separator);
+      this.delegate = requireNonNull(delegate);
+      this.separator = requireNonNull(separator);
       this.afterEveryChars = afterEveryChars;
       checkArgument(
           afterEveryChars > 0, "Cannot add a separator after every %s chars", afterEveryChars);
@@ -1138,8 +1138,8 @@ public abstract class BaseEncoding {
       return delegate.decodeTo(target, stripped);
     }
 
-    @Override
-    @GwtIncompatible // Reader,InputStream
+    @GwtIncompatible
+    @Override // Reader,InputStream
     public InputStream decodingStream(Reader reader) {
       return delegate.decodingStream(ignoringReader(reader, separator));
     }
diff --git a/guava/src/com/google/common/io/ByteArrayDataInput.java b/guava/src/com/google/common/io/ByteArrayDataInput.java
index cf84fcc136..c96d2563f7 100644
--- a/guava/src/com/google/common/io/ByteArrayDataInput.java
+++ b/guava/src/com/google/common/io/ByteArrayDataInput.java
@@ -87,8 +87,8 @@ public interface ByteArrayDataInput extends DataInput {
   double readDouble();
 
   @CanIgnoreReturnValue // to skip a line
-  @Override
   @CheckForNull
+  @Override
   String readLine();
 
   @CanIgnoreReturnValue // to skip a field
diff --git a/guava/src/com/google/common/io/ByteSink.java b/guava/src/com/google/common/io/ByteSink.java
index 7a6af6fc58..e09559812e 100644
--- a/guava/src/com/google/common/io/ByteSink.java
+++ b/guava/src/com/google/common/io/ByteSink.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -95,7 +95,7 @@ public abstract class ByteSink {
    * @throws IOException if an I/O occurs while writing to this sink
    */
   public void write(byte[] bytes) throws IOException {
-    checkNotNull(bytes);
+    requireNonNull(bytes);
 
     Closer closer = Closer.create();
     try {
@@ -118,7 +118,7 @@ public abstract class ByteSink {
    */
   @CanIgnoreReturnValue
   public long writeFrom(InputStream input) throws IOException {
-    checkNotNull(input);
+    requireNonNull(input);
 
     Closer closer = Closer.create();
     try {
@@ -142,7 +142,7 @@ public abstract class ByteSink {
     private final Charset charset;
 
     private AsCharSink(Charset charset) {
-      this.charset = checkNotNull(charset);
+      this.charset = requireNonNull(charset);
     }
 
     @Override
@@ -152,7 +152,7 @@ public abstract class ByteSink {
 
     @Override
     public String toString() {
-      return ByteSink.this.toString() + ".asCharSink(" + charset + ")";
+      return ByteSink.this + ".asCharSink(" + charset + ")";
     }
   }
 }
diff --git a/guava/src/com/google/common/io/ByteSource.java b/guava/src/com/google/common/io/ByteSource.java
index c8da9678b8..649a3638d9 100644
--- a/guava/src/com/google/common/io/ByteSource.java
+++ b/guava/src/com/google/common/io/ByteSource.java
@@ -15,9 +15,9 @@
 package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.io.ByteStreams.createBuffer;
 import static com.google.common.io.ByteStreams.skipUpTo;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -249,7 +249,7 @@ public abstract class ByteSource {
    */
   @CanIgnoreReturnValue
   public long copyTo(OutputStream output) throws IOException {
-    checkNotNull(output);
+    requireNonNull(output);
 
     Closer closer = Closer.create();
     try {
@@ -271,7 +271,7 @@ public abstract class ByteSource {
    */
   @CanIgnoreReturnValue
   public long copyTo(ByteSink sink) throws IOException {
-    checkNotNull(sink);
+    requireNonNull(sink);
 
     Closer closer = Closer.create();
     try {
@@ -317,7 +317,7 @@ public abstract class ByteSource {
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
   public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
-    checkNotNull(processor);
+    requireNonNull(processor);
 
     Closer closer = Closer.create();
     try {
@@ -348,7 +348,7 @@ public abstract class ByteSource {
    * @throws IOException if an I/O error occurs while reading from this source or {@code other}
    */
   public boolean contentEquals(ByteSource other) throws IOException {
-    checkNotNull(other);
+    requireNonNull(other);
 
     byte[] buf1 = createBuffer();
     byte[] buf2 = createBuffer();
@@ -458,7 +458,7 @@ public abstract class ByteSource {
     final Charset charset;
 
     AsCharSource(Charset charset) {
-      this.charset = checkNotNull(charset);
+      this.charset = requireNonNull(charset);
     }
 
     @Override
@@ -488,7 +488,7 @@ public abstract class ByteSource {
 
     @Override
     public String toString() {
-      return ByteSource.this.toString() + ".asCharSource(" + charset + ")";
+      return ByteSource.this + ".asCharSource(" + charset + ")";
     }
   }
 
@@ -567,7 +567,7 @@ public abstract class ByteSource {
 
     @Override
     public String toString() {
-      return ByteSource.this.toString() + ".slice(" + offset + ", " + length + ")";
+      return ByteSource.this + ".slice(" + offset + ", " + length + ")";
     }
   }
 
@@ -618,9 +618,9 @@ public abstract class ByteSource {
       return Arrays.copyOfRange(bytes, offset, offset + length);
     }
 
-    @SuppressWarnings("CheckReturnValue") // it doesn't matter what processBytes returns here
-    @Override
+    @Override // it doesn't matter what processBytes returns here
     @ParametricNullness
+    @SuppressWarnings("CheckReturnValue")
     public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
       processor.processBytes(bytes, offset, length);
       return processor.getResult();
@@ -666,7 +666,7 @@ public abstract class ByteSource {
 
     @Override
     public CharSource asCharSource(Charset charset) {
-      checkNotNull(charset);
+      requireNonNull(charset);
       return CharSource.empty();
     }
 
@@ -686,7 +686,7 @@ public abstract class ByteSource {
     final Iterable<? extends ByteSource> sources;
 
     ConcatenatedByteSource(Iterable<? extends ByteSource> sources) {
-      this.sources = checkNotNull(sources);
+      this.sources = requireNonNull(sources);
     }
 
     @Override
diff --git a/guava/src/com/google/common/io/ByteStreams.java b/guava/src/com/google/common/io/ByteStreams.java
index 99213bf16b..f99e23dd65 100644
--- a/guava/src/com/google/common/io/ByteStreams.java
+++ b/guava/src/com/google/common/io/ByteStreams.java
@@ -15,11 +15,11 @@
 package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static java.lang.Math.max;
 import static java.lang.Math.min;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -106,8 +106,8 @@ public final class ByteStreams {
    */
   @CanIgnoreReturnValue
   public static long copy(InputStream from, OutputStream to) throws IOException {
-    checkNotNull(from);
-    checkNotNull(to);
+    requireNonNull(from);
+    requireNonNull(to);
     byte[] buf = createBuffer();
     long total = 0;
     while (true) {
@@ -132,8 +132,8 @@ public final class ByteStreams {
    */
   @CanIgnoreReturnValue
   public static long copy(ReadableByteChannel from, WritableByteChannel to) throws IOException {
-    checkNotNull(from);
-    checkNotNull(to);
+    requireNonNull(from);
+    requireNonNull(to);
     if (from instanceof FileChannel) {
       FileChannel sourceChannel = (FileChannel) from;
       long oldPosition = sourceChannel.position();
@@ -234,7 +234,7 @@ public final class ByteStreams {
    * @throws IOException if an I/O error occurs
    */
   public static byte[] toByteArray(InputStream in) throws IOException {
-    checkNotNull(in);
+    requireNonNull(in);
     return toByteArrayInternal(in, new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE), 0);
   }
 
@@ -282,8 +282,8 @@ public final class ByteStreams {
    *
    * @since 20.0
    */
-  @CanIgnoreReturnValue
   @Beta
+  @CanIgnoreReturnValue
   public static long exhaust(InputStream in) throws IOException {
     long total = 0;
     long read;
@@ -325,7 +325,7 @@ public final class ByteStreams {
    */
   @Beta
   public static ByteArrayDataInput newDataInput(ByteArrayInputStream byteArrayInputStream) {
-    return new ByteArrayDataInputStream(checkNotNull(byteArrayInputStream));
+    return new ByteArrayDataInputStream(requireNonNull(byteArrayInputStream));
   }
 
   private static class ByteArrayDataInputStream implements ByteArrayDataInput {
@@ -454,8 +454,8 @@ public final class ByteStreams {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     public String readLine() {
       try {
         return input.readLine();
@@ -490,9 +490,7 @@ public final class ByteStreams {
   public static ByteArrayDataOutput newDataOutput(int size) {
     // When called at high frequency, boxing size generates too much garbage,
     // so avoid doing that if we can.
-    if (size < 0) {
-      throw new IllegalArgumentException(String.format("Invalid size: %s", size));
-    }
+    checkArgument(size >= 0, String.format("Invalid size: %s", size));
     return newDataOutput(new ByteArrayOutputStream(size));
   }
 
@@ -510,7 +508,7 @@ public final class ByteStreams {
    */
   @Beta
   public static ByteArrayDataOutput newDataOutput(ByteArrayOutputStream byteArrayOutputStream) {
-    return new ByteArrayDataOutputStream(checkNotNull(byteArrayOutputStream));
+    return new ByteArrayDataOutputStream(requireNonNull(byteArrayOutputStream));
   }
 
   private static class ByteArrayDataOutputStream implements ByteArrayDataOutput {
@@ -664,13 +662,13 @@ public final class ByteStreams {
         /** Discards the specified byte array. */
         @Override
         public void write(byte[] b) {
-          checkNotNull(b);
+          requireNonNull(b);
         }
 
         /** Discards the specified byte array. */
         @Override
         public void write(byte[] b, int off, int len) {
-          checkNotNull(b);
+          requireNonNull(b);
           checkPositionIndexes(off, off + len, b.length);
         }
 
@@ -710,7 +708,7 @@ public final class ByteStreams {
 
     LimitedInputStream(InputStream in, long limit) {
       super(in);
-      checkNotNull(in);
+      requireNonNull(in);
       checkArgument(limit >= 0, "limit must be non-negative");
       left = limit;
     }
@@ -891,8 +889,8 @@ public final class ByteStreams {
   @ParametricNullness
   public static <T extends @Nullable Object> T readBytes(
       InputStream input, ByteProcessor<T> processor) throws IOException {
-    checkNotNull(input);
-    checkNotNull(processor);
+    requireNonNull(input);
+    requireNonNull(processor);
 
     byte[] buf = createBuffer();
     int read;
@@ -931,8 +929,8 @@ public final class ByteStreams {
   // Sometimes you don't care how many bytes you actually read, I guess.
   // (You know that it's either going to read len bytes or stop at EOF.)
   public static int read(InputStream in, byte[] b, int off, int len) throws IOException {
-    checkNotNull(in);
-    checkNotNull(b);
+    requireNonNull(in);
+    requireNonNull(b);
     if (len < 0) {
       throw new IndexOutOfBoundsException(String.format("len (%s) cannot be negative", len));
     }
diff --git a/guava/src/com/google/common/io/CharSequenceReader.java b/guava/src/com/google/common/io/CharSequenceReader.java
index 790e266236..74ee117655 100644
--- a/guava/src/com/google/common/io/CharSequenceReader.java
+++ b/guava/src/com/google/common/io/CharSequenceReader.java
@@ -15,7 +15,6 @@
 package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static java.util.Objects.requireNonNull;
 
@@ -42,7 +41,7 @@ final class CharSequenceReader extends Reader {
 
   /** Creates a new reader wrapping the given character sequence. */
   public CharSequenceReader(CharSequence seq) {
-    this.seq = checkNotNull(seq);
+    this.seq = requireNonNull(seq);
   }
 
   private void checkOpen() throws IOException {
@@ -74,7 +73,7 @@ final class CharSequenceReader extends Reader {
 
   @Override
   public synchronized int read(CharBuffer target) throws IOException {
-    checkNotNull(target);
+    requireNonNull(target);
     checkOpen();
     requireNonNull(seq); // safe because of checkOpen
     if (!hasRemaining()) {
diff --git a/guava/src/com/google/common/io/CharSink.java b/guava/src/com/google/common/io/CharSink.java
index f804daeb7a..06b337f344 100644
--- a/guava/src/com/google/common/io/CharSink.java
+++ b/guava/src/com/google/common/io/CharSink.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -91,7 +91,7 @@ public abstract class CharSink {
    * @throws IOException if an I/O error while writing to this sink
    */
   public void write(CharSequence charSequence) throws IOException {
-    checkNotNull(charSequence);
+    requireNonNull(charSequence);
 
     Closer closer = Closer.create();
     try {
@@ -155,7 +155,7 @@ public abstract class CharSink {
 
   private void writeLines(Iterator<? extends CharSequence> lines, String lineSeparator)
       throws IOException {
-    checkNotNull(lineSeparator);
+    requireNonNull(lineSeparator);
 
     try (Writer out = openBufferedStream()) {
       while (lines.hasNext()) {
@@ -174,7 +174,7 @@ public abstract class CharSink {
    */
   @CanIgnoreReturnValue
   public long writeFrom(Readable readable) throws IOException {
-    checkNotNull(readable);
+    requireNonNull(readable);
 
     Closer closer = Closer.create();
     try {
diff --git a/guava/src/com/google/common/io/CharSource.java b/guava/src/com/google/common/io/CharSource.java
index 24a67af5c6..924ab9537b 100644
--- a/guava/src/com/google/common/io/CharSource.java
+++ b/guava/src/com/google/common/io/CharSource.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -23,6 +23,7 @@ import com.google.common.base.Optional;
 import com.google.common.base.Splitter;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Streams;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -246,7 +247,7 @@ public abstract class CharSource {
    */
   @CanIgnoreReturnValue
   public long copyTo(Appendable appendable) throws IOException {
-    checkNotNull(appendable);
+    requireNonNull(appendable);
 
     Closer closer = Closer.create();
     try {
@@ -268,7 +269,7 @@ public abstract class CharSource {
    */
   @CanIgnoreReturnValue
   public long copyTo(CharSink sink) throws IOException {
-    checkNotNull(sink);
+    requireNonNull(sink);
 
     Closer closer = Closer.create();
     try {
@@ -368,7 +369,7 @@ public abstract class CharSource {
   @CanIgnoreReturnValue // some processors won't return a useful result
   @ParametricNullness
   public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
-    checkNotNull(processor);
+    requireNonNull(processor);
 
     Closer closer = Closer.create();
     try {
@@ -513,7 +514,7 @@ public abstract class CharSource {
     final Charset charset;
 
     AsByteSource(Charset charset) {
-      this.charset = checkNotNull(charset);
+      this.charset = requireNonNull(charset);
     }
 
     @Override
@@ -531,7 +532,7 @@ public abstract class CharSource {
 
     @Override
     public String toString() {
-      return CharSource.this.toString() + ".asByteSource(" + charset + ")";
+      return CharSource.this + ".asByteSource(" + charset + ")";
     }
   }
 
@@ -542,7 +543,7 @@ public abstract class CharSource {
     protected final CharSequence seq;
 
     protected CharSequenceCharSource(CharSequence seq) {
-      this.seq = checkNotNull(seq);
+      this.seq = requireNonNull(seq);
     }
 
     @Override
@@ -578,8 +579,8 @@ public abstract class CharSource {
       return new AbstractIterator<String>() {
         Iterator<String> lines = LINE_SPLITTER.split(seq).iterator();
 
-        @Override
         @CheckForNull
+        @Override
         protected String computeNext() {
           if (lines.hasNext()) {
             String next = lines.next();
@@ -598,11 +599,11 @@ public abstract class CharSource {
       return Streams.stream(linesIterator());
     }
 
-    @Override
     @CheckForNull
+    @Override
     public String readFirstLine() {
       Iterator<String> lines = linesIterator();
-      return lines.hasNext() ? lines.next() : null;
+      return Iterators.getNext(lines, null);
     }
 
     @Override
@@ -661,7 +662,7 @@ public abstract class CharSource {
 
     @Override
     public long copyTo(CharSink sink) throws IOException {
-      checkNotNull(sink);
+      requireNonNull(sink);
       Closer closer = Closer.create();
       try {
         Writer writer = closer.register(sink.openStream());
@@ -694,7 +695,7 @@ public abstract class CharSource {
     private final Iterable<? extends CharSource> sources;
 
     ConcatenatedCharSource(Iterable<? extends CharSource> sources) {
-      this.sources = checkNotNull(sources);
+      this.sources = requireNonNull(sources);
     }
 
     @Override
diff --git a/guava/src/com/google/common/io/CharStreams.java b/guava/src/com/google/common/io/CharStreams.java
index d36f9a3c5c..0283624786 100644
--- a/guava/src/com/google/common/io/CharStreams.java
+++ b/guava/src/com/google/common/io/CharStreams.java
@@ -14,8 +14,8 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -79,8 +79,8 @@ public final class CharStreams {
       }
     }
 
-    checkNotNull(from);
-    checkNotNull(to);
+    requireNonNull(from);
+    requireNonNull(to);
     long total = 0;
     CharBuffer buf = createBuffer();
     while (from.read(buf) != -1) {
@@ -112,8 +112,8 @@ public final class CharStreams {
    */
   @CanIgnoreReturnValue
   static long copyReaderToBuilder(Reader from, StringBuilder to) throws IOException {
-    checkNotNull(from);
-    checkNotNull(to);
+    requireNonNull(from);
+    requireNonNull(to);
     char[] buf = new char[DEFAULT_BUF_SIZE];
     int nRead;
     long total = 0;
@@ -140,8 +140,8 @@ public final class CharStreams {
    */
   @CanIgnoreReturnValue
   static long copyReaderToWriter(Reader from, Writer to) throws IOException {
-    checkNotNull(from);
-    checkNotNull(to);
+    requireNonNull(from);
+    requireNonNull(to);
     char[] buf = new char[DEFAULT_BUF_SIZE];
     int nRead;
     long total = 0;
@@ -218,8 +218,8 @@ public final class CharStreams {
   @ParametricNullness
   public static <T extends @Nullable Object> T readLines(
       Readable readable, LineProcessor<T> processor) throws IOException {
-    checkNotNull(readable);
-    checkNotNull(processor);
+    requireNonNull(readable);
+    requireNonNull(processor);
 
     LineReader lineReader = new LineReader(readable);
     String line;
@@ -261,7 +261,7 @@ public final class CharStreams {
    */
   @Beta
   public static void skipFully(Reader reader, long n) throws IOException {
-    checkNotNull(reader);
+    requireNonNull(reader);
     while (n > 0) {
       long amt = reader.skip(n);
       if (amt == 0) {
@@ -290,7 +290,7 @@ public final class CharStreams {
 
     @Override
     public void write(char[] cbuf) {
-      checkNotNull(cbuf);
+      requireNonNull(cbuf);
     }
 
     @Override
@@ -300,7 +300,7 @@ public final class CharStreams {
 
     @Override
     public void write(String str) {
-      checkNotNull(str);
+      requireNonNull(str);
     }
 
     @Override
diff --git a/guava/src/com/google/common/io/Closer.java b/guava/src/com/google/common/io/Closer.java
index 12998eff95..469c2452b2 100644
--- a/guava/src/com/google/common/io/Closer.java
+++ b/guava/src/com/google/common/io/Closer.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -113,7 +113,7 @@ public final class Closer implements Closeable {
 
   @VisibleForTesting
   Closer(Suppressor suppressor) {
-    this.suppressor = checkNotNull(suppressor); // checkNotNull to satisfy null tests
+    this.suppressor = requireNonNull(suppressor); // checkNotNull to satisfy null tests
   }
 
   /**
@@ -147,7 +147,7 @@ public final class Closer implements Closeable {
    * @throws IOException when the given throwable is an IOException
    */
   public RuntimeException rethrow(Throwable e) throws IOException {
-    checkNotNull(e);
+    requireNonNull(e);
     thrown = e;
     Throwables.propagateIfPossible(e, IOException.class);
     throw new RuntimeException(e);
@@ -169,7 +169,7 @@ public final class Closer implements Closeable {
    */
   public <X extends Exception> RuntimeException rethrow(Throwable e, Class<X> declaredType)
       throws IOException, X {
-    checkNotNull(e);
+    requireNonNull(e);
     thrown = e;
     Throwables.propagateIfPossible(e, IOException.class);
     Throwables.propagateIfPossible(e, declaredType);
@@ -193,7 +193,7 @@ public final class Closer implements Closeable {
    */
   public <X1 extends Exception, X2 extends Exception> RuntimeException rethrow(
       Throwable e, Class<X1> declaredType1, Class<X2> declaredType2) throws IOException, X1, X2 {
-    checkNotNull(e);
+    requireNonNull(e);
     thrown = e;
     Throwables.propagateIfPossible(e, IOException.class);
     Throwables.propagateIfPossible(e, declaredType1, declaredType2);
diff --git a/guava/src/com/google/common/io/CountingInputStream.java b/guava/src/com/google/common/io/CountingInputStream.java
index a37807ae73..1269d7a0ed 100644
--- a/guava/src/com/google/common/io/CountingInputStream.java
+++ b/guava/src/com/google/common/io/CountingInputStream.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -42,7 +42,7 @@ public final class CountingInputStream extends FilterInputStream {
    * @param in the input stream to be wrapped
    */
   public CountingInputStream(InputStream in) {
-    super(checkNotNull(in));
+    super(requireNonNull(in));
   }
 
   /** Returns the number of bytes read. */
diff --git a/guava/src/com/google/common/io/CountingOutputStream.java b/guava/src/com/google/common/io/CountingOutputStream.java
index cf62b9c377..6caa134179 100644
--- a/guava/src/com/google/common/io/CountingOutputStream.java
+++ b/guava/src/com/google/common/io/CountingOutputStream.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import java.io.FilterOutputStream;
@@ -39,7 +39,7 @@ public final class CountingOutputStream extends FilterOutputStream {
    * @param out the output stream to be wrapped
    */
   public CountingOutputStream(OutputStream out) {
-    super(checkNotNull(out));
+    super(requireNonNull(out));
   }
 
   /** Returns the number of bytes written. */
diff --git a/guava/src/com/google/common/io/FileBackedOutputStream.java b/guava/src/com/google/common/io/FileBackedOutputStream.java
index 9912e2fcd1..4f3bcc65e0 100644
--- a/guava/src/com/google/common/io/FileBackedOutputStream.java
+++ b/guava/src/com/google/common/io/FileBackedOutputStream.java
@@ -82,8 +82,8 @@ public final class FileBackedOutputStream extends OutputStream {
   }
 
   /** Returns the file holding the data (possibly null). */
-  @VisibleForTesting
   @CheckForNull
+  @VisibleForTesting
   synchronized File getFile() {
     return file;
   }
diff --git a/guava/src/com/google/common/io/Files.java b/guava/src/com/google/common/io/Files.java
index 4ecab28074..8aa1aca003 100644
--- a/guava/src/com/google/common/io/Files.java
+++ b/guava/src/com/google/common/io/Files.java
@@ -15,8 +15,9 @@
 package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.io.FileWriteMode.APPEND;
+import static java.util.Collections.unmodifiableList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -51,7 +52,6 @@ import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -87,8 +87,8 @@ public final class Files {
    * @return the buffered reader
    */
   public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {
-    checkNotNull(file);
-    checkNotNull(charset);
+    requireNonNull(file);
+    requireNonNull(charset);
     return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));
   }
 
@@ -105,8 +105,8 @@ public final class Files {
    * @return the buffered writer
    */
   public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {
-    checkNotNull(file);
-    checkNotNull(charset);
+    requireNonNull(file);
+    requireNonNull(charset);
     return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));
   }
 
@@ -124,7 +124,7 @@ public final class Files {
     private final File file;
 
     private FileByteSource(File file) {
-      this.file = checkNotNull(file);
+      this.file = requireNonNull(file);
     }
 
     @Override
@@ -186,7 +186,7 @@ public final class Files {
     private final ImmutableSet<FileWriteMode> modes;
 
     private FileByteSink(File file, FileWriteMode... modes) {
-      this.file = checkNotNull(file);
+      this.file = requireNonNull(file);
       this.modes = ImmutableSet.copyOf(modes);
     }
 
@@ -358,7 +358,7 @@ public final class Files {
   @Deprecated
   @InlineMe(
       replacement = "Files.asCharSink(to, charset, FileWriteMode.APPEND).write(from)",
-      imports = {"com.google.common.io.FileWriteMode", "com.google.common.io.Files"})
+      imports = {"com.google.common.io.Files", "com.google.common.io.FileWriteMode"})
   public static void append(CharSequence from, File to, Charset charset) throws IOException {
     asCharSink(to, charset, FileWriteMode.APPEND).write(from);
   }
@@ -369,8 +369,8 @@ public final class Files {
    * @throws IOException if an I/O error occurs
    */
   public static boolean equal(File file1, File file2) throws IOException {
-    checkNotNull(file1);
-    checkNotNull(file2);
+    requireNonNull(file1);
+    requireNonNull(file2);
     if (file1 == file2 || file1.equals(file2)) {
       return true;
     }
@@ -451,7 +451,7 @@ public final class Files {
    */
   @SuppressWarnings("GoodTime") // reading system time without TimeSource
   public static void touch(File file) throws IOException {
-    checkNotNull(file);
+    requireNonNull(file);
     if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {
       throw new IOException("Unable to update modification time of " + file);
     }
@@ -467,7 +467,7 @@ public final class Files {
    * @since 4.0
    */
   public static void createParentDirs(File file) throws IOException {
-    checkNotNull(file);
+    requireNonNull(file);
     File parent = file.getCanonicalFile().getParentFile();
     if (parent == null) {
       /*
@@ -497,8 +497,8 @@ public final class Files {
    * @throws IllegalArgumentException if {@code from.equals(to)}
    */
   public static void move(File from, File to) throws IOException {
-    checkNotNull(from);
-    checkNotNull(to);
+    requireNonNull(from);
+    requireNonNull(to);
     checkArgument(!from.equals(to), "Source %s and destination %s must be different", from, to);
 
     if (!from.renameTo(to)) {
@@ -523,11 +523,11 @@ public final class Files {
    * @throws IOException if an I/O error occurs
    * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}.
    */
+  @CheckForNull
   @Deprecated
   @InlineMe(
       replacement = "Files.asCharSource(file, charset).readFirstLine()",
       imports = "com.google.common.io.Files")
-  @CheckForNull
   public static String readFirstLine(File file, Charset charset) throws IOException {
     return asCharSource(file, charset).readFirstLine();
   }
@@ -581,11 +581,11 @@ public final class Files {
    * @throws IOException if an I/O error occurs
    * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}.
    */
+  @CanIgnoreReturnValue
   @Deprecated
   @InlineMe(
       replacement = "Files.asCharSource(file, charset).readLines(callback)",
-      imports = "com.google.common.io.Files")
-  @CanIgnoreReturnValue // some processors won't return a useful result
+      imports = "com.google.common.io.Files") // some processors won't return a useful result
   @ParametricNullness
   public static <T extends @Nullable Object> T readLines(
       File file, Charset charset, LineProcessor<T> callback) throws IOException {
@@ -603,11 +603,11 @@ public final class Files {
    * @throws IOException if an I/O error occurs
    * @deprecated Prefer {@code asByteSource(file).read(processor)}.
    */
+  @CanIgnoreReturnValue
   @Deprecated
   @InlineMe(
       replacement = "Files.asByteSource(file).read(processor)",
-      imports = "com.google.common.io.Files")
-  @CanIgnoreReturnValue // some processors won't return a useful result
+      imports = "com.google.common.io.Files") // some processors won't return a useful result
   @ParametricNullness
   public static <T extends @Nullable Object> T readBytes(File file, ByteProcessor<T> processor)
       throws IOException {
@@ -648,7 +648,7 @@ public final class Files {
    * @since 2.0
    */
   public static MappedByteBuffer map(File file) throws IOException {
-    checkNotNull(file);
+    requireNonNull(file);
     return map(file, MapMode.READ_ONLY);
   }
 
@@ -699,8 +699,8 @@ public final class Files {
 
   private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)
       throws IOException {
-    checkNotNull(file);
-    checkNotNull(mode);
+    requireNonNull(file);
+    requireNonNull(mode);
 
     Closer closer = Closer.create();
     try {
@@ -736,8 +736,8 @@ public final class Files {
    * @since 11.0
    */
   public static String simplifyPath(String pathname) {
-    checkNotNull(pathname);
-    if (pathname.length() == 0) {
+    requireNonNull(pathname);
+    if (pathname.isEmpty()) {
       return ".";
     }
 
@@ -751,7 +751,7 @@ public final class Files {
         case ".":
           continue;
         case "..":
-          if (path.size() > 0 && !path.get(path.size() - 1).equals("..")) {
+          if (!path.isEmpty() && !path.get(path.size() - 1).equals("..")) {
             path.remove(path.size() - 1);
           } else {
             path.add("..");
@@ -796,7 +796,7 @@ public final class Files {
    * @since 11.0
    */
   public static String getFileExtension(String fullName) {
-    checkNotNull(fullName);
+    requireNonNull(fullName);
     String fileName = new File(fullName).getName();
     int dotIndex = fileName.lastIndexOf('.');
     return (dotIndex == -1) ? "" : fileName.substring(dotIndex + 1);
@@ -813,7 +813,7 @@ public final class Files {
    * @since 14.0
    */
   public static String getNameWithoutExtension(String file) {
-    checkNotNull(file);
+    requireNonNull(file);
     String fileName = new File(file).getName();
     int dotIndex = fileName.lastIndexOf('.');
     return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);
@@ -854,7 +854,7 @@ public final class Files {
           if (file.isDirectory()) {
             File[] files = file.listFiles();
             if (files != null) {
-              return Collections.unmodifiableList(Arrays.asList(files));
+              return unmodifiableList(Arrays.asList(files));
             }
           }
 
diff --git a/guava/src/com/google/common/io/LineReader.java b/guava/src/com/google/common/io/LineReader.java
index 2c57ac4546..2bf7b43c71 100644
--- a/guava/src/com/google/common/io/LineReader.java
+++ b/guava/src/com/google/common/io/LineReader.java
@@ -14,8 +14,8 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.io.CharStreams.createBuffer;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -55,7 +55,7 @@ public final class LineReader {
 
   /** Creates a new instance that will read lines from the given {@code Readable} object. */
   public LineReader(Readable readable) {
-    this.readable = checkNotNull(readable);
+    this.readable = requireNonNull(readable);
     this.reader = (readable instanceof Reader) ? (Reader) readable : null;
   }
 
diff --git a/guava/src/com/google/common/io/LittleEndianDataInputStream.java b/guava/src/com/google/common/io/LittleEndianDataInputStream.java
index 88c8e27bc3..26033a2586 100644
--- a/guava/src/com/google/common/io/LittleEndianDataInputStream.java
+++ b/guava/src/com/google/common/io/LittleEndianDataInputStream.java
@@ -14,9 +14,10 @@
 
 package com.google.common.io;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.Longs;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -50,13 +51,13 @@ public final class LittleEndianDataInputStream extends FilterInputStream impleme
    * @param in the stream to delegate to
    */
   public LittleEndianDataInputStream(InputStream in) {
-    super(Preconditions.checkNotNull(in));
+    super(requireNonNull(in));
   }
 
   /** This method will throw an {@link UnsupportedOperationException}. */
   @CanIgnoreReturnValue // to skip a line
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public String readLine() {
     throw new UnsupportedOperationException("readLine is not supported");
   }
diff --git a/guava/src/com/google/common/io/LittleEndianDataOutputStream.java b/guava/src/com/google/common/io/LittleEndianDataOutputStream.java
index 6e51aff49d..1c1b1959c3 100644
--- a/guava/src/com/google/common/io/LittleEndianDataOutputStream.java
+++ b/guava/src/com/google/common/io/LittleEndianDataOutputStream.java
@@ -14,9 +14,10 @@
 
 package com.google.common.io;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.primitives.Longs;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
@@ -46,7 +47,7 @@ public final class LittleEndianDataOutputStream extends FilterOutputStream imple
    * @param out the stream to delegate to
    */
   public LittleEndianDataOutputStream(OutputStream out) {
-    super(new DataOutputStream(Preconditions.checkNotNull(out)));
+    super(new DataOutputStream(requireNonNull(out)));
   }
 
   @Override
diff --git a/guava/src/com/google/common/io/MoreFiles.java b/guava/src/com/google/common/io/MoreFiles.java
index ffe200d5e8..f000119e76 100644
--- a/guava/src/com/google/common/io/MoreFiles.java
+++ b/guava/src/com/google/common/io/MoreFiles.java
@@ -16,7 +16,6 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static java.nio.file.LinkOption.NOFOLLOW_LINKS;
 import static java.util.Objects.requireNonNull;
@@ -96,7 +95,7 @@ public final class MoreFiles {
     private final boolean followLinks;
 
     private PathByteSource(Path path, OpenOption... options) {
-      this.path = checkNotNull(path);
+      this.path = requireNonNull(path);
       this.options = options.clone();
       this.followLinks = followLinks(this.options);
       // TODO(cgdecker): validate the provided options... for example, just WRITE seems wrong
@@ -172,8 +171,8 @@ public final class MoreFiles {
         // overload taking OpenOptions, meaning we can't guarantee the same behavior w.r.t. things
         // like following/not following symlinks.
         return new AsCharSource(charset) {
-          @SuppressWarnings("FilesLinesLeak") // the user needs to close it in this case
-          @Override
+          @Override // the user needs to close it in this case
+          @SuppressWarnings("FilesLinesLeak")
           public Stream<String> lines() throws IOException {
             return Files.lines(path, charset);
           }
@@ -209,7 +208,7 @@ public final class MoreFiles {
     private final OpenOption[] options;
 
     private PathByteSink(Path path, OpenOption... options) {
-      this.path = checkNotNull(path);
+      this.path = requireNonNull(path);
       this.options = options.clone();
       // TODO(cgdecker): validate the provided options... for example, just READ seems wrong
     }
@@ -369,8 +368,8 @@ public final class MoreFiles {
    * @since 22.0
    */
   public static boolean equal(Path path1, Path path2) throws IOException {
-    checkNotNull(path1);
-    checkNotNull(path2);
+    requireNonNull(path1);
+    requireNonNull(path2);
     if (Files.isSameFile(path1, path2)) {
       return true;
     }
@@ -396,7 +395,7 @@ public final class MoreFiles {
    */
   @SuppressWarnings("GoodTime") // reading system time without TimeSource
   public static void touch(Path path) throws IOException {
-    checkNotNull(path);
+    requireNonNull(path);
 
     try {
       Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));
diff --git a/guava/src/com/google/common/io/MultiInputStream.java b/guava/src/com/google/common/io/MultiInputStream.java
index 9a7e0fd1c0..f91751885d 100644
--- a/guava/src/com/google/common/io/MultiInputStream.java
+++ b/guava/src/com/google/common/io/MultiInputStream.java
@@ -14,7 +14,7 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
@@ -42,7 +42,7 @@ final class MultiInputStream extends InputStream {
    * @param it an iterator of I/O suppliers that will provide each substream
    */
   public MultiInputStream(Iterator<? extends ByteSource> it) throws IOException {
-    this.it = checkNotNull(it);
+    this.it = requireNonNull(it);
     advance();
   }
 
@@ -92,7 +92,7 @@ final class MultiInputStream extends InputStream {
 
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
-    checkNotNull(b);
+    requireNonNull(b);
     while (in != null) {
       int result = in.read(b, off, len);
       if (result != -1) {
diff --git a/guava/src/com/google/common/io/MultiReader.java b/guava/src/com/google/common/io/MultiReader.java
index cc36e527b6..a392af6b7f 100644
--- a/guava/src/com/google/common/io/MultiReader.java
+++ b/guava/src/com/google/common/io/MultiReader.java
@@ -14,10 +14,10 @@
 
 package com.google.common.io;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Iterator;
@@ -50,7 +50,7 @@ class MultiReader extends Reader {
 
   @Override
   public int read(char[] cbuf, int off, int len) throws IOException {
-    checkNotNull(cbuf);
+    requireNonNull(cbuf);
     if (current == null) {
       return -1;
     }
@@ -64,7 +64,7 @@ class MultiReader extends Reader {
 
   @Override
   public long skip(long n) throws IOException {
-    Preconditions.checkArgument(n >= 0, "n is negative");
+    checkArgument(n >= 0, "n is negative");
     if (n > 0) {
       while (current != null) {
         long result = current.skip(n);
diff --git a/guava/src/com/google/common/io/PatternFilenameFilter.java b/guava/src/com/google/common/io/PatternFilenameFilter.java
index 3cb2371e2f..580b02c6c1 100644
--- a/guava/src/com/google/common/io/PatternFilenameFilter.java
+++ b/guava/src/com/google/common/io/PatternFilenameFilter.java
@@ -14,9 +14,10 @@
 
 package com.google.common.io;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import java.io.File;
 import java.io.FilenameFilter;
 import java.util.regex.Pattern;
@@ -52,7 +53,7 @@ public final class PatternFilenameFilter implements FilenameFilter {
    * @param pattern the pattern on which to filter file names
    */
   public PatternFilenameFilter(Pattern pattern) {
-    this.pattern = Preconditions.checkNotNull(pattern);
+    this.pattern = requireNonNull(pattern);
   }
 
   /*
diff --git a/guava/src/com/google/common/io/ReaderInputStream.java b/guava/src/com/google/common/io/ReaderInputStream.java
index 75f8a3e1e3..bb3d42c26f 100644
--- a/guava/src/com/google/common/io/ReaderInputStream.java
+++ b/guava/src/com/google/common/io/ReaderInputStream.java
@@ -15,8 +15,8 @@
 package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.UnsignedBytes;
@@ -99,8 +99,8 @@ final class ReaderInputStream extends InputStream {
    * @throws IllegalArgumentException if bufferSize is non-positive
    */
   ReaderInputStream(Reader reader, CharsetEncoder encoder, int bufferSize) {
-    this.reader = checkNotNull(reader);
-    this.encoder = checkNotNull(encoder);
+    this.reader = requireNonNull(reader);
+    this.encoder = requireNonNull(encoder);
     checkArgument(bufferSize > 0, "bufferSize must be positive: %s", bufferSize);
     encoder.reset();
 
diff --git a/guava/src/com/google/common/io/Resources.java b/guava/src/com/google/common/io/Resources.java
index d1e37070a9..bf8cf5890f 100644
--- a/guava/src/com/google/common/io/Resources.java
+++ b/guava/src/com/google/common/io/Resources.java
@@ -15,7 +15,7 @@
 package com.google.common.io;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Charsets;
@@ -60,7 +60,7 @@ public final class Resources {
     private final URL url;
 
     private UrlByteSource(URL url) {
-      this.url = checkNotNull(url);
+      this.url = requireNonNull(url);
     }
 
     @Override
diff --git a/guava/src/com/google/common/math/BigDecimalMath.java b/guava/src/com/google/common/math/BigDecimalMath.java
index 33a55d3563..f7309def84 100644
--- a/guava/src/com/google/common/math/BigDecimalMath.java
+++ b/guava/src/com/google/common/math/BigDecimalMath.java
@@ -71,7 +71,7 @@ public class BigDecimalMath {
 
     @Override
     BigDecimal toX(double d, RoundingMode mode) {
-      return new BigDecimal(d);
+      return BigDecimal.valueOf(d);
     }
 
     @Override
diff --git a/guava/src/com/google/common/math/BigIntegerMath.java b/guava/src/com/google/common/math/BigIntegerMath.java
index 6ef1e81ed4..18f70ceac6 100644
--- a/guava/src/com/google/common/math/BigIntegerMath.java
+++ b/guava/src/com/google/common/math/BigIntegerMath.java
@@ -15,7 +15,6 @@
 package com.google.common.math;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.math.MathPreconditions.checkNonNegative;
 import static com.google.common.math.MathPreconditions.checkPositive;
 import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
@@ -24,6 +23,7 @@ import static java.math.RoundingMode.FLOOR;
 import static java.math.RoundingMode.HALF_DOWN;
 import static java.math.RoundingMode.HALF_EVEN;
 import static java.math.RoundingMode.UNNECESSARY;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -76,7 +76,7 @@ public final class BigIntegerMath {
 
   /** Returns {@code true} if {@code x} represents a power of two. */
   public static boolean isPowerOfTwo(BigInteger x) {
-    checkNotNull(x);
+    requireNonNull(x);
     return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;
   }
 
@@ -90,7 +90,7 @@ public final class BigIntegerMath {
   @SuppressWarnings("fallthrough")
   // TODO(kevinb): remove after this warning is disabled globally
   public static int log2(BigInteger x, RoundingMode mode) {
-    checkPositive("x", checkNotNull(x));
+    checkPositive("x", requireNonNull(x));
     int logFloor = x.bitLength() - 1;
     switch (mode) {
       case UNNECESSARY:
diff --git a/guava/src/com/google/common/math/DoubleMath.java b/guava/src/com/google/common/math/DoubleMath.java
index cdd0a4b39e..933247139a 100644
--- a/guava/src/com/google/common/math/DoubleMath.java
+++ b/guava/src/com/google/common/math/DoubleMath.java
@@ -518,8 +518,8 @@ public final class DoubleMath {
     return mean;
   }
 
-  @GwtIncompatible // com.google.common.math.DoubleUtils
-  @CanIgnoreReturnValue
+  @CanIgnoreReturnValue // com.google.common.math.DoubleUtils
+  @GwtIncompatible
   private static double checkFinite(double argument) {
     checkArgument(isFinite(argument));
     return argument;
diff --git a/guava/src/com/google/common/math/IntMath.java b/guava/src/com/google/common/math/IntMath.java
index 17a18c6999..d932a920ff 100644
--- a/guava/src/com/google/common/math/IntMath.java
+++ b/guava/src/com/google/common/math/IntMath.java
@@ -15,7 +15,6 @@
 package com.google.common.math;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.math.MathPreconditions.checkNoOverflow;
 import static com.google.common.math.MathPreconditions.checkNonNegative;
 import static com.google.common.math.MathPreconditions.checkPositive;
@@ -24,6 +23,7 @@ import static java.lang.Math.abs;
 import static java.lang.Math.min;
 import static java.math.RoundingMode.HALF_EVEN;
 import static java.math.RoundingMode.HALF_UP;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -315,7 +315,7 @@ public final class IntMath {
    */
   @SuppressWarnings("fallthrough")
   public static int divide(int p, int q, RoundingMode mode) {
-    checkNotNull(mode);
+    requireNonNull(mode);
     if (q == 0) {
       throw new ArithmeticException("/ by zero"); // for GWT
     }
@@ -719,8 +719,8 @@ public final class IntMath {
    * @throws IllegalArgumentException if {@code n} is negative
    * @since 20.0
    */
-  @GwtIncompatible // TODO
-  @Beta
+  @Beta // TODO
+  @GwtIncompatible
   public static boolean isPrime(int n) {
     return LongMath.isPrime(n);
   }
diff --git a/guava/src/com/google/common/math/LongMath.java b/guava/src/com/google/common/math/LongMath.java
index dd5ff06942..09cc73948e 100644
--- a/guava/src/com/google/common/math/LongMath.java
+++ b/guava/src/com/google/common/math/LongMath.java
@@ -15,7 +15,6 @@
 package com.google.common.math;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.math.MathPreconditions.checkNoOverflow;
 import static com.google.common.math.MathPreconditions.checkNonNegative;
 import static com.google.common.math.MathPreconditions.checkPositive;
@@ -24,6 +23,7 @@ import static java.lang.Math.abs;
 import static java.lang.Math.min;
 import static java.math.RoundingMode.HALF_EVEN;
 import static java.math.RoundingMode.HALF_UP;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -384,7 +384,7 @@ public final class LongMath {
   @GwtIncompatible // TODO
   @SuppressWarnings("fallthrough")
   public static long divide(long p, long q, RoundingMode mode) {
-    checkNotNull(mode);
+    requireNonNull(mode);
     long div = p / q; // throws if q == 0
     long rem = p - q * div; // equals p % q
 
@@ -999,8 +999,8 @@ public final class LongMath {
    * @throws IllegalArgumentException if {@code n} is negative
    * @since 20.0
    */
-  @GwtIncompatible // TODO
-  @Beta
+  @Beta // TODO
+  @GwtIncompatible
   public static boolean isPrime(long n) {
     if (n < 2) {
       checkNonNegative("n", n);
@@ -1242,8 +1242,8 @@ public final class LongMath {
    *     is not precisely representable as a {@code double}
    * @since 30.0
    */
-  @SuppressWarnings("deprecation")
   @GwtIncompatible
+  @SuppressWarnings("deprecation")
   public static double roundToDouble(long x, RoundingMode mode) {
     // Logic adapted from ToDoubleRounder.
     double roundArbitrarily = (double) x;
diff --git a/guava/src/com/google/common/math/MathPreconditions.java b/guava/src/com/google/common/math/MathPreconditions.java
index 37d608a823..6e6b4669fa 100644
--- a/guava/src/com/google/common/math/MathPreconditions.java
+++ b/guava/src/com/google/common/math/MathPreconditions.java
@@ -14,6 +14,8 @@
 
 package com.google.common.math;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.math.BigInteger;
@@ -29,44 +31,32 @@ import java.math.RoundingMode;
 @ElementTypesAreNonnullByDefault
 final class MathPreconditions {
   static int checkPositive(String role, int x) {
-    if (x <= 0) {
-      throw new IllegalArgumentException(role + " (" + x + ") must be > 0");
-    }
+    checkArgument(x > 0, "%s (%s) must be > 0", role, x);
     return x;
   }
 
   static long checkPositive(String role, long x) {
-    if (x <= 0) {
-      throw new IllegalArgumentException(role + " (" + x + ") must be > 0");
-    }
+    checkArgument(x > 0, "%s (%s) must be > 0", role, x);
     return x;
   }
 
   static BigInteger checkPositive(String role, BigInteger x) {
-    if (x.signum() <= 0) {
-      throw new IllegalArgumentException(role + " (" + x + ") must be > 0");
-    }
+    checkArgument(x.signum() > 0, "%s (%s) must be > 0", role, x);
     return x;
   }
 
   static int checkNonNegative(String role, int x) {
-    if (x < 0) {
-      throw new IllegalArgumentException(role + " (" + x + ") must be >= 0");
-    }
+    checkArgument(x >= 0, "%s (%s) must be >= 0", role, x);
     return x;
   }
 
   static long checkNonNegative(String role, long x) {
-    if (x < 0) {
-      throw new IllegalArgumentException(role + " (" + x + ") must be >= 0");
-    }
+    checkArgument(x >= 0, "%s (%s) must be >= 0", role, x);
     return x;
   }
 
   static BigInteger checkNonNegative(String role, BigInteger x) {
-    if (x.signum() < 0) {
-      throw new IllegalArgumentException(role + " (" + x + ") must be >= 0");
-    }
+    checkArgument(x.signum() >= 0, "%s (%s) must be >= 0", role, x);
     return x;
   }
 
diff --git a/guava/src/com/google/common/math/PairedStats.java b/guava/src/com/google/common/math/PairedStats.java
index 31ab9b7196..c558777796 100644
--- a/guava/src/com/google/common/math/PairedStats.java
+++ b/guava/src/com/google/common/math/PairedStats.java
@@ -15,11 +15,11 @@
 package com.google.common.math;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static java.lang.Double.NaN;
 import static java.lang.Double.doubleToLongBits;
 import static java.lang.Double.isNaN;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -303,7 +303,7 @@ public final class PairedStats implements Serializable {
    * versions.
    */
   public static PairedStats fromByteArray(byte[] byteArray) {
-    checkNotNull(byteArray);
+    requireNonNull(byteArray);
     checkArgument(
         byteArray.length == BYTES,
         "Expected PairedStats.BYTES = %s, got %s",
diff --git a/guava/src/com/google/common/math/Quantiles.java b/guava/src/com/google/common/math/Quantiles.java
index 6ddea9bcfd..f7bc468d1e 100644
--- a/guava/src/com/google/common/math/Quantiles.java
+++ b/guava/src/com/google/common/math/Quantiles.java
@@ -483,10 +483,10 @@ public final class Quantiles {
   }
 
   private static void checkIndex(int index, int scale) {
-    if (index < 0 || index > scale) {
-      throw new IllegalArgumentException(
-          "Quantile indexes must be between 0 and the scale, which is " + scale);
-    }
+    checkArgument(
+        index >= 0 && index <= scale,
+        "Quantile indexes must be between 0 and the scale, which is %s",
+        scale);
   }
 
   private static double[] longsToDoubles(long[] longs) {
diff --git a/guava/src/com/google/common/math/Stats.java b/guava/src/com/google/common/math/Stats.java
index 20c9466f5c..b38fea6025 100644
--- a/guava/src/com/google/common/math/Stats.java
+++ b/guava/src/com/google/common/math/Stats.java
@@ -15,7 +15,6 @@
 package com.google.common.math;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.math.DoubleUtils.ensureNonNegative;
 import static com.google.common.math.StatsAccumulator.calculateNewMeanNonFinite;
@@ -23,6 +22,7 @@ import static com.google.common.primitives.Doubles.isFinite;
 import static java.lang.Double.NaN;
 import static java.lang.Double.doubleToLongBits;
 import static java.lang.Double.isNaN;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -604,7 +604,7 @@ public final class Stats implements Serializable {
    *     is written. In the process increases the position of {@link ByteBuffer} by BYTES.
    */
   void writeTo(ByteBuffer buffer) {
-    checkNotNull(buffer);
+    requireNonNull(buffer);
     checkArgument(
         buffer.remaining() >= BYTES,
         "Expected at least Stats.BYTES = %s remaining , got %s",
@@ -626,7 +626,7 @@ public final class Stats implements Serializable {
    * versions.
    */
   public static Stats fromByteArray(byte[] byteArray) {
-    checkNotNull(byteArray);
+    requireNonNull(byteArray);
     checkArgument(
         byteArray.length == BYTES,
         "Expected Stats.BYTES = %s remaining , got %s",
@@ -646,7 +646,7 @@ public final class Stats implements Serializable {
    *     instance is read. In the process increases the position of {@link ByteBuffer} by BYTES.
    */
   static Stats readFrom(ByteBuffer buffer) {
-    checkNotNull(buffer);
+    requireNonNull(buffer);
     checkArgument(
         buffer.remaining() >= BYTES,
         "Expected at least Stats.BYTES = %s remaining , got %s",
diff --git a/guava/src/com/google/common/math/ToDoubleRounder.java b/guava/src/com/google/common/math/ToDoubleRounder.java
index 2e7e7fae09..fa7083c1fc 100644
--- a/guava/src/com/google/common/math/ToDoubleRounder.java
+++ b/guava/src/com/google/common/math/ToDoubleRounder.java
@@ -14,8 +14,8 @@
 
 package com.google.common.math;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import java.math.RoundingMode;
@@ -44,8 +44,8 @@ abstract class ToDoubleRounder<X extends Number & Comparable<X>> {
 
   /** Rounds {@code x} to a {@code double}. */
   final double roundToDouble(X x, RoundingMode mode) {
-    checkNotNull(x, "x");
-    checkNotNull(mode, "mode");
+    requireNonNull(x, "x");
+    requireNonNull(mode, "mode");
     double roundArbitrarily = roundToDoubleArbitrarily(x);
     if (Double.isInfinite(roundArbitrarily)) {
       switch (mode) {
diff --git a/guava/src/com/google/common/net/HostAndPort.java b/guava/src/com/google/common/net/HostAndPort.java
index a27eb65ff3..e9a6016c7d 100644
--- a/guava/src/com/google/common/net/HostAndPort.java
+++ b/guava/src/com/google/common/net/HostAndPort.java
@@ -15,8 +15,8 @@
 package com.google.common.net;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.CharMatcher;
@@ -165,7 +165,7 @@ public final class HostAndPort implements Serializable {
    */
   @CanIgnoreReturnValue // TODO(b/219820829): consider removing
   public static HostAndPort fromString(String hostPortString) {
-    checkNotNull(hostPortString);
+    requireNonNull(hostPortString);
     String host;
     String portString = null;
     boolean hasBracketlessColons = false;
diff --git a/guava/src/com/google/common/net/HostSpecifier.java b/guava/src/com/google/common/net/HostSpecifier.java
index c57f3d9759..ae6d1ab67d 100644
--- a/guava/src/com/google/common/net/HostSpecifier.java
+++ b/guava/src/com/google/common/net/HostSpecifier.java
@@ -14,8 +14,9 @@
 
 package com.google.common.net;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.net.InetAddress;
 import java.text.ParseException;
@@ -71,7 +72,7 @@ public final class HostSpecifier {
     // Verify that no port was specified, and strip optional brackets from
     // IPv6 literals.
     HostAndPort parsedHost = HostAndPort.fromString(specifier);
-    Preconditions.checkArgument(!parsedHost.hasPort());
+    checkArgument(!parsedHost.hasPort());
     String host = parsedHost.getHost();
 
     // Try to interpret the specifier as an IP address. Note we build
diff --git a/guava/src/com/google/common/net/InetAddresses.java b/guava/src/com/google/common/net/InetAddresses.java
index d3e68db8ac..c3b391fee3 100644
--- a/guava/src/com/google/common/net/InetAddresses.java
+++ b/guava/src/com/google/common/net/InetAddresses.java
@@ -15,7 +15,7 @@
 package com.google.common.net;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.CharMatcher;
@@ -404,7 +404,7 @@ public final class InetAddresses {
    * @since 10.0
    */
   public static String toAddrString(InetAddress ip) {
-    checkNotNull(ip);
+    requireNonNull(ip);
     if (ip instanceof Inet4Address) {
       // For IPv4, Java's formatting is good enough.
       return ip.getHostAddress();
@@ -538,7 +538,7 @@ public final class InetAddresses {
 
   @CheckForNull
   private static InetAddress forUriStringNoThrow(String hostAddr) {
-    checkNotNull(hostAddr);
+    requireNonNull(hostAddr);
 
     // Decide if this should be an IPv6 or IPv4 address.
     String ipString;
diff --git a/guava/src/com/google/common/net/InternetDomainName.java b/guava/src/com/google/common/net/InternetDomainName.java
index d71a9d5c3c..8e4b32cb71 100644
--- a/guava/src/com/google/common/net/InternetDomainName.java
+++ b/guava/src/com/google/common/net/InternetDomainName.java
@@ -15,8 +15,8 @@
 package com.google.common.net;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Ascii;
@@ -207,7 +207,7 @@ public final class InternetDomainName {
    */
   @CanIgnoreReturnValue // TODO(b/219820829): consider removing
   public static InternetDomainName from(String domain) {
-    return new InternetDomainName(checkNotNull(domain));
+    return new InternetDomainName(requireNonNull(domain));
   }
 
   /**
@@ -258,7 +258,7 @@ public final class InternetDomainName {
     // These tests could be collapsed into one big boolean expression, but
     // they have been left as independent tests for clarity.
 
-    if (part.length() < 1 || part.length() > MAX_DOMAIN_PART_LENGTH) {
+    if (part.isEmpty() || part.length() > MAX_DOMAIN_PART_LENGTH) {
       return false;
     }
 
@@ -556,7 +556,7 @@ public final class InternetDomainName {
    * @throws IllegalArgumentException if the resulting name is not valid
    */
   public InternetDomainName child(String leftParts) {
-    return from(checkNotNull(leftParts) + "." + name);
+    return from(requireNonNull(leftParts) + "." + name);
   }
 
   /**
diff --git a/guava/src/com/google/common/net/MediaType.java b/guava/src/com/google/common/net/MediaType.java
index a713d0b17a..cc7b248236 100644
--- a/guava/src/com/google/common/net/MediaType.java
+++ b/guava/src/com/google/common/net/MediaType.java
@@ -18,8 +18,8 @@ import static com.google.common.base.CharMatcher.ascii;
 import static com.google.common.base.CharMatcher.javaIsoControl;
 import static com.google.common.base.Charsets.UTF_8;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Ascii;
@@ -845,8 +845,8 @@ public final class MediaType {
    * @since 24.0
    */
   public MediaType withParameters(String attribute, Iterable<String> values) {
-    checkNotNull(attribute);
-    checkNotNull(values);
+    requireNonNull(attribute);
+    requireNonNull(values);
     String normalizedAttribute = normalizeToken(attribute);
     ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();
     for (Entry<String, String> entry : parameters.entries()) {
@@ -889,7 +889,7 @@ public final class MediaType {
    * representable as a {@link Charset} instance, use {@link #withParameter}.
    */
   public MediaType withCharset(Charset charset) {
-    checkNotNull(charset);
+    requireNonNull(charset);
     MediaType withCharset = withParameter(CHARSET_ATTRIBUTE, charset.name());
     // precache the charset so we don't need to parse it
     withCharset.parsedCharset = Optional.of(charset);
@@ -950,9 +950,9 @@ public final class MediaType {
 
   private static MediaType create(
       String type, String subtype, Multimap<String, String> parameters) {
-    checkNotNull(type);
-    checkNotNull(subtype);
-    checkNotNull(parameters);
+    requireNonNull(type);
+    requireNonNull(subtype);
+    requireNonNull(parameters);
     String normalizedType = normalizeToken(type);
     String normalizedSubtype = normalizeToken(subtype);
     checkArgument(
@@ -1029,7 +1029,7 @@ public final class MediaType {
   }
 
   private static String normalizeParameterValue(String attribute, String value) {
-    checkNotNull(value); // for GWT
+    requireNonNull(value); // for GWT
     checkArgument(ascii().matchesAllOf(value), "parameter values must be ASCII: %s", value);
     return CHARSET_ATTRIBUTE.equals(attribute) ? Ascii.toLowerCase(value) : value;
   }
@@ -1041,7 +1041,7 @@ public final class MediaType {
    */
   @CanIgnoreReturnValue // TODO(b/219820829): consider removing
   public static MediaType parse(String input) {
-    checkNotNull(input);
+    requireNonNull(input);
     Tokenizer tokenizer = new Tokenizer(input);
     try {
       String type = tokenizer.consumeToken(TOKEN_MATCHER);
diff --git a/guava/src/com/google/common/net/PercentEscaper.java b/guava/src/com/google/common/net/PercentEscaper.java
index 9290147312..2a33dd95d2 100644
--- a/guava/src/com/google/common/net/PercentEscaper.java
+++ b/guava/src/com/google/common/net/PercentEscaper.java
@@ -14,7 +14,8 @@
 
 package com.google.common.net;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.escape.UnicodeEscaper;
@@ -85,19 +86,17 @@ public final class PercentEscaper extends UnicodeEscaper {
   public PercentEscaper(String safeChars, boolean plusForSpace) {
     // TODO(dbeaumont): Switch to static factory methods for creation now that class is final.
     // TODO(dbeaumont): Support escapers where alphanumeric chars are not safe.
-    checkNotNull(safeChars); // eager for GWT.
+    requireNonNull(safeChars); // eager for GWT.
     // Avoid any misunderstandings about the behavior of this escaper
-    if (safeChars.matches(".*[0-9A-Za-z].*")) {
-      throw new IllegalArgumentException(
-          "Alphanumeric characters are always 'safe' and should not be explicitly specified");
-    }
+    checkArgument(
+        !safeChars.matches(".*[0-9A-Za-z].*"),
+        "Alphanumeric characters are always 'safe' and should not be explicitly specified");
     safeChars += "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
     // Avoid ambiguous parameters. Safe characters are never modified so if
     // space is a safe character then setting plusForSpace is meaningless.
-    if (plusForSpace && safeChars.contains(" ")) {
-      throw new IllegalArgumentException(
-          "plusForSpace cannot be specified when space is a 'safe' character");
-    }
+    checkArgument(
+        !plusForSpace || !safeChars.contains(" "),
+        "plusForSpace cannot be specified when space is a 'safe' character");
     this.plusForSpace = plusForSpace;
     this.safeOctets = createSafeOctets(safeChars);
   }
@@ -126,7 +125,7 @@ public final class PercentEscaper extends UnicodeEscaper {
    */
   @Override
   protected int nextEscapeIndex(CharSequence csq, int index, int end) {
-    checkNotNull(csq);
+    requireNonNull(csq);
     for (; index < end; index++) {
       char c = csq.charAt(index);
       if (c >= safeOctets.length || !safeOctets[c]) {
@@ -142,7 +141,7 @@ public final class PercentEscaper extends UnicodeEscaper {
    */
   @Override
   public String escape(String s) {
-    checkNotNull(s);
+    requireNonNull(s);
     int slen = s.length();
     for (int index = 0; index < slen; index++) {
       char c = s.charAt(index);
@@ -154,8 +153,8 @@ public final class PercentEscaper extends UnicodeEscaper {
   }
 
   /** Escapes the given Unicode code point in UTF-8. */
-  @Override
   @CheckForNull
+  @Override
   protected char[] escape(int cp) {
     // We should never get negative values here but if we do it will throw an
     // IndexOutOfBoundsException, so at least it will get spotted.
diff --git a/guava/src/com/google/common/primitives/Booleans.java b/guava/src/com/google/common/primitives/Booleans.java
index 522049bfe3..12d884ff49 100644
--- a/guava/src/com/google/common/primitives/Booleans.java
+++ b/guava/src/com/google/common/primitives/Booleans.java
@@ -16,8 +16,9 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -25,7 +26,6 @@ import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
@@ -184,8 +184,8 @@ public final class Booleans {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(boolean[] array, boolean[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -275,7 +275,7 @@ public final class Booleans {
    * @param array an array of {@code boolean} values, possibly empty
    */
   public static String join(String separator, boolean... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -351,7 +351,7 @@ public final class Booleans {
     boolean[] array = new boolean[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = (Boolean) checkNotNull(boxedArray[i]);
+      array[i] = (Boolean) requireNonNull(boxedArray[i]);
     }
     return array;
   }
@@ -370,7 +370,7 @@ public final class Booleans {
    */
   public static List<Boolean> asList(boolean... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new BooleanArrayAsList(backingArray);
   }
@@ -444,7 +444,7 @@ public final class Booleans {
       checkElementIndex(index, size());
       boolean oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -453,7 +453,7 @@ public final class Booleans {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new BooleanArrayAsList(array, start + fromIndex, start + toIndex);
     }
@@ -528,7 +528,7 @@ public final class Booleans {
    * @since 23.1
    */
   public static void reverse(boolean[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -543,7 +543,7 @@ public final class Booleans {
    * @since 23.1
    */
   public static void reverse(boolean[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       boolean tmp = array[i];
diff --git a/guava/src/com/google/common/primitives/Bytes.java b/guava/src/com/google/common/primitives/Bytes.java
index 62997f34aa..c19d3278ba 100644
--- a/guava/src/com/google/common/primitives/Bytes.java
+++ b/guava/src/com/google/common/primitives/Bytes.java
@@ -16,15 +16,15 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.RandomAccess;
 import javax.annotation.CheckForNull;
@@ -110,8 +110,8 @@ public final class Bytes {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(byte[] array, byte[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -213,7 +213,7 @@ public final class Bytes {
     byte[] array = new byte[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = ((Number) checkNotNull(boxedArray[i])).byteValue();
+      array[i] = ((Number) requireNonNull(boxedArray[i])).byteValue();
     }
     return array;
   }
@@ -232,7 +232,7 @@ public final class Bytes {
    */
   public static List<Byte> asList(byte... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new ByteArrayAsList(backingArray);
   }
@@ -305,7 +305,7 @@ public final class Bytes {
       checkElementIndex(index, size());
       byte oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -314,7 +314,7 @@ public final class Bytes {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new ByteArrayAsList(array, start + fromIndex, start + toIndex);
     }
@@ -373,7 +373,7 @@ public final class Bytes {
    * @since 23.1
    */
   public static void reverse(byte[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -388,7 +388,7 @@ public final class Bytes {
    * @since 23.1
    */
   public static void reverse(byte[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       byte tmp = array[i];
diff --git a/guava/src/com/google/common/primitives/Chars.java b/guava/src/com/google/common/primitives/Chars.java
index 4a2e3a3449..6a9ed342c9 100644
--- a/guava/src/com/google/common/primitives/Chars.java
+++ b/guava/src/com/google/common/primitives/Chars.java
@@ -16,8 +16,9 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -26,7 +27,6 @@ import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
@@ -167,8 +167,8 @@ public final class Chars {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(char[] array, char[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -354,7 +354,7 @@ public final class Chars {
    * @param array an array of {@code char} values, possibly empty
    */
   public static String join(String separator, char... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     int len = array.length;
     if (len == 0) {
       return "";
@@ -429,7 +429,7 @@ public final class Chars {
     char[] array = new char[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = (Character) checkNotNull(boxedArray[i]);
+      array[i] = (Character) requireNonNull(boxedArray[i]);
     }
     return array;
   }
@@ -440,7 +440,7 @@ public final class Chars {
    * @since 23.1
    */
   public static void sortDescending(char[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -451,7 +451,7 @@ public final class Chars {
    * @since 23.1
    */
   public static void sortDescending(char[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     Arrays.sort(array, fromIndex, toIndex);
     reverse(array, fromIndex, toIndex);
@@ -464,7 +464,7 @@ public final class Chars {
    * @since 23.1
    */
   public static void reverse(char[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -479,7 +479,7 @@ public final class Chars {
    * @since 23.1
    */
   public static void reverse(char[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       char tmp = array[i];
@@ -502,7 +502,7 @@ public final class Chars {
    */
   public static List<Character> asList(char... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new CharArrayAsList(backingArray);
   }
@@ -576,7 +576,7 @@ public final class Chars {
       checkElementIndex(index, size());
       char oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -585,7 +585,7 @@ public final class Chars {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new CharArrayAsList(array, start + fromIndex, start + toIndex);
     }
diff --git a/guava/src/com/google/common/primitives/Doubles.java b/guava/src/com/google/common/primitives/Doubles.java
index 6b621c5130..6212d92f5e 100644
--- a/guava/src/com/google/common/primitives/Doubles.java
+++ b/guava/src/com/google/common/primitives/Doubles.java
@@ -16,11 +16,12 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.base.Strings.lenientFormat;
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.POSITIVE_INFINITY;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -30,7 +31,6 @@ import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
@@ -161,8 +161,8 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(double[] array, double[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -357,7 +357,7 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @param array an array of {@code double} values, possibly empty
    */
   public static String join(String separator, double... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -418,7 +418,7 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(double[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -432,7 +432,7 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(double[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     Arrays.sort(array, fromIndex, toIndex);
     reverse(array, fromIndex, toIndex);
@@ -445,7 +445,7 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(double[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -460,7 +460,7 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(double[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       double tmp = array[i];
@@ -492,7 +492,7 @@ public final class Doubles extends DoublesMethodsForWeb {
     double[] array = new double[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = ((Number) checkNotNull(boxedArray[i])).doubleValue();
+      array[i] = ((Number) requireNonNull(boxedArray[i])).doubleValue();
     }
     return array;
   }
@@ -517,7 +517,7 @@ public final class Doubles extends DoublesMethodsForWeb {
    */
   public static List<Double> asList(double... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new DoubleArrayAsList(backingArray);
   }
@@ -596,7 +596,7 @@ public final class Doubles extends DoublesMethodsForWeb {
       checkElementIndex(index, size());
       double oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -605,7 +605,7 @@ public final class Doubles extends DoublesMethodsForWeb {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new DoubleArrayAsList(array, start + fromIndex, start + toIndex);
     }
@@ -699,8 +699,8 @@ public final class Doubles extends DoublesMethodsForWeb {
    * @since 14.0
    */
   @Beta
-  @GwtIncompatible // regular expressions
-  @CheckForNull
+  @CheckForNull // regular expressions
+  @GwtIncompatible
   public static Double tryParse(String string) {
     if (FLOATING_POINT_PATTERN.matcher(string).matches()) {
       // TODO(lowasser): could be potentially optimized, but only with
diff --git a/guava/src/com/google/common/primitives/Floats.java b/guava/src/com/google/common/primitives/Floats.java
index b038cb2896..242a0b36db 100644
--- a/guava/src/com/google/common/primitives/Floats.java
+++ b/guava/src/com/google/common/primitives/Floats.java
@@ -16,11 +16,12 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static com.google.common.base.Strings.lenientFormat;
 import static java.lang.Float.NEGATIVE_INFINITY;
 import static java.lang.Float.POSITIVE_INFINITY;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -30,7 +31,6 @@ import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
@@ -156,8 +156,8 @@ public final class Floats extends FloatsMethodsForWeb {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(float[] array, float[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -352,7 +352,7 @@ public final class Floats extends FloatsMethodsForWeb {
    * @param array an array of {@code float} values, possibly empty
    */
   public static String join(String separator, float... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -413,7 +413,7 @@ public final class Floats extends FloatsMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(float[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -427,7 +427,7 @@ public final class Floats extends FloatsMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(float[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     Arrays.sort(array, fromIndex, toIndex);
     reverse(array, fromIndex, toIndex);
@@ -440,7 +440,7 @@ public final class Floats extends FloatsMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(float[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -455,7 +455,7 @@ public final class Floats extends FloatsMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(float[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       float tmp = array[i];
@@ -487,7 +487,7 @@ public final class Floats extends FloatsMethodsForWeb {
     float[] array = new float[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = ((Number) checkNotNull(boxedArray[i])).floatValue();
+      array[i] = ((Number) requireNonNull(boxedArray[i])).floatValue();
     }
     return array;
   }
@@ -509,7 +509,7 @@ public final class Floats extends FloatsMethodsForWeb {
    */
   public static List<Float> asList(float... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new FloatArrayAsList(backingArray);
   }
@@ -582,7 +582,7 @@ public final class Floats extends FloatsMethodsForWeb {
       checkElementIndex(index, size());
       float oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -591,7 +591,7 @@ public final class Floats extends FloatsMethodsForWeb {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new FloatArrayAsList(array, start + fromIndex, start + toIndex);
     }
@@ -661,8 +661,8 @@ public final class Floats extends FloatsMethodsForWeb {
    * @since 14.0
    */
   @Beta
-  @GwtIncompatible // regular expressions
-  @CheckForNull
+  @CheckForNull // regular expressions
+  @GwtIncompatible
   public static Float tryParse(String string) {
     if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {
       // TODO(lowasser): could be potentially optimized, but only with
diff --git a/guava/src/com/google/common/primitives/ImmutableDoubleArray.java b/guava/src/com/google/common/primitives/ImmutableDoubleArray.java
index 9731c11315..6af3d5dd24 100644
--- a/guava/src/com/google/common/primitives/ImmutableDoubleArray.java
+++ b/guava/src/com/google/common/primitives/ImmutableDoubleArray.java
@@ -15,11 +15,12 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkElementIndex;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
 import com.google.errorprone.annotations.Immutable;
@@ -372,7 +373,7 @@ public final class ImmutableDoubleArray implements Serializable {
    *     {@link #length}
    */
   public double get(int index) {
-    Preconditions.checkElementIndex(index, length());
+    checkElementIndex(index, length());
     return array[start + index];
   }
 
@@ -414,7 +415,7 @@ public final class ImmutableDoubleArray implements Serializable {
 
   /** Invokes {@code consumer} for each value contained in this array, in order. */
   public void forEach(DoubleConsumer consumer) {
-    checkNotNull(consumer);
+    requireNonNull(consumer);
     for (int i = start; i < end; i++) {
       consumer.accept(array[i]);
     }
@@ -438,7 +439,7 @@ public final class ImmutableDoubleArray implements Serializable {
    * end).trimmed()}.
    */
   public ImmutableDoubleArray subArray(int startIndex, int endIndex) {
-    Preconditions.checkPositionIndexes(startIndex, endIndex, length());
+    checkPositionIndexes(startIndex, endIndex, length());
     return startIndex == endIndex
         ? EMPTY
         : new ImmutableDoubleArray(array, start + startIndex, start + endIndex);
diff --git a/guava/src/com/google/common/primitives/ImmutableIntArray.java b/guava/src/com/google/common/primitives/ImmutableIntArray.java
index cc3c671442..c1b5be02d2 100644
--- a/guava/src/com/google/common/primitives/ImmutableIntArray.java
+++ b/guava/src/com/google/common/primitives/ImmutableIntArray.java
@@ -15,11 +15,12 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkElementIndex;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
 import com.google.errorprone.annotations.Immutable;
@@ -369,7 +370,7 @@ public final class ImmutableIntArray implements Serializable {
    *     {@link #length}
    */
   public int get(int index) {
-    Preconditions.checkElementIndex(index, length());
+    checkElementIndex(index, length());
     return array[start + index];
   }
 
@@ -409,7 +410,7 @@ public final class ImmutableIntArray implements Serializable {
 
   /** Invokes {@code consumer} for each value contained in this array, in order. */
   public void forEach(IntConsumer consumer) {
-    checkNotNull(consumer);
+    requireNonNull(consumer);
     for (int i = start; i < end; i++) {
       consumer.accept(array[i]);
     }
@@ -433,7 +434,7 @@ public final class ImmutableIntArray implements Serializable {
    * end).trimmed()}.
    */
   public ImmutableIntArray subArray(int startIndex, int endIndex) {
-    Preconditions.checkPositionIndexes(startIndex, endIndex, length());
+    checkPositionIndexes(startIndex, endIndex, length());
     return startIndex == endIndex
         ? EMPTY
         : new ImmutableIntArray(array, start + startIndex, start + endIndex);
diff --git a/guava/src/com/google/common/primitives/ImmutableLongArray.java b/guava/src/com/google/common/primitives/ImmutableLongArray.java
index c8f70375d2..352f8ed66b 100644
--- a/guava/src/com/google/common/primitives/ImmutableLongArray.java
+++ b/guava/src/com/google/common/primitives/ImmutableLongArray.java
@@ -15,11 +15,12 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkElementIndex;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.CheckReturnValue;
 import com.google.errorprone.annotations.Immutable;
@@ -371,7 +372,7 @@ public final class ImmutableLongArray implements Serializable {
    *     {@link #length}
    */
   public long get(int index) {
-    Preconditions.checkElementIndex(index, length());
+    checkElementIndex(index, length());
     return array[start + index];
   }
 
@@ -411,7 +412,7 @@ public final class ImmutableLongArray implements Serializable {
 
   /** Invokes {@code consumer} for each value contained in this array, in order. */
   public void forEach(LongConsumer consumer) {
-    checkNotNull(consumer);
+    requireNonNull(consumer);
     for (int i = start; i < end; i++) {
       consumer.accept(array[i]);
     }
@@ -435,7 +436,7 @@ public final class ImmutableLongArray implements Serializable {
    * end).trimmed()}.
    */
   public ImmutableLongArray subArray(int startIndex, int endIndex) {
-    Preconditions.checkPositionIndexes(startIndex, endIndex, length());
+    checkPositionIndexes(startIndex, endIndex, length());
     return startIndex == endIndex
         ? EMPTY
         : new ImmutableLongArray(array, start + startIndex, start + endIndex);
diff --git a/guava/src/com/google/common/primitives/Ints.java b/guava/src/com/google/common/primitives/Ints.java
index b63b0f946e..6c833e7c3e 100644
--- a/guava/src/com/google/common/primitives/Ints.java
+++ b/guava/src/com/google/common/primitives/Ints.java
@@ -16,8 +16,9 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -27,7 +28,6 @@ import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
@@ -174,8 +174,8 @@ public final class Ints extends IntsMethodsForWeb {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(int[] array, int[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -407,7 +407,7 @@ public final class Ints extends IntsMethodsForWeb {
    * @param array an array of {@code int} values, possibly empty
    */
   public static String join(String separator, int... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -464,7 +464,7 @@ public final class Ints extends IntsMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(int[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -475,7 +475,7 @@ public final class Ints extends IntsMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(int[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     Arrays.sort(array, fromIndex, toIndex);
     reverse(array, fromIndex, toIndex);
@@ -488,7 +488,7 @@ public final class Ints extends IntsMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(int[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -503,7 +503,7 @@ public final class Ints extends IntsMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(int[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       int tmp = array[i];
@@ -535,7 +535,7 @@ public final class Ints extends IntsMethodsForWeb {
     int[] array = new int[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = ((Number) checkNotNull(boxedArray[i])).intValue();
+      array[i] = ((Number) requireNonNull(boxedArray[i])).intValue();
     }
     return array;
   }
@@ -557,7 +557,7 @@ public final class Ints extends IntsMethodsForWeb {
    */
   public static List<Integer> asList(int... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new IntArrayAsList(backingArray);
   }
@@ -635,7 +635,7 @@ public final class Ints extends IntsMethodsForWeb {
       checkElementIndex(index, size());
       int oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -644,7 +644,7 @@ public final class Ints extends IntsMethodsForWeb {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new IntArrayAsList(array, start + fromIndex, start + toIndex);
     }
diff --git a/guava/src/com/google/common/primitives/Longs.java b/guava/src/com/google/common/primitives/Longs.java
index 98c055e27a..1029e4a468 100644
--- a/guava/src/com/google/common/primitives/Longs.java
+++ b/guava/src/com/google/common/primitives/Longs.java
@@ -16,8 +16,9 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -26,7 +27,6 @@ import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
@@ -145,8 +145,8 @@ public final class Longs {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(long[] array, long[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -392,13 +392,13 @@ public final class Longs {
   @Beta
   @CheckForNull
   public static Long tryParse(String string, int radix) {
-    if (checkNotNull(string).isEmpty()) {
+    if (requireNonNull(string).isEmpty()) {
       return null;
     }
-    if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
-      throw new IllegalArgumentException(
-          "radix must be between MIN_RADIX and MAX_RADIX but was " + radix);
-    }
+    checkArgument(
+        radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX,
+        "radix must be between MIN_RADIX and MAX_RADIX but was %s",
+        radix);
     boolean negative = string.charAt(0) == '-';
     int index = negative ? 1 : 0;
     if (index == string.length()) {
@@ -502,7 +502,7 @@ public final class Longs {
    * @param array an array of {@code long} values, possibly empty
    */
   public static String join(String separator, long... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -560,7 +560,7 @@ public final class Longs {
    * @since 23.1
    */
   public static void sortDescending(long[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -571,7 +571,7 @@ public final class Longs {
    * @since 23.1
    */
   public static void sortDescending(long[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     Arrays.sort(array, fromIndex, toIndex);
     reverse(array, fromIndex, toIndex);
@@ -584,7 +584,7 @@ public final class Longs {
    * @since 23.1
    */
   public static void reverse(long[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -599,7 +599,7 @@ public final class Longs {
    * @since 23.1
    */
   public static void reverse(long[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       long tmp = array[i];
@@ -631,7 +631,7 @@ public final class Longs {
     long[] array = new long[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = ((Number) checkNotNull(boxedArray[i])).longValue();
+      array[i] = ((Number) requireNonNull(boxedArray[i])).longValue();
     }
     return array;
   }
@@ -653,7 +653,7 @@ public final class Longs {
    */
   public static List<Long> asList(long... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new LongArrayAsList(backingArray);
   }
@@ -731,7 +731,7 @@ public final class Longs {
       checkElementIndex(index, size());
       long oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -740,7 +740,7 @@ public final class Longs {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new LongArrayAsList(array, start + fromIndex, start + toIndex);
     }
diff --git a/guava/src/com/google/common/primitives/ParseRequest.java b/guava/src/com/google/common/primitives/ParseRequest.java
index a102d69b06..f1d9c06602 100644
--- a/guava/src/com/google/common/primitives/ParseRequest.java
+++ b/guava/src/com/google/common/primitives/ParseRequest.java
@@ -29,7 +29,7 @@ final class ParseRequest {
   }
 
   static ParseRequest fromString(String stringValue) {
-    if (stringValue.length() == 0) {
+    if (stringValue.isEmpty()) {
       throw new NumberFormatException("empty string");
     }
 
diff --git a/guava/src/com/google/common/primitives/Primitives.java b/guava/src/com/google/common/primitives/Primitives.java
index 7ceed03655..6b3db033b0 100644
--- a/guava/src/com/google/common/primitives/Primitives.java
+++ b/guava/src/com/google/common/primitives/Primitives.java
@@ -14,10 +14,10 @@
 
 package com.google.common.primitives;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -56,8 +56,8 @@ public final class Primitives {
     add(primToWrap, wrapToPrim, short.class, Short.class);
     add(primToWrap, wrapToPrim, void.class, Void.class);
 
-    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);
-    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);
+    PRIMITIVE_TO_WRAPPER_TYPE = unmodifiableMap(primToWrap);
+    WRAPPER_TO_PRIMITIVE_TYPE = unmodifiableMap(wrapToPrim);
   }
 
   private static void add(
@@ -96,7 +96,7 @@ public final class Primitives {
    * @see Class#isPrimitive
    */
   public static boolean isWrapperType(Class<?> type) {
-    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(checkNotNull(type));
+    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(requireNonNull(type));
   }
 
   /**
@@ -110,7 +110,7 @@ public final class Primitives {
    * </pre>
    */
   public static <T> Class<T> wrap(Class<T> type) {
-    checkNotNull(type);
+    requireNonNull(type);
 
     // cast is safe: long.class and Long.class are both of type Class<Long>
     @SuppressWarnings("unchecked")
@@ -129,7 +129,7 @@ public final class Primitives {
    * </pre>
    */
   public static <T> Class<T> unwrap(Class<T> type) {
-    checkNotNull(type);
+    requireNonNull(type);
 
     // cast is safe: long.class and Long.class are both of type Class<Long>
     @SuppressWarnings("unchecked")
diff --git a/guava/src/com/google/common/primitives/Shorts.java b/guava/src/com/google/common/primitives/Shorts.java
index 09e0f7cfc3..b396db64a0 100644
--- a/guava/src/com/google/common/primitives/Shorts.java
+++ b/guava/src/com/google/common/primitives/Shorts.java
@@ -16,8 +16,9 @@ package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -27,7 +28,6 @@ import java.io.Serializable;
 import java.util.AbstractList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
@@ -171,8 +171,8 @@ public final class Shorts extends ShortsMethodsForWeb {
    * @param target the array to search for as a sub-sequence of {@code array}
    */
   public static int indexOf(short[] array, short[] target) {
-    checkNotNull(array, "array");
-    checkNotNull(target, "target");
+    requireNonNull(array, "array");
+    requireNonNull(target, "target");
     if (target.length == 0) {
       return 0;
     }
@@ -406,7 +406,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    * @param array an array of {@code short} values, possibly empty
    */
   public static String join(String separator, short... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -464,7 +464,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(short[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -475,7 +475,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    * @since 23.1
    */
   public static void sortDescending(short[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     Arrays.sort(array, fromIndex, toIndex);
     reverse(array, fromIndex, toIndex);
@@ -488,7 +488,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(short[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     reverse(array, 0, array.length);
   }
 
@@ -503,7 +503,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    * @since 23.1
    */
   public static void reverse(short[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {
       short tmp = array[i];
@@ -535,7 +535,7 @@ public final class Shorts extends ShortsMethodsForWeb {
     short[] array = new short[len];
     for (int i = 0; i < len; i++) {
       // checkNotNull for GWT (do not optimize)
-      array[i] = ((Number) checkNotNull(boxedArray[i])).shortValue();
+      array[i] = ((Number) requireNonNull(boxedArray[i])).shortValue();
     }
     return array;
   }
@@ -554,7 +554,7 @@ public final class Shorts extends ShortsMethodsForWeb {
    */
   public static List<Short> asList(short... backingArray) {
     if (backingArray.length == 0) {
-      return Collections.emptyList();
+      return emptyList();
     }
     return new ShortArrayAsList(backingArray);
   }
@@ -627,7 +627,7 @@ public final class Shorts extends ShortsMethodsForWeb {
       checkElementIndex(index, size());
       short oldValue = array[start + index];
       // checkNotNull for GWT (do not optimize)
-      array[start + index] = checkNotNull(element);
+      array[start + index] = requireNonNull(element);
       return oldValue;
     }
 
@@ -636,7 +636,7 @@ public final class Shorts extends ShortsMethodsForWeb {
       int size = size();
       checkPositionIndexes(fromIndex, toIndex, size);
       if (fromIndex == toIndex) {
-        return Collections.emptyList();
+        return emptyList();
       }
       return new ShortArrayAsList(array, start + fromIndex, start + toIndex);
     }
diff --git a/guava/src/com/google/common/primitives/SignedBytes.java b/guava/src/com/google/common/primitives/SignedBytes.java
index 5fabaab6bd..42b1fae196 100644
--- a/guava/src/com/google/common/primitives/SignedBytes.java
+++ b/guava/src/com/google/common/primitives/SignedBytes.java
@@ -15,8 +15,8 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Arrays;
@@ -142,7 +142,7 @@ public final class SignedBytes {
    * @param array an array of {@code byte} values, possibly empty
    */
   public static String join(String separator, byte... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -201,7 +201,7 @@ public final class SignedBytes {
    * @since 23.1
    */
   public static void sortDescending(byte[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -212,7 +212,7 @@ public final class SignedBytes {
    * @since 23.1
    */
   public static void sortDescending(byte[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     Arrays.sort(array, fromIndex, toIndex);
     Bytes.reverse(array, fromIndex, toIndex);
diff --git a/guava/src/com/google/common/primitives/UnsignedBytes.java b/guava/src/com/google/common/primitives/UnsignedBytes.java
index db4f489e49..c681d824b4 100644
--- a/guava/src/com/google/common/primitives/UnsignedBytes.java
+++ b/guava/src/com/google/common/primitives/UnsignedBytes.java
@@ -15,7 +15,6 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
 import static java.util.Objects.requireNonNull;
 
@@ -222,7 +221,7 @@ public final class UnsignedBytes {
   @Beta
   @CanIgnoreReturnValue
   public static byte parseUnsignedByte(String string, int radix) {
-    int parse = Integer.parseInt(checkNotNull(string), radix);
+    int parse = Integer.parseInt(requireNonNull(string), radix);
     // We need to throw a NumberFormatException, so we have to duplicate checkedCast. =(
     if (parse >> Byte.SIZE == 0) {
       return (byte) parse;
@@ -241,7 +240,7 @@ public final class UnsignedBytes {
    * @param array an array of {@code byte} values, possibly empty
    */
   public static String join(String separator, byte... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -462,7 +461,7 @@ public final class UnsignedBytes {
    * @since 23.1
    */
   public static void sort(byte[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sort(array, 0, array.length);
   }
 
@@ -473,7 +472,7 @@ public final class UnsignedBytes {
    * @since 23.1
    */
   public static void sort(byte[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex; i < toIndex; i++) {
       array[i] = flip(array[i]);
@@ -491,7 +490,7 @@ public final class UnsignedBytes {
    * @since 23.1
    */
   public static void sortDescending(byte[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -502,7 +501,7 @@ public final class UnsignedBytes {
    * @since 23.1
    */
   public static void sortDescending(byte[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex; i < toIndex; i++) {
       array[i] ^= Byte.MAX_VALUE;
diff --git a/guava/src/com/google/common/primitives/UnsignedInteger.java b/guava/src/com/google/common/primitives/UnsignedInteger.java
index 0b30cef3f4..280d0338dd 100644
--- a/guava/src/com/google/common/primitives/UnsignedInteger.java
+++ b/guava/src/com/google/common/primitives/UnsignedInteger.java
@@ -15,10 +15,10 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.primitives.UnsignedInts.INT_MASK;
 import static com.google.common.primitives.UnsignedInts.compare;
 import static com.google.common.primitives.UnsignedInts.toLong;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -87,7 +87,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
    * @throws IllegalArgumentException if {@code value} is negative or {@code value >= 2^32}
    */
   public static UnsignedInteger valueOf(BigInteger value) {
-    checkNotNull(value);
+    requireNonNull(value);
     checkArgument(
         value.signum() >= 0 && value.bitLength() <= Integer.SIZE,
         "value (%s) is outside the range for an unsigned integer value",
@@ -124,7 +124,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
    * @since 14.0
    */
   public UnsignedInteger plus(UnsignedInteger val) {
-    return fromIntBits(this.value + checkNotNull(val).value);
+    return fromIntBits(this.value + requireNonNull(val).value);
   }
 
   /**
@@ -134,7 +134,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
    * @since 14.0
    */
   public UnsignedInteger minus(UnsignedInteger val) {
-    return fromIntBits(value - checkNotNull(val).value);
+    return fromIntBits(value - requireNonNull(val).value);
   }
 
   /**
@@ -146,7 +146,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
   @GwtIncompatible // Does not truncate correctly
   public UnsignedInteger times(UnsignedInteger val) {
     // TODO(lowasser): make this GWT-compatible
-    return fromIntBits(value * checkNotNull(val).value);
+    return fromIntBits(value * requireNonNull(val).value);
   }
 
   /**
@@ -156,7 +156,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
    * @since 14.0
    */
   public UnsignedInteger dividedBy(UnsignedInteger val) {
-    return fromIntBits(UnsignedInts.divide(value, checkNotNull(val).value));
+    return fromIntBits(UnsignedInts.divide(value, requireNonNull(val).value));
   }
 
   /**
@@ -166,7 +166,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
    * @since 14.0
    */
   public UnsignedInteger mod(UnsignedInteger val) {
-    return fromIntBits(UnsignedInts.remainder(value, checkNotNull(val).value));
+    return fromIntBits(UnsignedInts.remainder(value, requireNonNull(val).value));
   }
 
   /**
@@ -217,7 +217,7 @@ public final class UnsignedInteger extends Number implements Comparable<Unsigned
    */
   @Override
   public int compareTo(UnsignedInteger other) {
-    checkNotNull(other);
+    requireNonNull(other);
     return compare(value, other.value);
   }
 
diff --git a/guava/src/com/google/common/primitives/UnsignedInts.java b/guava/src/com/google/common/primitives/UnsignedInts.java
index ec6474e20f..e91c30dcdd 100644
--- a/guava/src/com/google/common/primitives/UnsignedInts.java
+++ b/guava/src/com/google/common/primitives/UnsignedInts.java
@@ -15,8 +15,8 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -164,7 +164,7 @@ public final class UnsignedInts {
    * @param array an array of unsigned {@code int} values, possibly empty
    */
   public static String join(String separator, int... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -218,7 +218,7 @@ public final class UnsignedInts {
    * @since 23.1
    */
   public static void sort(int[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sort(array, 0, array.length);
   }
 
@@ -229,7 +229,7 @@ public final class UnsignedInts {
    * @since 23.1
    */
   public static void sort(int[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex; i < toIndex; i++) {
       array[i] = flip(array[i]);
@@ -247,7 +247,7 @@ public final class UnsignedInts {
    * @since 23.1
    */
   public static void sortDescending(int[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -258,7 +258,7 @@ public final class UnsignedInts {
    * @since 23.1
    */
   public static void sortDescending(int[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex; i < toIndex; i++) {
       array[i] ^= Integer.MAX_VALUE;
@@ -355,7 +355,7 @@ public final class UnsignedInts {
    */
   @CanIgnoreReturnValue
   public static int parseUnsignedInt(String string, int radix) {
-    checkNotNull(string);
+    requireNonNull(string);
     long result = Long.parseLong(string, radix);
     if ((result & INT_MASK) != result) {
       throw new NumberFormatException(
diff --git a/guava/src/com/google/common/primitives/UnsignedLong.java b/guava/src/com/google/common/primitives/UnsignedLong.java
index d803634f49..346b3da748 100644
--- a/guava/src/com/google/common/primitives/UnsignedLong.java
+++ b/guava/src/com/google/common/primitives/UnsignedLong.java
@@ -15,7 +15,7 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -91,7 +91,7 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    */
   @CanIgnoreReturnValue
   public static UnsignedLong valueOf(BigInteger value) {
-    checkNotNull(value);
+    requireNonNull(value);
     checkArgument(
         value.signum() >= 0 && value.bitLength() <= Long.SIZE,
         "value (%s) is outside the range for an unsigned long value",
@@ -131,7 +131,7 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    * @since 14.0
    */
   public UnsignedLong plus(UnsignedLong val) {
-    return fromLongBits(this.value + checkNotNull(val).value);
+    return fromLongBits(this.value + requireNonNull(val).value);
   }
 
   /**
@@ -141,7 +141,7 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    * @since 14.0
    */
   public UnsignedLong minus(UnsignedLong val) {
-    return fromLongBits(this.value - checkNotNull(val).value);
+    return fromLongBits(this.value - requireNonNull(val).value);
   }
 
   /**
@@ -151,7 +151,7 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    * @since 14.0
    */
   public UnsignedLong times(UnsignedLong val) {
-    return fromLongBits(value * checkNotNull(val).value);
+    return fromLongBits(value * requireNonNull(val).value);
   }
 
   /**
@@ -160,7 +160,7 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    * @since 14.0
    */
   public UnsignedLong dividedBy(UnsignedLong val) {
-    return fromLongBits(UnsignedLongs.divide(value, checkNotNull(val).value));
+    return fromLongBits(UnsignedLongs.divide(value, requireNonNull(val).value));
   }
 
   /**
@@ -169,7 +169,7 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
    * @since 14.0
    */
   public UnsignedLong mod(UnsignedLong val) {
-    return fromLongBits(UnsignedLongs.remainder(value, checkNotNull(val).value));
+    return fromLongBits(UnsignedLongs.remainder(value, requireNonNull(val).value));
   }
 
   /** Returns the value of this {@code UnsignedLong} as an {@code int}. */
@@ -232,7 +232,7 @@ public final class UnsignedLong extends Number implements Comparable<UnsignedLon
 
   @Override
   public int compareTo(UnsignedLong o) {
-    checkNotNull(o);
+    requireNonNull(o);
     return UnsignedLongs.compare(value, o.value);
   }
 
diff --git a/guava/src/com/google/common/primitives/UnsignedLongs.java b/guava/src/com/google/common/primitives/UnsignedLongs.java
index 31c51cc346..9c14436484 100644
--- a/guava/src/com/google/common/primitives/UnsignedLongs.java
+++ b/guava/src/com/google/common/primitives/UnsignedLongs.java
@@ -15,8 +15,8 @@
 package com.google.common.primitives;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -129,7 +129,7 @@ public final class UnsignedLongs {
    * @param array an array of unsigned {@code long} values, possibly empty
    */
   public static String join(String separator, long... array) {
-    checkNotNull(separator);
+    requireNonNull(separator);
     if (array.length == 0) {
       return "";
     }
@@ -184,7 +184,7 @@ public final class UnsignedLongs {
    * @since 23.1
    */
   public static void sort(long[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sort(array, 0, array.length);
   }
 
@@ -195,7 +195,7 @@ public final class UnsignedLongs {
    * @since 23.1
    */
   public static void sort(long[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex; i < toIndex; i++) {
       array[i] = flip(array[i]);
@@ -213,7 +213,7 @@ public final class UnsignedLongs {
    * @since 23.1
    */
   public static void sortDescending(long[] array) {
-    checkNotNull(array);
+    requireNonNull(array);
     sortDescending(array, 0, array.length);
   }
 
@@ -224,7 +224,7 @@ public final class UnsignedLongs {
    * @since 23.1
    */
   public static void sortDescending(long[] array, int fromIndex, int toIndex) {
-    checkNotNull(array);
+    requireNonNull(array);
     checkPositionIndexes(fromIndex, toIndex, array.length);
     for (int i = fromIndex; i < toIndex; i++) {
       array[i] ^= Long.MAX_VALUE;
@@ -336,8 +336,8 @@ public final class UnsignedLongs {
    */
   @CanIgnoreReturnValue
   public static long parseUnsignedLong(String string, int radix) {
-    checkNotNull(string);
-    if (string.length() == 0) {
+    requireNonNull(string);
+    if (string.isEmpty()) {
       throw new NumberFormatException("empty string");
     }
     if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
diff --git a/guava/src/com/google/common/reflect/AbstractInvocationHandler.java b/guava/src/com/google/common/reflect/AbstractInvocationHandler.java
index ff921959db..f8b97b7e37 100644
--- a/guava/src/com/google/common/reflect/AbstractInvocationHandler.java
+++ b/guava/src/com/google/common/reflect/AbstractInvocationHandler.java
@@ -58,8 +58,8 @@ public abstract class AbstractInvocationHandler implements InvocationHandler {
    *   <li>other method calls are dispatched to {@link #handleInvocation}.
    * </ul>
    */
-  @Override
   @CheckForNull
+  @Override
   public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
       throws Throwable {
     if (args == null) {
diff --git a/guava/src/com/google/common/reflect/ClassPath.java b/guava/src/com/google/common/reflect/ClassPath.java
index d15bb5055d..2d87ddd4d2 100644
--- a/guava/src/com/google/common/reflect/ClassPath.java
+++ b/guava/src/com/google/common/reflect/ClassPath.java
@@ -15,9 +15,9 @@
 package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
 import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
+import static java.util.Objects.requireNonNull;
 import static java.util.logging.Level.WARNING;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -170,7 +170,7 @@ public final class ClassPath {
 
   /** Returns all top level classes whose package name is {@code packageName}. */
   public ImmutableSet<ClassInfo> getTopLevelClasses(String packageName) {
-    checkNotNull(packageName);
+    requireNonNull(packageName);
     ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();
     for (ClassInfo classInfo : getTopLevelClasses()) {
       if (classInfo.getPackageName().equals(packageName)) {
@@ -185,7 +185,7 @@ public final class ClassPath {
    * packageName} followed by a '.'.
    */
   public ImmutableSet<ClassInfo> getTopLevelClassesRecursive(String packageName) {
-    checkNotNull(packageName);
+    requireNonNull(packageName);
     String packagePrefix = packageName + '.';
     ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();
     for (ClassInfo classInfo : getTopLevelClasses()) {
@@ -217,9 +217,9 @@ public final class ClassPath {
     }
 
     ResourceInfo(File file, String resourceName, ClassLoader loader) {
-      this.file = checkNotNull(file);
-      this.resourceName = checkNotNull(resourceName);
-      this.loader = checkNotNull(loader);
+      this.file = requireNonNull(file);
+      this.resourceName = requireNonNull(resourceName);
+      this.loader = requireNonNull(loader);
     }
 
     /**
@@ -411,8 +411,8 @@ public final class ClassPath {
     private final ClassLoader classloader;
 
     LocationInfo(File home, ClassLoader classloader) {
-      this.home = checkNotNull(home);
-      this.classloader = checkNotNull(classloader);
+      this.home = requireNonNull(home);
+      this.classloader = requireNonNull(classloader);
     }
 
     /** Returns the file this location is from. */
diff --git a/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java b/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java
index 6273704a10..16ba194811 100644
--- a/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java
+++ b/guava/src/com/google/common/reflect/ImmutableTypeToInstanceMap.java
@@ -100,14 +100,14 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
     this.delegate = delegate;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public <T extends B> T getInstance(TypeToken<T> type) {
     return trustedGet(type.rejectTypeVariables());
   }
 
-  @Override
   @CheckForNull
+  @Override
   public <T extends B> T getInstance(Class<T> type) {
     return trustedGet(TypeToken.of(type));
   }
@@ -119,10 +119,10 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    * @throws UnsupportedOperationException always
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public <T extends B> T putInstance(TypeToken<T> type, T value) {
     throw new UnsupportedOperationException();
   }
@@ -134,10 +134,10 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    * @throws UnsupportedOperationException always
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public <T extends B> T putInstance(Class<T> type, T value) {
     throw new UnsupportedOperationException();
   }
@@ -149,10 +149,10 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    * @throws UnsupportedOperationException always
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public B put(TypeToken<? extends B> key, B value) {
     throw new UnsupportedOperationException();
   }
@@ -164,8 +164,8 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
    * @throws UnsupportedOperationException always
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {
     throw new UnsupportedOperationException();
   }
@@ -175,8 +175,8 @@ public final class ImmutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken
     return delegate;
   }
 
-  @SuppressWarnings("unchecked") // value could not get in if not a T
-  @CheckForNull
+  @CheckForNull // value could not get in if not a T
+  @SuppressWarnings("unchecked")
   private <T extends B> T trustedGet(TypeToken<T> type) {
     return (T) delegate.get(type);
   }
diff --git a/guava/src/com/google/common/reflect/Invokable.java b/guava/src/com/google/common/reflect/Invokable.java
index e6d3b6c53f..ae8d93801a 100644
--- a/guava/src/com/google/common/reflect/Invokable.java
+++ b/guava/src/com/google/common/reflect/Invokable.java
@@ -14,7 +14,8 @@
 
 package com.google.common.reflect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkArgument;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.collect.ImmutableList;
@@ -70,7 +71,7 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
   private final Member member;
 
   <M extends AccessibleObject & Member> Invokable(M member) {
-    checkNotNull(member);
+    requireNonNull(member);
     this.accessibleObject = member;
     this.member = member;
   }
@@ -90,8 +91,8 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
     return accessibleObject.isAnnotationPresent(annotationClass);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public final <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
     return accessibleObject.getAnnotation(annotationClass);
   }
@@ -253,12 +254,12 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
    * @throws InvocationTargetException if the underlying method or constructor throws an exception.
    */
   // All subclasses are owned by us and we'll make sure to get the R type right, including nullness.
-  @SuppressWarnings({"unchecked", "nullness"})
   @CanIgnoreReturnValue
   @CheckForNull
+  @SuppressWarnings({"nullness", "unchecked"})
   public final R invoke(@CheckForNull T receiver, @Nullable Object... args)
       throws InvocationTargetException, IllegalAccessException {
-    return (R) invokeInternal(receiver, checkNotNull(args));
+    return (R) invokeInternal(receiver, requireNonNull(args));
   }
 
   /** Returns the return type of this {@code Invokable}. */
@@ -313,17 +314,18 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
 
   /** Explicitly specifies the return type of this {@code Invokable}. */
   public final <R1 extends R> Invokable<T, R1> returning(TypeToken<R1> returnType) {
-    if (!returnType.isSupertypeOf(getReturnType())) {
-      throw new IllegalArgumentException(
-          "Invokable is known to return " + getReturnType() + ", not " + returnType);
-    }
+    checkArgument(
+        returnType.isSupertypeOf(getReturnType()),
+        "Invokable is known to return %s, not %s",
+        getReturnType(),
+        returnType);
     @SuppressWarnings("unchecked") // guarded by previous check
     Invokable<T, R1> specialized = (Invokable<T, R1>) this;
     return specialized;
   }
 
-  @SuppressWarnings("unchecked") // The declaring class is T's raw class, or one of its supertypes.
-  @Override
+  @Override // The declaring class is T's raw class, or one of its supertypes.
+  @SuppressWarnings("unchecked")
   public final Class<? super T> getDeclaringClass() {
     return (Class<? super T>) member.getDeclaringClass();
   }
@@ -361,8 +363,8 @@ public abstract class Invokable<T, R> implements AnnotatedElement, Member {
       this.method = method;
     }
 
-    @Override
     @CheckForNull
+    @Override
     final Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       return method.invoke(receiver, args);
diff --git a/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java b/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java
index 9542e0a7ed..22f0867f2c 100644
--- a/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java
+++ b/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java
@@ -14,7 +14,7 @@
 
 package com.google.common.reflect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.collect.ForwardingMap;
 import com.google.common.collect.ForwardingMapEntry;
@@ -44,28 +44,28 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
 
   private final Map<TypeToken<? extends B>, B> backingMap = Maps.newHashMap();
 
-  @Override
   @CheckForNull
+  @Override
   public <T extends B> T getInstance(Class<T> type) {
     return trustedGet(TypeToken.of(type));
   }
 
-  @Override
   @CheckForNull
+  @Override
   public <T extends B> T getInstance(TypeToken<T> type) {
     return trustedGet(type.rejectTypeVariables());
   }
 
-  @Override
   @CanIgnoreReturnValue
   @CheckForNull
+  @Override
   public <T extends B> T putInstance(Class<T> type, T value) {
     return trustedPut(TypeToken.of(type), value);
   }
 
-  @Override
   @CanIgnoreReturnValue
   @CheckForNull
+  @Override
   public <T extends B> T putInstance(TypeToken<T> type, T value) {
     return trustedPut(type.rejectTypeVariables(), value);
   }
@@ -77,10 +77,10 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
    * @throws UnsupportedOperationException always
    */
   @CanIgnoreReturnValue
+  @CheckForNull
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
-  @CheckForNull
+  @Override
   public B put(TypeToken<? extends B> key, B value) {
     throw new UnsupportedOperationException("Please use putInstance() instead.");
   }
@@ -92,8 +92,8 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
    * @throws UnsupportedOperationException always
    */
   @Deprecated
-  @Override
   @DoNotCall("Always throws UnsupportedOperationException")
+  @Override
   public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {
     throw new UnsupportedOperationException("Please use putInstance() instead.");
   }
@@ -108,14 +108,14 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
     return backingMap;
   }
 
-  @SuppressWarnings("unchecked") // value could not get in if not a T
-  @CheckForNull
+  @CheckForNull // value could not get in if not a T
+  @SuppressWarnings("unchecked")
   private <T extends B> T trustedPut(TypeToken<T> type, T value) {
     return (T) backingMap.put(type, value);
   }
 
-  @SuppressWarnings("unchecked") // value could not get in if not a T
-  @CheckForNull
+  @CheckForNull // value could not get in if not a T
+  @SuppressWarnings("unchecked")
   private <T extends B> T trustedGet(TypeToken<T> type) {
     return (T) backingMap.get(type);
   }
@@ -162,7 +162,7 @@ public final class MutableTypeToInstanceMap<B> extends ForwardingMap<TypeToken<?
     }
 
     private UnmodifiableEntry(java.util.Map.Entry<K, V> delegate) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
diff --git a/guava/src/com/google/common/reflect/Parameter.java b/guava/src/com/google/common/reflect/Parameter.java
index 5ef6606ea2..81f28d0492 100644
--- a/guava/src/com/google/common/reflect/Parameter.java
+++ b/guava/src/com/google/common/reflect/Parameter.java
@@ -14,7 +14,7 @@
 
 package com.google.common.reflect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.collect.FluentIterable;
@@ -73,10 +73,10 @@ public final class Parameter implements AnnotatedElement {
     return getAnnotation(annotationType) != null;
   }
 
-  @Override
   @CheckForNull
+  @Override
   public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
-    checkNotNull(annotationType);
+    requireNonNull(annotationType);
     for (Annotation annotation : annotations) {
       if (annotationType.isInstance(annotation)) {
         return annotationType.cast(annotation);
@@ -112,10 +112,10 @@ public final class Parameter implements AnnotatedElement {
    * @since 18.0
    */
   // @Override on JDK8
-  @Override
   @CheckForNull
+  @Override
   public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationType) {
-    checkNotNull(annotationType);
+    requireNonNull(annotationType);
     return FluentIterable.from(annotations).filter(annotationType).first().orNull();
   }
 
diff --git a/guava/src/com/google/common/reflect/Reflection.java b/guava/src/com/google/common/reflect/Reflection.java
index 9544963481..a4f9776b2d 100644
--- a/guava/src/com/google/common/reflect/Reflection.java
+++ b/guava/src/com/google/common/reflect/Reflection.java
@@ -15,7 +15,7 @@
 package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Proxy;
@@ -78,7 +78,7 @@ public final class Reflection {
    *     interface
    */
   public static <T> T newProxy(Class<T> interfaceType, InvocationHandler handler) {
-    checkNotNull(handler);
+    requireNonNull(handler);
     checkArgument(interfaceType.isInterface(), "%s is not an interface", interfaceType);
     Object object =
         Proxy.newProxyInstance(
diff --git a/guava/src/com/google/common/reflect/TypeResolver.java b/guava/src/com/google/common/reflect/TypeResolver.java
index 32517eb878..b1cb5e9f6a 100644
--- a/guava/src/com/google/common/reflect/TypeResolver.java
+++ b/guava/src/com/google/common/reflect/TypeResolver.java
@@ -15,9 +15,9 @@
 package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.Arrays.asList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.base.Joiner;
 import com.google.common.base.Objects;
@@ -111,7 +111,7 @@ public final class TypeResolver {
    */
   public TypeResolver where(Type formal, Type actual) {
     Map<TypeVariableKey, Type> mappings = Maps.newHashMap();
-    populateTypeMappings(mappings, checkNotNull(formal), checkNotNull(actual));
+    populateTypeMappings(mappings, requireNonNull(formal), requireNonNull(actual));
     return where(mappings);
   }
 
@@ -211,7 +211,7 @@ public final class TypeResolver {
    * corresponding type with type variables resolved.
    */
   public Type resolveType(Type type) {
-    checkNotNull(type);
+    requireNonNull(type);
     if (type instanceof TypeVariable) {
       return typeTable.resolve((TypeVariable<?>) type);
     } else if (type instanceof ParameterizedType) {
@@ -377,7 +377,7 @@ public final class TypeResolver {
      * superclass and the super interfaces of {@code contextClass}.
      */
     static ImmutableMap<TypeVariableKey, Type> getTypeMappings(Type contextType) {
-      checkNotNull(contextType);
+      requireNonNull(contextType);
       TypeMappingIntrospector introspector = new TypeMappingIntrospector();
       introspector.visit(contextType);
       return ImmutableMap.copyOf(introspector.mappings);
@@ -458,7 +458,7 @@ public final class TypeResolver {
     }
 
     final Type capture(Type type) {
-      checkNotNull(type);
+      requireNonNull(type);
       if (type instanceof Class) {
         return type;
       }
@@ -552,7 +552,7 @@ public final class TypeResolver {
     private final TypeVariable<?> var;
 
     TypeVariableKey(TypeVariable<?> var) {
-      this.var = checkNotNull(var);
+      this.var = requireNonNull(var);
     }
 
     @Override
diff --git a/guava/src/com/google/common/reflect/TypeToken.java b/guava/src/com/google/common/reflect/TypeToken.java
index fea1d53a2f..2994aac9b2 100644
--- a/guava/src/com/google/common/reflect/TypeToken.java
+++ b/guava/src/com/google/common/reflect/TypeToken.java
@@ -15,7 +15,6 @@
 package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.Objects.requireNonNull;
 
@@ -162,7 +161,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
   }
 
   private TypeToken(Type type) {
-    this.runtimeType = checkNotNull(type);
+    this.runtimeType = requireNonNull(type);
   }
 
   /** Returns an instance of type token that wraps {@code type}. */
@@ -278,7 +277,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
    * }</pre>
    */
   public final TypeToken<?> resolveType(Type type) {
-    checkNotNull(type);
+    requireNonNull(type);
     // Being conservative here because the user could use resolveType() to resolve a type in an
     // invariant context.
     return of(getInvariantTypeResolver().resolveType(type));
@@ -487,7 +486,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
    * @since 19.0
    */
   public final boolean isSubtypeOf(Type supertype) {
-    checkNotNull(supertype);
+    requireNonNull(supertype);
     if (supertype instanceof WildcardType) {
       // if 'supertype' is <? super Foo>, 'this' can be:
       // Foo, SubFoo, <? extends Foo>.
@@ -692,7 +691,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
       ImmutableSet<TypeToken<? super T>> filteredTypes = types;
       if (filteredTypes == null) {
         // Java has no way to express ? super T when we parameterize TypeToken vs. Class.
-        @SuppressWarnings({"unchecked", "rawtypes"})
+        @SuppressWarnings({"rawtypes", "unchecked"})
         ImmutableList<TypeToken<? super T>> collectedTypes =
             (ImmutableList) TypeCollector.FOR_GENERIC_TYPE.collectTypes(TypeToken.this);
         return (types =
@@ -707,7 +706,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
     /** Returns the raw types of the types in this set, in the same order. */
     public Set<Class<? super T>> rawTypes() {
       // Java has no way to express ? super T when we parameterize TypeToken vs. Class.
-      @SuppressWarnings({"unchecked", "rawtypes"})
+      @SuppressWarnings({"rawtypes", "unchecked"})
       ImmutableList<Class<? super T>> collectedTypes =
           (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());
       return ImmutableSet.copyOf(collectedTypes);
@@ -744,7 +743,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
     @Override
     public Set<Class<? super T>> rawTypes() {
       // Java has no way to express ? super T when we parameterize TypeToken vs. Class.
-      @SuppressWarnings({"unchecked", "rawtypes"})
+      @SuppressWarnings({"rawtypes", "unchecked"})
       ImmutableList<Class<? super T>> collectedTypes =
           (ImmutableList) TypeCollector.FOR_RAW_TYPE.collectTypes(getRawTypes());
       return FluentIterable.from(collectedTypes).filter(Class::isInterface).toSet();
@@ -770,7 +769,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
     protected Set<TypeToken<? super T>> delegate() {
       ImmutableSet<TypeToken<? super T>> result = classes;
       if (result == null) {
-        @SuppressWarnings({"unchecked", "rawtypes"})
+        @SuppressWarnings({"rawtypes", "unchecked"})
         ImmutableList<TypeToken<? super T>> collectedTypes =
             (ImmutableList)
                 TypeCollector.FOR_GENERIC_TYPE.classesOnly().collectTypes(TypeToken.this);
@@ -791,7 +790,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
     @Override
     public Set<Class<? super T>> rawTypes() {
       // Java has no way to express ? super T when we parameterize TypeToken vs. Class.
-      @SuppressWarnings({"unchecked", "rawtypes"})
+      @SuppressWarnings({"rawtypes", "unchecked"})
       ImmutableList<Class<? super T>> collectedTypes =
           (ImmutableList) TypeCollector.FOR_RAW_TYPE.classesOnly().collectTypes(getRawTypes());
       return ImmutableSet.copyOf(collectedTypes);
@@ -1124,7 +1123,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
       }
     }.visit(runtimeType);
     // Cast from ImmutableSet<Class<?>> to ImmutableSet<Class<? super T>>
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     ImmutableSet<Class<? super T>> result = (ImmutableSet) builder.build();
     return result;
   }
@@ -1235,9 +1234,7 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
     @SuppressWarnings("rawtypes")
     TypeToken componentType = getComponentType();
     // TODO(cpovirk): checkArgument?
-    if (componentType == null) {
-      throw new IllegalArgumentException(supertype + " isn't a super type of " + this);
-    }
+    checkArgument(componentType != null, "%s isn't a super type of %s", supertype, this);
     // array is covariant. component type is super type, so is the array type.
     @SuppressWarnings("unchecked") // going from raw type back to generics
     /*
@@ -1256,9 +1253,8 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
 
   private TypeToken<? extends T> getArraySubtype(Class<?> subclass) {
     Class<?> subclassComponentType = subclass.getComponentType();
-    if (subclassComponentType == null) {
-      throw new IllegalArgumentException(subclass + " does not appear to be a subtype of " + this);
-    }
+    checkArgument(
+        subclassComponentType != null, "%s does not appear to be a subtype of %s", subclass, this);
     // array is covariant. component type is subtype, so is the array type.
     // requireNonNull is safe because we call getArraySubtype only when isArray().
     TypeToken<?> componentSubtype =
@@ -1334,8 +1330,8 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
             return type.getGenericInterfaces();
           }
 
-          @Override
           @CheckForNull
+          @Override
           TypeToken<?> getSuperclass(TypeToken<?> type) {
             return type.getGenericSuperclass();
           }
@@ -1353,8 +1349,8 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
             return Arrays.asList(type.getInterfaces());
           }
 
-          @Override
           @CheckForNull
+          @Override
           Class<?> getSuperclass(Class<?> type) {
             return type.getSuperclass();
           }
@@ -1459,8 +1455,8 @@ public abstract class TypeToken<T> extends TypeCapture<T> implements Serializabl
         return delegate.getInterfaces(type);
       }
 
-      @Override
       @CheckForNull
+      @Override
       K getSuperclass(K type) {
         return delegate.getSuperclass(type);
       }
diff --git a/guava/src/com/google/common/reflect/Types.java b/guava/src/com/google/common/reflect/Types.java
index e69b42a8e8..8d6a9e3540 100644
--- a/guava/src/com/google/common/reflect/Types.java
+++ b/guava/src/com/google/common/reflect/Types.java
@@ -15,7 +15,7 @@
 package com.google.common.reflect;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Predicates.not;
 import static com.google.common.collect.Iterables.transform;
 import static java.util.Objects.requireNonNull;
 
@@ -85,7 +85,7 @@ final class Types {
       return newParameterizedType(rawType, arguments);
     }
     // ParameterizedTypeImpl constructor already checks, but we want to throw NPE before IAE
-    checkNotNull(arguments);
+    requireNonNull(arguments);
     checkArgument(rawType.getEnclosingClass() != null, "Owner type for unenclosed %s", rawType);
     return new ParameterizedTypeImpl(ownerType, rawType, arguments);
   }
@@ -99,15 +99,15 @@ final class Types {
   /** Decides what owner type to use for constructing {@link ParameterizedType} from a raw class. */
   private enum ClassOwnership {
     OWNED_BY_ENCLOSING_CLASS {
-      @Override
       @CheckForNull
+      @Override
       Class<?> getOwnerType(Class<?> rawType) {
         return rawType.getEnclosingClass();
       }
     },
     LOCAL_CLASS_HAS_NO_OWNER {
-      @Override
       @CheckForNull
+      @Override
       Class<?> getOwnerType(Class<?> rawType) {
         if (rawType.isLocalClass()) {
           return null;
@@ -170,7 +170,7 @@ final class Types {
 
   @CheckForNull
   static Type getComponentType(Type type) {
-    checkNotNull(type);
+    requireNonNull(type);
     AtomicReference<@Nullable Type> result = new AtomicReference<>();
     new TypeVisitor() {
       @Override
@@ -261,7 +261,7 @@ final class Types {
     private final Class<?> rawType;
 
     ParameterizedTypeImpl(@CheckForNull Type ownerType, Class<?> rawType, Type[] typeArguments) {
-      checkNotNull(rawType);
+      requireNonNull(rawType);
       checkArgument(typeArguments.length == rawType.getTypeParameters().length);
       disallowPrimitiveType(typeArguments, "type parameter");
       this.ownerType = ownerType;
@@ -279,8 +279,8 @@ final class Types {
       return rawType;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Type getOwnerType() {
       return ownerType;
     }
@@ -381,8 +381,8 @@ final class Types {
       this.typeVariableImpl = typeVariableImpl;
     }
 
-    @Override
     @CheckForNull
+    @Override
     public Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
         throws Throwable {
       String methodName = method.getName();
@@ -407,8 +407,8 @@ final class Types {
 
     TypeVariableImpl(D genericDeclaration, String name, Type[] bounds) {
       disallowPrimitiveType(bounds, "bound for type variable");
-      this.genericDeclaration = checkNotNull(genericDeclaration);
-      this.name = checkNotNull(name);
+      this.genericDeclaration = requireNonNull(genericDeclaration);
+      this.name = requireNonNull(name);
       this.bounds = ImmutableList.copyOf(bounds);
     }
 
@@ -522,7 +522,7 @@ final class Types {
   }
 
   private static Iterable<Type> filterUpperBounds(Iterable<Type> bounds) {
-    return Iterables.filter(bounds, Predicates.not(Predicates.<Type>equalTo(Object.class)));
+    return Iterables.filter(bounds, not(Predicates.<Type>equalTo(Object.class)));
   }
 
   private static void disallowPrimitiveType(Type[] types, String usedAs) {
@@ -552,7 +552,7 @@ final class Types {
 
       @Override
       Type usedInGenericType(Type type) {
-        checkNotNull(type);
+        requireNonNull(type);
         if (type instanceof Class) {
           Class<?> cls = (Class<?>) type;
           if (cls.isArray()) {
@@ -574,7 +574,7 @@ final class Types {
 
       @Override
       Type usedInGenericType(Type type) {
-        return checkNotNull(type);
+        return requireNonNull(type);
       }
     },
     JAVA8 {
diff --git a/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java
index 76eada2140..7a561f1740 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java
@@ -19,6 +19,7 @@ import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor;
 import static com.google.common.util.concurrent.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.util.concurrent.Platform.isInstanceOfThrowableClass;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
@@ -67,9 +68,9 @@ abstract class AbstractCatchingFuture<
 
   AbstractCatchingFuture(
       ListenableFuture<? extends V> inputFuture, Class<X> exceptionType, F fallback) {
-    this.inputFuture = checkNotNull(inputFuture);
-    this.exceptionType = checkNotNull(exceptionType);
-    this.fallback = checkNotNull(fallback);
+    this.inputFuture = requireNonNull(inputFuture);
+    this.exceptionType = requireNonNull(exceptionType);
+    this.fallback = requireNonNull(fallback);
   }
 
   @Override
@@ -142,8 +143,8 @@ abstract class AbstractCatchingFuture<
     setResult(fallbackResult);
   }
 
-  @Override
   @CheckForNull
+  @Override
   protected String pendingToString() {
     ListenableFuture<? extends V> localInputFuture = inputFuture;
     Class<X> localExceptionType = exceptionType;
diff --git a/guava/src/com/google/common/util/concurrent/AbstractFuture.java b/guava/src/com/google/common/util/concurrent/AbstractFuture.java
index fc408a92d2..71bd8a6215 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractFuture.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
 import static com.google.common.util.concurrent.NullnessCasts.uncheckedNull;
 import static java.lang.Integer.toHexString;
@@ -67,12 +66,9 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * @author Luke Sandberg
  * @since 1.0
  */
-@SuppressWarnings({
-  "ShortCircuitBoolean", // we use non-short circuiting comparisons intentionally
-  "nullness", // TODO(b/147136275): Remove once our checker understands & and |.
-})
+@SuppressWarnings({"nullness", "ShortCircuitBoolean"})
 @GwtCompatible(emulated = true)
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
+@ReflectionSupport(ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractFuture<V extends @Nullable Object> extends InternalFutureFailureAccess
     implements ListenableFuture<V> {
@@ -310,7 +306,7 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
     final Throwable exception;
 
     Failure(Throwable exception) {
-      this.exception = checkNotNull(exception);
+      this.exception = requireNonNull(exception);
     }
   }
 
@@ -732,8 +728,8 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    */
   @Override
   public void addListener(Runnable listener, Executor executor) {
-    checkNotNull(listener, "Runnable was null.");
-    checkNotNull(executor, "Executor was null.");
+    requireNonNull(listener, "Runnable was null.");
+    requireNonNull(executor, "Executor was null.");
     // Checking isDone and listeners != TOMBSTONE may seem redundant, but our contract for
     // addListener says that listeners execute 'immediate' if the future isDone(). However, our
     // protocol for completing a future is to assign the value field (which sets isDone to true) and
@@ -803,7 +799,7 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    */
   @CanIgnoreReturnValue
   protected boolean setException(Throwable throwable) {
-    Object valueToSet = new Failure(checkNotNull(throwable));
+    Object valueToSet = new Failure(requireNonNull(throwable));
     if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
       complete(this);
       return true;
@@ -842,7 +838,7 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    */
   @CanIgnoreReturnValue
   protected boolean setFuture(ListenableFuture<? extends V> future) {
-    checkNotNull(future);
+    requireNonNull(future);
     Object localValue = value;
     if (localValue == null) {
       if (future.isDone()) {
@@ -1078,13 +1074,13 @@ public abstract class AbstractFuture<V extends @Nullable Object> extends Interna
    *
    * @since 27.0
    */
-  @Override
+  @CheckForNull
   /*
    * We should annotate the superclass, InternalFutureFailureAccess, to say that its copy of this
    * method returns @Nullable, too. However, we're not sure if we want to make any changes to that
    * class, since it's in a separate artifact that we planned to release only a single version of.
    */
-  @CheckForNull
+  @Override
   protected final Throwable tryInternalFastPathGetFailure() {
     if (this instanceof Trusted) {
       Object obj = value;
diff --git a/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java
index 65d29c38bc..74d3bdc879 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java
@@ -15,7 +15,6 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
@@ -144,7 +143,7 @@ public abstract class AbstractScheduledService implements Service {
     @SuppressWarnings("GoodTime") // should accept a java.time.Duration
     public static Scheduler newFixedDelaySchedule(
         final long initialDelay, final long delay, final TimeUnit unit) {
-      checkNotNull(unit);
+      requireNonNull(unit);
       checkArgument(delay > 0, "delay must be > 0, found %s", delay);
       return new Scheduler() {
         @Override
@@ -180,7 +179,7 @@ public abstract class AbstractScheduledService implements Service {
     @SuppressWarnings("GoodTime") // should accept a java.time.Duration
     public static Scheduler newFixedRateSchedule(
         final long initialDelay, final long period, final TimeUnit unit) {
-      checkNotNull(unit);
+      requireNonNull(unit);
       checkArgument(period > 0, "period must be > 0, found %s", period);
       return new Scheduler() {
         @Override
@@ -596,8 +595,8 @@ public abstract class AbstractScheduledService implements Service {
         this.service = service;
       }
 
-      @Override
       @CheckForNull
+      @Override
       public Void call() throws Exception {
         wrappedRunnable.run();
         reschedule();
@@ -741,7 +740,7 @@ public abstract class AbstractScheduledService implements Service {
        */
       public Schedule(long delay, TimeUnit unit) {
         this.delay = delay;
-        this.unit = checkNotNull(unit);
+        this.unit = requireNonNull(unit);
       }
 
       /**
diff --git a/guava/src/com/google/common/util/concurrent/AbstractService.java b/guava/src/com/google/common/util/concurrent/AbstractService.java
index 8838f91962..9251add8d1 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractService.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractService.java
@@ -15,7 +15,6 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.Service.State.FAILED;
 import static com.google.common.util.concurrent.Service.State.NEW;
@@ -459,7 +458,7 @@ public abstract class AbstractService implements Service {
    * or otherwise cannot be started nor stopped.
    */
   protected final void notifyFailed(Throwable cause) {
-    checkNotNull(cause);
+    requireNonNull(cause);
 
     monitor.enter();
     try {
diff --git a/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java b/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java
index 841c1acad0..84dae78434 100644
--- a/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java
@@ -17,6 +17,7 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Function;
@@ -38,7 +39,7 @@ abstract class AbstractTransformFuture<
       ListenableFuture<I> input,
       AsyncFunction<? super I, ? extends O> function,
       Executor executor) {
-    checkNotNull(executor);
+    requireNonNull(executor);
     AsyncTransformFuture<I, O> output = new AsyncTransformFuture<>(input, function);
     input.addListener(output, rejectionPropagatingExecutor(executor, output));
     return output;
@@ -46,7 +47,7 @@ abstract class AbstractTransformFuture<
 
   static <I extends @Nullable Object, O extends @Nullable Object> ListenableFuture<O> create(
       ListenableFuture<I> input, Function<? super I, ? extends O> function, Executor executor) {
-    checkNotNull(function);
+    requireNonNull(function);
     TransformFuture<I, O> output = new TransformFuture<>(input, function);
     input.addListener(output, rejectionPropagatingExecutor(executor, output));
     return output;
@@ -60,8 +61,8 @@ abstract class AbstractTransformFuture<
   @CheckForNull F function;
 
   AbstractTransformFuture(ListenableFuture<? extends I> inputFuture, F function) {
-    this.inputFuture = checkNotNull(inputFuture);
-    this.function = checkNotNull(function);
+    this.inputFuture = requireNonNull(inputFuture);
+    this.function = requireNonNull(function);
   }
 
   @Override
@@ -184,8 +185,8 @@ abstract class AbstractTransformFuture<
     this.function = null;
   }
 
-  @Override
   @CheckForNull
+  @Override
   protected String pendingToString() {
     ListenableFuture<? extends I> localInputFuture = inputFuture;
     F localFunction = function;
diff --git a/guava/src/com/google/common/util/concurrent/AggregateFuture.java b/guava/src/com/google/common/util/concurrent/AggregateFuture.java
index 6d2ed9c8e8..bf4c371b9b 100644
--- a/guava/src/com/google/common/util/concurrent/AggregateFuture.java
+++ b/guava/src/com/google/common/util/concurrent/AggregateFuture.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.ALL_INPUT_FUTURES_PROCESSED;
 import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;
@@ -66,7 +65,7 @@ abstract class AggregateFuture<InputT extends @Nullable Object, OutputT extends
       boolean allMustSucceed,
       boolean collectsValues) {
     super(futures.size());
-    this.futures = checkNotNull(futures);
+    this.futures = requireNonNull(futures);
     this.allMustSucceed = allMustSucceed;
     this.collectsValues = collectsValues;
   }
@@ -90,8 +89,8 @@ abstract class AggregateFuture<InputT extends @Nullable Object, OutputT extends
      */
   }
 
-  @Override
   @CheckForNull
+  @Override
   protected final String pendingToString() {
     ImmutableCollection<? extends Future<?>> localFutures = futures;
     if (localFutures != null) {
@@ -192,7 +191,7 @@ abstract class AggregateFuture<InputT extends @Nullable Object, OutputT extends
    * particular Throwable.
    */
   private void handleException(Throwable throwable) {
-    checkNotNull(throwable);
+    requireNonNull(throwable);
 
     if (allMustSucceed) {
       // As soon as the first one fails, make that failure the result of the output future.
@@ -235,7 +234,7 @@ abstract class AggregateFuture<InputT extends @Nullable Object, OutputT extends
 
   @Override
   final void addInitialException(Set<Throwable> seen) {
-    checkNotNull(seen);
+    requireNonNull(seen);
     if (!isCancelled()) {
       /*
        * requireNonNull is safe because:
@@ -322,7 +321,7 @@ abstract class AggregateFuture<InputT extends @Nullable Object, OutputT extends
   @ForOverride
   @OverridingMethodsMustInvokeSuper
   void releaseResources(ReleaseResourcesReason reason) {
-    checkNotNull(reason);
+    requireNonNull(reason);
     /*
      * All elements of `futures` are completed, or this future has already completed and read
      * `futures` into a local variable (in preparation for propagating cancellation to them). In
diff --git a/guava/src/com/google/common/util/concurrent/AggregateFutureState.java b/guava/src/com/google/common/util/concurrent/AggregateFutureState.java
index ee23ca021e..332fb45ea8 100644
--- a/guava/src/com/google/common/util/concurrent/AggregateFutureState.java
+++ b/guava/src/com/google/common/util/concurrent/AggregateFutureState.java
@@ -39,7 +39,7 @@ import org.checkerframework.checker.nullness.qual.Nullable;
  * </ul>
  */
 @GwtCompatible(emulated = true)
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
+@ReflectionSupport(ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
 abstract class AggregateFutureState<OutputT extends @Nullable Object>
     extends AbstractFuture.TrustedFuture<OutputT> {
diff --git a/guava/src/com/google/common/util/concurrent/AtomicDouble.java b/guava/src/com/google/common/util/concurrent/AtomicDouble.java
index 56360a8703..a2c0ff4122 100644
--- a/guava/src/com/google/common/util/concurrent/AtomicDouble.java
+++ b/guava/src/com/google/common/util/concurrent/AtomicDouble.java
@@ -14,9 +14,9 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.lang.Double.doubleToRawLongBits;
 import static java.lang.Double.longBitsToDouble;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -55,7 +55,7 @@ import java.util.function.DoubleUnaryOperator;
  * @since 11.0
  */
 @GwtIncompatible
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
+@ReflectionSupport(ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
 public class AtomicDouble extends Number implements java.io.Serializable {
   private static final long serialVersionUID = 0L;
@@ -183,7 +183,7 @@ public class AtomicDouble extends Number implements java.io.Serializable {
    */
   @CanIgnoreReturnValue
   public final double getAndAccumulate(double x, DoubleBinaryOperator accumulatorFunction) {
-    checkNotNull(accumulatorFunction);
+    requireNonNull(accumulatorFunction);
     return getAndUpdate(oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));
   }
 
@@ -198,7 +198,7 @@ public class AtomicDouble extends Number implements java.io.Serializable {
    */
   @CanIgnoreReturnValue
   public final double accumulateAndGet(double x, DoubleBinaryOperator accumulatorFunction) {
-    checkNotNull(accumulatorFunction);
+    requireNonNull(accumulatorFunction);
     return updateAndGet(oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));
   }
 
diff --git a/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java b/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java
index 6cc28aad0a..3d6284d652 100644
--- a/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java
+++ b/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java
@@ -13,9 +13,9 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.lang.Double.doubleToRawLongBits;
 import static java.lang.Double.longBitsToDouble;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.ImmutableLongArray;
@@ -201,7 +201,7 @@ public class AtomicDoubleArray implements java.io.Serializable {
    */
   @CanIgnoreReturnValue
   public final double getAndAccumulate(int i, double x, DoubleBinaryOperator accumulatorFunction) {
-    checkNotNull(accumulatorFunction);
+    requireNonNull(accumulatorFunction);
     return getAndUpdate(i, oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));
   }
 
@@ -217,7 +217,7 @@ public class AtomicDoubleArray implements java.io.Serializable {
    */
   @CanIgnoreReturnValue
   public final double accumulateAndGet(int i, double x, DoubleBinaryOperator accumulatorFunction) {
-    checkNotNull(accumulatorFunction);
+    requireNonNull(accumulatorFunction);
     return updateAndGet(i, oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));
   }
 
diff --git a/guava/src/com/google/common/util/concurrent/AtomicLongMap.java b/guava/src/com/google/common/util/concurrent/AtomicLongMap.java
index 456b3aceb1..015561bf92 100644
--- a/guava/src/com/google/common/util/concurrent/AtomicLongMap.java
+++ b/guava/src/com/google/common/util/concurrent/AtomicLongMap.java
@@ -16,13 +16,13 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
-import java.util.Collections;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -60,7 +60,7 @@ public final class AtomicLongMap<K> implements Serializable {
   private final ConcurrentHashMap<K, Long> map;
 
   private AtomicLongMap(ConcurrentHashMap<K, Long> map) {
-    this.map = checkNotNull(map);
+    this.map = requireNonNull(map);
   }
 
   /** Creates an {@code AtomicLongMap}. */
@@ -142,7 +142,7 @@ public final class AtomicLongMap<K> implements Serializable {
    */
   @CanIgnoreReturnValue
   public long updateAndGet(K key, LongUnaryOperator updaterFunction) {
-    checkNotNull(updaterFunction);
+    requireNonNull(updaterFunction);
     return map.compute(
         key, (k, value) -> updaterFunction.applyAsLong((value == null) ? 0L : value.longValue()));
   }
@@ -156,7 +156,7 @@ public final class AtomicLongMap<K> implements Serializable {
    */
   @CanIgnoreReturnValue
   public long getAndUpdate(K key, LongUnaryOperator updaterFunction) {
-    checkNotNull(updaterFunction);
+    requireNonNull(updaterFunction);
     AtomicLong holder = new AtomicLong();
     map.compute(
         key,
@@ -178,7 +178,7 @@ public final class AtomicLongMap<K> implements Serializable {
    */
   @CanIgnoreReturnValue
   public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {
-    checkNotNull(accumulatorFunction);
+    requireNonNull(accumulatorFunction);
     return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));
   }
 
@@ -192,7 +192,7 @@ public final class AtomicLongMap<K> implements Serializable {
    */
   @CanIgnoreReturnValue
   public long getAndAccumulate(K key, long x, LongBinaryOperator accumulatorFunction) {
-    checkNotNull(accumulatorFunction);
+    requireNonNull(accumulatorFunction);
     return getAndUpdate(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));
   }
 
@@ -272,7 +272,7 @@ public final class AtomicLongMap<K> implements Serializable {
   }
 
   private Map<K, Long> createAsMap() {
-    return Collections.unmodifiableMap(map);
+    return unmodifiableMap(map);
   }
 
   /** Returns true if this map contains a mapping for the specified key. */
diff --git a/guava/src/com/google/common/util/concurrent/Callables.java b/guava/src/com/google/common/util/concurrent/Callables.java
index 3b52c2e982..1d38e397c8 100644
--- a/guava/src/com/google/common/util/concurrent/Callables.java
+++ b/guava/src/com/google/common/util/concurrent/Callables.java
@@ -14,7 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -51,8 +51,8 @@ public final class Callables {
   @GwtIncompatible
   public static <T extends @Nullable Object> AsyncCallable<T> asAsyncCallable(
       Callable<T> callable, ListeningExecutorService listeningExecutorService) {
-    checkNotNull(callable);
-    checkNotNull(listeningExecutorService);
+    requireNonNull(callable);
+    requireNonNull(listeningExecutorService);
     return () -> listeningExecutorService.submit(callable);
   }
 
@@ -67,8 +67,8 @@ public final class Callables {
   @GwtIncompatible // threads
   static <T extends @Nullable Object> Callable<T> threadRenaming(
       Callable<T> callable, Supplier<String> nameSupplier) {
-    checkNotNull(nameSupplier);
-    checkNotNull(callable);
+    requireNonNull(nameSupplier);
+    requireNonNull(callable);
     return () -> {
       Thread currentThread = Thread.currentThread();
       String oldName = currentThread.getName();
@@ -93,8 +93,8 @@ public final class Callables {
    */
   @GwtIncompatible // threads
   static Runnable threadRenaming(Runnable task, Supplier<String> nameSupplier) {
-    checkNotNull(nameSupplier);
-    checkNotNull(task);
+    requireNonNull(nameSupplier);
+    requireNonNull(task);
     return () -> {
       Thread currentThread = Thread.currentThread();
       String oldName = currentThread.getName();
diff --git a/guava/src/com/google/common/util/concurrent/ClosingFuture.java b/guava/src/com/google/common/util/concurrent/ClosingFuture.java
index fbd604cead..f2c3de5fea 100644
--- a/guava/src/com/google/common/util/concurrent/ClosingFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ClosingFuture.java
@@ -19,7 +19,6 @@ package com.google.common.util.concurrent;
 import static com.google.common.base.Functions.constant;
 import static com.google.common.base.MoreObjects.toStringHelper;
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Lists.asList;
 import static com.google.common.util.concurrent.ClosingFuture.State.CLOSED;
@@ -32,6 +31,7 @@ import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
 import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static java.util.Objects.requireNonNull;
 import static java.util.logging.Level.FINER;
 import static java.util.logging.Level.SEVERE;
 import static java.util.logging.Level.WARNING;
@@ -234,7 +234,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
     @ParametricNullness
     public <C extends @Nullable Object & @Nullable AutoCloseable> C eventuallyClose(
         @ParametricNullness C closeable, Executor closingExecutor) {
-      checkNotNull(closingExecutor);
+      requireNonNull(closingExecutor);
       if (closeable != null) {
         list.add(closeable, closingExecutor);
       }
@@ -331,7 +331,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
     private final ClosingFuture<? extends V> closingFuture;
 
     ValueAndCloser(ClosingFuture<? extends V> closingFuture) {
-      this.closingFuture = checkNotNull(closingFuture);
+      this.closingFuture = requireNonNull(closingFuture);
     }
 
     /**
@@ -437,7 +437,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
   public static <C extends @Nullable Object & @Nullable AutoCloseable>
       ClosingFuture<C> eventuallyClosing(
           ListenableFuture<C> future, final Executor closingExecutor) {
-    checkNotNull(closingExecutor);
+    requireNonNull(closingExecutor);
     final ClosingFuture<C> closingFuture = new ClosingFuture<>(nonCancellationPropagating(future));
     Futures.addCallback(
         future,
@@ -595,7 +595,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
   }
 
   private ClosingFuture(final ClosingCallable<V> callable, Executor executor) {
-    checkNotNull(callable);
+    requireNonNull(callable);
     TrustedListenableFutureTask<V> task =
         TrustedListenableFutureTask.create(
             new Callable<V>() {
@@ -615,7 +615,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
   }
 
   private ClosingFuture(final AsyncClosingCallable<V> callable, Executor executor) {
-    checkNotNull(callable);
+    requireNonNull(callable);
     TrustedListenableFutureTask<V> task =
         TrustedListenableFutureTask.create(
             new AsyncCallable<V>() {
@@ -690,7 +690,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    */
   public <U extends @Nullable Object> ClosingFuture<U> transform(
       final ClosingFunction<? super V, U> function, Executor executor) {
-    checkNotNull(function);
+    requireNonNull(function);
     AsyncFunction<V, U> applyFunction =
         new AsyncFunction<V, U>() {
           @Override
@@ -784,7 +784,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    */
   public <U extends @Nullable Object> ClosingFuture<U> transformAsync(
       final AsyncClosingFunction<? super V, U> function, Executor executor) {
-    checkNotNull(function);
+    requireNonNull(function);
     AsyncFunction<V, U> applyFunction =
         new AsyncFunction<V, U>() {
           @Override
@@ -828,7 +828,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    */
   public static <V extends @Nullable Object, U extends @Nullable Object>
       AsyncClosingFunction<V, U> withoutCloser(final AsyncFunction<V, U> function) {
-    checkNotNull(function);
+    requireNonNull(function);
     return new AsyncClosingFunction<V, U>() {
       @Override
       public ClosingFuture<U> apply(DeferredCloser closer, V input) throws Exception {
@@ -886,7 +886,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
   // Avoids generic type capture inconsistency problems where |? extends V| is incompatible with V.
   private <X extends Throwable, W extends V> ClosingFuture<V> catchingMoreGeneric(
       Class<X> exceptionType, final ClosingFunction<? super X, W> fallback, Executor executor) {
-    checkNotNull(fallback);
+    requireNonNull(fallback);
     AsyncFunction<X, W> applyFallback =
         new AsyncFunction<X, W>() {
           @Override
@@ -985,7 +985,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
       Class<X> exceptionType,
       final AsyncClosingFunction<? super X, W> fallback,
       Executor executor) {
-    checkNotNull(fallback);
+    requireNonNull(fallback);
     AsyncFunction<X, W> asyncFunction =
         new AsyncFunction<X, W>() {
           @Override
@@ -1065,7 +1065,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
    */
   public void finishToValueAndCloser(
       final ValueAndCloserConsumer<? super V> consumer, Executor executor) {
-    checkNotNull(consumer);
+    requireNonNull(consumer);
     if (!compareAndUpdateState(OPEN, WILL_CREATE_VALUE_AND_CLOSER)) {
       switch (state.get()) {
         case SUBSUMED:
@@ -1154,7 +1154,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
     private volatile boolean beingCalled;
 
     private Peeker(ImmutableList<ClosingFuture<?>> futures) {
-      this.futures = checkNotNull(futures);
+      this.futures = requireNonNull(futures);
     }
 
     /**
@@ -2151,7 +2151,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
 
   @Override
   protected void finalize() {
-    if (state.get().equals(OPEN)) {
+    if (state.get() == OPEN) {
       logger.log(SEVERE, "Uh oh! An open ClosingFuture has leaked and will close: {0}", this);
       FluentFuture<V> unused = finishToFuture();
     }
@@ -2250,7 +2250,7 @@ public final class ClosingFuture<V extends @Nullable Object> {
     }
 
     void add(@CheckForNull AutoCloseable closeable, Executor executor) {
-      checkNotNull(executor);
+      requireNonNull(executor);
       if (closeable == null) {
         return;
       }
diff --git a/guava/src/com/google/common/util/concurrent/CombinedFuture.java b/guava/src/com/google/common/util/concurrent/CombinedFuture.java
index c22211164c..fb19a3e537 100644
--- a/guava/src/com/google/common/util/concurrent/CombinedFuture.java
+++ b/guava/src/com/google/common/util/concurrent/CombinedFuture.java
@@ -16,6 +16,7 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
@@ -95,7 +96,7 @@ final class CombinedFuture<V extends @Nullable Object>
     private final Executor listenerExecutor;
 
     CombinedFutureInterruptibleTask(Executor listenerExecutor) {
-      this.listenerExecutor = checkNotNull(listenerExecutor);
+      this.listenerExecutor = requireNonNull(listenerExecutor);
     }
 
     @Override
@@ -157,7 +158,7 @@ final class CombinedFuture<V extends @Nullable Object>
 
     AsyncCallableInterruptibleTask(AsyncCallable<V> callable, Executor listenerExecutor) {
       super(listenerExecutor);
-      this.callable = checkNotNull(callable);
+      this.callable = requireNonNull(callable);
     }
 
     @Override
@@ -187,7 +188,7 @@ final class CombinedFuture<V extends @Nullable Object>
 
     CallableInterruptibleTask(Callable<V> callable, Executor listenerExecutor) {
       super(listenerExecutor);
-      this.callable = checkNotNull(callable);
+      this.callable = requireNonNull(callable);
     }
 
     @Override
diff --git a/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java b/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java
index 7989bf3a0a..f3052f72b3 100644
--- a/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java
+++ b/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java
@@ -14,14 +14,14 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.Collections.unmodifiableMap;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import com.google.common.collect.MapMaker;
@@ -31,7 +31,6 @@ import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.Weak;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.EnumMap;
 import java.util.List;
 import java.util.Map;
@@ -279,8 +278,8 @@ public class CycleDetectingLockFactory {
       Class<E> enumClass, Policy policy) {
     // createNodes maps each enumClass to a Map with the corresponding enum key
     // type.
-    checkNotNull(enumClass);
-    checkNotNull(policy);
+    requireNonNull(enumClass);
+    requireNonNull(policy);
     @SuppressWarnings("unchecked")
     Map<E, LockGraphNode> lockGraphNodes = (Map<E, LockGraphNode>) getOrCreateNodes(enumClass);
     return new WithExplicitOrdering<>(policy, lockGraphNodes);
@@ -324,7 +323,7 @@ public class CycleDetectingLockFactory {
     for (int i = 0; i < numKeys - 1; i++) {
       nodes.get(i).checkAcquiredLocks(Policies.DISABLED, nodes.subList(i + 1, numKeys));
     }
-    return Collections.unmodifiableMap(map);
+    return unmodifiableMap(map);
   }
 
   /**
@@ -457,7 +456,7 @@ public class CycleDetectingLockFactory {
   final Policy policy;
 
   private CycleDetectingLockFactory(Policy policy) {
-    this.policy = checkNotNull(policy);
+    this.policy = requireNonNull(policy);
   }
 
   /**
@@ -606,7 +605,7 @@ public class CycleDetectingLockFactory {
     final String lockName;
 
     LockGraphNode(String lockName) {
-      this.lockName = Preconditions.checkNotNull(lockName);
+      this.lockName = requireNonNull(lockName);
     }
 
     String getLockName() {
@@ -635,7 +634,7 @@ public class CycleDetectingLockFactory {
       // can happen because multiple locks may share the same LockGraphNode. In
       // this situation, throw an IllegalStateException as defined by contract
       // described in the documentation of WithExplicitOrdering.
-      Preconditions.checkState(
+      checkState(
           this != acquiredLock,
           "Attempted to acquire multiple locks with the same rank %s",
           acquiredLock.getLockName());
@@ -754,7 +753,7 @@ public class CycleDetectingLockFactory {
 
     private CycleDetectingReentrantLock(LockGraphNode lockGraphNode, boolean fair) {
       super(fair);
-      this.lockGraphNode = Preconditions.checkNotNull(lockGraphNode);
+      this.lockGraphNode = requireNonNull(lockGraphNode);
     }
 
     ///// CycleDetectingLock methods. /////
@@ -837,7 +836,7 @@ public class CycleDetectingLockFactory {
       super(fair);
       this.readLock = new CycleDetectingReentrantReadLock(this);
       this.writeLock = new CycleDetectingReentrantWriteLock(this);
-      this.lockGraphNode = Preconditions.checkNotNull(lockGraphNode);
+      this.lockGraphNode = requireNonNull(lockGraphNode);
     }
 
     ///// Overridden ReentrantReadWriteLock methods. /////
diff --git a/guava/src/com/google/common/util/concurrent/ExecutionList.java b/guava/src/com/google/common/util/concurrent/ExecutionList.java
index 96fc51ca88..a8d1dbe6e8 100644
--- a/guava/src/com/google/common/util/concurrent/ExecutionList.java
+++ b/guava/src/com/google/common/util/concurrent/ExecutionList.java
@@ -14,7 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
@@ -70,8 +70,8 @@ public final class ExecutionList {
   public void add(Runnable runnable, Executor executor) {
     // Fail fast on a null. We throw NPE here because the contract of Executor states that it throws
     // NPE on null listener, so we propagate that contract up into the add method as well.
-    checkNotNull(runnable, "Runnable was null.");
-    checkNotNull(executor, "Executor was null.");
+    requireNonNull(runnable, "Runnable was null.");
+    requireNonNull(executor, "Executor was null.");
 
     // Lock while we check state. We must maintain the lock while adding the new pair so that
     // another thread can't run the list out from under us. We only add to the list if we have not
diff --git a/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java b/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java
index 80c7779342..f54c86844f 100644
--- a/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java
+++ b/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.CANCELLED;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.NOT_RUN;
@@ -144,8 +143,8 @@ public final class ExecutionSequencer {
    */
   public <T extends @Nullable Object> ListenableFuture<T> submit(
       Callable<T> callable, Executor executor) {
-    checkNotNull(callable);
-    checkNotNull(executor);
+    requireNonNull(callable);
+    requireNonNull(executor);
     return submitAsync(
         new AsyncCallable<T>() {
           @Override
@@ -170,8 +169,8 @@ public final class ExecutionSequencer {
    */
   public <T extends @Nullable Object> ListenableFuture<T> submitAsync(
       AsyncCallable<T> callable, Executor executor) {
-    checkNotNull(callable);
-    checkNotNull(executor);
+    requireNonNull(callable);
+    requireNonNull(executor);
     TaskNonReentrantExecutor taskExecutor = new TaskNonReentrantExecutor(executor, this);
     AsyncCallable<T> task =
         new AsyncCallable<T>() {
@@ -369,8 +368,8 @@ public final class ExecutionSequencer {
       }
     }
 
-    @SuppressWarnings("ShortCircuitBoolean")
     @Override
+    @SuppressWarnings("ShortCircuitBoolean")
     public void run() {
       Thread currentThread = Thread.currentThread();
       if (currentThread != submitting) {
diff --git a/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java b/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java
index ddc9440188..a104ebc9bf 100644
--- a/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/FakeTimeLimiter.java
@@ -14,7 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -42,9 +42,9 @@ public final class FakeTimeLimiter implements TimeLimiter {
   @Override
   public <T> T newProxy(
       T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit) {
-    checkNotNull(target);
-    checkNotNull(interfaceType);
-    checkNotNull(timeoutUnit);
+    requireNonNull(target);
+    requireNonNull(interfaceType);
+    requireNonNull(timeoutUnit);
     return target; // ha ha
   }
 
@@ -52,8 +52,8 @@ public final class FakeTimeLimiter implements TimeLimiter {
   @ParametricNullness
   public <T extends @Nullable Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
-    checkNotNull(callable);
-    checkNotNull(timeoutUnit);
+    requireNonNull(callable);
+    requireNonNull(timeoutUnit);
     try {
       return callable.call();
     } catch (RuntimeException e) {
@@ -78,8 +78,8 @@ public final class FakeTimeLimiter implements TimeLimiter {
 
   @Override
   public void runWithTimeout(Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) {
-    checkNotNull(runnable);
-    checkNotNull(timeoutUnit);
+    requireNonNull(runnable);
+    requireNonNull(timeoutUnit);
     try {
       runnable.run();
     } catch (RuntimeException e) {
diff --git a/guava/src/com/google/common/util/concurrent/FluentFuture.java b/guava/src/com/google/common/util/concurrent/FluentFuture.java
index b47e67927f..e2d49db20b 100644
--- a/guava/src/com/google/common/util/concurrent/FluentFuture.java
+++ b/guava/src/com/google/common/util/concurrent/FluentFuture.java
@@ -14,8 +14,8 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -144,7 +144,7 @@ public abstract class FluentFuture<V extends @Nullable Object>
    */
   @Deprecated
   public static <V extends @Nullable Object> FluentFuture<V> from(FluentFuture<V> future) {
-    return checkNotNull(future);
+    return requireNonNull(future);
   }
 
   /**
@@ -184,8 +184,8 @@ public abstract class FluentFuture<V extends @Nullable Object>
    *     {@code get()} throws a different kind of exception, that exception itself.
    * @param executor the executor that runs {@code fallback} if the input fails
    */
-  @Partially.GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
   @Beta
+  @Partially.GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
   public final <X extends Throwable> FluentFuture<V> catching(
       Class<X> exceptionType, Function<? super X, ? extends V> fallback, Executor executor) {
     return (FluentFuture<V>) Futures.catching(this, exceptionType, fallback, executor);
@@ -249,8 +249,8 @@ public abstract class FluentFuture<V extends @Nullable Object>
    *     {@code get()} throws a different kind of exception, that exception itself.
    * @param executor the executor that runs {@code fallback} if the input fails
    */
-  @Partially.GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
   @Beta
+  @Partially.GwtIncompatible("AVAILABLE but requires exceptionType to be Throwable.class")
   public final <X extends Throwable> FluentFuture<V> catchingAsync(
       Class<X> exceptionType, AsyncFunction<? super X, ? extends V> fallback, Executor executor) {
     return (FluentFuture<V>) Futures.catchingAsync(this, exceptionType, fallback, executor);
@@ -266,8 +266,8 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * @param scheduledExecutor The executor service to enforce the timeout.
    * @since 28.0
    */
-  @GwtIncompatible // ScheduledExecutorService
-  @Beta
+  @Beta // ScheduledExecutorService
+  @GwtIncompatible
   public final FluentFuture<V> withTimeout(
       Duration timeout, ScheduledExecutorService scheduledExecutor) {
     return withTimeout(toNanosSaturated(timeout), TimeUnit.NANOSECONDS, scheduledExecutor);
@@ -283,9 +283,9 @@ public abstract class FluentFuture<V extends @Nullable Object>
    * @param unit the time unit of the time parameter
    * @param scheduledExecutor The executor service to enforce the timeout.
    */
-  @GwtIncompatible // ScheduledExecutorService
-  @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @Beta
+  @Beta // ScheduledExecutorService
+  @GwtIncompatible // should accept a java.time.Duration
+  @SuppressWarnings("GoodTime")
   public final FluentFuture<V> withTimeout(
       long timeout, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {
     return (FluentFuture<V>) Futures.withTimeout(this, timeout, unit, scheduledExecutor);
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java b/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java
index d0d72a8159..2ee8902208 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingBlockingDeque.java
@@ -90,14 +90,14 @@ public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
     return delegate().takeLast();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E pollFirst(long timeout, TimeUnit unit) throws InterruptedException {
     return delegate().pollFirst(timeout, unit);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E pollLast(long timeout, TimeUnit unit) throws InterruptedException {
     return delegate().pollLast(timeout, unit);
   }
@@ -117,8 +117,8 @@ public abstract class ForwardingBlockingDeque<E> extends ForwardingDeque<E>
     return delegate().take();
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E poll(long timeout, TimeUnit unit) throws InterruptedException {
     return delegate().poll(timeout, unit);
   }
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java b/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java
index dc8511d94c..676b874e1a 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingBlockingQueue.java
@@ -63,8 +63,8 @@ public abstract class ForwardingBlockingQueue<E> extends ForwardingQueue<E>
     return delegate().offer(e, timeout, unit);
   }
 
-  @Override
   @CheckForNull
+  @Override
   public E poll(long timeout, TimeUnit unit) throws InterruptedException {
     return delegate().poll(timeout, unit);
   }
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java b/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java
index cb779c34ed..38937257a5 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java
@@ -14,7 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.concurrent.ExecutionException;
@@ -39,7 +39,7 @@ final class ForwardingFluentFuture<V extends @Nullable Object> extends FluentFut
   private final ListenableFuture<V> delegate;
 
   ForwardingFluentFuture(ListenableFuture<V> delegate) {
-    this.delegate = checkNotNull(delegate);
+    this.delegate = requireNonNull(delegate);
   }
 
   @Override
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingFuture.java b/guava/src/com/google/common/util/concurrent/ForwardingFuture.java
index 47002b03a3..d321730296 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingFuture.java
@@ -14,8 +14,9 @@
 
 package com.google.common.util.concurrent;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ForwardingObject;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.ExecutionException;
@@ -85,7 +86,7 @@ public abstract class ForwardingFuture<V extends @Nullable Object> extends Forwa
     private final Future<V> delegate;
 
     protected SimpleForwardingFuture(Future<V> delegate) {
-      this.delegate = Preconditions.checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
diff --git a/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java b/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java
index 386809194b..b9158fa403 100644
--- a/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java
@@ -14,8 +14,9 @@
 
 package com.google.common.util.concurrent;
 
+import static java.util.Objects.requireNonNull;
+
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Executor;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -59,7 +60,7 @@ public abstract class ForwardingListenableFuture<V extends @Nullable Object>
     private final ListenableFuture<V> delegate;
 
     protected SimpleForwardingListenableFuture(ListenableFuture<V> delegate) {
-      this.delegate = Preconditions.checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
diff --git a/guava/src/com/google/common/util/concurrent/Futures.java b/guava/src/com/google/common/util/concurrent/Futures.java
index 09b5c3c1a4..8fe7acd7cb 100644
--- a/guava/src/com/google/common/util/concurrent/Futures.java
+++ b/guava/src/com/google/common/util/concurrent/Futures.java
@@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
@@ -26,7 +25,6 @@ import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.CollectionFuture.ListFuture;
 import com.google.common.util.concurrent.ImmediateFuture.ImmediateCancelledFuture;
@@ -161,7 +159,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
    */
   public static <V extends @Nullable Object> ListenableFuture<V> immediateFailedFuture(
       Throwable throwable) {
-    checkNotNull(throwable);
+    requireNonNull(throwable);
     return new ImmediateFailedFuture<V>(throwable);
   }
 
@@ -516,8 +514,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
   @GwtIncompatible // TODO
   public static <I extends @Nullable Object, O extends @Nullable Object> Future<O> lazyTransform(
       final Future<I> input, final Function<? super I, ? extends O> function) {
-    checkNotNull(input);
-    checkNotNull(function);
+    requireNonNull(input);
+    requireNonNull(function);
     return new Future<O>() {
 
       @Override
@@ -759,8 +757,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
     public ListenableFuture<?> run(final Runnable combiner, Executor executor) {
       return call(
           new Callable<@Nullable Void>() {
-            @Override
             @CheckForNull
+            @Override
             public Void call() throws Exception {
               combiner.run();
               return null;
@@ -806,8 +804,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
       }
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected String pendingToString() {
       ListenableFuture<V> localDelegate = delegate;
       if (localDelegate != null) {
@@ -979,8 +977,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
       state = null;
     }
 
-    @Override
     @CheckForNull
+    @Override
     protected String pendingToString() {
       InCompletionOrderState<T> localState = state;
       if (localState != null) {
@@ -1101,7 +1099,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
       final ListenableFuture<V> future,
       final FutureCallback<? super V> callback,
       Executor executor) {
-    Preconditions.checkNotNull(callback);
+    requireNonNull(callback);
     future.addListener(new CallbackListener<V>(future, callback), executor);
   }
 
@@ -1330,8 +1328,8 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
   @Beta
   @CanIgnoreReturnValue
   @GwtIncompatible // reflection
-  @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @ParametricNullness
+  @ParametricNullness // should accept a java.time.Duration
+  @SuppressWarnings("GoodTime")
   public static <V extends @Nullable Object, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X {
     return FuturesGetChecked.getChecked(future, exceptionClass, timeout, unit);
@@ -1374,7 +1372,7 @@ public final class Futures extends GwtFuturesCatchingSpecialization {
   @CanIgnoreReturnValue
   @ParametricNullness
   public static <V extends @Nullable Object> V getUnchecked(Future<V> future) {
-    checkNotNull(future);
+    requireNonNull(future);
     try {
       return getUninterruptibly(future);
     } catch (ExecutionException e) {
diff --git a/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java b/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java
index 6f09b8066d..bc3470ea78 100644
--- a/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java
+++ b/guava/src/com/google/common/util/concurrent/FuturesGetChecked.java
@@ -51,8 +51,8 @@ final class FuturesGetChecked {
 
   /** Implementation of {@link Futures#getChecked(Future, Class)}. */
   @CanIgnoreReturnValue
-  @VisibleForTesting
   @ParametricNullness
+  @VisibleForTesting
   static <V extends @Nullable Object, X extends Exception> V getChecked(
       GetCheckedTypeValidator validator, Future<V> future, Class<X> exceptionClass) throws X {
     validator.validateClass(exceptionClass);
@@ -228,7 +228,7 @@ final class FuturesGetChecked {
 
   private static <X extends Exception> X newWithCause(Class<X> exceptionClass, Throwable cause) {
     // getConstructors() guarantees this as long as we don't modify the array.
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     List<Constructor<X>> constructors = (List) Arrays.asList(exceptionClass.getConstructors());
     for (Constructor<X> constructor : preferringStrings(constructors)) {
       X instance = newFromConstructor(constructor, cause);
diff --git a/guava/src/com/google/common/util/concurrent/ImmediateFuture.java b/guava/src/com/google/common/util/concurrent/ImmediateFuture.java
index 8b1c17ae48..55259da09b 100644
--- a/guava/src/com/google/common/util/concurrent/ImmediateFuture.java
+++ b/guava/src/com/google/common/util/concurrent/ImmediateFuture.java
@@ -14,7 +14,7 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.util.concurrent.AbstractFuture.TrustedFuture;
@@ -42,8 +42,8 @@ class ImmediateFuture<V extends @Nullable Object> implements ListenableFuture<V>
 
   @Override
   public void addListener(Runnable listener, Executor executor) {
-    checkNotNull(listener, "Runnable was null.");
-    checkNotNull(executor, "Executor was null.");
+    requireNonNull(listener, "Runnable was null.");
+    requireNonNull(executor, "Executor was null.");
     try {
       executor.execute(listener);
     } catch (RuntimeException e) {
@@ -71,7 +71,7 @@ class ImmediateFuture<V extends @Nullable Object> implements ListenableFuture<V>
   @Override
   @ParametricNullness
   public V get(long timeout, TimeUnit unit) throws ExecutionException {
-    checkNotNull(unit);
+    requireNonNull(unit);
     return get();
   }
 
diff --git a/guava/src/com/google/common/util/concurrent/InterruptibleTask.java b/guava/src/com/google/common/util/concurrent/InterruptibleTask.java
index bcec007303..6fbf846bcd 100644
--- a/guava/src/com/google/common/util/concurrent/InterruptibleTask.java
+++ b/guava/src/com/google/common/util/concurrent/InterruptibleTask.java
@@ -25,7 +25,7 @@ import java.util.concurrent.locks.LockSupport;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 @GwtCompatible(emulated = true)
-@ReflectionSupport(value = ReflectionSupport.Level.FULL)
+@ReflectionSupport(ReflectionSupport.Level.FULL)
 @ElementTypesAreNonnullByDefault
 // Some Android 5.0.x Samsung devices have bugs in JDK reflection APIs that cause
 // getDeclaredField to throw a NoSuchFieldException when the field is definitely there.
@@ -52,8 +52,8 @@ abstract class InterruptibleTask<T extends @Nullable Object>
   // Why 1000?  WHY NOT!
   private static final int MAX_BUSY_WAIT_SPINS = 1000;
 
-  @SuppressWarnings("ThreadPriorityCheck") // The cow told me to
-  @Override
+  @Override // The cow told me to
+  @SuppressWarnings("ThreadPriorityCheck")
   public final void run() {
     /*
      * Set runner thread before checking isDone(). If we were to check isDone() first, the task
diff --git a/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java b/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java
index 0b0db4573a..27374e17f3 100644
--- a/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java
+++ b/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java
@@ -14,8 +14,8 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -81,7 +81,7 @@ public final class JdkFutureAdapters {
    */
   public static <V extends @Nullable Object> ListenableFuture<V> listenInPoolThread(
       Future<V> future, Executor executor) {
-    checkNotNull(executor);
+    requireNonNull(executor);
     if (future instanceof ListenableFuture) {
       return (ListenableFuture<V>) future;
     }
@@ -125,8 +125,8 @@ public final class JdkFutureAdapters {
     }
 
     ListenableFutureAdapter(Future<V> delegate, Executor adapterExecutor) {
-      this.delegate = checkNotNull(delegate);
-      this.adapterExecutor = checkNotNull(adapterExecutor);
+      this.delegate = requireNonNull(delegate);
+      this.adapterExecutor = requireNonNull(adapterExecutor);
     }
 
     @Override
diff --git a/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java b/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java
index ed8c9065ac..e46beea867 100644
--- a/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java
+++ b/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java
@@ -14,14 +14,14 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.Collections.synchronizedList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.common.collect.Queues;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.Executor;
@@ -60,7 +60,7 @@ final class ListenerCallQueue<L> {
 
   // TODO(chrisn): promote AppendOnlyCollection for use here.
   private final List<PerListenerQueue<L>> listeners =
-      Collections.synchronizedList(new ArrayList<PerListenerQueue<L>>());
+      synchronizedList(new ArrayList<PerListenerQueue<L>>());
 
   /** Method reference-compatible listener event. */
   interface Event<L> {
@@ -73,8 +73,8 @@ final class ListenerCallQueue<L> {
    * #enqueue enqueued} and {@link #dispatch dispatched}.
    */
   public void addListener(L listener, Executor executor) {
-    checkNotNull(listener, "listener");
-    checkNotNull(executor, "executor");
+    requireNonNull(listener, "listener");
+    requireNonNull(executor, "executor");
     listeners.add(new PerListenerQueue<>(listener, executor));
   }
 
@@ -101,8 +101,8 @@ final class ListenerCallQueue<L> {
   }
 
   private void enqueueHelper(Event<L> event, Object label) {
-    checkNotNull(event, "event");
-    checkNotNull(label, "label");
+    requireNonNull(event, "event");
+    requireNonNull(label, "label");
     synchronized (listeners) {
       for (PerListenerQueue<L> queue : listeners) {
         queue.add(event, label);
@@ -143,8 +143,8 @@ final class ListenerCallQueue<L> {
     boolean isThreadScheduled;
 
     PerListenerQueue(L listener, Executor executor) {
-      this.listener = checkNotNull(listener);
-      this.executor = checkNotNull(executor);
+      this.listener = requireNonNull(listener);
+      this.executor = requireNonNull(executor);
     }
 
     /** Enqueues a event to be run. */
@@ -191,7 +191,7 @@ final class ListenerCallQueue<L> {
           ListenerCallQueue.Event<L> nextToRun;
           Object nextLabel;
           synchronized (PerListenerQueue.this) {
-            Preconditions.checkState(isThreadScheduled);
+            checkState(isThreadScheduled);
             nextToRun = waitQueue.poll();
             nextLabel = labelQueue.poll();
             if (nextToRun == null) {
diff --git a/guava/src/com/google/common/util/concurrent/Monitor.java b/guava/src/com/google/common/util/concurrent/Monitor.java
index d01c6faa2a..126b49cee6 100644
--- a/guava/src/com/google/common/util/concurrent/Monitor.java
+++ b/guava/src/com/google/common/util/concurrent/Monitor.java
@@ -14,8 +14,8 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Longs;
@@ -316,7 +316,7 @@ public final class Monitor {
     Guard next;
 
     protected Guard(Monitor monitor) {
-      this.monitor = checkNotNull(monitor, "monitor");
+      this.monitor = requireNonNull(monitor, "monitor");
       this.condition = monitor.lock.newCondition();
     }
 
@@ -369,7 +369,7 @@ public final class Monitor {
    * @since 21.0
    */
   public Guard newGuard(final BooleanSupplier isSatisfied) {
-    checkNotNull(isSatisfied, "isSatisfied");
+    requireNonNull(isSatisfied, "isSatisfied");
     return new Guard(this) {
       @Override
       public boolean isSatisfied() {
diff --git a/guava/src/com/google/common/util/concurrent/MoreExecutors.java b/guava/src/com/google/common/util/concurrent/MoreExecutors.java
index 90776bc9e6..f1130ef480 100644
--- a/guava/src/com/google/common/util/concurrent/MoreExecutors.java
+++ b/guava/src/com/google/common/util/concurrent/MoreExecutors.java
@@ -15,8 +15,9 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
+import static java.util.Collections.emptyList;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -32,7 +33,6 @@ import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.lang.reflect.InvocationTargetException;
 import java.time.Duration;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
@@ -259,8 +259,8 @@ public final class MoreExecutors {
 
     final void addDelayedShutdownHook(
         final ExecutorService service, final long terminationTimeout, final TimeUnit timeUnit) {
-      checkNotNull(service);
-      checkNotNull(timeUnit);
+      requireNonNull(service);
+      requireNonNull(timeUnit);
       addShutdownHook(
           MoreExecutors.newThread(
               "DelayedShutdownHook-for-" + service,
@@ -347,7 +347,7 @@ public final class MoreExecutors {
     @Override
     public List<Runnable> shutdownNow() {
       shutdown();
-      return Collections.emptyList();
+      return emptyList();
     }
 
     @Override
@@ -598,7 +598,7 @@ public final class MoreExecutors {
     private final ExecutorService delegate;
 
     ListeningDecorator(ExecutorService delegate) {
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
@@ -645,7 +645,7 @@ public final class MoreExecutors {
 
     ScheduledListeningDecorator(ScheduledExecutorService delegate) {
       super(delegate);
-      this.delegate = checkNotNull(delegate);
+      this.delegate = requireNonNull(delegate);
     }
 
     @Override
@@ -721,7 +721,7 @@ public final class MoreExecutors {
       private final Runnable delegate;
 
       public NeverSuccessfulListenableFutureTask(Runnable delegate) {
-        this.delegate = checkNotNull(delegate);
+        this.delegate = requireNonNull(delegate);
       }
 
       @Override
@@ -772,9 +772,9 @@ public final class MoreExecutors {
    * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}
    * implementations.
    */
-  @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @GwtIncompatible
+  @GwtIncompatible // should accept a java.time.Duration
   @ParametricNullness
+  @SuppressWarnings("GoodTime")
   static <T extends @Nullable Object> T invokeAnyImpl(
       ListeningExecutorService executorService,
       Collection<? extends Callable<T>> tasks,
@@ -782,8 +782,8 @@ public final class MoreExecutors {
       long timeout,
       TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
-    checkNotNull(executorService);
-    checkNotNull(unit);
+    requireNonNull(executorService);
+    requireNonNull(unit);
     int ntasks = tasks.size();
     checkArgument(ntasks > 0);
     List<Future<T>> futures = Lists.newArrayListWithCapacity(ntasks);
@@ -945,8 +945,8 @@ public final class MoreExecutors {
    */
   @GwtIncompatible // concurrency
   static Thread newThread(String name, Runnable runnable) {
-    checkNotNull(name);
-    checkNotNull(runnable);
+    requireNonNull(name);
+    requireNonNull(runnable);
     Thread result = platformThreadFactory().newThread(runnable);
     try {
       result.setName(name);
@@ -972,8 +972,8 @@ public final class MoreExecutors {
    */
   @GwtIncompatible // concurrency
   static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {
-    checkNotNull(executor);
-    checkNotNull(nameSupplier);
+    requireNonNull(executor);
+    requireNonNull(nameSupplier);
     return new Executor() {
       @Override
       public void execute(Runnable command) {
@@ -996,8 +996,8 @@ public final class MoreExecutors {
   @GwtIncompatible // concurrency
   static ExecutorService renamingDecorator(
       final ExecutorService service, final Supplier<String> nameSupplier) {
-    checkNotNull(service);
-    checkNotNull(nameSupplier);
+    requireNonNull(service);
+    requireNonNull(nameSupplier);
     return new WrappingExecutorService(service) {
       @Override
       protected <T extends @Nullable Object> Callable<T> wrapTask(Callable<T> callable) {
@@ -1025,8 +1025,8 @@ public final class MoreExecutors {
   @GwtIncompatible // concurrency
   static ScheduledExecutorService renamingDecorator(
       final ScheduledExecutorService service, final Supplier<String> nameSupplier) {
-    checkNotNull(service);
-    checkNotNull(nameSupplier);
+    requireNonNull(service);
+    requireNonNull(nameSupplier);
     return new WrappingScheduledExecutorService(service) {
       @Override
       protected <T extends @Nullable Object> Callable<T> wrapTask(Callable<T> callable) {
@@ -1128,8 +1128,8 @@ public final class MoreExecutors {
    */
   static Executor rejectionPropagatingExecutor(
       final Executor delegate, final AbstractFuture<?> future) {
-    checkNotNull(delegate);
-    checkNotNull(future);
+    requireNonNull(delegate);
+    requireNonNull(future);
     if (delegate == directExecutor()) {
       // directExecutor() cannot throw RejectedExecutionException
       return delegate;
diff --git a/guava/src/com/google/common/util/concurrent/NullnessCasts.java b/guava/src/com/google/common/util/concurrent/NullnessCasts.java
index a3a914e897..a72f7a1459 100644
--- a/guava/src/com/google/common/util/concurrent/NullnessCasts.java
+++ b/guava/src/com/google/common/util/concurrent/NullnessCasts.java
@@ -50,8 +50,8 @@ final class NullnessCasts {
    * addressed by this method is the case in which {@code T} has parametric nullness -- and thus its
    * value may be legitimately {@code null}.)
    */
-  @SuppressWarnings("nullness")
   @ParametricNullness
+  @SuppressWarnings("nullness")
   static <T extends @Nullable Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
     return t;
   }
@@ -65,9 +65,9 @@ final class NullnessCasts {
    * return to a caller, the code needs to a way to return {@code null} from a method that returns
    * "plain {@code T}." This API provides that.
    */
-  @SuppressWarnings({"nullness", "TypeParameterUnusedInFormals", "ReturnMissingNullable"})
-  // The warnings are legitimate. Each time we use this method, we document why.
   @ParametricNullness
+  // The warnings are legitimate. Each time we use this method, we document why.
+  @SuppressWarnings({"nullness", "ReturnMissingNullable", "TypeParameterUnusedInFormals"})
   static <T extends @Nullable Object> T uncheckedNull() {
     return null;
   }
diff --git a/guava/src/com/google/common/util/concurrent/RateLimiter.java b/guava/src/com/google/common/util/concurrent/RateLimiter.java
index 4b8b025541..933dce2b26 100644
--- a/guava/src/com/google/common/util/concurrent/RateLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/RateLimiter.java
@@ -15,9 +15,9 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 import static java.lang.Math.max;
+import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.TimeUnit.MICROSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -231,7 +231,7 @@ public abstract class RateLimiter {
   }
 
   RateLimiter(SleepingStopwatch stopwatch) {
-    this.stopwatch = checkNotNull(stopwatch);
+    this.stopwatch = requireNonNull(stopwatch);
   }
 
   /**
diff --git a/guava/src/com/google/common/util/concurrent/SequentialExecutor.java b/guava/src/com/google/common/util/concurrent/SequentialExecutor.java
index d0b600be84..c108a4f1a7 100644
--- a/guava/src/com/google/common/util/concurrent/SequentialExecutor.java
+++ b/guava/src/com/google/common/util/concurrent/SequentialExecutor.java
@@ -14,15 +14,14 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.IDLE;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUED;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUING;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.RUNNING;
 import static java.lang.System.identityHashCode;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
 import com.google.j2objc.annotations.RetainedWith;
 import java.util.ArrayDeque;
@@ -86,7 +85,7 @@ final class SequentialExecutor implements Executor {
 
   /** Use {@link MoreExecutors#newSequentialExecutor} */
   SequentialExecutor(Executor executor) {
-    this.executor = Preconditions.checkNotNull(executor);
+    this.executor = requireNonNull(executor);
   }
 
   /**
@@ -97,7 +96,7 @@ final class SequentialExecutor implements Executor {
    */
   @Override
   public void execute(Runnable task) {
-    checkNotNull(task);
+    requireNonNull(task);
     Runnable submittedTask;
     long oldRunCount;
     synchronized (queue) {
@@ -249,8 +248,8 @@ final class SequentialExecutor implements Executor {
       }
     }
 
-    @SuppressWarnings("GuardedBy")
     @Override
+    @SuppressWarnings("GuardedBy")
     public String toString() {
       Runnable currentlyRunning = task;
       if (currentlyRunning != null) {
diff --git a/guava/src/com/google/common/util/concurrent/ServiceManager.java b/guava/src/com/google/common/util/concurrent/ServiceManager.java
index 5ab95ffa6b..4c5a32b3c8 100644
--- a/guava/src/com/google/common/util/concurrent/ServiceManager.java
+++ b/guava/src/com/google/common/util/concurrent/ServiceManager.java
@@ -15,7 +15,6 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.in;
@@ -29,6 +28,7 @@ import static com.google.common.util.concurrent.Service.State.RUNNING;
 import static com.google.common.util.concurrent.Service.State.STARTING;
 import static com.google.common.util.concurrent.Service.State.STOPPING;
 import static com.google.common.util.concurrent.Service.State.TERMINATED;
+import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 import com.google.common.annotations.GwtIncompatible;
@@ -485,8 +485,8 @@ public final class ServiceManager implements ServiceManagerBridge {
         super(ServiceManagerState.this.monitor);
       }
 
-      @Override
       @GuardedBy("ServiceManagerState.this.monitor")
+      @Override
       public boolean isSatisfied() {
         // All services have started or some service has terminated/failed.
         return states.count(RUNNING) == numberOfServices
@@ -505,8 +505,8 @@ public final class ServiceManager implements ServiceManagerBridge {
         super(ServiceManagerState.this.monitor);
       }
 
-      @Override
       @GuardedBy("ServiceManagerState.this.monitor")
+      @Override
       public boolean isSatisfied() {
         return states.count(TERMINATED) + states.count(FAILED) == numberOfServices;
       }
@@ -674,7 +674,7 @@ public final class ServiceManager implements ServiceManagerBridge {
      * </ol>
      */
     void transitionService(final Service service, State from, State to) {
-      checkNotNull(service);
+      requireNonNull(service);
       checkArgument(from != to);
       monitor.enter();
       try {
diff --git a/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java b/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java
index c6ade6a3a0..e9094450af 100644
--- a/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java
@@ -15,7 +15,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -53,7 +53,7 @@ public final class SimpleTimeLimiter implements TimeLimiter {
   private final ExecutorService executor;
 
   private SimpleTimeLimiter(ExecutorService executor) {
-    this.executor = checkNotNull(executor);
+    this.executor = requireNonNull(executor);
   }
 
   /**
@@ -74,9 +74,9 @@ public final class SimpleTimeLimiter implements TimeLimiter {
   @Override
   public <T> T newProxy(
       T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit) {
-    checkNotNull(target);
-    checkNotNull(interfaceType);
-    checkNotNull(timeoutUnit);
+    requireNonNull(target);
+    requireNonNull(interfaceType);
+    requireNonNull(timeoutUnit);
     checkPositiveTimeout(timeoutDuration);
     checkArgument(interfaceType.isInterface(), "interfaceType must be an interface type");
 
@@ -84,8 +84,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
 
     InvocationHandler handler =
         new InvocationHandler() {
-          @Override
           @CheckForNull
+          @Override
           public Object invoke(Object obj, Method method, @CheckForNull @Nullable Object[] args)
               throws Throwable {
             Callable<@Nullable Object> callable =
@@ -114,8 +114,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
   private <T extends @Nullable Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean amInterruptible)
       throws Exception {
-    checkNotNull(callable);
-    checkNotNull(timeoutUnit);
+    requireNonNull(callable);
+    requireNonNull(timeoutUnit);
     checkPositiveTimeout(timeoutDuration);
 
     Future<T> future = executor.submit(callable);
@@ -144,8 +144,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
   public <T extends @Nullable Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, InterruptedException, ExecutionException {
-    checkNotNull(callable);
-    checkNotNull(timeoutUnit);
+    requireNonNull(callable);
+    requireNonNull(timeoutUnit);
     checkPositiveTimeout(timeoutDuration);
 
     Future<T> future = executor.submit(callable);
@@ -166,8 +166,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
   public <T extends @Nullable Object> T callUninterruptiblyWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, ExecutionException {
-    checkNotNull(callable);
-    checkNotNull(timeoutUnit);
+    requireNonNull(callable);
+    requireNonNull(timeoutUnit);
     checkPositiveTimeout(timeoutDuration);
 
     Future<T> future = executor.submit(callable);
@@ -186,8 +186,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
   @Override
   public void runWithTimeout(Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, InterruptedException {
-    checkNotNull(runnable);
-    checkNotNull(timeoutUnit);
+    requireNonNull(runnable);
+    requireNonNull(timeoutUnit);
     checkPositiveTimeout(timeoutDuration);
 
     Future<?> future = executor.submit(runnable);
@@ -206,8 +206,8 @@ public final class SimpleTimeLimiter implements TimeLimiter {
   @Override
   public void runUninterruptiblyWithTimeout(
       Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) throws TimeoutException {
-    checkNotNull(runnable);
-    checkNotNull(timeoutUnit);
+    requireNonNull(runnable);
+    requireNonNull(timeoutUnit);
     checkPositiveTimeout(timeoutDuration);
 
     Future<?> future = executor.submit(runnable);
diff --git a/guava/src/com/google/common/util/concurrent/Striped.java b/guava/src/com/google/common/util/concurrent/Striped.java
index 2ea61cb324..f356c07060 100644
--- a/guava/src/com/google/common/util/concurrent/Striped.java
+++ b/guava/src/com/google/common/util/concurrent/Striped.java
@@ -14,13 +14,15 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkElementIndex;
 import static com.google.common.collect.Lists.newArrayList;
+import static java.util.Collections.unmodifiableList;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
-import com.google.common.base.Preconditions;
 import com.google.common.base.Supplier;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.MapMaker;
@@ -31,7 +33,6 @@ import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.math.RoundingMode;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Semaphore;
@@ -181,7 +182,7 @@ public abstract class Striped<L> {
      */
     @SuppressWarnings("unchecked") // we carefully replaced all keys with their respective L's
     List<L> asStripes = (List<L>) result;
-    return Collections.unmodifiableList(asStripes);
+    return unmodifiableList(asStripes);
   }
 
   // Static factories
@@ -340,7 +341,7 @@ public abstract class Striped<L> {
     final int mask;
 
     PowerOfTwoStriped(int stripes) {
-      Preconditions.checkArgument(stripes > 0, "Stripes must be positive");
+      checkArgument(stripes > 0, "Stripes must be positive");
       this.mask = stripes > Ints.MAX_POWER_OF_TWO ? ALL_SET : ceilToPowerOfTwo(stripes) - 1;
     }
 
@@ -366,7 +367,7 @@ public abstract class Striped<L> {
 
     private CompactStriped(int stripes, Supplier<L> supplier) {
       super(stripes);
-      Preconditions.checkArgument(stripes <= Ints.MAX_POWER_OF_TWO, "Stripes must be <= 2^30)");
+      checkArgument(stripes <= Ints.MAX_POWER_OF_TWO, "Stripes must be <= 2^30)");
 
       this.array = new Object[mask + 1];
       for (int i = 0; i < array.length; i++) {
@@ -374,8 +375,8 @@ public abstract class Striped<L> {
       }
     }
 
-    @SuppressWarnings("unchecked") // we only put L's in the array
-    @Override
+    @Override // we only put L's in the array
+    @SuppressWarnings("unchecked")
     public L getAt(int index) {
       return (L) array[index];
     }
@@ -408,7 +409,7 @@ public abstract class Striped<L> {
     @Override
     public L getAt(int index) {
       if (size != Integer.MAX_VALUE) {
-        Preconditions.checkElementIndex(index, size());
+        checkElementIndex(index, size());
       } // else no check necessary, all index values are valid
       ArrayReference<? extends L> existingRef = locks.get(index);
       L existing = existingRef == null ? null : existingRef.get();
@@ -479,7 +480,7 @@ public abstract class Striped<L> {
     @Override
     public L getAt(int index) {
       if (size != Integer.MAX_VALUE) {
-        Preconditions.checkElementIndex(index, size());
+        checkElementIndex(index, size());
       } // else no check necessary, all index values are valid
       L existing = locks.get(index);
       if (existing != null) {
diff --git a/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java b/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java
index 091f56e799..942b5efabe 100644
--- a/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java
+++ b/guava/src/com/google/common/util/concurrent/ThreadFactoryBuilder.java
@@ -15,7 +15,6 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
@@ -118,7 +117,7 @@ public final class ThreadFactoryBuilder {
    */
   public ThreadFactoryBuilder setUncaughtExceptionHandler(
       UncaughtExceptionHandler uncaughtExceptionHandler) {
-    this.uncaughtExceptionHandler = checkNotNull(uncaughtExceptionHandler);
+    this.uncaughtExceptionHandler = requireNonNull(uncaughtExceptionHandler);
     return this;
   }
 
@@ -132,7 +131,7 @@ public final class ThreadFactoryBuilder {
    * @see MoreExecutors
    */
   public ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory) {
-    this.backingThreadFactory = checkNotNull(backingThreadFactory);
+    this.backingThreadFactory = requireNonNull(backingThreadFactory);
     return this;
   }
 
diff --git a/guava/src/com/google/common/util/concurrent/TimeLimiter.java b/guava/src/com/google/common/util/concurrent/TimeLimiter.java
index 0245fec3ca..c743db35c4 100644
--- a/guava/src/com/google/common/util/concurrent/TimeLimiter.java
+++ b/guava/src/com/google/common/util/concurrent/TimeLimiter.java
@@ -144,8 +144,8 @@ public interface TimeLimiter {
    * @throws ExecutionError if {@code callable} throws an {@code Error}
    * @since 22.0
    */
-  @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @CanIgnoreReturnValue
+  @CanIgnoreReturnValue // should accept a java.time.Duration
+  @SuppressWarnings("GoodTime")
   <T extends @Nullable Object> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, InterruptedException, ExecutionException;
@@ -191,8 +191,8 @@ public interface TimeLimiter {
    * @throws ExecutionError if {@code callable} throws an {@code Error}
    * @since 22.0
    */
-  @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @CanIgnoreReturnValue
+  @CanIgnoreReturnValue // should accept a java.time.Duration
+  @SuppressWarnings("GoodTime")
   <T extends @Nullable Object> T callUninterruptiblyWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)
       throws TimeoutException, ExecutionException;
diff --git a/guava/src/com/google/common/util/concurrent/TimeoutFuture.java b/guava/src/com/google/common/util/concurrent/TimeoutFuture.java
index ed8a7bfdbe..4ca3e34ce1 100644
--- a/guava/src/com/google/common/util/concurrent/TimeoutFuture.java
+++ b/guava/src/com/google/common/util/concurrent/TimeoutFuture.java
@@ -15,9 +15,9 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
@@ -77,7 +77,7 @@ final class TimeoutFuture<V extends @Nullable Object> extends FluentFuture.Trust
   @CheckForNull private ScheduledFuture<?> timer;
 
   private TimeoutFuture(ListenableFuture<V> delegate) {
-    this.delegateRef = Preconditions.checkNotNull(delegate);
+    this.delegateRef = requireNonNull(delegate);
   }
 
   /** A runnable that is called when the delegate or the timer completes. */
@@ -153,8 +153,8 @@ final class TimeoutFuture<V extends @Nullable Object> extends FluentFuture.Trust
     }
   }
 
-  @Override
   @CheckForNull
+  @Override
   protected String pendingToString() {
     ListenableFuture<? extends V> localInputFuture = delegateRef;
     ScheduledFuture<?> localTimer = timer;
diff --git a/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java b/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java
index 929c9fb1ea..3653d70ca4 100644
--- a/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java
+++ b/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java
@@ -15,6 +15,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.j2objc.annotations.WeakOuter;
@@ -102,8 +103,8 @@ class TrustedListenableFutureTask<V extends @Nullable Object> extends FluentFutu
     this.task = null;
   }
 
-  @Override
   @CheckForNull
+  @Override
   protected String pendingToString() {
     InterruptibleTask<?> localTask = task;
     if (localTask != null) {
@@ -117,7 +118,7 @@ class TrustedListenableFutureTask<V extends @Nullable Object> extends FluentFutu
     private final Callable<V> callable;
 
     TrustedFutureInterruptibleTask(Callable<V> callable) {
-      this.callable = checkNotNull(callable);
+      this.callable = requireNonNull(callable);
     }
 
     @Override
@@ -153,7 +154,7 @@ class TrustedListenableFutureTask<V extends @Nullable Object> extends FluentFutu
     private final AsyncCallable<V> callable;
 
     TrustedFutureInterruptibleAsyncTask(AsyncCallable<V> callable) {
-      this.callable = checkNotNull(callable);
+      this.callable = requireNonNull(callable);
     }
 
     @Override
diff --git a/guava/src/com/google/common/util/concurrent/Uninterruptibles.java b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
index 09ace92fae..4c10ed21b4 100644
--- a/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
+++ b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
@@ -16,11 +16,11 @@ package com.google.common.util.concurrent;
 
 import static com.google.common.base.Verify.verify;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
+import static java.util.Objects.requireNonNull;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.time.Duration;
 import java.util.concurrent.BlockingQueue;
@@ -190,7 +190,7 @@ public final class Uninterruptibles {
   @GwtIncompatible // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit unit) {
-    Preconditions.checkNotNull(toJoin);
+    requireNonNull(toJoin);
     boolean interrupted = false;
     try {
       long remainingNanos = unit.toNanos(timeout);
@@ -296,8 +296,8 @@ public final class Uninterruptibles {
    */
   @CanIgnoreReturnValue
   @GwtIncompatible // TODO
-  @SuppressWarnings("GoodTime") // should accept a java.time.Duration
-  @ParametricNullness
+  @ParametricNullness // should accept a java.time.Duration
+  @SuppressWarnings("GoodTime")
   public static <V extends @Nullable Object> V getUninterruptibly(
       Future<V> future, long timeout, TimeUnit unit) throws ExecutionException, TimeoutException {
     boolean interrupted = false;
diff --git a/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java b/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java
index 5a3c3927a6..e1f68eec5a 100644
--- a/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java
+++ b/guava/src/com/google/common/util/concurrent/WrappingExecutorService.java
@@ -14,8 +14,8 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.ImmutableList;
@@ -48,7 +48,7 @@ abstract class WrappingExecutorService implements ExecutorService {
   private final ExecutorService delegate;
 
   protected WrappingExecutorService(ExecutorService delegate) {
-    this.delegate = checkNotNull(delegate);
+    this.delegate = requireNonNull(delegate);
   }
 
   /**
@@ -95,7 +95,7 @@ abstract class WrappingExecutorService implements ExecutorService {
 
   @Override
   public final <T extends @Nullable Object> Future<T> submit(Callable<T> task) {
-    return delegate.submit(wrapTask(checkNotNull(task)));
+    return delegate.submit(wrapTask(requireNonNull(task)));
   }
 
   @Override
diff --git a/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java b/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java
index 89cdadd3da..bf10de81a8 100644
--- a/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java
+++ b/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java
@@ -75,7 +75,7 @@ final class TrieParser {
       // ':' represents an interior node that represents a private entry in the map
       // ',' represents a leaf node, which represents a private entry in the map.
       String domain = PREFIX_JOINER.join(stack);
-      if (domain.length() > 0) {
+      if (!domain.isEmpty()) {
         builder.put(domain, PublicSuffixType.fromCode(c));
       }
     }
