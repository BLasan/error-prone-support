diff --git a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
index b16828f8e..ddb37db47 100644
--- a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
+++ b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraFilter.java
@@ -38,11 +38,12 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
@@ -105,7 +106,7 @@ public CassandraFilter(
 
   @Override public void implement(Implementor implementor) {
     implementor.visitChild(0, getInput());
-    implementor.add(null, Collections.singletonList(match));
+    implementor.add(null, ImmutableList.of(match));
   }
 
   /**
diff --git a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
index 838b5d3d9..610460ff7 100644
--- a/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
+++ b/cassandra/src/main/java/org/apache/calcite/adapter/cassandra/CassandraSchema.java
@@ -67,6 +67,8 @@
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /** Schema mapped onto a Cassandra column family. */
 public class CassandraSchema extends AbstractSchema {
   final CqlSession session;
@@ -131,14 +133,14 @@ RelProtoDataType getRelDataType(String columnFamily, boolean view) {
     if (view) {
       Optional<ViewMetadata> optionalViewMetadata = getKeyspace().getView(tableName);
       if (optionalViewMetadata.isPresent()) {
-        columns = optionalViewMetadata.get().getColumns();
+        columns = optionalViewMetadata.orElseThrow().getColumns();
       } else {
         throw new IllegalStateException("Unknown view " + tableName + " in keyspace " + keyspace);
       }
     } else {
       Optional<TableMetadata> optionalTableMetadata = getKeyspace().getTable(tableName);
       if (optionalTableMetadata.isPresent()) {
-        columns = optionalTableMetadata.get().getColumns();
+        columns = optionalTableMetadata.orElseThrow().getColumns();
       } else {
         throw new IllegalStateException("Unknown table " + tableName + " in keyspace " + keyspace);
       }
@@ -331,10 +333,11 @@ private void addMaterializedViews() {
       // Add the view for this query
       String viewName = "$" + getTableNames().size();
       SchemaPlus schema = parentSchema.getSubSchema(name);
-      if (schema == null) {
-        throw new IllegalStateException(
-            "Cannot find schema " + name + " in parent schema " + parentSchema.getName());
-      }
+      checkState(
+          schema != null,
+          "Cannot find schema %s in parent schema %s",
+          name,
+          parentSchema.getName());
       CalciteSchema calciteSchema = CalciteSchema.from(schema);
 
       List<String> viewPath = calciteSchema.path(viewName);
diff --git a/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java b/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java
index 0e23ff025..a2971a3d4 100644
--- a/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java
+++ b/core/src/main/java/org/apache/calcite/adapter/clone/ArrayTable.java
@@ -409,7 +409,7 @@ public static class ObjectDictionary implements Representation {
     }
 
     @Override public Object freeze(ColumnLoader.ValueSet valueSet, int @Nullable [] sources) {
-      final int n = valueSet.map.keySet().size();
+      final int n = valueSet.map.size();
       int extra = valueSet.containsNull ? 1 : 0;
       @SuppressWarnings("all")
       @Nullable
diff --git a/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java b/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
index 8e6763ecf..03b7a3c5c 100644
--- a/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
+++ b/core/src/main/java/org/apache/calcite/adapter/clone/ColumnLoader.java
@@ -189,7 +189,7 @@ private void load(final RelDataType elementType, List<ColumnMetaData.Rep> repLis
       for (Object o : list2) {
         valueSet.add((Comparable) o);
       }
-      if (sort != null && sort[0] < 0 && valueSet.map.keySet().size() == list.size()) {
+      if (sort != null && sort[0] < 0 && valueSet.map.size() == list.size()) {
         // We have discovered a the first unique key in the table.
         sort[0] = pair.i;
         // map.keySet().size() == list.size() above implies list contains only non-null elements
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java
index 88e3ac8bf..d800b6a56 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/AggImpState.java
@@ -23,6 +23,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Represents internal state when implementing aggregate functions. */
 public class AggImpState {
   public final int aggIdx;
@@ -37,12 +39,11 @@ public AggImpState(int aggIdx, AggregateCall call, boolean windowContext) {
     this.aggIdx = aggIdx;
     this.call = call;
     AggImplementor implementor = RexImpTable.INSTANCE.get(call.getAggregation(), windowContext);
-    if (implementor == null) {
-      throw new IllegalArgumentException(
-          "Unable to get aggregate implementation for aggregate "
-              + call.getAggregation()
-              + (windowContext ? " in window context" : ""));
-    }
+    checkArgument(
+        implementor != null,
+        "Unable to get aggregate implementation for aggregate %s%s",
+        call.getAggregation(),
+        windowContext ? " in window context" : "");
     this.implementor = implementor;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
index 0f4a787bb..2772a9625 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java
@@ -847,7 +847,7 @@ private static class SessionizationEnumerator implements Enumerator<@Nullable Ob
     }
 
     @Override public boolean moveNext() {
-      return initialized ? list.size() > 0 : inputEnumerator.moveNext();
+      return initialized ? !list.isEmpty() : inputEnumerator.moveNext();
     }
 
     @Override public void reset() {
@@ -929,7 +929,7 @@ private void initialize() {
     }
 
     private static boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {
-      return !(b.left >= a.right);
+      return b.left < a.right;
     }
 
     private static Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {
@@ -992,7 +992,7 @@ private static class HopEnumerator implements Enumerator<@Nullable Object[]> {
     }
 
     @Override public @Nullable Object[] current() {
-      if (list.size() > 0) {
+      if (!list.isEmpty()) {
         return takeOne();
       } else {
         @Nullable Object[] current = inputEnumerator.current();
@@ -1013,7 +1013,7 @@ private static class HopEnumerator implements Enumerator<@Nullable Object[]> {
     }
 
     @Override public boolean moveNext() {
-      return list.size() > 0 || inputEnumerator.moveNext();
+      return !list.isEmpty() || inputEnumerator.moveNext();
     }
 
     @Override public void reset() {
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
index 148c14026..e48896665 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java
@@ -93,7 +93,7 @@ protected EnumerableMergeJoin(
     }
 
     final List<RelCollation> collations = traits.getTraits(RelCollationTraitDef.INSTANCE);
-    assert collations != null && collations.size() > 0;
+    assert collations != null && !collations.isEmpty();
     ImmutableIntList rightKeys = joinInfo.rightKeys.incr(left.getRowType().getFieldCount());
     // Currently it has very limited ability to represent the equivalent traits
     // due to the flaw of RelCompositeTrait, so the following case is totally
@@ -368,12 +368,10 @@ private Mappings.TargetMapping buildMapping(boolean left2Right) {
       keyMap.put(sourceKeys.get(i), targetKeys.get(i));
     }
 
-    Mappings.TargetMapping mapping =
-        Mappings.target(
-            keyMap,
-            (left2Right ? left : right).getRowType().getFieldCount(),
-            (left2Right ? right : left).getRowType().getFieldCount());
-    return mapping;
+    return Mappings.target(
+        keyMap,
+        (left2Right ? left : right).getRowType().getFieldCount(),
+        (left2Right ? right : left).getRowType().getFieldCount());
   }
 
   /** This function extends collation by appending new collation fields defined on keys. */
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
index d9706b400..3d5f30b20 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoinRule.java
@@ -69,7 +69,7 @@ protected EnumerableMergeJoinRule(Config config) {
       // EnumerableMergeJoin only supports certain join types.
       return null;
     }
-    if (info.pairs().size() == 0) {
+    if (info.pairs().isEmpty()) {
       // EnumerableMergeJoin CAN support cartesian join, but disable it for now.
       return null;
     }
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java
index dd8c129a4..aa50130e1 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeUnion.java
@@ -32,6 +32,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Implementation of {@link org.apache.calcite.rel.core.Union} in {@link
  * org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.
@@ -45,21 +47,17 @@ protected EnumerableMergeUnion(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
     super(cluster, traitSet, inputs, all);
     final RelCollation collation = traitSet.getCollation();
-    if (collation == null || collation.getFieldCollations().isEmpty()) {
-      throw new IllegalArgumentException("EnumerableMergeUnion with no collation");
-    }
+    checkArgument(
+        collation != null && !collation.getFieldCollations().isEmpty(),
+        "EnumerableMergeUnion with no collation");
     for (RelNode input : inputs) {
       final RelCollation inputCollation = input.getTraitSet().getCollation();
-      if (inputCollation == null || !inputCollation.satisfies(collation)) {
-        throw new IllegalArgumentException(
-            "EnumerableMergeUnion input does "
-                + "not satisfy collation. EnumerableMergeUnion collation: "
-                + collation
-                + ". Input collation: "
-                + inputCollation
-                + ". Input: "
-                + input);
-      }
+      checkArgument(
+          inputCollation != null && inputCollation.satisfies(collation),
+          "EnumerableMergeUnion input does not satisfy collation. EnumerableMergeUnion collation: %s. Input collation: %s. Input: %s",
+          collation,
+          inputCollation,
+          input);
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java
index 318ee5b92..cb838c2e2 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableNestedLoopJoin.java
@@ -135,8 +135,7 @@ public static EnumerableNestedLoopJoin create(
 
     RelOptCost cost = planner.getCostFactory().makeCost(rowCount, 0, 0);
     // Give it some penalty
-    cost = cost.multiplyBy(10);
-    return cost;
+    return cost.multiplyBy(10);
   }
 
   @Override public @Nullable Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
index 88ae5c1ff..9e1e1517d 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableRelImplementor.java
@@ -62,7 +62,6 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -178,11 +177,7 @@ public ClassDeclaration implementRoot(EnumerableRel rootRel, EnumerableRel.Prefe
                 Expressions.return_(
                     null, Expressions.constant(result.physType.getJavaRowType())))));
     return Expressions.classDecl(
-        Modifier.PUBLIC,
-        "Baz",
-        null,
-        Collections.singletonList(Bindable.class),
-        memberDeclarations);
+        Modifier.PUBLIC, "Baz", null, ImmutableList.of(Bindable.class), memberDeclarations);
   }
 
   private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordType type) {
@@ -254,7 +249,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
             Modifier.PUBLIC,
             boolean.class,
             "equals",
-            Collections.singletonList(oParameter),
+            ImmutableList.of(oParameter),
             blockBuilder2.toBlock()));
 
     // hashCode method:
@@ -282,11 +277,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
     blockBuilder3.add(Expressions.return_(null, hParameter));
     classDeclaration.memberDeclarations.add(
         Expressions.methodDecl(
-            Modifier.PUBLIC,
-            int.class,
-            "hashCode",
-            Collections.emptyList(),
-            blockBuilder3.toBlock()));
+            Modifier.PUBLIC, int.class, "hashCode", ImmutableList.of(), blockBuilder3.toBlock()));
 
     // compareTo method:
     //   public int compareTo(MyClass that) {
@@ -334,7 +325,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
             Modifier.PUBLIC,
             int.class,
             "compareTo",
-            Collections.singletonList(thatParameter),
+            ImmutableList.of(thatParameter),
             blockBuilder4.toBlock()));
 
     // toString method:
@@ -365,7 +356,7 @@ private static ClassDeclaration classDecl(JavaTypeFactoryImpl.SyntheticRecordTyp
             Modifier.PUBLIC,
             String.class,
             "toString",
-            Collections.emptyList(),
+            ImmutableList.of(),
             blockBuilder5.toBlock()));
 
     return classDeclaration;
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
index acc91f207..cef75bc5b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTableScan.java
@@ -57,6 +57,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.tree.Types.toClass;
 
 import static java.util.Objects.requireNonNull;
@@ -204,14 +206,11 @@ public static JavaRowFormat deduceFormat(RelOptTable table) {
 
   private Expression getExpression(PhysType physType) {
     final Expression expression = table.getExpression(Queryable.class);
-    if (expression == null) {
-      throw new IllegalStateException(
-          "Unable to implement "
-              + RelOptUtil.toString(this, SqlExplainLevel.ALL_ATTRIBUTES)
-              + ": "
-              + table
-              + ".getExpression(Queryable.class) returned null");
-    }
+    checkState(
+        expression != null,
+        "Unable to implement %s: %s.getExpression(Queryable.class) returned null",
+        RelOptUtil.toString(this, SqlExplainLevel.ALL_ATTRIBUTES),
+        table);
     final Expression expression2 = toEnumerable(expression);
     assert Types.isAssignableFrom(Enumerable.class, expression2.getType());
     return toRows(physType, expression2);
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java
index be89fda9d..97e689769 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableTraitsUtils.java
@@ -140,7 +140,7 @@ private static boolean isCollationOnTrivialExpr(
       }
     }
 
-    if (collationFieldsToDerive.size() > 0) {
+    if (!collationFieldsToDerive.isEmpty()) {
       final RelCollation newCollation = RelCollations.of(collationFieldsToDerive).apply(mapping);
       return Pair.of(
           currentTraits.replace(newCollation), ImmutableList.of(currentTraits.replace(collation)));
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
index ad07cc526..8adcdee8b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableUncollect.java
@@ -29,10 +29,10 @@
 import org.apache.calcite.sql.type.MapSqlType;
 import org.apache.calcite.util.BuiltInMethod;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.primitives.Ints;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 import static org.apache.calcite.sql.type.NonNullableAccessors.getComponentTypeOrThrow;
@@ -54,7 +54,7 @@ public EnumerableUncollect(RelOptCluster cluster, RelTraitSet traitSet, RelNode
    */
   public EnumerableUncollect(
       RelOptCluster cluster, RelTraitSet traitSet, RelNode child, boolean withOrdinality) {
-    super(cluster, traitSet, child, withOrdinality, Collections.emptyList());
+    super(cluster, traitSet, child, withOrdinality, ImmutableList.of());
     assert getConvention() instanceof EnumerableConvention;
     assert getConvention() == child.getConvention();
   }
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
index 0887a4b1f..3269df012 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java
@@ -89,7 +89,6 @@
 import java.math.RoundingMode;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -99,6 +98,7 @@
 import java.util.stream.Collectors;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 
 import static org.apache.calcite.adapter.enumerable.EnumUtils.generateCollatorExpression;
 import static org.apache.calcite.linq4j.tree.ExpressionType.Add;
@@ -1047,10 +1047,10 @@ private static RexCallImplementor wrapAsRexCallImplementor(final CallImplementor
   public @Nullable RexCallImplementor get(final SqlOperator operator) {
     if (operator instanceof SqlUserDefinedFunction) {
       org.apache.calcite.schema.Function udf = ((SqlUserDefinedFunction) operator).getFunction();
-      if (!(udf instanceof ImplementableFunction)) {
-        throw new IllegalStateException(
-            "User defined function " + operator + " must implement ImplementableFunction");
-      }
+      checkState(
+          (udf instanceof ImplementableFunction),
+          "User defined function %s must implement ImplementableFunction",
+          operator);
       CallImplementor implementor = ((ImplementableFunction) udf).getImplementor();
       return wrapAsRexCallImplementor(implementor);
     } else if (operator instanceof SqlTypeConstructorFunction) {
@@ -1063,10 +1063,10 @@ private static RexCallImplementor wrapAsRexCallImplementor(final CallImplementor
       final SqlAggFunction aggregation, boolean forWindowAggregate) {
     if (aggregation instanceof SqlUserDefinedAggFunction) {
       final SqlUserDefinedAggFunction udaf = (SqlUserDefinedAggFunction) aggregation;
-      if (!(udaf.function instanceof ImplementableAggFunction)) {
-        throw new IllegalStateException(
-            "User defined aggregation " + aggregation + " must implement ImplementableAggFunction");
-      }
+      checkState(
+          (udaf.function instanceof ImplementableAggFunction),
+          "User defined aggregation %s must implement ImplementableAggFunction",
+          aggregation);
       return ((ImplementableAggFunction) udaf.function).getImplementor(forWindowAggregate);
     }
     if (forWindowAggregate) {
@@ -1277,7 +1277,7 @@ static class CountWinImplementor extends StrictWinAggImplementor {
       }
       if (!hasNullable) {
         justFrameRowCount = true;
-        return Collections.emptyList();
+        return ImmutableList.of();
       }
       return super.getNotNullState(info);
     }
@@ -1761,7 +1761,7 @@ public UserDefinedAggReflectiveImplementor(AggregateFunctionImpl afi) {
 
     @Override public List<Type> getNotNullState(AggContext info) {
       if (afi.isStatic) {
-        return Collections.singletonList(afi.accumulatorType);
+        return ImmutableList.of(afi.accumulatorType);
       }
       return Arrays.asList(afi.accumulatorType, afi.declaringClass);
     }
@@ -1907,7 +1907,7 @@ protected FirstLastValueImplementor(SeekType seekType) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -1951,7 +1951,7 @@ protected LastValueImplementor() {
   /** Implementor for the {@code NTH_VALUE} windowed aggregate function. */
   static class NthValueImplementor implements WinAggImplementor {
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2015,7 +2015,7 @@ protected LeadLagImplementor(boolean isLead) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2095,7 +2095,7 @@ protected LagImplementor() {
   /** Implementor for the {@code NTILE} windowed aggregate function. */
   static class NtileImplementor implements WinAggImplementor {
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2130,7 +2130,7 @@ static class NtileImplementor implements WinAggImplementor {
   /** Implementor for the {@code ROW_NUMBER} windowed aggregate function. */
   static class RowNumberImplementor extends StrictWinAggImplementor {
     @Override public List<Type> getNotNullState(WinAggContext info) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     @Override protected void implementNotNullAdd(WinAggContext info, WinAggAddContext add) {
@@ -2157,7 +2157,7 @@ static Supplier<JsonObjectAggImplementor> supplierFor(Method m) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.singletonList(Map.class);
+      return ImmutableList.of(Map.class);
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2176,10 +2176,9 @@ static Supplier<JsonObjectAggImplementor> supplierFor(Method m) {
                   Expressions.call(
                       m,
                       Iterables.concat(
-                          Collections.singletonList(add.accumulator().get(0)),
+                          ImmutableList.of(add.accumulator().get(0)),
                           add.arguments(),
-                          Collections.singletonList(
-                              Expressions.constant(function.getNullClause()))))));
+                          ImmutableList.of(Expressions.constant(function.getNullClause()))))));
     }
 
     @Override public Expression implementResult(AggContext info, AggResultContext result) {
@@ -2200,7 +2199,7 @@ static Supplier<JsonArrayAggImplementor> supplierFor(Method m) {
     }
 
     @Override public List<Type> getStateType(AggContext info) {
-      return Collections.singletonList(List.class);
+      return ImmutableList.of(List.class);
     }
 
     @Override public void implementReset(AggContext info, AggResetContext reset) {
@@ -2220,10 +2219,9 @@ static Supplier<JsonArrayAggImplementor> supplierFor(Method m) {
                   Expressions.call(
                       m,
                       Iterables.concat(
-                          Collections.singletonList(add.accumulator().get(0)),
+                          ImmutableList.of(add.accumulator().get(0)),
                           add.arguments(),
-                          Collections.singletonList(
-                              Expressions.constant(function.getNullClause()))))));
+                          ImmutableList.of(Expressions.constant(function.getNullClause()))))));
     }
 
     @Override public Expression implementResult(AggContext info, AggResultContext result) {
@@ -2612,7 +2610,7 @@ private static class JsonValueImplementor extends MethodImplementor {
       Expression errorBehavior = Expressions.constant(SqlJsonValueEmptyOrErrorBehavior.NULL);
       Expression defaultValueOnError = Expressions.constant(null);
       // Patched up with user defines.
-      if (leftExprs.size() > 0) {
+      if (!leftExprs.isEmpty()) {
         for (int i = 0; i < leftExprs.size(); i++) {
           Expression expr = leftExprs.get(i);
           final Object exprVal = translator.getLiteralValue(expr);
@@ -2818,7 +2816,7 @@ private static class UnaryImplementor extends AbstractRexCallImplementor {
       // BigDecimal, we should call negate method of BigDecimal
       if (expressionType == ExpressionType.Negate
           && argValue.type == BigDecimal.class
-          && null != backupMethodName) {
+          && backupMethodName != null) {
         e = Expressions.call(argValue, backupMethodName);
       } else {
         e = Expressions.makeUnary(expressionType, argValue);
diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
index 84af8160f..d2204d91b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/StrictAggImplementor.java
@@ -25,9 +25,10 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 
+import com.google.common.collect.ImmutableList;
+
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -83,7 +84,7 @@ public List<Type> getNotNullState(AggContext info) {
     Type type = info.returnType();
     type = EnumUtils.fromInternal(type);
     type = Primitive.unbox(type);
-    return Collections.singletonList(type);
+    return ImmutableList.of(type);
   }
 
   @Override public final void implementReset(AggContext info, AggResetContext reset) {
diff --git a/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java b/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
index 493715381..c02e8866b 100644
--- a/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
+++ b/core/src/main/java/org/apache/calcite/adapter/java/ReflectiveSchema.java
@@ -48,8 +48,10 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
 
@@ -61,7 +63,6 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -142,7 +143,7 @@ private Map<String, Table> createTableMap() {
         table.statistic =
             Statistics.of(
                 ImmutableList.copyOf(
-                    Iterables.concat(referentialConstraints, Collections.singleton(rc))));
+                    Iterables.concat(referentialConstraints, ImmutableSet.of(rc))));
       }
     }
     return tableMap;
@@ -156,7 +157,7 @@ private Map<String, Table> createTableMap() {
   }
 
   private Multimap<String, Function> createFunctionMap() {
-    final ImmutableMultimap.Builder<String, Function> builder = ImmutableMultimap.builder();
+    final ImmutableMultimap.Builder<String, Function> builder = ImmutableListMultimap.builder();
     for (Method method : clazz.getMethods()) {
       final String methodName = method.getName();
       if (method.getDeclaringClass() == Object.class || methodName.equals("toString")) {
diff --git a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java
index f7ebf1cce..5095dd2f9 100644
--- a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java
+++ b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcCatalogSchema.java
@@ -60,8 +60,7 @@ public class JdbcCatalogSchema extends AbstractSchema {
 
   /** Sub-schemas by name, lazily initialized. */
   @SuppressWarnings("method.invocation.invalid")
-  final Supplier<SubSchemaMap> subSchemaMapSupplier =
-      Suppliers.memoize(() -> computeSubSchemaMap());
+  final Supplier<SubSchemaMap> subSchemaMapSupplier = Suppliers.memoize(this::computeSubSchemaMap);
 
   /** Creates a JdbcCatalogSchema. */
   public JdbcCatalogSchema(
diff --git a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
index 3a09adad4..97a5c4bc7 100644
--- a/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
+++ b/core/src/main/java/org/apache/calcite/adapter/jdbc/JdbcSchema.java
@@ -41,9 +41,10 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
+import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
@@ -177,7 +178,7 @@ public static JdbcSchema create(
     String jdbcSchema = (String) operand.get("jdbcSchema");
     String sqlDialectFactory = (String) operand.get("sqlDialectFactory");
 
-    if (sqlDialectFactory == null || sqlDialectFactory.isEmpty()) {
+    if (Strings.isNullOrEmpty(sqlDialectFactory)) {
       return JdbcSchema.create(parentSchema, name, dataSource, jdbcCatalog, jdbcSchema);
     } else {
       SqlDialectFactory factory =
@@ -235,7 +236,7 @@ public DataSource getDataSource() {
 
   protected Multimap<String, Function> getFunctions() {
     // TODO: populate map from JDBC metadata
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public final Collection<Function> getFunctions(String name) {
diff --git a/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java b/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
index 86b4f629c..5cb6302de 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/AggregateNode.java
@@ -44,6 +44,7 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.Comparators;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -499,7 +500,7 @@ public static class BigDecimalSum {
     public BigDecimalSum() {}
 
     public BigDecimal init() {
-      return new BigDecimal("0");
+      return BigDecimal.ZERO;
     }
 
     public BigDecimal add(BigDecimal accumulator, BigDecimal v) {
@@ -593,7 +594,7 @@ public MinDouble() {
    */
   public static class MinBigDecimal extends NumericComparison<BigDecimal> {
     public MinBigDecimal() {
-      super(new BigDecimal(Double.MAX_VALUE), MinBigDecimal::min);
+      super(BigDecimal.valueOf(Double.MAX_VALUE), MinBigDecimal::min);
     }
 
     public static BigDecimal min(BigDecimal a, BigDecimal b) {
@@ -613,7 +614,7 @@ public Boolean init() {
     }
 
     public Boolean add(Boolean accumulator, Boolean value) {
-      return accumulator.compareTo(value) < 0 ? accumulator : value;
+      return Comparators.min(value, accumulator);
     }
 
     public Boolean merge(Boolean accumulator0, Boolean accumulator1) {
@@ -671,7 +672,7 @@ public MaxDouble() {
    */
   public static class MaxBigDecimal extends NumericComparison<BigDecimal> {
     public MaxBigDecimal() {
-      super(new BigDecimal(Double.MIN_VALUE), MaxBigDecimal::max);
+      super(BigDecimal.valueOf(Double.MIN_VALUE), MaxBigDecimal::max);
     }
 
     public static BigDecimal max(BigDecimal a, BigDecimal b) {
diff --git a/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java b/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
index 81feb1e9f..d0f1a0e35 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/Interpreter.java
@@ -43,10 +43,8 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.initialization.qual.NotOnlyInitialized;
@@ -84,7 +82,7 @@ public Interpreter(DataContext dataContext, RelNode rootRel) {
     @SuppressWarnings("method.invocation.invalid")
     Pair<RelNode, Map<RelNode, NodeInfo>> pair = compiler.visitRoot(rel);
     this.rootRel = pair.left;
-    this.nodes = ImmutableMap.copyOf(pair.right);
+    this.nodes = pair.right;
   }
 
   private static RelNode optimize(RelNode rootRel) {
@@ -99,8 +97,7 @@ private static RelNode optimize(RelNode rootRel) {
             .build();
     final HepPlanner planner = new HepPlanner(hepProgram);
     planner.setRoot(rootRel);
-    rootRel = planner.findBestExp();
-    return rootRel;
+    return planner.findBestExp();
   }
 
   @Override public Enumerator<@Nullable Object[]> enumerator() {
@@ -241,7 +238,7 @@ private static class DuplicatingSink implements Sink {
     private List<ArrayDeque<Row>> queues;
 
     private DuplicatingSink(List<ArrayDeque<Row>> queues) {
-      this.queues = ImmutableList.copyOf(queues);
+      this.queues = queues;
     }
 
     @Override public void send(Row row) throws InterruptedException {
@@ -317,7 +314,7 @@ Pair<RelNode, Map<RelNode, NodeInfo>> visitRoot(RelNode p) {
         if (parent != null) {
           List<RelNode> inputs = relInputs.get(parent);
           if (inputs == null) {
-            inputs = Lists.newArrayList(parent.getInputs());
+            inputs = new ArrayList<>(parent.getInputs());
             relInputs.put(parent, inputs);
           }
           inputs.set(ordinal, p);
diff --git a/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java b/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
index c9934c6df..e8f561500 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/TableScanNode.java
@@ -42,13 +42,13 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
+import java.util.ArrayList;
 import java.util.List;
 
 import static org.apache.calcite.util.Static.RESOURCE;
@@ -173,7 +173,7 @@ private static TableScanNode createFilterable(
       @Nullable ImmutableIntList projects,
       FilterableTable filterableTable) {
     final DataContext root = compiler.getDataContext();
-    final List<RexNode> mutableFilters = Lists.newArrayList(filters);
+    final List<RexNode> mutableFilters = new ArrayList<>(filters);
     final Enumerable<@Nullable Object[]> enumerable = filterableTable.scan(root, mutableFilters);
     for (RexNode filter : mutableFilters) {
       if (!filters.contains(filter)) {
@@ -193,7 +193,7 @@ private static TableScanNode createProjectableFilterable(
     final DataContext root = compiler.getDataContext();
     final ImmutableIntList originalProjects = projects;
     for (; ; ) {
-      final List<RexNode> mutableFilters = Lists.newArrayList(filters);
+      final List<RexNode> mutableFilters = new ArrayList<>(filters);
       final int[] projectInts;
       if (projects == null || projects.equals(TableScan.identity(rel.getTable()))) {
         projectInts = null;
diff --git a/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java b/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java
index ee76e5bee..ad08f9f02 100644
--- a/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java
+++ b/core/src/main/java/org/apache/calcite/interpreter/UncollectNode.java
@@ -22,6 +22,8 @@
 import java.util.Locale;
 import java.util.Map;
 
+import static java.util.Objects.requireNonNull;
+
 /** Interpreter node that implements a {@link org.apache.calcite.rel.core.Uncollect}. */
 public class UncollectNode extends AbstractSingleNode<Uncollect> {
 
@@ -33,9 +35,7 @@ public UncollectNode(Compiler compiler, Uncollect uncollect) {
     Row row = null;
     while ((row = source.receive()) != null) {
       for (Object value : row.getValues()) {
-        if (value == null) {
-          throw new NullPointerException("NULL value for unnest.");
-        }
+        requireNonNull(value, "NULL value for unnest.");
         int i = 1;
         if (value instanceof List) {
           List list = (List) value;
diff --git a/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java b/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
index c0cf8a567..896b86358 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/CalciteMetaImpl.java
@@ -74,7 +74,6 @@
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -193,7 +192,7 @@ private <E> MetaResultSet createResultSet(
     //noinspection unchecked
     final Iterable<Object> iterable = (Iterable<Object>) (Iterable) enumerable;
     return createResultSet(
-        Collections.emptyMap(),
+        ImmutableMap.of(),
         columns,
         CursorFactory.record(clazz, fields, fieldNames),
         new Frame(0, true, iterable));
@@ -472,7 +471,7 @@ public Enumerable<MetaColumn> columns(final MetaTable table_) {
                   Optional.ofNullable(field.getType().getMeasureElementType())
                       .map(RelDataType::getSqlTypeName)
                       .map(SqlTypeName::getJdbcOrdinal)
-                      .orElse(field.getType().getSqlTypeName().getJdbcOrdinal());
+                      .orElseGet(() -> field.getType().getSqlTypeName().getJdbcOrdinal());
               return new MetaColumn(
                   table.tableCat,
                   table.tableSchem,
@@ -728,7 +727,7 @@ private static CalcitePrepare.Query<Object> toQuery(Context context, String sql)
     } else {
       // Don't populate the first frame.
       // It's not worth saving a round-trip, since we're local.
-      final Meta.Frame frame = new Meta.Frame(0, false, Collections.emptyList());
+      final Meta.Frame frame = new Meta.Frame(0, false, ImmutableList.of());
       metaResultSet = MetaResultSet.create(h.connectionId, h.id, false, signature, frame);
     }
 
diff --git a/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java b/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java
index de3f550c7..68eb6b043 100644
--- a/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java
+++ b/core/src/main/java/org/apache/calcite/jdbc/CalciteSchema.java
@@ -253,7 +253,7 @@ public List<String> path(@Nullable String name) {
         list.add(s.name);
       }
     }
-    return ImmutableList.copyOf(Lists.reverse(list));
+    return Lists.reverse(list);
   }
 
   public final @Nullable CalciteSchema getSubSchema(String schemaName, boolean caseSensitive) {
@@ -328,7 +328,7 @@ public final NavigableMap<String, CalciteSchema> getSubSchemaMap() {
     // Build a map of implicit sub-schemas first, then explicit sub-schemas.
     // If there are implicit and explicit with the same name, explicit wins.
     final ImmutableSortedMap.Builder<String, CalciteSchema> builder =
-        new ImmutableSortedMap.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedMap.orderedBy(NameSet.COMPARATOR);
     builder.putAll(subSchemaMap.map());
     addImplicitSubSchemaToBuilder(builder);
     return builder.build();
@@ -349,7 +349,7 @@ public NavigableMap<String, LatticeEntry> getLatticeMap() {
    */
   public final NavigableSet<String> getTableNames() {
     final ImmutableSortedSet.Builder<String> builder =
-        new ImmutableSortedSet.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedSet.orderedBy(NameSet.COMPARATOR);
     // Add explicit tables, case-sensitive.
     builder.addAll(tableMap.map().keySet());
     // Add implicit tables, case-sensitive.
@@ -360,7 +360,7 @@ public final NavigableSet<String> getTableNames() {
   /** Returns the set of all types names. */
   public final NavigableSet<String> getTypeNames() {
     final ImmutableSortedSet.Builder<String> builder =
-        new ImmutableSortedSet.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedSet.orderedBy(NameSet.COMPARATOR);
     // Add explicit types.
     builder.addAll(typeMap.map().keySet());
     // Add implicit types.
@@ -393,7 +393,7 @@ public final Collection<Function> getFunctions(String name, boolean caseSensitiv
   /** Returns the list of function names in this schema, both implicit and explicit, never null. */
   public final NavigableSet<String> getFunctionNames() {
     final ImmutableSortedSet.Builder<String> builder =
-        new ImmutableSortedSet.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedSet.orderedBy(NameSet.COMPARATOR);
     // Add explicit functions, case-sensitive.
     builder.addAll(functionMap.map().keySet());
     // Add implicit functions, case-sensitive.
@@ -404,7 +404,7 @@ public final NavigableSet<String> getFunctionNames() {
   /** Returns tables derived from explicit and implicit functions that take zero parameters. */
   public final NavigableMap<String, Table> getTablesBasedOnNullaryFunctions() {
     ImmutableSortedMap.Builder<String, Table> builder =
-        new ImmutableSortedMap.Builder<>(NameSet.COMPARATOR);
+        ImmutableSortedMap.orderedBy(NameSet.COMPARATOR);
     for (Map.Entry<String, FunctionEntry> entry : nullaryFunctionMap.map().entrySet()) {
       final Function function = entry.getValue().getFunction();
       if (function instanceof TableMacro) {
diff --git a/core/src/main/java/org/apache/calcite/materialize/Lattice.java b/core/src/main/java/org/apache/calcite/materialize/Lattice.java
index b9ddf00bf..9cd87bf98 100644
--- a/core/src/main/java/org/apache/calcite/materialize/Lattice.java
+++ b/core/src/main/java/org/apache/calcite/materialize/Lattice.java
@@ -86,6 +86,8 @@
 import java.util.function.IntFunction;
 import java.util.stream.Collectors;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -730,7 +732,7 @@ public static class DerivedColumn extends Column {
     private DerivedColumn(int ordinal, String alias, RexNode e, List<String> tables) {
       super(ordinal, alias);
       this.e = e;
-      this.tables = ImmutableList.copyOf(tables);
+      this.tables = tables;
     }
 
     @Override public String toString() {
@@ -974,7 +976,7 @@ public ImmutableList<Column> resolveArgs(@Nullable Object args) {
     /** Looks up a column in this lattice by alias. The alias must be unique within the lattice. */
     private Column resolveColumnByAlias(String name) {
       final ImmutableList<Column> list = columnsByAlias.get(name);
-      if (list == null || list.size() == 0) {
+      if (list == null || list.isEmpty()) {
         throw new RuntimeException("Unknown lattice column '" + name + "'");
       } else if (list.size() == 1) {
         return list.get(0);
@@ -1106,9 +1108,7 @@ private static class Fixer {
       int c;
 
       void fixUp(MutableNode node) {
-        if (!seen.add(node)) {
-          throw new IllegalArgumentException("cyclic query graph");
-        }
+        checkArgument(seen.add(node), "cyclic query graph");
         if (node.alias == null) {
           node.alias = Util.last(node.table.t.getQualifiedName());
         }
diff --git a/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java b/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java
index 26255094b..66d9c4d9f 100644
--- a/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java
+++ b/core/src/main/java/org/apache/calcite/materialize/LatticeSpace.java
@@ -73,11 +73,11 @@ String simpleName(List<String> table) {
     }
     final String name2 = Util.last(table);
     if (simpleNames.add(name2)) {
-      simpleTableNames.put(ImmutableList.copyOf(table), name2);
+      simpleTableNames.put(table, name2);
       return name2;
     }
     final String name3 = table.toString();
-    simpleTableNames.put(ImmutableList.copyOf(table), name3);
+    simpleTableNames.put(table, name3);
     return name3;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java b/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
index 16955d3b6..bec798de8 100644
--- a/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
+++ b/core/src/main/java/org/apache/calcite/materialize/LatticeSuggester.java
@@ -105,7 +105,7 @@ public LatticeSuggester(FrameworkConfig config) {
   public Set<Lattice> getLatticeSet() {
     final Set<Lattice> set = new LinkedHashSet<>(latticeMap.values());
     set.removeAll(obsoleteLatticeMap.keySet());
-    return ImmutableSet.copyOf(set);
+    return set;
   }
 
   /** Converts a column reference to an expression. */
@@ -142,7 +142,7 @@ public List<Lattice> addQuery(RelNode r) {
     frames(frameList, q, r2);
     final List<Lattice> lattices = new ArrayList<>();
     frameList.forEach(frame -> addFrame(q, frame, lattices));
-    return ImmutableList.copyOf(lattices);
+    return lattices;
   }
 
   private void addFrame(Query q, Frame frame, List<Lattice> lattices) {
@@ -604,8 +604,8 @@ abstract static class Frame {
         List<Hop> hops,
         List<MutableMeasure> measures,
         Collection<TableRef> tableRefs) {
-      this.hops = ImmutableList.copyOf(hops);
-      this.measures = ImmutableList.copyOf(measures);
+      this.hops = hops;
+      this.measures = measures;
       this.tableRefs = ImmutableSet.copyOf(tableRefs);
       this.columnCount = columnCount;
     }
diff --git a/core/src/main/java/org/apache/calcite/materialize/Path.java b/core/src/main/java/org/apache/calcite/materialize/Path.java
index 6c740411a..58608dce9 100644
--- a/core/src/main/java/org/apache/calcite/materialize/Path.java
+++ b/core/src/main/java/org/apache/calcite/materialize/Path.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.materialize;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.List;
@@ -31,7 +29,7 @@ class Path {
   private final int id;
 
   Path(List<Step> steps, int id) {
-    this.steps = ImmutableList.copyOf(steps);
+    this.steps = steps;
     this.id = id;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java b/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
index 8a0152128..2d08b71c3 100644
--- a/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
+++ b/core/src/main/java/org/apache/calcite/materialize/ProfilerLatticeStatisticProvider.java
@@ -86,8 +86,8 @@ private ProfilerLatticeStatisticProvider(Lattice lattice) {
 
   @Override public double cardinality(List<Lattice.Column> columns) {
     final ImmutableBitSet build = Lattice.Column.toBitSet(columns);
-    final double cardinality = profile.get().cardinality(build);
+    return profile.get().cardinality(build);
     //    System.out.println(columns + ": " + cardinality);
-    return cardinality;
+
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/materialize/Step.java b/core/src/main/java/org/apache/calcite/materialize/Step.java
index 64cca5892..ff8e848a9 100644
--- a/core/src/main/java/org/apache/calcite/materialize/Step.java
+++ b/core/src/main/java/org/apache/calcite/materialize/Step.java
@@ -21,7 +21,6 @@
 import org.apache.calcite.util.graph.DefaultEdge;
 import org.apache.calcite.util.mapping.IntPair;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Ordering;
 
 import org.checkerframework.checker.initialization.qual.NotOnlyInitialized;
@@ -51,7 +50,7 @@ class Step extends DefaultEdge {
 
   private Step(LatticeTable source, LatticeTable target, List<IntPair> keys, String keyString) {
     super(source, target);
-    this.keys = ImmutableList.copyOf(keys);
+    this.keys = keys;
     this.keyString = Objects.requireNonNull(keyString, "keyString");
     assert IntPair.ORDERING.isStrictlyOrdered(keys); // ordered and unique
   }
diff --git a/core/src/main/java/org/apache/calcite/model/ModelHandler.java b/core/src/main/java/org/apache/calcite/model/ModelHandler.java
index dcae5ef61..fe56df0b7 100644
--- a/core/src/main/java/org/apache/calcite/model/ModelHandler.java
+++ b/core/src/main/java/org/apache/calcite/model/ModelHandler.java
@@ -48,6 +48,7 @@
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;
+import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
@@ -57,7 +58,6 @@
 import java.io.IOException;
 import java.sql.SQLException;
 import java.util.ArrayDeque;
-import java.util.Collections;
 import java.util.Deque;
 import java.util.List;
 import java.util.Locale;
@@ -321,7 +321,7 @@ public void visit(JsonJdbcSchema jsonSchema) {
             jsonSchema.jdbcUser,
             jsonSchema.jdbcPassword);
     final JdbcSchema schema;
-    if (jsonSchema.sqlDialectFactory == null || jsonSchema.sqlDialectFactory.isEmpty()) {
+    if (Strings.isNullOrEmpty(jsonSchema.sqlDialectFactory)) {
       schema =
           JdbcSchema.create(
               parentSchema,
@@ -449,7 +449,7 @@ public void visit(JsonView jsonView) {
   }
 
   private List<String> currentSchemaPath() {
-    return Collections.singletonList(currentSchemaName());
+    return ImmutableList.of(currentSchemaName());
   }
 
   private Pair<? extends @Nullable String, SchemaPlus> nameAndSchema() {
diff --git a/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java b/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
index 777a01060..c3cb01fe2 100644
--- a/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
+++ b/core/src/main/java/org/apache/calcite/plan/AbstractRelOptPlanner.java
@@ -287,7 +287,7 @@ protected void onNewClass(RelNode node) {
 
   protected void dumpRuleAttemptsInfo() {
     if (this.ruleAttemptsListener != null) {
-      RULE_ATTEMPTS_LOGGER.debug("Rule Attempts Info for " + this.getClass().getSimpleName());
+      RULE_ATTEMPTS_LOGGER.debug("Rule Attempts Info for {}", this.getClass().getSimpleName());
       RULE_ATTEMPTS_LOGGER.debug(this.ruleAttemptsListener.dump());
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java b/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
index e73a123f8..8f0df52c0 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptAbstractTable.java
@@ -33,7 +33,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 
 /** Partial implementation of {@link RelOptTable}. */
@@ -76,7 +75,7 @@ public String getName() {
 
   // Override to define collations.
   @Override public @Nullable List<RelCollation> getCollationList() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public @Nullable RelDistribution getDistribution() {
@@ -94,12 +93,12 @@ public String getName() {
 
   // Override to get unique keys
   @Override public @Nullable List<ImmutableBitSet> getKeys() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   // Override to define foreign keys
   @Override public @Nullable List<RelReferentialConstraint> getReferentialConstraints() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public RelNode toRel(ToRelContext context) {
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java b/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java
index 0ce697701..4e8d444b7 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptMaterializations.java
@@ -224,12 +224,7 @@ private static List<RelNode> substitute(
     hepPlanner.setRoot(root);
     root = hepPlanner.findBestExp();
 
-    return new SubstitutionVisitor(
-            target,
-            root,
-            ImmutableList.<SubstitutionVisitor.UnifyRule>builder()
-                .addAll(materializationRules)
-                .build())
+    return new SubstitutionVisitor(target, root, ImmutableList.copyOf(materializationRules))
         .go(materialization.tableRel);
   }
 
@@ -237,7 +232,7 @@ private static List<RelNode> substitute(
   private static RelNode trimUnusedfields(RelNode relNode) {
     final List<RelOptTable> relOptTables = RelOptUtil.findAllTables(relNode);
     RelOptSchema relOptSchema = null;
-    if (relOptTables.size() != 0) {
+    if (!relOptTables.isEmpty()) {
       relOptSchema = relOptTables.get(0).getRelOptSchema();
     }
     final RelBuilder relBuilder =
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptRule.java b/core/src/main/java/org/apache/calcite/plan/RelOptRule.java
index 539bc689e..c085e405e 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptRule.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptRule.java
@@ -358,7 +358,7 @@ private List<RelOptRuleOperand> flattenOperands(
     rootOperand.ordinalInRule = operandList.size();
     operandList.add(rootOperand);
     flattenRecurse(operandList, rootOperand);
-    return ImmutableList.copyOf(operandList);
+    return operandList;
   }
 
   /**
@@ -426,7 +426,7 @@ public RelOptRuleOperand getOperand() {
    * @return flattened list of operands
    */
   public List<RelOptRuleOperand> getOperands() {
-    return ImmutableList.copyOf(operands);
+    return operands;
   }
 
   @Override public int hashCode() {
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java b/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
index d1ec1b15f..9893b8633 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptRuleOperand.java
@@ -109,13 +109,13 @@ <R extends RelNode> RelOptRuleOperand(
       case ANY:
         break;
       case LEAF:
-        assert children.size() == 0;
+        assert children.isEmpty();
         break;
       case UNORDERED:
         assert children.size() == 1;
         break;
       default:
-        assert children.size() > 0;
+        assert !children.isEmpty();
     }
     this.childPolicy = childPolicy;
     this.clazz = Objects.requireNonNull(clazz, "clazz");
diff --git a/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java b/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
index 0bcdbfa4f..9e74f59b9 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelOptUtil.java
@@ -106,7 +106,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.initialization.qual.NotOnlyInitialized;
@@ -135,6 +134,8 @@
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.rel.type.RelDataTypeImpl.NON_NULLABLE_SUFFIX;
 
 import static java.util.Objects.requireNonNull;
@@ -226,11 +227,11 @@ public static Set<CorrelationId> getVariablesSet(RelNode rel) {
   @SuppressWarnings("MixedMutabilityReturnType")
   public static List<CorrelationId> getVariablesSetAndUsed(RelNode rel0, RelNode rel1) {
     Set<CorrelationId> set = getVariablesSet(rel0);
-    if (set.size() == 0) {
+    if (set.isEmpty()) {
       return ImmutableList.of();
     }
     Set<CorrelationId> used = getVariablesUsed(rel1);
-    if (used.size() == 0) {
+    if (used.isEmpty()) {
       return ImmutableList.of();
     }
     final List<CorrelationId> result = new ArrayList<>();
@@ -357,7 +358,7 @@ public static void verifyTypeEquivalence(
             + "\nexpression type is "
             + actualRowType.getFullTypeString()
             + "\nset is "
-            + equivalenceClass.toString()
+            + equivalenceClass
             + "\nexpression is "
             + RelOptUtil.toString(newRel)
             + getFullTypeDifferenceString(
@@ -393,7 +394,7 @@ public static void verifyTypeEquivalence(
    */
   @Experimental
   public static RelNode propagateRelHints(RelNode originalRel, RelNode equiv) {
-    if (!(originalRel instanceof Hintable) || ((Hintable) originalRel).getHints().size() == 0) {
+    if (!(originalRel instanceof Hintable) || ((Hintable) originalRel).getHints().isEmpty()) {
       return equiv;
     }
     final RelShuttle shuttle =
@@ -451,7 +452,7 @@ public static RelNode copyRelHints(RelNode originalRel, RelNode newRel, boolean
 
     if (originalRel instanceof Hintable
         && newRel instanceof Hintable
-        && ((Hintable) originalRel).getHints().size() > 0) {
+        && !((Hintable) originalRel).getHints().isEmpty()) {
       final List<RelHint> hints = ((Hintable) originalRel).getHints();
       if (filterHints) {
         HintStrategyTable hintStrategies = originalRel.getCluster().getHintStrategies();
@@ -534,7 +535,7 @@ public static RelNode createExistsPlan(
     assert extraExpr == null || extraName != null;
     RelNode ret = seekRel;
 
-    if ((conditions != null) && (conditions.size() > 0)) {
+    if ((conditions != null) && !conditions.isEmpty()) {
       RexNode conditionExp = RexUtil.composeConjunction(cluster.getRexBuilder(), conditions, true);
 
       if (conditionExp != null) {
@@ -797,15 +798,11 @@ public static RelNode createCastRel(
       // nothing to do
       return rel;
     }
-    if (rowType.getFieldCount() != castRowType.getFieldCount()) {
-      throw new IllegalArgumentException(
-          "Field counts are not equal: "
-              + "rowType ["
-              + rowType
-              + "] castRowType ["
-              + castRowType
-              + "]");
-    }
+    checkArgument(
+        rowType.getFieldCount() == castRowType.getFieldCount(),
+        "Field counts are not equal: rowType [%s] castRowType [%s]",
+        rowType,
+        castRowType);
     final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
     List<RexNode> castExps;
     RelNode input;
@@ -921,13 +918,13 @@ public static boolean analyzeSimpleEquiJoin(LogicalJoin join, int[] joinFieldOrd
 
     final int leftFieldCount = join.getLeft().getRowType().getFieldCount();
     RexInputRef leftFieldAccess = (RexInputRef) leftComparand;
-    if (!(leftFieldAccess.getIndex() < leftFieldCount)) {
+    if (leftFieldAccess.getIndex() >= leftFieldCount) {
       // left field must access left side of join
       return false;
     }
 
     RexInputRef rightFieldAccess = (RexInputRef) rightComparand;
-    if (!(rightFieldAccess.getIndex() >= leftFieldCount)) {
+    if (rightFieldAccess.getIndex() < leftFieldCount) {
       // right field must access right side of join
       return false;
     }
@@ -1019,7 +1016,7 @@ public static boolean isEqui(RelNode left, RelNode right, RexNode condition) {
         rightKeys,
         filterNulls,
         nonEquiList);
-    return nonEquiList.size() == 0;
+    return nonEquiList.isEmpty();
   }
 
   /**
@@ -2199,8 +2196,7 @@ public static RelNode renameIfNecessary(RelNode rel, RelDataType desiredRowType)
       // The row types are different ignoring names. Nothing we can do.
       return rel;
     }
-    rel = createRename(rel, desiredRowType.getFieldNames());
-    return rel;
+    return createRename(rel, desiredRowType.getFieldNames());
   }
 
   public static String dumpType(RelDataType type) {
@@ -3587,7 +3583,7 @@ private static RexNode pushDownEqualJoinConditions(
       case AND:
         final RexCall call = (RexCall) node;
         final List<RexNode> list = new ArrayList<>();
-        List<RexNode> operands = Lists.newArrayList(call.getOperands());
+        List<RexNode> operands = new ArrayList<>(call.getOperands());
         for (int i = 0; i < operands.size(); i++) {
           RexNode operand = operands.get(i);
           if (operand instanceof RexCall) {
@@ -3793,7 +3789,7 @@ private static class RelHintPropagateShuttle extends RelHomogeneousShuttle {
      */
     private RelNode visitHintable(RelNode node) {
       final List<RelHint> topHints = ((Hintable) node).getHints();
-      final boolean hasHints = topHints != null && topHints.size() > 0;
+      final boolean hasHints = topHints != null && !topHints.isEmpty();
       final boolean hasQueryHints = hasHints && !(node instanceof TableScan);
       if (hasQueryHints) {
         inheritPaths.push(Pair.of(topHints, new ArrayDeque<>()));
@@ -3807,7 +3803,7 @@ private RelNode visitHintable(RelNode node) {
 
     private RelNode attachHints(RelNode original) {
       assert original instanceof Hintable;
-      if (inheritPaths.size() > 0) {
+      if (!inheritPaths.isEmpty()) {
         final List<RelHint> hints =
             inheritPaths.stream()
                 .sorted(Comparator.comparingInt(o -> o.right.size()))
@@ -3819,7 +3815,7 @@ private RelNode attachHints(RelNode original) {
                       return acc;
                     });
         final List<RelHint> filteredHints = hintStrategies.apply(hints, original);
-        if (filteredHints.size() > 0) {
+        if (!filteredHints.isEmpty()) {
           return ((Hintable) original).attachHints(filteredHints);
         }
       }
@@ -3922,7 +3918,7 @@ private static class SubTreeHintPropagateShuttle extends RelHomogeneousShuttle {
      */
     private RelNode visitHintable(RelNode node) {
       final List<RelHint> topHints = ((Hintable) node).getHints();
-      final boolean hasHints = topHints != null && topHints.size() > 0;
+      final boolean hasHints = topHints != null && !topHints.isEmpty();
       if (hasHints) {
         // This node is definitely not created by the planner, returns early.
         return node;
@@ -3941,14 +3937,14 @@ private RelNode attachHints(RelNode original) {
               .map(hint -> copyWithAppendPath(hint, appendPath))
               .collect(Collectors.toList());
       final List<RelHint> filteredHints = hintStrategies.apply(hints, original);
-      if (filteredHints.size() > 0) {
+      if (!filteredHints.isEmpty()) {
         return ((Hintable) original).attachHints(filteredHints);
       }
       return original;
     }
 
     private static RelHint copyWithAppendPath(RelHint hint, List<Integer> appendPaths) {
-      if (appendPaths.size() == 0) {
+      if (appendPaths.isEmpty()) {
         return hint;
       } else {
         List<Integer> newPath = new ArrayList<>(hint.inheritPath);
@@ -3984,10 +3980,10 @@ private static class ResetHintsShuttle extends RelHomogeneousShuttle {
     }
 
     private static RelNode resetHints(Hintable hintable) {
-      if (hintable.getHints().size() > 0) {
+      if (!hintable.getHints().isEmpty()) {
         final List<RelHint> resetHints =
             hintable.getHints().stream()
-                .filter(hint -> hint.inheritPath.size() == 0)
+                .filter(hint -> hint.inheritPath.isEmpty())
                 .collect(Collectors.toList());
         return hintable.withHints(resetHints);
       } else {
diff --git a/core/src/main/java/org/apache/calcite/plan/RelRule.java b/core/src/main/java/org/apache/calcite/plan/RelRule.java
index cc1f98da5..09b88d4b1 100644
--- a/core/src/main/java/org/apache/calcite/plan/RelRule.java
+++ b/core/src/main/java/org/apache/calcite/plan/RelRule.java
@@ -16,15 +16,9 @@
  */
 package org.apache.calcite.plan;
 
-import org.apache.calcite.rel.RelNode;
-import org.apache.calcite.rel.core.RelFactories;
-import org.apache.calcite.tools.RelBuilderFactory;
+import static com.google.common.base.Preconditions.checkArgument;
 
 import com.google.common.collect.ImmutableList;
-
-import org.checkerframework.checker.nullness.qual.Nullable;
-import org.immutables.value.Value;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -32,6 +26,11 @@
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.RelFactories;
+import org.apache.calcite.tools.RelBuilderFactory;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.immutables.value.Value;
 
 /**
  * Rule that is parameterized via a configuration.
@@ -237,10 +236,8 @@ static RelOptRuleOperand operand(OperandTransform transform) {
       final OperandBuilderImpl b = new OperandBuilderImpl();
       final Done done = transform.apply(b);
       Objects.requireNonNull(done, "done");
-      if (b.operands.size() != 1) {
-        throw new IllegalArgumentException("operand supplier must call one of "
+      checkArgument(b.operands.size() == 1, "operand supplier must call one of "
             + "the following methods: operand or exactly");
-      }
       return b.operands.get(0);
     }
 
diff --git a/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java b/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
index 56c788669..f7dce61d1 100644
--- a/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
+++ b/core/src/main/java/org/apache/calcite/plan/RexImplicationChecker.java
@@ -217,7 +217,7 @@ private boolean implies2(RexNode first, RexNode second) {
         firstUsageFinder.usageMap.entrySet()) {
       ImmutableSet.Builder<Pair<RexInputRef, @Nullable RexNode>> usageBuilder =
           ImmutableSet.builder();
-      if (entry.getValue().usageList.size() > 0) {
+      if (!entry.getValue().usageList.isEmpty()) {
         entry
             .getValue()
             .usageList
@@ -381,13 +381,13 @@ private static boolean isEquivalentOp(@Nullable SqlKind fKind, SqlKind sKind) {
     switch (sKind) {
       case GREATER_THAN:
       case GREATER_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.GREATER_THAN) && !(fKind == SqlKind.GREATER_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.GREATER_THAN && fKind != SqlKind.GREATER_THAN_OR_EQUAL) {
           return false;
         }
         break;
       case LESS_THAN:
       case LESS_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.LESS_THAN) && !(fKind == SqlKind.LESS_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.LESS_THAN && fKind != SqlKind.LESS_THAN_OR_EQUAL) {
           return false;
         }
         break;
@@ -402,13 +402,13 @@ private static boolean isOppositeOp(SqlKind fKind, SqlKind sKind) {
     switch (sKind) {
       case GREATER_THAN:
       case GREATER_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.LESS_THAN) && !(fKind == SqlKind.LESS_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.LESS_THAN && fKind != SqlKind.LESS_THAN_OR_EQUAL) {
           return false;
         }
         break;
       case LESS_THAN:
       case LESS_THAN_OR_EQUAL:
-        if (!(fKind == SqlKind.GREATER_THAN) && !(fKind == SqlKind.GREATER_THAN_OR_EQUAL)) {
+        if (fKind != SqlKind.GREATER_THAN && fKind != SqlKind.GREATER_THAN_OR_EQUAL) {
           return false;
         }
         break;
diff --git a/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java b/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
index 15934f701..fb60d16c6 100644
--- a/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
+++ b/core/src/main/java/org/apache/calcite/plan/SubstitutionVisitor.java
@@ -204,13 +204,13 @@ public SubstitutionVisitor(
     // Leaves are all nodes that are not parents.
     // For determinism, it is important that the list is in scan order.
     allNodes.removeAll(parents);
-    targetLeaves = ImmutableList.copyOf(allNodes);
+    targetLeaves = allNodes;
 
     allNodes.clear();
     parents.clear();
     visitor.go(query);
     allNodes.removeAll(parents);
-    queryLeaves = ImmutableList.copyOf(allNodes);
+    queryLeaves = allNodes;
   }
 
   void register(MutableRel result, MutableRel query) {}
@@ -346,9 +346,7 @@ private static RexNode canonizeNode(RexBuilder rexBuilder, RexNode condition) {
             return call;
           }
           final RexNode result = RexUtil.invert(rexBuilder, call);
-          if (result == null) {
-            throw new NullPointerException("RexUtil.invert returned null for " + call);
-          }
+          requireNonNull(result, "RexUtil.invert returned null for " + call);
           return result;
         }
       case SEARCH:
@@ -591,7 +589,7 @@ private List<List<Replacement>> go(MutableRel replacement) {
                         : rule + "should have returned a result containing the target.";
                     attempted.add(r);
                   }
-                  substitutions.add(ImmutableList.copyOf(attempted));
+                  substitutions.add(attempted);
                   attempted.clear();
                   queryDescendant = next;
                   continue outer;
@@ -773,10 +771,8 @@ private static void reverseSubstitute(
                     + rule
                     + "\nQuery:\n"
                     + queryParent.deep()
-                    + (x.call.query != queryParent
-                        ? "\nQuery (original):\n"
-  + queryParent.toString()
-                        : "")
+                    + (x.call.query != queryParent ? "\nQuery (original):\n"
+  + queryParent : "")
                     + "\nTarget:\n"
                     + target.deep()
                     + "\nResult:\n"
@@ -791,7 +787,7 @@ private static void reverseSubstitute(
       System.out.println(
           "Unify failed:" + "\nQuery:\n"
   + queryParent + "\nTarget:\n"
-  + target.toString() + "\n");
+  + target + "\n");
     }
     return null;
   }
@@ -1462,8 +1458,8 @@ private AggregateOnCalcToAggregateUnifyRule() {
           pairs.add(mapping.getTarget(groupings.get(i)), i);
         }
         pairs.sort(
-            Comparator.<Map.Entry<Integer, Integer>>comparingInt(Map.Entry::getKey)
-                .thenComparingInt(Map.Entry::getValue));
+            Comparator.<Map.Entry<Integer, Integer>, Integer>comparing(Map.Entry::getKey)
+                .thenComparing(Map.Entry::getValue));
         final List<Integer> posList = new ArrayList<>(pairs.rightList());
         for (int i = posList.size(); i < fieldCount; i++) {
           posList.add(i);
@@ -1700,9 +1696,7 @@ public static Pair<RexNode, List<RexNode>> explainCalc(MutableCalc calc) {
     final RexShuttle shuttle = getExpandShuttle(calc.program);
     final RexNode condition = shuttle.apply(calc.program.getCondition());
     final List<RexNode> projects = new ArrayList<>();
-    for (RexNode rex : shuttle.apply(calc.program.getProjectList())) {
-      projects.add(rex);
-    }
+    projects.addAll(shuttle.apply(calc.program.getProjectList()));
     if (condition == null) {
       return Pair.of(calc.cluster.getRexBuilder().makeLiteral(true), projects);
     } else {
@@ -1965,7 +1959,7 @@ public static MutableAggregate permute(
       newArgList.add(newArgIndex);
     }
     final boolean isAllowBuild;
-    if (newArgList.size() == 0) {
+    if (newArgList.isEmpty()) {
       // Size of agg-call's args is empty, we stop to build a new agg-call,
       // eg: count(1) or count(*).
       isAllowBuild = false;
diff --git a/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java
index 927ee3507..1ca11a30e 100644
--- a/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/plan/hep/HepRelMetadataProvider.java
@@ -24,7 +24,7 @@
 import org.apache.calcite.rel.metadata.UnboundMetadata;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -68,7 +68,7 @@ class HepRelMetadataProvider implements RelMetadataProvider {
 
   @Deprecated // to be removed before 2.0
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public List<MetadataHandler<?>> handlers(Class<? extends MetadataHandler<?>> handlerClass) {
diff --git a/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java b/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java
index e22521601..5e690468e 100644
--- a/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java
+++ b/core/src/main/java/org/apache/calcite/plan/visualizer/NodeUpdateHelper.java
@@ -60,7 +60,7 @@ void updateAttribute(final String attr, final Object newValue) {
       update = new NodeUpdateInfo();
     }
 
-    if (newValue instanceof List && ((List<?>) newValue).size() == 0 && !update.containsKey(attr)) {
+    if (newValue instanceof List && ((List<?>) newValue).isEmpty() && !update.containsKey(attr)) {
       return;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java b/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java
index 632807ce4..f0574fec5 100644
--- a/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java
+++ b/core/src/main/java/org/apache/calcite/plan/visualizer/StepInfo.java
@@ -16,9 +16,6 @@
  */
 package org.apache.calcite.plan.visualizer;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-
 import java.util.List;
 import java.util.Map;
 
@@ -30,8 +27,8 @@ class StepInfo {
 
   StepInfo(final String id, final Map<String, Object> updates, final List<String> matchedRels) {
     this.id = id;
-    this.updates = ImmutableMap.copyOf(updates);
-    this.matchedRels = ImmutableList.copyOf(matchedRels);
+    this.updates = updates;
+    this.matchedRels = matchedRels;
   }
 
   public String getId() {
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java b/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java
index 42006dd6c..174f77a8a 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/Dumpers.java
@@ -195,7 +195,7 @@ static void dumpGraphviz(VolcanoPlanner planner, PrintWriter pw) {
           pw.append("no subset found for rel");
           continue;
         }
-        String traits = "." + relSubset.getTraitSet().toString();
+        String traits = "." + relSubset.getTraitSet();
         String title = rel.toString().replace(traits, "");
         if (title.endsWith(")")) {
           int openParen = title.indexOf('(');
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java b/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
index fe567e764..73312581e 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/RelSet.java
@@ -391,7 +391,7 @@ void mergeWith(VolcanoPlanner planner, RelSet otherSet) {
     // fact that the child has been renamed.
     //
     // Copy array to prevent ConcurrentModificationException.
-    final List<RelNode> previousParents = ImmutableList.copyOf(otherSet.getParentRels());
+    final List<RelNode> previousParents = otherSet.getParentRels();
     for (RelNode parentRel : previousParents) {
       planner.rename(parentRel);
     }
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java b/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
index 4dea98e70..afcb865de 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/RelSubset.java
@@ -623,7 +623,7 @@ public RelNode visit(RelNode p, int ordinal, @Nullable RelNode parent) {
             // Sort problems from most often to less often ones
             String problems =
                 problemCounts.entrySet().stream()
-                    .sorted(Comparator.comparingLong(Map.Entry<String, Long>::getValue).reversed())
+                    .sorted(Comparator.comparing(Map.Entry<String, Long>::getValue).reversed())
                     .map(
                         e -> e.getKey() + (e.getValue() > 1 ? " (" + e.getValue() + " cases)" : ""))
                     .collect(Collectors.joining(", "));
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
index 94cfaa2bd..ab4a2e8b9 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
@@ -84,6 +84,9 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -258,7 +261,7 @@ public void setTopDownOpt(boolean value) {
   }
 
   @Override public List<RelOptMaterialization> getMaterializations() {
-    return ImmutableList.copyOf(materializations);
+    return materializations;
   }
 
   @Override public void addMaterialization(RelOptMaterialization materialization) {
@@ -547,11 +550,10 @@ void ensureRootConverters() {
     } else {
       final RelDataType relType = rel.getRowType();
       final RelDataType equivRelType = equivRel.getRowType();
-      if (!RelOptUtil.areRowTypesEqual(relType, equivRelType, false)) {
-        throw new IllegalArgumentException(
-            RelOptUtil.getFullTypeDifferenceString(
-                "rel rowtype", relType, "equiv rowtype", equivRelType));
-      }
+      checkArgument(
+          RelOptUtil.areRowTypesEqual(relType, equivRelType, false),
+          RelOptUtil.getFullTypeDifferenceString(
+              "rel rowtype", relType, "equiv rowtype", equivRelType));
       equivRel = ensureRegistered(equivRel, null);
       set = getSet(equivRel);
     }
@@ -1116,9 +1118,7 @@ private RelSet merge(RelSet set1, RelSet set2) {
     // Merge.
     set1.mergeWith(this, set2);
 
-    if (root == null) {
-      throw new IllegalStateException("root must not be null");
-    }
+    checkState(root != null, "root must not be null");
 
     // Was the set we merged with the root? If so, the result is the new
     // root.
@@ -1159,8 +1159,7 @@ static RelSet equivRoot(RelSet s) {
   /** Moves forward two links, checking for a cycle at each. */
   private static @Nullable RelSet forward2(RelSet s, @Nullable RelSet p) {
     p = forward1(s, p);
-    p = forward1(s, p);
-    return p;
+    return forward1(s, p);
   }
 
   /** Moves forward one link, checking for a cycle. */
@@ -1244,11 +1243,10 @@ private RelSubset registerImpl(RelNode rel, @Nullable RelSet set) {
       // The same rel is already registered, so return its subset
       return getSubsetNonNull(equivExp);
     } else {
-      if (!RelOptUtil.areRowTypesEqual(equivExp.getRowType(), rel.getRowType(), false)) {
-        throw new IllegalArgumentException(
-            RelOptUtil.getFullTypeDifferenceString(
-                "equiv rowtype", equivExp.getRowType(), "rel rowtype", rel.getRowType()));
-      }
+      checkArgument(
+          RelOptUtil.areRowTypesEqual(equivExp.getRowType(), rel.getRowType(), false),
+          RelOptUtil.getFullTypeDifferenceString(
+              "equiv rowtype", equivExp.getRowType(), "rel rowtype", rel.getRowType()));
       checkPruned(equivExp, rel);
 
       RelSet equivSet = getSet(equivExp);
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java
index 98efda013..e6fb49d91 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRelMetadataProvider.java
@@ -24,7 +24,7 @@
 import org.apache.calcite.rel.metadata.UnboundMetadata;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -121,7 +121,7 @@ public class VolcanoRelMetadataProvider implements RelMetadataProvider {
 
   @Deprecated
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public List<MetadataHandler<?>> handlers(Class<? extends MetadataHandler<?>> handlerClass) {
diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
index 9bd6ee3ab..a50795cf7 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoRuleCall.java
@@ -28,7 +28,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -355,13 +354,13 @@ private void matchRecurse(int solve) {
             // RelSubsets? Random relations from those subsets?
             // For now, Calcite code does not use getChildRels, so the bug is just waiting its day
             if (ascending) {
-              final List<RelNode> inputs = Lists.newArrayList(rel.getInputs());
+              final List<RelNode> inputs = new ArrayList<>(rel.getInputs());
               inputs.set(previousOperand.ordinalInParent, previous);
               setChildRels(rel, inputs);
             } else {
               List<RelNode> inputs = getChildRels(previous);
               if (inputs == null) {
-                inputs = Lists.newArrayList(previous.getInputs());
+                inputs = new ArrayList<>(previous.getInputs());
               }
               inputs.set(operand.ordinalInParent, rel);
               setChildRels(previous, inputs);
diff --git a/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java b/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
index b772fce01..da101f8e2 100644
--- a/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
+++ b/core/src/main/java/org/apache/calcite/prepare/CalciteCatalogReader.java
@@ -194,7 +194,7 @@ private Collection<org.apache.calcite.schema.Function> getFunctionsFrom(List<Str
     if (schema == null) {
       return ImmutableList.of();
     }
-    final ImmutableList.Builder<SqlMoniker> result = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<SqlMoniker> result = ImmutableList.builder();
 
     // Add root schema if not anonymous
     if (!schema.name.equals("")) {
diff --git a/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java b/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
index 44511ff12..2cf716e4c 100644
--- a/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
+++ b/core/src/main/java/org/apache/calcite/prepare/CalcitePrepareImpl.java
@@ -454,7 +454,7 @@ protected RelOptCluster createCluster(RelOptPlanner planner, RexBuilder rexBuild
    * #createPlanner(org.apache.calcite.jdbc.CalcitePrepare.Context)}.
    */
   protected List<Function1<Context, RelOptPlanner>> createPlannerFactories() {
-    return Collections.singletonList(context -> createPlanner(context, null, null));
+    return ImmutableList.of(context -> createPlanner(context, null, null));
   }
 
   /** Creates a query planner and initializes it with a default set of rules. */
@@ -1288,7 +1288,7 @@ private static List<Expression> simpleList(BlockStatement statement) {
         NewExpression newExpression = (NewExpression) simple;
         return newExpression.arguments;
       } else {
-        return Collections.singletonList(simple);
+        return ImmutableList.of(simple);
       }
     }
 
diff --git a/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java b/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
index b33700242..c3042a190 100644
--- a/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
+++ b/core/src/main/java/org/apache/calcite/prepare/LixToRelTranslator.java
@@ -43,7 +43,6 @@
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;
@@ -153,7 +152,7 @@ private static Type getElementType(MethodCallExpression call) {
 
   private List<RexNode> toRex(RelNode child, FunctionExpression expression) {
     RexBuilder rexBuilder = cluster.getRexBuilder();
-    List<RexNode> list = Collections.singletonList(rexBuilder.makeRangeReference(child));
+    List<RexNode> list = ImmutableList.of(rexBuilder.makeRangeReference(child));
     CalcitePrepareImpl.ScalarTranslator translator =
         CalcitePrepareImpl.EmptyScalarTranslator.empty(rexBuilder)
             .bind(getParameterList(expression), list);
diff --git a/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java b/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
index c99f9d0ec..9d978528b 100644
--- a/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
+++ b/core/src/main/java/org/apache/calcite/prepare/PlannerImpl.java
@@ -66,6 +66,8 @@
 import java.io.Reader;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Implementation of {@link org.apache.calcite.tools.Planner}. */
@@ -150,9 +152,8 @@ private void ensure(State state) {
     if (state == this.state) {
       return;
     }
-    if (state.ordinal() < this.state.ordinal()) {
-      throw new IllegalArgumentException("cannot move to " + state + " from " + this.state);
-    }
+    checkArgument(
+        state.ordinal() >= this.state.ordinal(), "cannot move to %s from %s", state, this.state);
     state.from(this);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/prepare/Prepare.java b/core/src/main/java/org/apache/calcite/prepare/Prepare.java
index 1f9180bb4..3e807d503 100644
--- a/core/src/main/java/org/apache/calcite/prepare/Prepare.java
+++ b/core/src/main/java/org/apache/calcite/prepare/Prepare.java
@@ -499,7 +499,7 @@ protected PreparedExplain(
     }
 
     @Override public List<@Nullable List<String>> getFieldOrigins() {
-      return Collections.singletonList(Collections.nCopies(4, null));
+      return ImmutableList.of(Collections.nCopies(4, null));
     }
   }
 
@@ -559,7 +559,7 @@ protected PreparedResultImpl(
       this.rowType = requireNonNull(rowType, "rowType");
       this.parameterRowType = requireNonNull(parameterRowType, "parameterRowType");
       this.fieldOrigins = requireNonNull(fieldOrigins, "fieldOrigins");
-      this.collations = ImmutableList.copyOf(collations);
+      this.collations = collations;
       this.rootRel = requireNonNull(rootRel, "rootRel");
       this.tableModOp = tableModOp;
       this.isDml = isDml;
diff --git a/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java b/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
index ab4629980..b470c5660 100644
--- a/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
+++ b/core/src/main/java/org/apache/calcite/profile/ProfilerImpl.java
@@ -28,7 +28,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
@@ -57,6 +56,8 @@
 import java.util.TreeSet;
 import java.util.function.Predicate;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.profile.ProfilerImpl.CompositeCollector.OF;
 
@@ -163,11 +164,9 @@ class Run {
      *     they may be interesting
      */
     Run(final List<Column> columns, Collection<ImmutableBitSet> initialGroups) {
-      this.columns = ImmutableList.copyOf(columns);
+      this.columns = columns;
       for (Ord<Column> column : Ord.zip(columns)) {
-        if (column.e.ordinal != column.i) {
-          throw new IllegalArgumentException();
-        }
+        checkArgument(column.e.ordinal == column.i);
       }
       this.singletonSpaces = new ArrayList<>(Collections.nCopies(columns.size(), (Space) null));
       if (combinationsPerPass > Math.pow(2D, columns.size())) {
@@ -462,7 +461,7 @@ private double expectedCardinality(double rowCount, ImmutableBitSet columns) {
 
     private ImmutableSortedSet<Column> toColumns(Iterable<Integer> ordinals) {
       //noinspection Convert2MethodRef
-      return ImmutableSortedSet.copyOf(Util.transform(ordinals, idx -> columns.get(idx)));
+      return ImmutableSortedSet.copyOf(Util.transform(ordinals, columns::get));
     }
   }
 
@@ -774,7 +773,7 @@ static class SurpriseQueue {
     }
 
     @Override public String toString() {
-      return "min: " + priorityQueue.peek() + ", contents: " + deque.toString();
+      return "min: " + priorityQueue.peek() + ", contents: " + deque;
     }
 
     boolean isValid() {
diff --git a/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java b/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java
index 7452374b1..e7a346287 100644
--- a/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java
+++ b/core/src/main/java/org/apache/calcite/profile/SimpleProfiler.java
@@ -44,6 +44,8 @@
 import java.util.SortedSet;
 import java.util.TreeSet;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Basic implementation of {@link Profiler}. */
@@ -106,9 +108,7 @@ static class Run {
 
     Run(final List<Column> columns) {
       for (Ord<Column> column : Ord.zip(columns)) {
-        if (column.e.ordinal != column.i) {
-          throw new IllegalArgumentException();
-        }
+        checkArgument(column.e.ordinal == column.i);
       }
       this.columns = columns;
       this.singletonSpaces = new ArrayList<>(Collections.nCopies(columns.size(), null));
@@ -292,7 +292,7 @@ private boolean hasNull(ImmutableBitSet columnOrdinals) {
     private ImmutableSortedSet<Column> toColumns(
         @UnknownInitialization Run this, Iterable<Integer> ordinals) {
       //noinspection Convert2MethodRef
-      return ImmutableSortedSet.copyOf(Util.transform(ordinals, idx -> columns.get(idx)));
+      return ImmutableSortedSet.copyOf(Util.transform(ordinals, columns::get));
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java b/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
index 1f01198ff..0ed42416c 100644
--- a/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
+++ b/core/src/main/java/org/apache/calcite/rel/AbstractRelNode.java
@@ -39,6 +39,7 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
 import org.apiguardian.api.API;
@@ -48,7 +49,6 @@
 import org.checkerframework.dataflow.qual.Pure;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -182,7 +182,7 @@ protected RelDataType deriveRowType() {
   }
 
   @Override public List<RelNode> getInputs() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public double estimateRowCount(RelMetadataQuery mq) {
diff --git a/core/src/main/java/org/apache/calcite/rel/RelCollations.java b/core/src/main/java/org/apache/calcite/rel/RelCollations.java
index 1278c32e4..70e845a40 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelCollations.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelCollations.java
@@ -208,7 +208,7 @@ public static boolean containsOrderless(List<Integer> keys, RelCollation collati
     if (colKeys.size() > distinctKeys.size()) {
       return false;
     } else {
-      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));
+      return colKeys.stream().allMatch(distinctKeys::contains);
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java b/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java
index a4485d2dd..f97a3698a 100644
--- a/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/RelReferentialConstraintImpl.java
@@ -18,8 +18,6 @@
 
 import org.apache.calcite.util.mapping.IntPair;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.List;
 
 /** RelOptReferentialConstraint base implementation. */
@@ -33,9 +31,9 @@ private RelReferentialConstraintImpl(
       List<String> sourceQualifiedName,
       List<String> targetQualifiedName,
       List<IntPair> columnPairs) {
-    this.sourceQualifiedName = ImmutableList.copyOf(sourceQualifiedName);
-    this.targetQualifiedName = ImmutableList.copyOf(targetQualifiedName);
-    this.columnPairs = ImmutableList.copyOf(columnPairs);
+    this.sourceQualifiedName = sourceQualifiedName;
+    this.targetQualifiedName = targetQualifiedName;
+    this.columnPairs = columnPairs;
   }
 
   @Override public List<String> getSourceQualifiedName() {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java b/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
index 214306640..419c17bb7 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Aggregate.java
@@ -151,7 +151,7 @@ protected Aggregate(
       List<AggregateCall> aggCalls) {
     super(cluster, traitSet, input);
     this.hints = ImmutableList.copyOf(hints);
-    this.aggCalls = ImmutableList.copyOf(aggCalls);
+    this.aggCalls = aggCalls;
     this.groupSet = requireNonNull(groupSet, "groupSet");
     if (groupSets == null) {
       this.groupSets = ImmutableList.of(groupSet);
@@ -485,9 +485,8 @@ public enum Group {
     OTHER;
 
     public static Group induce(ImmutableBitSet groupSet, List<ImmutableBitSet> groupSets) {
-      if (!ImmutableBitSet.ORDERING.isStrictlyOrdered(groupSets)) {
-        throw new IllegalArgumentException("must be sorted: " + groupSets);
-      }
+      checkArgument(
+          ImmutableBitSet.ORDERING.isStrictlyOrdered(groupSets), "must be sorted: %s", groupSets);
       if (groupSets.size() == 1 && groupSets.get(0).equals(groupSet)) {
         return SIMPLE;
       }
@@ -559,7 +558,7 @@ public static List<Integer> getRollup(List<ImmutableBitSet> groupSets) {
         g = bitSet;
       }
       Collections.reverse(rollUpBits);
-      return ImmutableList.copyOf(rollUpBits);
+      return rollUpBits;
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java b/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
index ff7fad064..7b9caee36 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/AggregateCall.java
@@ -125,7 +125,7 @@ private AggregateCall(
     this.name = name;
     this.aggFunction = requireNonNull(aggFunction, "aggFunction");
     this.argList = ImmutableList.copyOf(argList);
-    this.rexList = ImmutableList.copyOf(rexList);
+    this.rexList = rexList;
     this.distinctKeys = distinctKeys;
     this.filterArg = filterArg;
     this.collation = requireNonNull(collation, "collation");
@@ -652,7 +652,7 @@ public AggregateCall rename(@Nullable String name) {
       buf.append("APPROXIMATE ");
     }
     if (distinct) {
-      buf.append((argList.size() == 0) ? "DISTINCT" : "DISTINCT ");
+      buf.append(argList.isEmpty() ? "DISTINCT" : "DISTINCT ");
     }
     int i = -1;
     for (RexNode rexNode : rexList) {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Intersect.java b/core/src/main/java/org/apache/calcite/rel/core/Intersect.java
index 9b5ed4d4c..3a47ac2a6 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Intersect.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Intersect.java
@@ -24,7 +24,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.sql.SqlKind;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -47,7 +48,7 @@ public Intersect(
   /** Creates an Intersect. */
   protected Intersect(
       RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, boolean all) {
-    this(cluster, traits, Collections.emptyList(), inputs, all);
+    this(cluster, traits, ImmutableList.of(), inputs, all);
   }
 
   /** Creates an Intersect by parsing serialized output. */
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Join.java b/core/src/main/java/org/apache/calcite/rel/core/Join.java
index 2c4d13682..f14d5544e 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Join.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Join.java
@@ -45,7 +45,6 @@
 import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
@@ -286,7 +285,7 @@ public boolean isSemiJoin() {
    * @return list of system fields
    */
   public List<RelDataTypeField> getSystemFieldList() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Match.java b/core/src/main/java/org/apache/calcite/rel/core/Match.java
index fda9c9cee..223ddffe1 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Match.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Match.java
@@ -257,7 +257,7 @@ private static class AggregateFinder extends RexVisitorImpl<Void> {
                 aggFunction, call.getType(), call.getOperands(), aggregateCalls.size());
         aggregateCalls.add(aggCall);
         Set<String> pv = new PatternVarFinder().go(call.getOperands());
-        if (pv.size() == 0) {
+        if (pv.isEmpty()) {
           pv.add(STAR);
         }
         for (String alpha : pv) {
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Minus.java b/core/src/main/java/org/apache/calcite/rel/core/Minus.java
index e0d51f2f5..72d8fe800 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Minus.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Minus.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.sql.SqlKind;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -49,7 +50,7 @@ public Minus(
   }
 
   protected Minus(RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, boolean all) {
-    this(cluster, traits, Collections.emptyList(), inputs, all);
+    this(cluster, traits, ImmutableList.of(), inputs, all);
   }
 
   /** Creates a Minus by parsing serialized output. */
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Project.java b/core/src/main/java/org/apache/calcite/rel/core/Project.java
index d535bbae1..8a223819b 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Project.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Project.java
@@ -55,10 +55,10 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
 import java.util.Set;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.Objects.requireNonNullElse;
 
 /**
  * Relational expression that computes a set of 'select expressions' from its input relational
@@ -151,8 +151,7 @@ protected Project(RelInput input) {
         input.getRowType("exprs", "fields"),
         ImmutableSet.copyOf(
             Util.transform(
-                Optional.ofNullable(input.getIntegerList("variablesSet"))
-                    .orElse(ImmutableList.of()),
+                requireNonNullElse(input.getIntegerList("variablesSet"), ImmutableList.of()),
                 id -> new CorrelationId(id))));
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java b/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
index 271f77338..da1a43380 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/RepeatUnion.java
@@ -33,6 +33,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Relational expression that computes a repeat union (recursive union in SQL terminology).
  *
@@ -114,12 +116,10 @@ public RelNode getIterativeRel() {
   @Override protected RelDataType deriveRowType() {
     final List<RelDataType> inputRowTypes = Util.transform(getInputs(), RelNode::getRowType);
     final RelDataType rowType = getCluster().getTypeFactory().leastRestrictive(inputRowTypes);
-    if (rowType == null) {
-      throw new IllegalArgumentException(
-          "Cannot compute compatible row type "
-              + "for arguments: "
-              + Util.sepList(inputRowTypes, ", "));
-    }
+    checkArgument(
+        rowType != null,
+        "Cannot compute compatible row type for arguments: %s",
+        Util.sepList(inputRowTypes, ", "));
     return rowType;
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/rel/core/SetOp.java b/core/src/main/java/org/apache/calcite/rel/core/SetOp.java
index 53a8874c9..cd78891e1 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/SetOp.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/SetOp.java
@@ -34,9 +34,10 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * <code>SetOp</code> is an abstract base for relational set operators such as UNION, MINUS (aka
  * EXCEPT), and INTERSECT.
@@ -71,7 +72,7 @@ protected SetOp(
   /** Creates a SetOp. */
   protected SetOp(
       RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, SqlKind kind, boolean all) {
-    this(cluster, traits, Collections.emptyList(), inputs, kind, all);
+    this(cluster, traits, ImmutableList.of(), inputs, kind, all);
   }
 
   /** Creates a SetOp by parsing serialized output. */
@@ -79,7 +80,7 @@ protected SetOp(RelInput input) {
     this(
         input.getCluster(),
         input.getTraitSet(),
-        Collections.emptyList(),
+        ImmutableList.of(),
         input.getInputs(),
         SqlKind.UNION,
         input.getBoolean("all", false));
@@ -115,12 +116,10 @@ protected SetOp(RelInput input) {
   @Override protected RelDataType deriveRowType() {
     final List<RelDataType> inputRowTypes = Util.transform(inputs, RelNode::getRowType);
     final RelDataType rowType = getCluster().getTypeFactory().leastRestrictive(inputRowTypes);
-    if (rowType == null) {
-      throw new IllegalArgumentException(
-          "Cannot compute compatible row type "
-              + "for arguments to set op: "
-              + Util.sepList(inputRowTypes, ", "));
-    }
+    checkArgument(
+        rowType != null,
+        "Cannot compute compatible row type for arguments to set op: %s",
+        Util.sepList(inputRowTypes, ", "));
     return rowType;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Sort.java b/core/src/main/java/org/apache/calcite/rel/core/Sort.java
index a92540fe2..3e2c01249 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Sort.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Sort.java
@@ -40,7 +40,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 
@@ -97,7 +96,7 @@ protected Sort(
    * @param collation array of sort specifications
    */
   protected Sort(RelOptCluster cluster, RelTraitSet traits, RelNode child, RelCollation collation) {
-    this(cluster, traits, Collections.emptyList(), child, collation, null, null);
+    this(cluster, traits, ImmutableList.of(), child, collation, null, null);
   }
 
   /**
@@ -117,7 +116,7 @@ protected Sort(
       RelCollation collation,
       @Nullable RexNode offset,
       @Nullable RexNode fetch) {
-    this(cluster, traits, Collections.emptyList(), child, collation, offset, fetch);
+    this(cluster, traits, ImmutableList.of(), child, collation, offset, fetch);
   }
 
   /** Creates a Sort by parsing serialized output. */
@@ -222,7 +221,7 @@ public abstract Sort copy(
   }
 
   @Override public boolean isEnforcer() {
-    return offset == null && fetch == null && collation.getFieldCollations().size() > 0;
+    return offset == null && fetch == null && !collation.getFieldCollations().isEmpty();
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java b/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
index dc28ea56d..cdafa46ef 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/TableFunctionScan.java
@@ -38,7 +38,6 @@
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -132,7 +131,7 @@ protected TableFunctionScan(RelInput input) {
     this(
         input.getCluster(),
         input.getTraitSet(),
-        Collections.emptyList(),
+        ImmutableList.of(),
         input.getInputs(),
         requireNonNull(input.getExpression("invocation"), "invocation"),
         (Type) input.get("elementType"),
@@ -190,7 +189,7 @@ public abstract TableFunctionScan copy(
     // for a no-input UDX, behave like an AbstractRelNode; for a one-input
     // UDX, behave like a SingleRel; for a multi-input UDX, behave like
     // UNION ALL.  TODO jvs 10-Sep-2007: UDX-supplied costing metadata.
-    if (inputs.size() == 0) {
+    if (inputs.isEmpty()) {
       return super.estimateRowCount(mq);
     }
     double nRows = 0.0;
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java b/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
index b27284ea0..1a21e6d65 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Uncollect.java
@@ -32,7 +32,6 @@
 
 import com.google.common.collect.ImmutableList;
 
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -60,7 +59,7 @@ public class Uncollect extends SingleRel {
 
   @Deprecated // to be removed before 2.0
   public Uncollect(RelOptCluster cluster, RelTraitSet traitSet, RelNode child) {
-    this(cluster, traitSet, child, false, Collections.emptyList());
+    this(cluster, traitSet, child, false, ImmutableList.of());
   }
 
   /**
@@ -77,7 +76,7 @@ public Uncollect(
       List<String> itemAliases) {
     super(cluster, traitSet, input);
     this.withOrdinality = withOrdinality;
-    this.itemAliases = ImmutableList.copyOf(itemAliases);
+    this.itemAliases = itemAliases;
     assert deriveRowType() != null : "invalid child rowtype";
   }
 
@@ -88,7 +87,7 @@ public Uncollect(RelInput input) {
         input.getTraitSet(),
         input.getInput(),
         input.getBoolean("withOrdinality", false),
-        Collections.emptyList());
+        ImmutableList.of());
   }
 
   /**
@@ -164,7 +163,7 @@ public static RelDataType deriveUncollectRowType(
         builder.add(SqlUnnestOperator.MAP_VALUE_COLUMN_NAME, mapType.getValueType());
       } else {
         RelDataType ret = field.getType().getComponentType();
-        assert null != ret;
+        assert ret != null;
 
         if (requireAlias) {
           builder.add(itemAliases.get(i), ret);
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Union.java b/core/src/main/java/org/apache/calcite/rel/core/Union.java
index bae3b5306..146e6544b 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Union.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Union.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.metadata.RelMetadataQuery;
 import org.apache.calcite.sql.SqlKind;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -47,7 +48,7 @@ protected Union(
   }
 
   protected Union(RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, boolean all) {
-    super(cluster, traits, Collections.emptyList(), inputs, SqlKind.UNION, all);
+    super(cluster, traits, ImmutableList.of(), inputs, SqlKind.UNION, all);
   }
 
   /** Creates a Union by parsing serialized output. */
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Values.java b/core/src/main/java/org/apache/calcite/rel/core/Values.java
index 9ca0c9659..208542f49 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Values.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Values.java
@@ -39,7 +39,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -109,7 +108,7 @@ protected Values(
       RelDataType rowType,
       ImmutableList<ImmutableList<RexLiteral>> tuples,
       RelTraitSet traits) {
-    this(cluster, Collections.emptyList(), rowType, tuples, traits);
+    this(cluster, ImmutableList.of(), rowType, tuples, traits);
   }
 
   /** Creates a Values by parsing serialized output. */
diff --git a/core/src/main/java/org/apache/calcite/rel/core/Window.java b/core/src/main/java/org/apache/calcite/rel/core/Window.java
index b05d87b8f..0450581f0 100644
--- a/core/src/main/java/org/apache/calcite/rel/core/Window.java
+++ b/core/src/main/java/org/apache/calcite/rel/core/Window.java
@@ -52,7 +52,6 @@
 import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 import java.util.AbstractList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 
@@ -117,7 +116,7 @@ public Window(
       List<RexLiteral> constants,
       RelDataType rowType,
       List<Group> groups) {
-    this(cluster, traitSet, Collections.emptyList(), input, constants, rowType, groups);
+    this(cluster, traitSet, ImmutableList.of(), input, constants, rowType, groups);
   }
 
   @Override public boolean isValid(Litmus litmus, @Nullable Context context) {
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
index 75adc54ac..fadefb7c9 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelJson.java
@@ -651,10 +651,10 @@ public Object toJson(RexNode node) {
 
   private Object toJson(RexWindow window) {
     final Map<String, @Nullable Object> map = jsonBuilder().map();
-    if (window.partitionKeys.size() > 0) {
+    if (!window.partitionKeys.isEmpty()) {
       map.put("partition", toJson(window.partitionKeys));
     }
-    if (window.orderKeys.size() > 0) {
+    if (!window.orderKeys.isEmpty()) {
       map.put("order", toJson(window.orderKeys));
     }
     if (window.getLowerBound() == null) {
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
index 9a701f4a4..0c936eb6c 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonReader.java
@@ -165,7 +165,7 @@ private void readRel(final Map<String, Object> jsonRel) {
             if (jsonInputs == null) {
               return ImmutableList.of(requireNonNull(lastRel, "lastRel"));
             }
-            final ImmutableList.Builder<RelNode> inputs = new ImmutableList.Builder<>();
+            final ImmutableList.Builder<RelNode> inputs = ImmutableList.builder();
             for (String jsonInput : jsonInputs) {
               inputs.add(lookupInput(jsonInput));
             }
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java
index db31051ca..668a6e58d 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelJsonWriter.java
@@ -22,8 +22,6 @@
 import org.apache.calcite.util.JsonBuilder;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.ArrayList;
@@ -127,7 +125,7 @@ private void put(Map<String, @Nullable Object> map, String name, @Nullable Objec
   }
 
   @Override public RelWriter done(RelNode node) {
-    final List<Pair<String, @Nullable Object>> valuesCopy = ImmutableList.copyOf(values);
+    final List<Pair<String, @Nullable Object>> valuesCopy = values;
     values.clear();
     explain_(node, valuesCopy);
     return this;
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
index a1b1b0d11..e6810741a 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelWriterImpl.java
@@ -24,8 +24,6 @@
 import org.apache.calcite.sql.SqlExplainLevel;
 import org.apache.calcite.util.Pair;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.io.PrintWriter;
@@ -137,7 +135,7 @@ private void explainInputs(List<RelNode> inputs) {
 
   @Override public RelWriter done(RelNode node) {
     assert checkInputsPresentInExplain(node);
-    final List<Pair<String, @Nullable Object>> valuesCopy = ImmutableList.copyOf(values);
+    final List<Pair<String, @Nullable Object>> valuesCopy = values;
     values.clear();
     explain_(node, valuesCopy);
     pw.flush();
@@ -146,7 +144,7 @@ private void explainInputs(List<RelNode> inputs) {
 
   private boolean checkInputsPresentInExplain(RelNode node) {
     int i = 0;
-    if (values.size() > 0 && values.get(0).left.equals("subset")) {
+    if (!values.isEmpty() && values.get(0).left.equals("subset")) {
       ++i;
     }
     for (RelNode input : node.getInputs()) {
diff --git a/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java b/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
index 1afbf3d43..6b1007524 100644
--- a/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
+++ b/core/src/main/java/org/apache/calcite/rel/externalize/RelXmlWriter.java
@@ -26,7 +26,6 @@
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Objects;
 
 /** Callback for a relational expression to dump in XML format. */
 public class RelXmlWriter extends RelWriterImpl {
@@ -144,7 +143,7 @@ private void explainSpecific(RelNode rel, List<Pair<String, @Nullable Object>> v
       if (value.right instanceof RelNode) {
         continue;
       }
-      xmlOutput.attribute(value.left, Objects.toString(value.right));
+      xmlOutput.attribute(value.left, String.valueOf(value.right));
     }
     xmlOutput.endBeginTag(tagName);
     spacer.add(2);
diff --git a/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java b/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
index e64c53a82..0cc4ba4d7 100644
--- a/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
+++ b/core/src/main/java/org/apache/calcite/rel/hint/HintStrategyTable.java
@@ -66,7 +66,7 @@ public class HintStrategyTable {
   private final Litmus errorHandler;
 
   private HintStrategyTable(Map<Key, HintStrategy> strategies, Litmus litmus) {
-    this.strategies = ImmutableMap.copyOf(strategies);
+    this.strategies = strategies;
     this.errorHandler = litmus;
   }
 
@@ -119,7 +119,7 @@ public boolean validateHint(RelHint hint) {
    */
   public boolean isRuleExcluded(Hintable hintable, RelOptRule rule) {
     final List<RelHint> hints = hintable.getHints();
-    if (hints.size() == 0) {
+    if (hints.isEmpty()) {
       return false;
     }
 
@@ -142,7 +142,7 @@ public boolean isRuleExcluded(Hintable hintable, RelOptRule rule) {
   private static boolean isDesiredConversionPossible(
       Set<ConverterRule> converterRules, Hintable hintable) {
     // If no converter rules are specified, we assume the conversion is possible.
-    return converterRules.size() == 0
+    return converterRules.isEmpty()
         || converterRules.stream()
             .anyMatch(converterRule -> converterRule.convert((RelNode) hintable) != null);
   }
diff --git a/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java b/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java
index 823d2d559..43d1bbdf0 100644
--- a/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java
+++ b/core/src/main/java/org/apache/calcite/rel/hint/RelHint.java
@@ -114,8 +114,8 @@ private RelHint(
     Objects.requireNonNull(hintName, "hintName");
     this.inheritPath = ImmutableList.copyOf(inheritPath);
     this.hintName = hintName;
-    this.listOptions = listOption == null ? ImmutableList.of() : ImmutableList.copyOf(listOption);
-    this.kvOptions = kvOptions == null ? ImmutableMap.of() : ImmutableMap.copyOf(kvOptions);
+    this.listOptions = listOption == null ? ImmutableList.of() : listOption;
+    this.kvOptions = kvOptions == null ? ImmutableMap.of() : kvOptions;
   }
 
   // ~ Methods ----------------------------------------------------------------
@@ -157,12 +157,12 @@ public RelHint copy(List<Integer> inheritPath) {
   @Override public String toString() {
     StringBuilder builder = new StringBuilder();
     builder.append("[").append(this.hintName).append(" inheritPath:").append(this.inheritPath);
-    if (this.listOptions.size() > 0 || this.kvOptions.size() > 0) {
+    if (!this.listOptions.isEmpty() || this.kvOptions.size() > 0) {
       builder.append(" options:");
-      if (this.listOptions.size() > 0) {
-        builder.append(this.listOptions.toString());
+      if (!this.listOptions.isEmpty()) {
+        builder.append(this.listOptions);
       } else {
-        builder.append(this.kvOptions.toString());
+        builder.append(this.kvOptions);
       }
     }
     builder.append("]");
@@ -221,7 +221,7 @@ public Builder hintOption(String optionKey, String optionValue) {
       Objects.requireNonNull(optionKey, "optionKey");
       Objects.requireNonNull(optionValue, "optionValue");
       Preconditions.checkState(
-          this.listOptions.size() == 0, "List options and key value options can not be mixed in");
+          this.listOptions.isEmpty(), "List options and key value options can not be mixed in");
       this.kvOptions.put(optionKey, optionValue);
       return this;
     }
@@ -230,7 +230,7 @@ public Builder hintOption(String optionKey, String optionValue) {
     public Builder hintOptions(Map<String, String> kvOptions) {
       Objects.requireNonNull(kvOptions, "kvOptions");
       Preconditions.checkState(
-          this.listOptions.size() == 0, "List options and key value options can not be mixed in");
+          this.listOptions.isEmpty(), "List options and key value options can not be mixed in");
       this.kvOptions = kvOptions;
       return this;
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java
index 5cb9a4066..466fa90a4 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalCalc.java
@@ -130,7 +130,7 @@ public static LogicalCalc create(final RelNode input, final RexProgram program)
   }
 
   @Override public RelNode withHints(List<RelHint> hintList) {
-    return new LogicalCalc(getCluster(), traitSet, ImmutableList.copyOf(hintList), input, program);
+    return new LogicalCalc(getCluster(), traitSet, hintList, input, program);
   }
 
   @Override public RelNode accept(RelShuttle shuttle) {
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java
index 4a78f0643..735ae0968 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalIntersect.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.core.Intersect;
 import org.apache.calcite.rel.hint.RelHint;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -56,7 +57,7 @@ public LogicalIntersect(
    */
   public LogicalIntersect(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
-    this(cluster, traitSet, Collections.emptyList(), inputs, all);
+    this(cluster, traitSet, ImmutableList.of(), inputs, all);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java
index 55fc1af79..5354b12ca 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalMinus.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.core.Minus;
 import org.apache.calcite.rel.hint.RelHint;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -56,7 +57,7 @@ public LogicalMinus(
    */
   public LogicalMinus(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
-    this(cluster, traitSet, Collections.emptyList(), inputs, all);
+    this(cluster, traitSet, ImmutableList.of(), inputs, all);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java
index 8813985a3..f74a31473 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalSort.java
@@ -28,9 +28,10 @@
 import org.apache.calcite.rel.hint.RelHint;
 import org.apache.calcite.rex.RexNode;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -45,7 +46,7 @@ private LogicalSort(
       RelCollation collation,
       @Nullable RexNode offset,
       @Nullable RexNode fetch) {
-    this(cluster, traitSet, Collections.emptyList(), input, collation, offset, fetch);
+    this(cluster, traitSet, ImmutableList.of(), input, collation, offset, fetch);
   }
 
   private LogicalSort(
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java
index 3c6c4ba4f..72bfc49b9 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalTableFunctionScan.java
@@ -30,10 +30,11 @@
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexNode;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Type;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -90,7 +91,7 @@ public LogicalTableFunctionScan(
     this(
         cluster,
         traitSet,
-        Collections.emptyList(),
+        ImmutableList.of(),
         inputs,
         rexCall,
         elementType,
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java
index a2782e60e..80ddaa869 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalUnion.java
@@ -25,7 +25,8 @@
 import org.apache.calcite.rel.core.Union;
 import org.apache.calcite.rel.hint.RelHint;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
+
 import java.util.List;
 
 /**
@@ -56,7 +57,7 @@ public LogicalUnion(
    */
   public LogicalUnion(
       RelOptCluster cluster, RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
-    this(cluster, traitSet, Collections.emptyList(), inputs, all);
+    this(cluster, traitSet, ImmutableList.of(), inputs, all);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java
index f02645946..c06f6e3fd 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalValues.java
@@ -36,7 +36,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.math.BigDecimal;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -81,7 +80,7 @@ public LogicalValues(
       RelTraitSet traitSet,
       RelDataType rowType,
       ImmutableList<ImmutableList<RexLiteral>> tuples) {
-    this(cluster, traitSet, Collections.emptyList(), rowType, tuples);
+    this(cluster, traitSet, ImmutableList.of(), rowType, tuples);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java b/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
index a9c5c463b..594356850 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/LogicalWindow.java
@@ -40,6 +40,7 @@
 import org.apache.calcite.util.Pair;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.LinkedListMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
@@ -49,7 +50,6 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.List;
@@ -104,7 +104,7 @@ public LogicalWindow(
       List<RexLiteral> constants,
       RelDataType rowType,
       List<Group> groups) {
-    this(cluster, traitSet, Collections.emptyList(), input, constants, rowType, groups);
+    this(cluster, traitSet, ImmutableList.of(), input, constants, rowType, groups);
   }
 
   @Override public LogicalWindow copy(RelTraitSet traitSet, List<RelNode> inputs) {
diff --git a/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java b/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java
index 5cc9dccbc..2e2554231 100644
--- a/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java
+++ b/core/src/main/java/org/apache/calcite/rel/logical/ToLogicalConverter.java
@@ -41,7 +41,7 @@
 import org.apache.calcite.rel.core.Window;
 import org.apache.calcite.tools.RelBuilder;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
 
 /** Shuttle to convert any rel plan to a plan with all logical nodes. */
 public class ToLogicalConverter extends RelShuttleImpl {
@@ -178,7 +178,7 @@ public ToLogicalConverter(RelBuilder relBuilder) {
       final Uncollect uncollect = (Uncollect) relNode;
       final RelNode input = visit(uncollect.getInput());
       return Uncollect.create(
-          input.getTraitSet(), input, uncollect.withOrdinality, Collections.emptyList());
+          input.getTraitSet(), input, uncollect.withOrdinality, ImmutableList.of());
     }
 
     throw new AssertionError(
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java
index 6873fcaf2..82f533b25 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/ChainedRelMetadataProvider.java
@@ -20,6 +20,7 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 
@@ -102,7 +103,7 @@ protected ChainedRelMetadataProvider(ImmutableList<RelMetadataProvider> provider
   @Deprecated // to be removed before 2.0
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
     final ImmutableMultimap.Builder<Method, MetadataHandler<M>> builder =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
     for (RelMetadataProvider provider : providers.reverse()) {
       builder.putAll(provider.handlers(def));
     }
@@ -130,7 +131,7 @@ private static class ChainedInvocationHandler implements InvocationHandler {
     private final List<Metadata> metadataList;
 
     ChainedInvocationHandler(List<Metadata> metadataList) {
-      this.metadataList = ImmutableList.copyOf(metadataList);
+      this.metadataList = metadataList;
     }
 
     @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java b/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
index 8b64ad606..af97a2d18 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/ReflectiveRelMetadataProvider.java
@@ -27,6 +27,7 @@
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 
@@ -48,6 +49,8 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Implementation of the {@link RelMetadataProvider} interface that dispatches metadata methods to
  * methods on a given object via reflection.
@@ -90,7 +93,7 @@ protected ReflectiveRelMetadataProvider(
         "ReflectiveRelMetadataProvider " + "methods map is empty; are your methods named wrong?");
     this.map = map;
     this.metadataClass0 = metadataClass0;
-    this.handlerMap = ImmutableMultimap.copyOf(handlerMap);
+    this.handlerMap = ImmutableListMultimap.copyOf(handlerMap);
     this.handlerClass = handlerClass;
     this.handlers = ImmutableList.copyOf(handlerMap.values());
   }
@@ -222,7 +225,7 @@ private static RelMetadataProvider reflectiveSource(
   @Deprecated // to be removed before 2.0
   @Override public <M extends Metadata> Multimap<Method, MetadataHandler<M>> handlers(MetadataDef<M> def) {
     final ImmutableMultimap.Builder<Method, MetadataHandler<M>> builder =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
     for (Map.Entry<Method, MetadataHandler> entry : handlerMap.entries()) {
       if (def.methods.contains(entry.getKey())) {
         //noinspection unchecked
@@ -309,7 +312,7 @@ static class Space {
     final ImmutableMultimap<Method, MetadataHandler<?>> providerMap;
 
     Space(Multimap<Method, MetadataHandler<?>> providerMap) {
-      this.providerMap = ImmutableMultimap.copyOf(providerMap);
+      this.providerMap = ImmutableListMultimap.copyOf(providerMap);
 
       // Find the distinct set of RelNode classes handled by this provider,
       // ordered base-class first.
@@ -349,14 +352,11 @@ Method find(final Class<? extends RelNode> relNodeClass, Method method) {
           }
         }
         r = r.getSuperclass();
-        if (r == null || !RelNode.class.isAssignableFrom(r)) {
-          throw new IllegalArgumentException(
-              "No handler for method ["
-                  + method
-                  + "] applied to argument of type ["
-                  + relNodeClass
-                  + "]; we recommend you create a catch-all (RelNode) handler");
-        }
+        checkArgument(
+            r != null && RelNode.class.isAssignableFrom(r),
+            "No handler for method [%s] applied to argument of type [%s]; we recommend you create a catch-all (RelNode) handler",
+            method,
+            relNodeClass);
       }
     }
   }
@@ -374,7 +374,7 @@ static class Space2 extends Space {
 
     @Deprecated // to be removed before 2.0
     public static Space2 create(MetadataHandler<?> target, ImmutableList<Method> methods) {
-      assert methods.size() > 0;
+      assert !methods.isEmpty();
       final Method method0 = methods.get(0);
       //noinspection unchecked
       Class<Metadata> metadataClass0 = (Class) method0.getDeclaringClass();
@@ -384,7 +384,7 @@ public static Space2 create(MetadataHandler<?> target, ImmutableList<Method> met
       }
 
       final ImmutableMultimap.Builder<Method, MetadataHandler<?>> providerBuilder =
-          ImmutableMultimap.builder();
+          ImmutableListMultimap.builder();
       for (final Method method : methods) {
         providerBuilder.put(method, target);
       }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
index 2b4f1d53c..82b7cb18f 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdCollation.java
@@ -552,7 +552,7 @@ public static Ordering<List<RexLiteral>> comparator(RelFieldCollation fieldColla
       case FULL:
         for (RelCollation collation : leftCollations) {
           for (RelFieldCollation field : collation.getFieldCollations()) {
-            if (!(RelFieldCollation.NullDirection.LAST == field.nullDirection)) {
+            if (RelFieldCollation.NullDirection.LAST != field.nullDirection) {
               return null;
             }
           }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
index 6ca8331f6..a687b0ab0 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnOrigins.java
@@ -148,9 +148,7 @@ private RelMdColumnOrigins() {}
           }
         };
     final List<RexNode> projects = new ArrayList<>();
-    for (RexNode rex : rexShuttle.apply(rel.getProgram().getProjectList())) {
-      projects.add(rex);
-    }
+    projects.addAll(rexShuttle.apply(rel.getProgram().getProjectList()));
     final RexNode rexNode = projects.get(iOutputColumn);
     if (rexNode instanceof RexInputRef) {
       // Direct reference:  no derivation added.
@@ -202,7 +200,7 @@ private RelMdColumnOrigins() {}
     final Set<RelColumnOrigin> set = new HashSet<>();
     Set<RelColumnMapping> mappings = rel.getColumnMappings();
     if (mappings == null) {
-      if (rel.getInputs().size() > 0) {
+      if (!rel.getInputs().isEmpty()) {
         // This is a non-leaf transformation:  say we don't
         // know about origins, because there are probably
         // columns below.
@@ -239,7 +237,7 @@ private RelMdColumnOrigins() {}
     // it's up to the plugin writer to override with the
     // correct information.
 
-    if (rel.getInputs().size() > 0) {
+    if (!rel.getInputs().isEmpty()) {
       // No generic logic available for non-leaf rels.
       return null;
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
index 03bc74d79..d42338067 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdColumnUniqueness.java
@@ -385,7 +385,7 @@ public Boolean areColumnsUnique(
         Comparable value = literal.getValueAs(Comparable.class);
         values.add(value == null ? NullSentinel.INSTANCE : value);
       }
-      if (!set.add(ImmutableList.copyOf(values))) {
+      if (!set.add(values)) {
         return false;
       }
       values.clear();
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java
index 82f5443b9..77e3ae61f 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdDistinctRowCount.java
@@ -203,7 +203,7 @@ public Double getDistinctRowCount(
         Comparable value = literal.getValueAs(Comparable.class);
         values.add(value == null ? NullSentinel.INSTANCE : value);
       }
-      set.add(ImmutableList.copyOf(values));
+      set.add(values);
       values.clear();
     }
     double nRows = set.size();
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java
index 13549ecaa..2399dd4b8 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPercentageOriginalRows.java
@@ -127,7 +127,7 @@ public Double getPercentageOriginalRows(Union rel, RelMetadataQuery mq) {
       return null;
     }
 
-    if (rel.getInputs().size() == 0) {
+    if (rel.getInputs().isEmpty()) {
       // Assume no filtering happening at leaf.
       return 1.0;
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
index f6c28312f..1d43fa2b9 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdPredicates.java
@@ -68,7 +68,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -726,7 +725,7 @@ public RelOptPredicateList inferPredicates(boolean includeEqualityInference) {
               inferredPredicates,
               EMPTY_LIST);
         default:
-          assert inferredPredicates.size() == 0;
+          assert inferredPredicates.isEmpty();
           return RelOptPredicateList.EMPTY;
       }
     }
@@ -774,7 +773,7 @@ Iterable<Mapping> mappings(final RexNode predicate) {
               exprFields.get(predicate),
               () -> "exprFields.get(predicate) is null for " + predicate);
       if (fields.cardinality() == 0) {
-        return Collections.emptyList();
+        return ImmutableList.of();
       }
       return () -> new ExprsItr(fields);
     }
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java
index bcdb6168e..21b696f17 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdSelectivity.java
@@ -70,7 +70,7 @@ protected RelMdSelectivity() {}
 
   public @Nullable Double getSelectivity(
       Union rel, RelMetadataQuery mq, @Nullable RexNode predicate) {
-    if ((rel.getInputs().size() == 0) || (predicate == null)) {
+    if (rel.getInputs().isEmpty() || (predicate == null)) {
       return 1.0;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
index 458d87424..122b9a08b 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUniqueKeys.java
@@ -38,6 +38,7 @@
 import org.apache.calcite.util.ImmutableBitSet;
 import org.apache.calcite.util.Util;
 
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
@@ -113,7 +114,7 @@ private static Set<ImmutableBitSet> getProjectUniqueKeys(
     // to be mapped to match the output of the project.
 
     // Single input can be mapped to multiple outputs
-    ImmutableMultimap.Builder<Integer, Integer> inToOutPosBuilder = ImmutableMultimap.builder();
+    ImmutableMultimap.Builder<Integer, Integer> inToOutPosBuilder = ImmutableListMultimap.builder();
     ImmutableBitSet.Builder mappedInColumnsBuilder = ImmutableBitSet.builder();
 
     // Build an input to output position map.
@@ -283,7 +284,7 @@ public Set<ImmutableBitSet> getUniqueKeys(Union rel, RelMetadataQuery mq, boolea
   /** Any unique key of any input of Intersect is an unique key of the Intersect. */
   public Set<ImmutableBitSet> getUniqueKeys(
       Intersect rel, RelMetadataQuery mq, boolean ignoreNulls) {
-    ImmutableSet.Builder<ImmutableBitSet> keys = new ImmutableSet.Builder<>();
+    ImmutableSet.Builder<ImmutableBitSet> keys = ImmutableSet.builder();
     for (RelNode input : rel.getInputs()) {
       Set<ImmutableBitSet> uniqueKeys = mq.getUniqueKeys(input, ignoreNulls);
       if (uniqueKeys != null) {
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
index bf747c196..aab0a7861 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java
@@ -88,7 +88,7 @@ public static RexNode makeSemiJoinSelectivityRexNode(RelMetadataQuery mq, Join r
     RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
     double selectivity = computeSemiJoinSelectivity(mq, rel.getLeft(), rel.getRight(), rel);
     return rexBuilder.makeCall(
-        ARTIFICIAL_SELECTIVITY_FUNC, rexBuilder.makeApproxLiteral(new BigDecimal(selectivity)));
+        ARTIFICIAL_SELECTIVITY_FUNC, rexBuilder.makeApproxLiteral(BigDecimal.valueOf(selectivity)));
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java b/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
index 2c3354069..5a5f9a82a 100644
--- a/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
+++ b/core/src/main/java/org/apache/calcite/rel/metadata/RelMetadataQuery.java
@@ -368,8 +368,7 @@ public static RelMetadataQuery instance() {
     if (origins == null || origins.size() != 1) {
       return null;
     }
-    final RelColumnOrigin origin = Iterables.getOnlyElement(origins);
-    return origin;
+    return Iterables.getOnlyElement(origins);
   }
 
   /** Determines the origin of a column. */
@@ -409,7 +408,7 @@ public static RelMetadataQuery instance() {
       return null;
     }
     final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0);
-    if (colOrigins == null || colOrigins.size() == 0) {
+    if (colOrigins == null || colOrigins.isEmpty()) {
       return null;
     }
     return colOrigins.iterator().next().getOriginTable();
diff --git a/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java b/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java
index b5b743945..2a53b5199 100644
--- a/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java
+++ b/core/src/main/java/org/apache/calcite/rel/mutable/MutableBiRel.java
@@ -23,6 +23,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Mutable equivalent of {@link org.apache.calcite.rel.BiRel}. */
 abstract class MutableBiRel extends MutableRel {
   protected MutableRel left;
@@ -46,9 +48,7 @@ protected MutableBiRel(
   }
 
   @Override public void setInput(int ordinalInParent, MutableRel input) {
-    if (ordinalInParent > 1) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(ordinalInParent <= 1);
     if (ordinalInParent == 0) {
       this.left = input;
     } else {
diff --git a/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java b/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
index 93519cbc5..6c3f455aa 100644
--- a/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
+++ b/core/src/main/java/org/apache/calcite/rel/mutable/MutableRels.java
@@ -65,7 +65,6 @@
 
 import java.util.AbstractList;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Collectors;
@@ -248,7 +247,7 @@ public static RelNode fromMutable(MutableRel node, RelBuilder relBuilder) {
           final MutableUncollect uncollect = (MutableUncollect) node;
           final RelNode child = fromMutable(uncollect.getInput(), relBuilder);
           return Uncollect.create(
-              child.getTraitSet(), child, uncollect.withOrdinality, Collections.emptyList());
+              child.getTraitSet(), child, uncollect.withOrdinality, ImmutableList.of());
         }
       case WINDOW:
         {
diff --git a/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java b/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java
index a5b68c91d..495bdf9d0 100644
--- a/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java
+++ b/core/src/main/java/org/apache/calcite/rel/mutable/MutableSingleRel.java
@@ -22,6 +22,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Mutable equivalent of {@link org.apache.calcite.rel.SingleRel}. */
 abstract class MutableSingleRel extends MutableRel {
   protected MutableRel input;
@@ -35,9 +37,7 @@ protected MutableSingleRel(MutableRelType type, RelDataType rowType, MutableRel
   }
 
   @Override public void setInput(int ordinalInParent, MutableRel input) {
-    if (ordinalInParent > 0) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(ordinalInParent <= 0);
     this.input = input;
     if (input != null) {
       input.parent = this;
diff --git a/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java b/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
index 652be2382..12238ba8d 100644
--- a/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
+++ b/core/src/main/java/org/apache/calcite/rel/rel2sql/RelToSqlConverter.java
@@ -628,7 +628,7 @@ private List<SqlNode> generateGroupList(
     }
     switch (aggregate.getGroupType()) {
       case SIMPLE:
-        return ImmutableList.copyOf(groupKeys);
+        return groupKeys;
       case CUBE:
         if (aggregate.getGroupSet().cardinality() > 1) {
           return ImmutableList.of(
@@ -881,7 +881,7 @@ public Result visit(Values e) {
             list.stream()
                 .map(select -> (SqlNode) select)
                 .reduce((l, r) -> SqlStdOperatorTable.UNION_ALL.createCall(POS, l, r))
-                .get();
+                .orElseThrow();
       }
     } else {
       // Generate ANSI syntax
diff --git a/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java b/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
index ac452665c..d598f95bc 100644
--- a/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
+++ b/core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java
@@ -1432,7 +1432,7 @@ public static SqlNode toSql(RexLiteral literal) {
         //noinspection unchecked
         final List<RexLiteral> list = castNonNull(literal.getValueAs(List.class));
         return SqlStdOperatorTable.ROW.createCall(
-            POS, list.stream().map(e -> toSql(e)).collect(Util.toImmutableList()));
+            POS, list.stream().map(SqlImplementor::toSql).collect(Util.toImmutableList()));
 
       case SARG:
         final Sarg arg = literal.getValueAs(Sarg.class);
@@ -1498,9 +1498,9 @@ public static SqlNode toSql(RexLiteral literal) {
 
   /**
    * Simple implementation of {@link Context} that cannot handle sub-queries or correlations.
-   * Because it is so simple, you do not need to create a {@link SqlImplementor} or {@link
-   * org.apache.calcite.tools.RelBuilder} to use it. It is a good way to convert a {@link RexNode}
-   * to SQL text.
+   * Because it is so simple, you do not need to create a {@link
+   * org.apache.calcite.rel.rel2sql.SqlImplementor} or {@link org.apache.calcite.tools.RelBuilder}
+   * to use it. It is a good way to convert a {@link RexNode} to SQL text.
    */
   public static class SimpleContext extends Context {
     private final IntFunction<SqlNode> field;
@@ -1520,8 +1520,8 @@ public SimpleContext(SqlDialect dialect, IntFunction<SqlNode> field) {
   }
 
   /**
-   * Implementation of {@link Context} that has an enclosing {@link SqlImplementor} and can
-   * therefore do non-trivial expressions.
+   * Implementation of {@link Context} that has an enclosing {@link
+   * org.apache.calcite.rel.rel2sql.SqlImplementor} and can therefore do non-trivial expressions.
    */
   protected abstract class BaseContext extends Context {
     BaseContext(SqlDialect dialect, int fieldCount) {
@@ -2232,7 +2232,7 @@ public Builder(
         boolean anon,
         @Nullable Map<String, RelDataType> aliases) {
       this.rel = requireNonNull(rel, "rel");
-      this.clauses = ImmutableList.copyOf(clauses);
+      this.clauses = clauses;
       this.select = requireNonNull(select, "select");
       this.context = requireNonNull(context, "context");
       this.anon = anon;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
index 59ae745c3..ea58b6810 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandDistinctAggregatesRule.java
@@ -46,7 +46,6 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.immutables.value.Value;
@@ -159,7 +158,7 @@ public AggregateExpandDistinctAggregatesRule(
             .map(aggCall -> Pair.of(aggCall.getArgList(), aggCall.filterArg))
             .collect(Collectors.toCollection(LinkedHashSet::new));
 
-    Preconditions.checkState(distinctCallArgLists.size() > 0, "containsDistinctCall lied");
+    Preconditions.checkState(!distinctCallArgLists.isEmpty(), "containsDistinctCall lied");
 
     // If all of the agg expressions are distinct and have the same
     // arguments then we can use a more efficient form.
@@ -204,7 +203,7 @@ public AggregateExpandDistinctAggregatesRule(
     if (distinctAggCalls.size() == 1 // one distinct aggregate
         && filterCount == 0 // no filter
         && unsupportedNonDistinctAggCallCount == 0 // sum/min/max/count in non-distinct aggregate
-        && nonDistinctAggCalls.size() > 0) { // one or more non-distinct aggregates
+        && !nonDistinctAggCalls.isEmpty()) { // one or more non-distinct aggregates
       final RelBuilder relBuilder = call.builder();
       convertSingletonDistinct(relBuilder, aggregate, distinctCallArgLists);
       call.transformTo(relBuilder.build());
@@ -666,7 +665,7 @@ private static RelBuilder convertMonopole(
     createSelectDistinct(relBuilder, aggregate, argList, filterArg, sourceOf);
 
     // Create an aggregate on top, with the new aggregate list.
-    final List<AggregateCall> newAggCalls = Lists.newArrayList(aggregate.getAggCallList());
+    final List<AggregateCall> newAggCalls = new ArrayList<>(aggregate.getAggCallList());
     rewriteAggCalls(newAggCalls, argList, sourceOf);
     final int cardinality = aggregate.getGroupSet().cardinality();
     relBuilder.push(
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
index 60d5caf35..48d5cc02d 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateExpandWithinDistinctRule.java
@@ -425,7 +425,7 @@ int getCount(int filterArg) {
               }
             }
           }
-          if (filters.size() > 0) {
+          if (!filters.isEmpty()) {
             aggCall = aggCall.filter(b.and(filters));
           }
           aggCalls.add(aggCall);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
index 00e0a4d35..2f68d1aa5 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateMergeRule.java
@@ -101,7 +101,7 @@ private static boolean isAggregateSupported(AggregateCall aggCall) {
 
     final List<AggregateCall> finalCalls = new ArrayList<>();
     for (AggregateCall topCall : topAgg.getAggCallList()) {
-      if (!isAggregateSupported(topCall) || topCall.getArgList().size() == 0) {
+      if (!isAggregateSupported(topCall) || topCall.getArgList().isEmpty()) {
         return;
       }
       // Make sure top aggregate argument refers to one of the aggregate
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
index 1bb46bc10..30ee4c8b4 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateReduceFunctionsRule.java
@@ -58,6 +58,8 @@
 import java.util.function.IntPredicate;
 import java.util.function.Predicate;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Planner rule that reduces aggregate functions in {@link org.apache.calcite.rel.core.Aggregate}s
  * to simpler forms.
@@ -91,10 +93,10 @@ public class AggregateReduceFunctionsRule extends RelRule<AggregateReduceFunctio
   // ~ Static fields/initializers ---------------------------------------------
 
   private static void validateFunction(SqlKind function) {
-    if (!isValid(function)) {
-      throw new IllegalArgumentException(
-          "AggregateReduceFunctionsRule doesn't " + "support function: " + function.sql);
-    }
+    checkArgument(
+        isValid(function),
+        "AggregateReduceFunctionsRule doesn't support function: %s",
+        function.sql);
   }
 
   private static boolean isValid(SqlKind function) {
@@ -110,7 +112,7 @@ private static boolean isValid(SqlKind function) {
   /** Creates an AggregateReduceFunctionsRule. */
   protected AggregateReduceFunctionsRule(Config config) {
     super(config);
-    this.functionsToReduce = ImmutableSet.copyOf(config.actualFunctionsToReduce());
+    this.functionsToReduce = config.actualFunctionsToReduce();
   }
 
   @Deprecated // to be removed before 2.0
@@ -260,8 +262,8 @@ private RexNode reduceAgg(
     if (canReduceAggCallByGrouping(oldAggRel, oldCall)) {
       // replace original MAX/MIN/AVG/ANY_VALUE/FIRST_VALUE/LAST_VALUE(x) with
       // target field of x, when x exists in group
-      final RexNode reducedNode = reduceAggCallByGrouping(oldAggRel, oldCall);
-      return reducedNode;
+      return reduceAggCallByGrouping(oldAggRel, oldCall);
+
     } else if (canReduce(oldCall)) {
       final Integer y;
       final Integer x;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java b/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
index be0e4fda9..b773ceb70 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/AggregateStarTableRule.java
@@ -100,7 +100,7 @@ protected void apply(
     final RelOptPlanner planner = call.getPlanner();
     final Optional<CalciteConnectionConfig> config =
         planner.getContext().maybeUnwrap(CalciteConnectionConfig.class);
-    if (!(config.isPresent() && config.get().createMaterializations())) {
+    if (!(config.isPresent() && config.orElseThrow().createMaterializations())) {
       // Disable this rule if we if materializations are disabled - in
       // particular, if we are in a recursive statement that is being used to
       // populate a materialization
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java b/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
index 8a892e035..e8eec7fe6 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/CalcRelSplitter.java
@@ -44,6 +44,8 @@
 import org.apache.calcite.util.graph.TopologicalOrderIterator;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.primitives.Ints;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -53,7 +55,6 @@
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
@@ -397,7 +398,7 @@ private static List<Integer> computeTopologicalOrdering(
       final Set<Integer> cohort = findCohort(cohorts, i);
       final Set<Integer> targets;
       if (cohort == null) {
-        targets = Collections.singleton(i);
+        targets = ImmutableSet.of(i);
       } else {
         targets = cohort;
       }
@@ -536,11 +537,10 @@ private RexProgram createProgramForLevel(
     if (outputRowType == null) {
       outputRowType = RexUtil.createStructType(typeFactory, projectRefs, fieldNames, null);
     }
-    final RexProgram program =
-        new RexProgram(inputRowType, exprs, projectRefs, conditionRef, outputRowType);
+    return new RexProgram(inputRowType, exprs, projectRefs, conditionRef, outputRowType);
     // Program is NOT normalized here (e.g. can contain literals in
     // call operands), since literals should be inlined.
-    return program;
+
   }
 
   private String deriveFieldName(RexNode expr, int ordinal) {
@@ -659,7 +659,7 @@ protected boolean canImplement(LogicalCalc rel, String relTypeName) {
    *     attempt to place on the same level
    */
   protected List<Set<Integer>> getCohorts() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   // ~ Inner Classes ----------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java b/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
index 7efe8a7eb..e53234290 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/DateRangeRules.java
@@ -436,7 +436,7 @@ private boolean canRewriteExtract(RexNode operand) {
             //noinspection unchecked
             return (List<RexNode>) exprs;
           }
-          final Map<RexNode, RangeSet<Calendar>> save = ImmutableMap.copyOf(operandRanges);
+          final Map<RexNode, RangeSet<Calendar>> save = operandRanges;
           final ImmutableList.Builder<RexNode> clonedOperands = ImmutableList.builder();
           for (RexNode operand : exprs) {
             RexNode clonedOperand = operand;
@@ -514,7 +514,7 @@ RexNode compareExtract(SqlKind comparison, RexNode operand, RexLiteral literal)
       }
       // Intersect old range set with new.
       s2.removeAll(rangeSet.complement());
-      operandRanges.put(operand, ImmutableRangeSet.copyOf(s2));
+      operandRanges.put(operand, s2);
       final List<RexNode> nodes = new ArrayList<>();
       for (Range<Calendar> r : s2.asRanges()) {
         nodes.add(toRex(operand, r));
@@ -663,7 +663,7 @@ private RexNode compareFloorCeil(
       s2.add(range);
       // Intersect old range set with new.
       s2.removeAll(rangeSet.complement());
-      operandRanges.put(operand, ImmutableRangeSet.copyOf(s2));
+      operandRanges.put(operand, s2);
       if (range.isEmpty()) {
         return rexBuilder.makeLiteral(false);
       }
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
index 01929d320..a3d7b7e35 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/FilterJoinRule.java
@@ -73,7 +73,7 @@ protected FilterJoinRule(C config) {
 
   protected void perform(RelOptRuleCall call, @Nullable Filter filter, Join join) {
     List<RexNode> joinFilters = RelOptUtil.conjunctions(join.getCondition());
-    final List<RexNode> origJoinFilters = ImmutableList.copyOf(joinFilters);
+    final List<RexNode> origJoinFilters = joinFilters;
 
     // If there is only the joinRel,
     // make sure it does not match a cartesian product joinRel
@@ -332,7 +332,7 @@ private static List<RexNode> constructConditionFromEqualSets(
         }
       }
       // Only need one equal condition for each equal set.
-      if (leftSet.size() > 0 && rightSet.size() > 0) {
+      if (!leftSet.isEmpty() && !rightSet.isEmpty()) {
         result.add(
             rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, leftSet.get(0), rightSet.get(0)));
       }
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java b/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
index 999abc3f0..dd4660743 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/FilterProjectTransposeRule.java
@@ -32,9 +32,10 @@
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 
+import com.google.common.collect.ImmutableList;
+
 import org.immutables.value.Value;
 
-import java.util.Collections;
 import java.util.function.Predicate;
 
 /**
@@ -177,12 +178,11 @@ protected FilterProjectTransposeRule(
               .replaceIfs(
                   RelCollationTraitDef.INSTANCE,
                   () ->
-                      Collections.singletonList(
-                          input.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE)))
+                      ImmutableList.of(input.getTraitSet().getTrait(RelCollationTraitDef.INSTANCE)))
               .replaceIfs(
                   RelDistributionTraitDef.INSTANCE,
                   () ->
-                      Collections.singletonList(
+                      ImmutableList.of(
                           input.getTraitSet().getTrait(RelDistributionTraitDef.INSTANCE)));
       newCondition = RexUtil.removeNullabilityCast(relBuilder.getTypeFactory(), newCondition);
       newFilterRel = filter.copy(traitSet, input, newCondition);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java b/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
index 77c908051..132e55bf1 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/IntersectToDistinctRule.java
@@ -117,7 +117,7 @@ public IntersectToDistinctRule(
     relBuilder.filter(
         relBuilder.equals(
             relBuilder.field(fieldCount - 1),
-            rexBuilder.makeBigintLiteral(new BigDecimal(branchCount))));
+            rexBuilder.makeBigintLiteral(BigDecimal.valueOf(branchCount))));
 
     // Project all but the last field
     relBuilder.project(Util.skipLast(relBuilder.fields()));
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
index c6be90be9..3868a8916 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinAddRedundantSemiJoinRule.java
@@ -74,7 +74,7 @@ public JoinAddRedundantSemiJoinRule(
 
     // determine if we have a valid join condition
     final JoinInfo joinInfo = origJoinRel.analyzeCondition();
-    if (joinInfo.leftKeys.size() == 0) {
+    if (joinInfo.leftKeys.isEmpty()) {
       return;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
index b451efce0..59079eeac 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinProjectTransposeRule.java
@@ -41,11 +41,12 @@
 import org.apache.calcite.tools.RelBuilderFactory;
 import org.apache.calcite.util.Pair;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.immutables.value.Value;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;
@@ -189,7 +190,7 @@ public JoinProjectTransposeRule(
             JoinRelType.INNER,
             join.getCluster().getTypeFactory(),
             null,
-            Collections.emptyList());
+            ImmutableList.of());
 
     // Create projection expressions, combining the projection expressions
     // from the projects that feed into the join.  For the RHS projection
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
index 23a4c0a16..b53e149bc 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinPushTransitivePredicatesRule.java
@@ -80,14 +80,14 @@ public JoinPushTransitivePredicatesRule(
     final RelBuilder relBuilder = call.builder();
 
     RelNode left = join.getLeft();
-    if (preds.leftInferredPredicates.size() > 0) {
+    if (!preds.leftInferredPredicates.isEmpty()) {
       RelNode curr = left;
       left = relBuilder.push(left).filter(preds.leftInferredPredicates).build();
       call.getPlanner().onCopy(curr, left);
     }
 
     RelNode right = join.getRight();
-    if (preds.rightInferredPredicates.size() > 0) {
+    if (!preds.rightInferredPredicates.isEmpty()) {
       RelNode curr = right;
       right = relBuilder.push(right).filter(preds.rightInferredPredicates).build();
       call.getPlanner().onCopy(curr, right);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
index 811517dfd..3ac1f8a69 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/JoinToMultiJoinRule.java
@@ -403,14 +403,12 @@ private static boolean canCombine(RelNode input, boolean nullGenerating) {
     for (int i = 0; i < nFieldsOnRight; i++) {
       adjustments[i] = nFieldsOnLeft;
     }
-    rightFilter =
-        rightFilter.accept(
-            new RelOptUtil.RexInputConverter(
-                joinRel.getCluster().getRexBuilder(),
-                right.getRowType().getFieldList(),
-                joinRel.getRowType().getFieldList(),
-                adjustments));
-    return rightFilter;
+    return rightFilter.accept(
+        new RelOptUtil.RexInputConverter(
+            joinRel.getCluster().getRexBuilder(),
+            right.getRowType().getFieldList(),
+            joinRel.getRowType().getFieldList(),
+            adjustments));
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java b/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java
index fbac06544..6ab2af12f 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/LoptMultiJoin.java
@@ -33,7 +33,6 @@
 import org.apache.calcite.util.ImmutableIntList;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.initialization.qual.UnderInitialization;
 import org.checkerframework.checker.initialization.qual.UnknownInitialization;
@@ -164,7 +163,7 @@ public LoptMultiJoin(MultiJoin multiJoin) {
     projFields = multiJoin.getProjFields();
     joinFieldRefCountsMap = multiJoin.getCopyJoinFieldRefCountsMap();
 
-    joinFilters = Lists.newArrayList(RelOptUtil.conjunctions(multiJoin.getJoinFilter()));
+    joinFilters = new ArrayList<>(RelOptUtil.conjunctions(multiJoin.getJoinFilter()));
 
     allJoinFilters = new ArrayList<>(joinFilters);
     List<@Nullable RexNode> outerJoinFilters = multiJoin.getOuterJoinConditions();
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
index 0417ab9aa..eb6352a99 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/LoptOptimizeJoinRule.java
@@ -320,7 +320,7 @@ private static void findRemovableSelfJoins(RelMetadataQuery mq, LoptMultiJoin mu
           selfJoinFilters.add(filter);
         }
       }
-      if ((selfJoinFilters.size() > 0)
+      if (!selfJoinFilters.isEmpty()
           && isSelfJoinFilterUnique(mq, multiJoin, factor1, factor2, selfJoinFilters)) {
         multiJoin.addRemovableSelfJoinPair(factor1, factor2);
       }
@@ -679,7 +679,7 @@ private static void setFactorJoinKeys(
       prevFactor = nextFactor;
     }
 
-    assert filtersToAdd.size() == 0;
+    assert filtersToAdd.isEmpty();
     return joinTree;
   }
 
@@ -1702,15 +1702,12 @@ private static RexNode swapFilter(
       adjustments[i] = -nFieldsOnLeft;
     }
 
-    condition =
-        condition.accept(
-            new RelOptUtil.RexInputConverter(
-                rexBuilder,
-                multiJoin.getJoinFields(origLeft, origRight),
-                multiJoin.getJoinFields(origRight, origLeft),
-                adjustments));
-
-    return condition;
+    return condition.accept(
+        new RelOptUtil.RexInputConverter(
+            rexBuilder,
+            multiJoin.getJoinFields(origLeft, origRight),
+            multiJoin.getJoinFields(origRight, origLeft),
+            adjustments));
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java b/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
index 79538b464..6bf59cf93 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/LoptSemiJoinOptimizer.java
@@ -39,7 +39,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -237,11 +236,11 @@ private static int isSuitableFilter(LoptMultiJoin multiJoin, RexNode joinFilter,
     RelNode factRel = multiJoin.getJoinFactor(factIdx);
     RelNode dimRel = multiJoin.getJoinFactor(dimIdx);
     final JoinInfo joinInfo = JoinInfo.of(factRel, dimRel, semiJoinCondition);
-    assert joinInfo.leftKeys.size() > 0;
+    assert !joinInfo.leftKeys.isEmpty();
 
     // mutable copies
-    final List<Integer> leftKeys = Lists.newArrayList(joinInfo.leftKeys);
-    final List<Integer> rightKeys = Lists.newArrayList(joinInfo.rightKeys);
+    final List<Integer> leftKeys = new ArrayList<>(joinInfo.leftKeys);
+    final List<Integer> rightKeys = new ArrayList<>(joinInfo.rightKeys);
 
     // make sure all the fact table keys originate from the same table
     // and are simple column references
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java b/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
index e26f41122..2a3ee2245 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/MaterializedViewFilterScanRule.java
@@ -32,10 +32,10 @@
 import org.apache.calcite.tools.RelBuilderFactory;
 
 import com.google.common.base.Suppliers;
+import com.google.common.collect.ImmutableList;
 
 import org.immutables.value.Value;
 
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Supplier;
 
@@ -83,7 +83,7 @@ protected void apply(RelOptRuleCall call, Filter filter, TableScan scan) {
     final RelOptPlanner planner = call.getPlanner();
     final List<RelOptMaterialization> materializations = planner.getMaterializations();
     if (!materializations.isEmpty()) {
-      RelNode root = filter.copy(filter.getTraitSet(), Collections.singletonList(scan));
+      RelNode root = filter.copy(filter.getTraitSet(), ImmutableList.of(scan));
       List<RelOptMaterialization> applicableMaterializations =
           RelOptMaterializations.getApplicableMaterializations(root, materializations);
       for (RelOptMaterialization materialization : applicableMaterializations) {
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java b/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
index 333e8c163..46a2357d2 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/MultiJoin.java
@@ -33,7 +33,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -97,7 +96,7 @@ public MultiJoin(
       ImmutableMap<Integer, ImmutableIntList> joinFieldRefCountsMap,
       @Nullable RexNode postJoinFilter) {
     super(cluster, cluster.traitSetOf(Convention.NONE));
-    this.inputs = Lists.newArrayList(inputs);
+    this.inputs = new ArrayList<>(inputs);
     this.joinFilter = joinFilter;
     this.rowType = rowType;
     this.isFullOuterJoin = isFullOuterJoin;
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java b/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
index ae97616e8..5d8faaa70 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java
@@ -44,6 +44,8 @@
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.tools.RelBuilderFactory;
 
+import com.google.common.collect.ImmutableList;
+
 import org.immutables.value.Value;
 
 import java.util.Collections;
@@ -333,7 +335,7 @@ public <R extends SingleRel> RemoveEmptySingleRule(
       if (emptyValues.getConvention() != null) {
         traits = traits.replace(emptyValues.getConvention());
       }
-      emptyValues = emptyValues.copy(traits, Collections.emptyList());
+      emptyValues = emptyValues.copy(traits, ImmutableList.of());
       call.transformTo(emptyValues);
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java b/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
index e17f1ac88..5939dc12e 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/PushProjector.java
@@ -42,7 +42,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -210,7 +209,7 @@ public PushProjector(
 
     if (childRel instanceof Join) {
       Join join = (Join) childRel;
-      childFields = Lists.newArrayList(join.getLeft().getRowType().getFieldList());
+      childFields = new ArrayList<>(join.getLeft().getRowType().getFieldList());
       childFields.addAll(join.getRight().getRowType().getFieldList());
     } else {
       childFields = childRel.getRowType().getFieldList();
@@ -317,7 +316,7 @@ public PushProjector(
     // special expressions to preserve in the projection; otherwise,
     // there's no point in proceeding any further
     if (origProj == null) {
-      if (childPreserveExprs.size() == 0) {
+      if (childPreserveExprs.isEmpty()) {
         return null;
       }
 
@@ -329,14 +328,14 @@ public PushProjector(
         projRefs.set(0, nChildFields);
       }
       nProject = nChildFields;
-    } else if ((projRefs.cardinality() == nChildFields) && (childPreserveExprs.size() == 0)) {
+    } else if ((projRefs.cardinality() == nChildFields) && childPreserveExprs.isEmpty()) {
       return null;
     }
 
     // if nothing is being selected from the underlying rel, just
     // project the default expression passed in as a parameter or the
     // first column if there is no default expression
-    if ((projRefs.cardinality() == 0) && (childPreserveExprs.size() == 0)) {
+    if ((projRefs.cardinality() == 0) && childPreserveExprs.isEmpty()) {
       if (defaultExpr != null) {
         childPreserveExprs.add(defaultExpr);
       } else if (nChildFields == 1) {
@@ -419,12 +418,12 @@ public boolean locateAllRefs() {
       // if nothing is projected from the children, arbitrarily project
       // the first columns; this is necessary since Fennel doesn't
       // handle 0-column projections
-      if ((nProject == 0) && (childPreserveExprs.size() == 0)) {
+      if ((nProject == 0) && childPreserveExprs.isEmpty()) {
         projRefs.set(0);
         nProject = 1;
       }
       if (childRel instanceof Join) {
-        if ((nRightProject == 0) && (rightPreserveExprs.size() == 0)) {
+        if ((nRightProject == 0) && rightPreserveExprs.isEmpty()) {
           projRefs.set(nFields);
           nRightProject = 1;
         }
@@ -435,8 +434,8 @@ public boolean locateAllRefs() {
     // referenced and there are no special preserve expressions; note
     // that we need to do this check after we've handled the 0-column
     // project cases
-    boolean allFieldsReferenced = IntStream.range(0, nChildFields).allMatch(i -> projRefs.get(i));
-    if (allFieldsReferenced && childPreserveExprs.size() == 0 && rightPreserveExprs.size() == 0) {
+    boolean allFieldsReferenced = IntStream.range(0, nChildFields).allMatch(projRefs::get);
+    if (allFieldsReferenced && childPreserveExprs.isEmpty() && rightPreserveExprs.isEmpty()) {
       return true;
     }
 
@@ -484,7 +483,7 @@ public Project createProjectRefsAndExprs(RelNode projChild, boolean adjust, bool
     // add on the expressions that need to be preserved, converting the
     // arguments to reference the projected columns (if necessary)
     int[] adjustments = {};
-    if ((preserveExprs.size() > 0) && adjust) {
+    if (!preserveExprs.isEmpty() && adjust) {
       adjustments = new int[childFields.size()];
       for (int idx = offset; idx < childFields.size(); idx++) {
         adjustments[idx] = -offset;
@@ -503,7 +502,7 @@ public Project createProjectRefsAndExprs(RelNode projChild, boolean adjust, bool
 
       List<RelDataType> typeList =
           projChild.getRowType().getFieldList().stream()
-              .map(field -> field.getType())
+              .map(RelDataTypeField::getType)
               .collect(Collectors.toList());
       RexUtil.FixNullabilityShuttle fixer =
           new RexUtil.FixNullabilityShuttle(projChild.getCluster().getRexBuilder(), typeList);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
index bca502d59..b5f9b89dc 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ReduceDecimalsRule.java
@@ -631,8 +631,7 @@ private CastExpander(RexBuilder builder) {
       }
 
       if (!SqlTypeUtil.isExactNumeric(fromType) || !SqlTypeUtil.isExactNumeric(toType)) {
-        throw Util.needToImplement(
-            "Cast from '" + fromType.toString() + "' to '" + toType.toString() + "'");
+        throw Util.needToImplement("Cast from '" + fromType + "' to '" + toType + "'");
       }
       int fromScale = fromType.getScale();
       int toScale = toType.getScale();
@@ -1019,8 +1018,7 @@ private CastArgAsTypeExpander(RexBuilder builder) {
       }
 
       RexNode ret = builder.makeCall(call.getType(), call.getOperator(), opBuilder.build());
-      ret = ensureType(call.getType(), ret, true);
-      return ret;
+      return ensureType(call.getType(), ret, true);
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java b/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
index 68ace4725..e54daaa64 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/ReduceExpressionsRule.java
@@ -310,7 +310,7 @@ public ProjectReduceExpressionsRule(
       final Project project = call.rel(0);
       final RelMetadataQuery mq = call.getMetadataQuery();
       final RelOptPredicateList predicates = mq.getPulledUpPredicates(project.getInput());
-      final List<RexNode> expList = Lists.newArrayList(project.getProjects());
+      final List<RexNode> expList = new ArrayList<>(project.getProjects());
       if (reduceExpressions(
           project,
           expList,
@@ -734,7 +734,7 @@ protected static boolean reduceExpressions(
       boolean treatDynamicCallsAsConstant) {
     final RelOptCluster cluster = rel.getCluster();
     final RexBuilder rexBuilder = cluster.getRexBuilder();
-    final List<RexNode> originExpList = Lists.newArrayList(expList);
+    final List<RexNode> originExpList = new ArrayList<>(expList);
     final RexExecutor executor = Util.first(cluster.getPlanner().getExecutor(), RexUtil.EXECUTOR);
     final RexSimplify simplify = new RexSimplify(rexBuilder, predicates, executor);
 
@@ -785,10 +785,10 @@ protected static boolean reduceExpressionsInternal(
       return changed;
     }
 
-    final List<RexNode> constExps2 = Lists.newArrayList(constExps);
+    final List<RexNode> constExps2 = new ArrayList<>(constExps);
     if (!predicates.constantMap.isEmpty()) {
       final List<Map.Entry<RexNode, RexNode>> pairs =
-          Lists.newArrayList(predicates.constantMap.entrySet());
+          new ArrayList<>(predicates.constantMap.entrySet());
       RexReplacer replacer =
           new RexReplacer(
               simplify,
@@ -940,7 +940,7 @@ public static RexCall pushPredicateIntoCase(RexCall call) {
 
   /** Converts op(arg0, ..., argOrdinal, ..., argN) to op(arg0,..., node, ..., argN). */
   protected static RexNode substitute(RexCall call, int ordinal, RexNode node) {
-    final List<RexNode> newOperands = Lists.newArrayList(call.getOperands());
+    final List<RexNode> newOperands = new ArrayList<>(call.getOperands());
     newOperands.set(ordinal, node);
     return call.clone(call.getType(), newOperands);
   }
@@ -982,8 +982,7 @@ protected static class RexReplacer extends RexShuttle {
       if (node != null) {
         return node;
       }
-      node = super.visitCall(call);
-      return node;
+      return super.visitCall(call);
     }
 
     private @Nullable RexNode visit(final RexNode call) {
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
index 03ebfa6ce..c31f30948 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewAggregateRule.java
@@ -62,6 +62,7 @@
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.BiMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
@@ -568,7 +569,7 @@ public abstract class MaterializedViewAggregateRule<C extends MaterializedViewAg
       }
       // Target is coarser level of aggregation. Generate an aggregate.
       final ImmutableMultimap.Builder<Integer, Integer> rewritingMappingB =
-          ImmutableMultimap.builder();
+          ImmutableListMultimap.builder();
       final ImmutableBitSet.Builder groupSetB = ImmutableBitSet.builder();
       for (int i = 0; i < queryAggregate.getGroupCount(); i++) {
         final int targetIdx = aggregateMapping.getTargetOpt(i);
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
index b3227dcda..ab1767247 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewJoinRule.java
@@ -44,6 +44,8 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Materialized view rewriting for join.
  *
@@ -281,17 +283,12 @@ public abstract class MaterializedViewJoinRule<C extends MaterializedViewRule.Co
         // Bail out
         return null;
       }
-      if (lineages.size() != 1) {
-        throw new IllegalStateException(
-            "We only support project - filter - join, "
-                + "thus expression lineage should map to a single expression, got: '"
-                + lineages
-                + "' for expr '"
-                + expr
-                + "' in node '"
-                + node
-                + "'");
-      }
+      checkState(
+          lineages.size() == 1,
+          "We only support project - filter - join, thus expression lineage should map to a single expression, got: '%s' for expr '%s' in node '%s'",
+          lineages,
+          expr,
+          node);
       // Rewrite expr. Take first element from the corresponding equivalence class
       // (no need to swap the table references following the table mapping)
       exprsLineage.add(
diff --git a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
index 8f4171db8..d029bd79f 100644
--- a/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
+++ b/core/src/main/java/org/apache/calcite/rel/rules/materialize/MaterializedViewRule.java
@@ -77,6 +77,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -1128,17 +1130,12 @@ protected NodeLineage generateSwapTableColumnReferencesLineage(
         // Next expression
         continue;
       }
-      if (lineages.size() != 1) {
-        throw new IllegalStateException(
-            "We only support project - filter - join, "
-                + "thus expression lineage should map to a single expression, got: '"
-                + lineages
-                + "' for expr '"
-                + expr
-                + "' in node '"
-                + node
-                + "'");
-      }
+      checkState(
+          lineages.size() == 1,
+          "We only support project - filter - join, thus expression lineage should map to a single expression, got: '%s' for expr '%s' in node '%s'",
+          lineages,
+          expr,
+          node);
       // Rewrite expr. First we swap the table references following the table
       // mapping, then we take first element from the corresponding equivalence class
       final RexNode e =
@@ -1172,17 +1169,12 @@ protected NodeLineage generateSwapColumnTableReferencesLineage(
         // Next expression
         continue;
       }
-      if (lineages.size() != 1) {
-        throw new IllegalStateException(
-            "We only support project - filter - join, "
-                + "thus expression lineage should map to a single expression, got: '"
-                + lineages
-                + "' for expr '"
-                + expr
-                + "' in node '"
-                + node
-                + "'");
-      }
+      checkState(
+          lineages.size() == 1,
+          "We only support project - filter - join, thus expression lineage should map to a single expression, got: '%s' for expr '%s' in node '%s'",
+          lineages,
+          expr,
+          node);
       // Rewrite expr. First we take first element from the corresponding
       // equivalence class, then we swap the table references following the
       // table mapping
@@ -1406,7 +1398,7 @@ protected void addEquivalenceClass(RexTableInputRef p1, RexTableInputRef p2) {
 
     protected Map<RexTableInputRef, Set<RexTableInputRef>> getEquivalenceClassesMap() {
       if (cacheEquivalenceClassesMap == null) {
-        cacheEquivalenceClassesMap = ImmutableMap.copyOf(nodeToEquivalenceClass);
+        cacheEquivalenceClassesMap = nodeToEquivalenceClass;
       }
       return cacheEquivalenceClassesMap;
     }
@@ -1445,8 +1437,8 @@ protected static class NodeLineage {
 
     private NodeLineage(
         Map<RexNode, Integer> exprsLineage, Map<RexNode, Integer> exprsLineageLosslessCasts) {
-      this.exprsLineage = ImmutableMap.copyOf(exprsLineage);
-      this.exprsLineageLosslessCasts = ImmutableMap.copyOf(exprsLineageLosslessCasts);
+      this.exprsLineage = exprsLineage;
+      this.exprsLineageLosslessCasts = exprsLineageLosslessCasts;
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java b/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java
index e2f91a12c..a6e897848 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelCrossType.java
@@ -40,7 +40,7 @@ public class RelCrossType extends RelDataTypeImpl {
   public RelCrossType(List<RelDataType> types, List<RelDataTypeField> fields) {
     super(fields);
     this.types = ImmutableList.copyOf(types);
-    assert types.size() >= 1;
+    assert !types.isEmpty();
     for (RelDataType type : types) {
       assert !(type instanceof RelCrossType);
     }
@@ -71,7 +71,7 @@ public List<RelDataType> getTypes() {
       if (withDetail) {
         sb.append(type.e.getFullTypeString());
       } else {
-        sb.append(type.e.toString());
+        sb.append(type.e);
       }
     }
     sb.append(")");
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
index 1ee79cc60..e7a1863cf 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeFactoryImpl.java
@@ -191,7 +191,7 @@ private RelDataType createStructType(
       List<RelDataType> types, SqlTypeMappingRule mappingRule) {
     requireNonNull(types, "types");
     requireNonNull(mappingRule, "mappingRule");
-    checkArgument(types.size() >= 1, "types.size >= 1");
+    checkArgument(!types.isEmpty(), "types.size >= 1");
     RelDataType type0 = types.get(0);
     if (type0.isStruct()) {
       return leastRestrictiveStructuredType(types);
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
index 9df8a3de7..976d61a53 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeImpl.java
@@ -38,6 +38,8 @@
 import java.util.Map;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -90,10 +92,11 @@ protected RelDataTypeImpl() {
 
   @Override public @Nullable RelDataTypeField getField(
       String fieldName, boolean caseSensitive, boolean elideRecord) {
-    if (fieldList == null) {
-      throw new IllegalStateException(
-          "Trying to access field " + fieldName + " in a type with no fields: " + this);
-    }
+    checkState(
+        fieldList != null,
+        "Trying to access field %s in a type with no fields: %s",
+        fieldName,
+        this);
     final Map<String, RelDataTypeField> fieldMap = getFieldMap();
     if (caseSensitive && fieldMap != null) {
       RelDataTypeField field = fieldMap.get(fieldName);
@@ -123,7 +126,7 @@ protected RelDataTypeImpl() {
       }
     }
     // Extra field
-    if (fieldList.size() > 0) {
+    if (!fieldList.isEmpty()) {
       final RelDataTypeField lastField = Iterables.getLast(fieldList);
       if (lastField.getName().equals("_extra")) {
         return new RelDataTypeFieldImpl(fieldName, -1, lastField.getType());
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
index 993b47594..1eedee934 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelDataTypeSystem.java
@@ -224,9 +224,7 @@ default boolean shouldUseDoubleMultiplication(
         precision = Math.min(precision, getMaxNumericPrecision());
 
         RelDataType ret;
-        ret = typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
-
-        return ret;
+        return typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
       }
     }
 
@@ -288,9 +286,7 @@ default boolean shouldUseDoubleMultiplication(
         assert precision > 0;
 
         RelDataType ret;
-        ret = typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
-
-        return ret;
+        return typeFactory.createSqlType(SqlTypeName.DECIMAL, precision, scale);
       }
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java b/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
index 75daabc51..123564214 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/RelRecordType.java
@@ -19,8 +19,6 @@
 import org.apache.calcite.linq4j.Ord;
 import org.apache.calcite.sql.type.SqlTypeName;
 
-import com.google.common.collect.ImmutableMap;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.io.Serializable;
@@ -66,7 +64,7 @@ public RelRecordType(StructKind kind, List<RelDataTypeField> fields, boolean nul
           map.putIfAbsent("", f);
         }
       }
-      this.fieldNameMap = ImmutableMap.copyOf(map);
+      this.fieldNameMap = map;
     } else {
       this.fieldNameMap = null;
     }
@@ -136,7 +134,7 @@ public RelRecordType(List<RelDataTypeField> fields) {
       if (withDetail) {
         sb.append(field.getType().getFullTypeString());
       } else {
-        sb.append(field.getType().toString());
+        sb.append(field.getType());
       }
       sb.append(" ");
       sb.append(field.getName());
diff --git a/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java b/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java
index b214ed245..fb1929e09 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/TimeFrameSet.java
@@ -35,6 +35,8 @@
 import java.util.NavigableMap;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.avatica.util.DateTimeUtils.MILLIS_PER_DAY;
 
 import static java.lang.Math.floorDiv;
@@ -82,9 +84,7 @@ public static Builder builder() {
    */
   public TimeFrame get(String name) {
     TimeFrame timeFrame = getOpt(name);
-    if (timeFrame == null) {
-      throw new IllegalArgumentException("unknown frame: " + name);
-    }
+    checkArgument(timeFrame != null, "unknown frame: %s", name);
     return timeFrame;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java b/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java
index c758478f5..b08567ee9 100644
--- a/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java
+++ b/core/src/main/java/org/apache/calcite/rel/type/TimeFrames.java
@@ -27,6 +27,7 @@
 import org.apache.commons.math3.fraction.BigFraction;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Iterables;
@@ -43,6 +44,8 @@
 import java.util.Set;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.avatica.util.DateTimeUtils.EPOCH_JULIAN;
 
 import static java.lang.Math.floorDiv;
@@ -241,7 +244,7 @@ static class BuilderImpl implements TimeFrameSet.Builder {
     final MonotonicSupplier<TimeFrameSet> frameSetSupplier = new MonotonicSupplier<>();
     final Map<String, TimeFrameImpl> map = new LinkedHashMap<>();
     final ImmutableMultimap.Builder<TimeFrameImpl, TimeFrameImpl> rollupList =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
 
     @Override public TimeFrameSet build() {
       final TimeFrameSet frameSet = new TimeFrameSet(ImmutableMap.copyOf(map), rollupList.build());
@@ -262,9 +265,7 @@ static BigInteger toBigInteger(Number number) {
     /** Returns the time frame with the given name, or throws {@link IllegalArgumentException}. */
     TimeFrameImpl getFrame(String name) {
       final TimeFrameImpl timeFrame = map.get(name);
-      if (timeFrame == null) {
-        throw new IllegalArgumentException("unknown frame: " + name);
-      }
+      checkArgument(timeFrame != null, "unknown frame: %s", name);
       return timeFrame;
     }
 
diff --git a/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java b/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
index f76043603..fd1ab5a45 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexAnalyzer.java
@@ -69,8 +69,8 @@ private static List<Comparable> getComparables(RexNode variable) {
         break;
       case INTEGER:
         values.add(BigDecimal.valueOf(-1L));
-        values.add(BigDecimal.valueOf(0L));
-        values.add(BigDecimal.valueOf(1L));
+        values.add(BigDecimal.ZERO);
+        values.add(BigDecimal.ONE);
         values.add(BigDecimal.valueOf(1_000_000L));
         break;
       case DECIMAL:
diff --git a/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java b/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java
index cd1947b13..d71b3912b 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexBiVisitor.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.rex;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -69,7 +67,7 @@ default void visitList(Iterable<? extends RexNode> exprs, P arg, List<R> out) {
   default List<R> visitList(Iterable<? extends RexNode> exprs, P arg) {
     final List<R> out = new ArrayList<>();
     visitList(exprs, arg, out);
-    return ImmutableList.copyOf(out);
+    return out;
   }
 
   /** Visits a list of expressions. */
diff --git a/core/src/main/java/org/apache/calcite/rex/RexBuilder.java b/core/src/main/java/org/apache/calcite/rex/RexBuilder.java
index d8844924d..6a8bb0302 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexBuilder.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexBuilder.java
@@ -76,6 +76,8 @@
 import java.util.function.IntPredicate;
 import java.util.stream.Collectors;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Util.verifyNotNull;
 
@@ -937,10 +939,11 @@ protected RexLiteral makeLiteral(@Nullable Comparable o, RelDataType type, SqlTy
       default:
         break;
     }
-    if (typeName == SqlTypeName.DECIMAL && !SqlTypeUtil.isValidDecimalValue((BigDecimal) o, type)) {
-      throw new IllegalArgumentException(
-          "Cannot convert " + o + " to " + type + " due to overflow");
-    }
+    checkArgument(
+        typeName != SqlTypeName.DECIMAL || SqlTypeUtil.isValidDecimalValue((BigDecimal) o, type),
+        "Cannot convert %s to %s due to overflow",
+        o,
+        type);
     return new RexLiteral(o, type, typeName);
   }
 
@@ -1631,7 +1634,7 @@ public RexNode makeLiteral(
                 "%s is not compatible with %s, try to use makeExactLiteral",
                 o.getClass().getCanonicalName(),
                 type.getSqlTypeName());
-        return new BigDecimal(((Number) o).longValue());
+        return BigDecimal.valueOf(((Number) o).longValue());
       case FLOAT:
         if (o instanceof BigDecimal) {
           return o;
diff --git a/core/src/main/java/org/apache/calcite/rex/RexCall.java b/core/src/main/java/org/apache/calcite/rex/RexCall.java
index ed89832d5..627c1b5d1 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexCall.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexCall.java
@@ -147,7 +147,7 @@ private static String computeDigest(RexLiteral literal, RexDigestIncludeType inc
 
   protected String computeDigest(boolean withType) {
     final StringBuilder sb = new StringBuilder(op.getName());
-    if ((operands.size() == 0) && (op.getSyntax() == SqlSyntax.FUNCTION_ID)) {
+    if (operands.isEmpty() && (op.getSyntax() == SqlSyntax.FUNCTION_ID)) {
       // Don't print params for empty arg list. For example, we want
       // "SYSTEM_USER", not "SYSTEM_USER()".
     } else {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java b/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
index 44c6392a9..9120f6290 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexCallBinding.java
@@ -55,7 +55,7 @@ public RexCallBinding(
       List<RelCollation> inputCollations) {
     super(typeFactory, sqlOperator);
     this.operands = ImmutableList.copyOf(operands);
-    this.inputCollations = ImmutableList.copyOf(inputCollations);
+    this.inputCollations = inputCollations;
   }
 
   /** Creates a binding of the appropriate type. */
diff --git a/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java b/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java
index 22864d5d5..243174524 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexFieldAccess.java
@@ -76,7 +76,9 @@ private static void checkValid(RexNode expr, RelDataTypeField field) {
         fieldIdx >= 0
             && fieldIdx < exprType.getFieldList().size()
             && exprType.getFieldList().get(fieldIdx).equals(field),
-        "Field " + field + " does not exist for expression " + expr);
+        "Field %s does not exist for expression %s",
+        field,
+        expr);
   }
 
   public RelDataTypeField getField() {
@@ -119,7 +121,6 @@ public RexNode getReferenceExpr() {
 
   @Override public int hashCode() {
     int result = expr.hashCode();
-    result = 31 * result + field.hashCode();
-    return result;
+    return 31 * result + field.hashCode();
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java b/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
index 279f02755..0d5dc6875 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexInterpreter.java
@@ -31,7 +31,6 @@
 import org.apache.calcite.util.TimestampString;
 import org.apache.calcite.util.Util;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.RangeSet;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -96,7 +95,7 @@ public class RexInterpreter implements RexVisitor<Comparable> {
    * @param environment Values of certain expressions (usually {@link RexInputRef}s)
    */
   private RexInterpreter(Map<RexNode, Comparable> environment) {
-    this.environment = ImmutableMap.copyOf(environment);
+    this.environment = environment;
   }
 
   /** Evaluates an expression in an environment. */
@@ -190,9 +189,17 @@ private Comparable getOrUnbound(RexNode e) {
       case LESS_THAN_OR_EQUAL:
         return compare(values, c -> c <= 0);
       case AND:
-        return values.stream().map(Truthy::of).min(Comparator.naturalOrder()).get().toComparable();
+        return values.stream()
+            .map(Truthy::of)
+            .min(Comparator.naturalOrder())
+            .orElseThrow()
+            .toComparable();
       case OR:
-        return values.stream().map(Truthy::of).max(Comparator.naturalOrder()).get().toComparable();
+        return values.stream()
+            .map(Truthy::of)
+            .max(Comparator.naturalOrder())
+            .orElseThrow()
+            .toComparable();
       case NOT:
         return not(values.get(0));
       case CASE:
@@ -416,8 +423,8 @@ private static BigDecimal number(Comparable comparable) {
             : comparable instanceof Long
                     || comparable instanceof Integer
                     || comparable instanceof Short
-                ? new BigDecimal(((Number) comparable).longValue())
-                : new BigDecimal(((Number) comparable).doubleValue());
+                ? BigDecimal.valueOf(((Number) comparable).longValue())
+                : BigDecimal.valueOf(((Number) comparable).doubleValue());
   }
 
   private static Comparable compare(List<Comparable> values, IntPredicate p) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexLiteral.java b/core/src/main/java/org/apache/calcite/rex/RexLiteral.java
index 08bbfa16e..4ab1b505b 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexLiteral.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexLiteral.java
@@ -630,11 +630,11 @@ private static void appendAsJava(
         break;
       case BOOLEAN:
         assert value instanceof Boolean;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case DECIMAL:
         assert value instanceof BigDecimal;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case DOUBLE:
         assert value instanceof BigDecimal;
@@ -643,7 +643,7 @@ private static void appendAsJava(
       case BIGINT:
         assert value instanceof BigDecimal;
         long narrowLong = ((BigDecimal) value).longValue();
-        sb.append(String.valueOf(narrowLong));
+        sb.append(narrowLong);
         sb.append('L');
         break;
       case BINARY:
@@ -664,22 +664,22 @@ private static void appendAsJava(
       case SYMBOL:
         assert value instanceof Enum;
         sb.append("FLAG(");
-        sb.append(value.toString());
+        sb.append(value);
         sb.append(")");
         break;
       case DATE:
         assert value instanceof DateString;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case TIME:
       case TIME_WITH_LOCAL_TIME_ZONE:
         assert value instanceof TimeString;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case TIMESTAMP:
       case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
         assert value instanceof TimestampString;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case INTERVAL_YEAR:
       case INTERVAL_YEAR_MONTH:
@@ -695,7 +695,7 @@ private static void appendAsJava(
       case INTERVAL_MINUTE_SECOND:
       case INTERVAL_SECOND:
         assert value instanceof BigDecimal;
-        sb.append(value.toString());
+        sb.append(value);
         break;
       case MULTISET:
       case ROW:
diff --git a/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java b/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java
index af7551b07..30bd525f0 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexMultisetUtil.java
@@ -87,7 +87,7 @@ public static boolean containsMixing(RexNode node) {
    *     expression <em>is</em> a multiset.
    */
   public static boolean containsMultiset(final RexNode node, boolean deep) {
-    return null != findFirstMultiset(node, deep);
+    return findFirstMultiset(node, deep) != null;
   }
 
   /** Returns whether a list of expressions contains a multiset. */
@@ -131,7 +131,7 @@ public static boolean isMultisetCast(RexCall call) {
     RexCall firstOne = null;
     for (SqlOperator op : MULTISET_OPERATORS) {
       firstOne = RexUtil.findOperatorCall(op, call);
-      if (null != firstOne) {
+      if (firstOne != null) {
         if (firstOne.getOperator().equals(SqlStdOperatorTable.CAST) && !isMultisetCast(firstOne)) {
           firstOne = null;
           continue;
diff --git a/core/src/main/java/org/apache/calcite/rex/RexProgram.java b/core/src/main/java/org/apache/calcite/rex/RexProgram.java
index 2a57ef326..94df0a8b3 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexProgram.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexProgram.java
@@ -57,6 +57,8 @@
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -117,7 +119,7 @@ public RexProgram(
       RelDataType outputRowType) {
     this.inputRowType = inputRowType;
     this.exprs = ImmutableList.copyOf(exprs);
-    this.projects = ImmutableList.copyOf(projects);
+    this.projects = projects;
     this.condition = condition;
     this.outputRowType = outputRowType;
     assert isValid(Litmus.THROW, null);
@@ -348,11 +350,12 @@ public static RexProgram createIdentity(RelDataType rowType) {
    * output fields.
    */
   public static RexProgram createIdentity(RelDataType rowType, RelDataType outputRowType) {
-    if (rowType != outputRowType
-        && !Pair.right(rowType.getFieldList()).equals(Pair.right(outputRowType.getFieldList()))) {
-      throw new IllegalArgumentException(
-          "field type mismatch: " + rowType + " vs. " + outputRowType);
-    }
+    checkArgument(
+        rowType == outputRowType
+            || Pair.right(rowType.getFieldList()).equals(Pair.right(outputRowType.getFieldList())),
+        "field type mismatch: %s vs. %s",
+        rowType,
+        outputRowType);
     final List<RelDataTypeField> fields = rowType.getFieldList();
     final List<RexLocalRef> projectRefs = new ArrayList<>();
     final List<RexInputRef> refs = new ArrayList<>();
diff --git a/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java b/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
index 9dd51748c..f25e2b8b2 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexProgramBuilder.java
@@ -920,8 +920,7 @@ protected RegisterInputShuttle(boolean valid) {
 
       // Return a reference to the N'th expression, which should be
       // equivalent.
-      final RexLocalRef ref = localRefList.get(index);
-      return ref;
+      return localRefList.get(index);
     }
 
     @Override public RexNode visitLocalRef(RexLocalRef local) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexSimplify.java b/core/src/main/java/org/apache/calcite/rex/RexSimplify.java
index 75848ee6c..61a37c9b5 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexSimplify.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexSimplify.java
@@ -1413,7 +1413,7 @@ static boolean isSafeExpression(RexNode r) {
     // but not interfere with the normal simplification recursion
     List<CaseBranch> branches = new ArrayList<>();
     for (CaseBranch branch : inputBranches) {
-      if ((branches.size() > 0 && !isSafeExpression(branch.cond))
+      if ((!branches.isEmpty() && !isSafeExpression(branch.cond))
           || !isSafeExpression(branch.value)) {
         return null;
       }
@@ -1427,8 +1427,7 @@ static boolean isSafeExpression(RexNode r) {
       branches.add(new CaseBranch(cond, value));
     }
 
-    result = simplifyBooleanCaseGeneric(rexBuilder, branches);
-    return result;
+    return simplifyBooleanCaseGeneric(rexBuilder, branches);
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/rex/RexSlot.java b/core/src/main/java/org/apache/calcite/rex/RexSlot.java
index 38e0577c3..9c1de2916 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexSlot.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexSlot.java
@@ -21,6 +21,8 @@
 import java.util.AbstractList;
 import java.util.concurrent.CopyOnWriteArrayList;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Abstract base class for {@link RexInputRef} and {@link RexLocalRef}. */
 public abstract class RexSlot extends RexVariable {
   // ~ Instance fields --------------------------------------------------------
@@ -78,9 +80,7 @@ private static AbstractList<String> fromTo(
         try {
           return super.get(index);
         } catch (IndexOutOfBoundsException e) {
-          if (index < 0) {
-            throw new IllegalArgumentException();
-          }
+          checkArgument(index >= 0);
           // Double-checked locking, but safe because CopyOnWriteArrayList.array
           // is marked volatile, and size() uses array.length.
           synchronized (this) {
diff --git a/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java b/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java
index 55883f5df..a30fd9d8b 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexSubQuery.java
@@ -36,6 +36,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Scalar expression that represents an IN, EXISTS or scalar sub-query. */
 public class RexSubQuery extends RexCall {
   public final RelNode rel;
@@ -107,9 +109,7 @@ public static RexSubQuery unique(RelNode rel) {
   /** Creates a scalar sub-query. */
   public static RexSubQuery scalar(RelNode rel) {
     final List<RelDataTypeField> fieldList = rel.getRowType().getFieldList();
-    if (fieldList.size() != 1) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(fieldList.size() == 1);
     final RelDataTypeFactory typeFactory = rel.getCluster().getTypeFactory();
     final RelDataType type =
         typeFactory.createTypeWithNullability(fieldList.get(0).getType(), true);
diff --git a/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java b/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
index 79504fe3f..d142ba063 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexTableInputRef.java
@@ -49,7 +49,7 @@ public class RexTableInputRef extends RexInputRef {
   private RexTableInputRef(RelTableRef tableRef, int index, RelDataType type) {
     super(index, type);
     this.tableRef = tableRef;
-    this.digest = tableRef.toString() + ".$" + index;
+    this.digest = tableRef + ".$" + index;
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/rex/RexTransformer.java b/core/src/main/java/org/apache/calcite/rex/RexTransformer.java
index 1851d9089..fd3c7b8df 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexTransformer.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexTransformer.java
@@ -105,7 +105,7 @@ private RexNode transformNullSemantics(RexNode node) {
 
     // Special case when we have a Literal, Parameter or Identifier directly
     // as an operand to IS TRUE or IS FALSE.
-    if (null != directlyUnderIs) {
+    if (directlyUnderIs != null) {
       RexCall call = (RexCall) node;
       assert isParentsCount > 0 : "Stack should not be empty";
       assert 1 == call.operands.size();
@@ -117,13 +117,11 @@ private RexNode transformNullSemantics(RexNode node) {
           RexNode notNullNode = rexBuilder.makeCall(SqlStdOperatorTable.IS_NOT_NULL, operand);
           RexNode boolNode = rexBuilder.makeLiteral(directlyUnderIs.booleanValue());
           RexNode eqNode = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operand, boolNode);
-          RexNode andBoolNode = rexBuilder.makeCall(SqlStdOperatorTable.AND, notNullNode, eqNode);
+          return rexBuilder.makeCall(SqlStdOperatorTable.AND, notNullNode, eqNode);
 
-          return andBoolNode;
         } else {
           RexNode boolNode = rexBuilder.makeLiteral(directlyUnderIs.booleanValue());
-          RexNode andBoolNode = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, node, boolNode);
-          return andBoolNode;
+          return rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, node, boolNode);
         }
       }
 
@@ -139,7 +137,7 @@ private RexNode transformNullSemantics(RexNode node) {
         operands.add(transformNullSemantics(operand));
       }
 
-      if (null != directlyUnderIs) {
+      if (directlyUnderIs != null) {
         isParentsCount--;
         directlyUnderIs = null;
         return operands.get(0);
@@ -163,19 +161,17 @@ private RexNode transformNullSemantics(RexNode node) {
         }
 
         RexNode intoFinalAnd = null;
-        if ((null != isNotNullOne) && (null != isNotNullTwo)) {
+        if (isNotNullOne != null && isNotNullTwo != null) {
           intoFinalAnd = rexBuilder.makeCall(SqlStdOperatorTable.AND, isNotNullOne, isNotNullTwo);
-        } else if (null != isNotNullOne) {
+        } else if (isNotNullOne != null) {
           intoFinalAnd = isNotNullOne;
-        } else if (null != isNotNullTwo) {
+        } else if (isNotNullTwo != null) {
           intoFinalAnd = isNotNullTwo;
         }
 
-        if (null != intoFinalAnd) {
-          RexNode andNullAndCheckNode =
-              rexBuilder.makeCall(
-                  SqlStdOperatorTable.AND, intoFinalAnd, call.clone(call.getType(), operands));
-          return andNullAndCheckNode;
+        if (intoFinalAnd != null) {
+          return rexBuilder.makeCall(
+              SqlStdOperatorTable.AND, intoFinalAnd, call.clone(call.getType(), operands));
         }
 
         // if come here no need to do anything
diff --git a/core/src/main/java/org/apache/calcite/rex/RexUtil.java b/core/src/main/java/org/apache/calcite/rex/RexUtil.java
index 443062a21..26b4cc1a6 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexUtil.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexUtil.java
@@ -157,7 +157,7 @@ public static boolean isNullLiteral(RexNode node, boolean allowCast) {
     if (node instanceof RexLiteral) {
       RexLiteral literal = (RexLiteral) node;
       if (literal.getTypeName() == SqlTypeName.NULL) {
-        assert null == literal.getValue();
+        assert literal.getValue() == null;
         return true;
       } else {
         // We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as
diff --git a/core/src/main/java/org/apache/calcite/rex/RexVisitor.java b/core/src/main/java/org/apache/calcite/rex/RexVisitor.java
index c27f55758..0eaf1a33e 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexVisitor.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexVisitor.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.rex;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -70,7 +68,7 @@ default void visitList(Iterable<? extends RexNode> exprs, List<R> out) {
   default List<R> visitList(Iterable<? extends RexNode> exprs) {
     final List<R> out = new ArrayList<>();
     visitList(exprs, out);
-    return ImmutableList.copyOf(out);
+    return out;
   }
 
   /** Visits a list of expressions. */
diff --git a/core/src/main/java/org/apache/calcite/rex/RexWindow.java b/core/src/main/java/org/apache/calcite/rex/RexWindow.java
index 8722b4cab..a7270be2c 100644
--- a/core/src/main/java/org/apache/calcite/rex/RexWindow.java
+++ b/core/src/main/java/org/apache/calcite/rex/RexWindow.java
@@ -119,7 +119,7 @@ StringBuilder appendDigest(StringBuilder sb, boolean allowFraming) {
 
   private StringBuilder appendDigest_(StringBuilder sb, boolean allowFraming) {
     final int initialLength = sb.length();
-    if (partitionKeys.size() > 0) {
+    if (!partitionKeys.isEmpty()) {
       sb.append("PARTITION BY ");
       for (int i = 0; i < partitionKeys.size(); i++) {
         if (i > 0) {
@@ -128,7 +128,7 @@ private StringBuilder appendDigest_(StringBuilder sb, boolean allowFraming) {
         sb.append(partitionKeys.get(i));
       }
     }
-    if (orderKeys.size() > 0) {
+    if (!orderKeys.isEmpty()) {
       sb.append(sb.length() > initialLength ? " ORDER BY " : "ORDER BY ");
       for (int i = 0; i < orderKeys.size(); i++) {
         if (i > 0) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java b/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java
index b69f1cb4f..896844b0b 100644
--- a/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java
+++ b/core/src/main/java/org/apache/calcite/runtime/AddPointOperation.java
@@ -20,6 +20,8 @@
 import org.locationtech.jts.geom.Geometry;
 import org.locationtech.jts.geom.util.GeometryEditor;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Geometry editor operation that adds a point to a geometry. */
 public class AddPointOperation extends GeometryEditor.CoordinateOperation {
 
@@ -33,9 +35,7 @@ public AddPointOperation(Geometry point, int index) {
   }
 
   @Override public Coordinate[] edit(Coordinate[] coordinates, Geometry geometry) {
-    if (index < 0 || index > coordinates.length) {
-      throw new IllegalArgumentException("Invalid index: " + index);
-    }
+    checkArgument(index >= 0 && index <= coordinates.length, "Invalid index: %s", index);
     Coordinate[] newCoordinates = new Coordinate[coordinates.length + 1];
     for (int i = 0; i < index; i++) {
       newCoordinates[i] = (Coordinate) coordinates[i].clone();
diff --git a/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java b/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
index 291c6c5f4..eb3d12a4d 100644
--- a/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
+++ b/core/src/main/java/org/apache/calcite/runtime/AutomatonBuilder.java
@@ -26,12 +26,13 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.ArrayList;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
+import static java.util.Map.Entry.comparingByValue;
+
 /** Builds a state-transition graph for deterministic finite automaton. */
 public class AutomatonBuilder {
   private final Map<String, Integer> symbolIds = new HashMap<>();
@@ -109,7 +110,7 @@ public Automaton build() {
     // starting from zero.
     final ImmutableList<String> symbolNames =
         symbolIds.entrySet().stream()
-            .sorted(Comparator.comparingInt(Map.Entry::getValue))
+            .sorted(comparingByValue())
             .map(Map.Entry::getKey)
             .collect(Util.toImmutableList());
     return new Automaton(
diff --git a/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java b/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java
index 0493d9c1f..a29adfb4e 100644
--- a/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java
+++ b/core/src/main/java/org/apache/calcite/runtime/BufferStyle.java
@@ -16,10 +16,14 @@
  */
 package org.apache.calcite.runtime;
 
+import com.google.common.base.Strings;
+
 import org.locationtech.jts.operation.buffer.BufferParameters;
 
 import java.util.Locale;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** A parser for buffer styles as defined by PostGIS. */
 public class BufferStyle {
 
@@ -34,13 +38,11 @@ public class BufferStyle {
   public BufferStyle(String style) {
     String[] parameters = style.toLowerCase(Locale.ROOT).split(" ");
     for (String parameter : parameters) {
-      if (parameter == null || parameter.isEmpty()) {
+      if (Strings.isNullOrEmpty(parameter)) {
         continue;
       }
       String[] keyValue = parameter.split("=");
-      if (keyValue.length != 2) {
-        throw new IllegalArgumentException("Invalid buffer style: " + style);
-      }
+      checkArgument(keyValue.length == 2, "Invalid buffer style: %s", style);
       String key = keyValue[0];
       String value = keyValue[1];
       switch (key) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java b/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java
index ee479cd22..605c53b18 100644
--- a/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java
+++ b/core/src/main/java/org/apache/calcite/runtime/CoordinateTransformer.java
@@ -22,8 +22,8 @@
 import org.locationtech.jts.geom.impl.CoordinateArraySequence;
 import org.locationtech.jts.geom.util.GeometryTransformer;
 
+import java.util.Arrays;
 import java.util.function.Function;
-import java.util.stream.Stream;
 
 /** Transforms the coordinates of a geometry. */
 public class CoordinateTransformer extends GeometryTransformer {
@@ -38,7 +38,9 @@ public CoordinateTransformer(Function<Coordinate, Coordinate> transform) {
   @Override protected CoordinateSequence transformCoordinates(
       CoordinateSequence coordinateSequence, Geometry parent) {
     Coordinate[] coordinateArray =
-        Stream.of(coordinateSequence.toCoordinateArray()).map(transform).toArray(Coordinate[]::new);
+        Arrays.stream(coordinateSequence.toCoordinateArray())
+            .map(transform)
+            .toArray(Coordinate[]::new);
     return new CoordinateArraySequence(coordinateArray);
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/runtime/FlatLists.java b/core/src/main/java/org/apache/calcite/runtime/FlatLists.java
index c211419b6..28edd3cfe 100644
--- a/core/src/main/java/org/apache/calcite/runtime/FlatLists.java
+++ b/core/src/main/java/org/apache/calcite/runtime/FlatLists.java
@@ -27,7 +27,6 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -324,7 +323,7 @@ protected static class Flat1List<T> extends AbstractFlatList<T> implements Compa
     }
 
     @Override public Iterator<T> iterator() {
-      return Collections.singletonList(t0).iterator();
+      return ImmutableList.of(t0).iterator();
     }
 
     @Override public boolean equals(@Nullable Object o) {
@@ -340,8 +339,7 @@ protected static class Flat1List<T> extends AbstractFlatList<T> implements Compa
 
     @Override public int hashCode() {
       int h = 1;
-      h = h * 31 + Utilities.hash(t0);
-      return h;
+      return h * 31 + Utilities.hash(t0);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -370,7 +368,7 @@ protected static class Flat1List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 1) {
         // Make a new array of a's runtime type, but my contents:
@@ -454,8 +452,7 @@ protected static class Flat2List<T> extends AbstractFlatList<T> implements Compa
     @Override public int hashCode() {
       int h = 1;
       h = h * 31 + Utilities.hash(t0);
-      h = h * 31 + Utilities.hash(t1);
-      return h;
+      return h * 31 + Utilities.hash(t1);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -496,7 +493,7 @@ protected static class Flat2List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 2) {
         // Make a new array of a's runtime type, but my contents:
@@ -584,8 +581,7 @@ protected static class Flat3List<T> extends AbstractFlatList<T> implements Compa
       int h = 1;
       h = h * 31 + Utilities.hash(t0);
       h = h * 31 + Utilities.hash(t1);
-      h = h * 31 + Utilities.hash(t2);
-      return h;
+      return h * 31 + Utilities.hash(t2);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -638,7 +634,7 @@ protected static class Flat3List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 3) {
         // Make a new array of a's runtime type, but my contents:
@@ -733,8 +729,7 @@ protected static class Flat4List<T> extends AbstractFlatList<T> implements Compa
       h = h * 31 + Utilities.hash(t0);
       h = h * 31 + Utilities.hash(t1);
       h = h * 31 + Utilities.hash(t2);
-      h = h * 31 + Utilities.hash(t3);
-      return h;
+      return h * 31 + Utilities.hash(t3);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -799,7 +794,7 @@ protected static class Flat4List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 4) {
         // Make a new array of a's runtime type, but my contents:
@@ -903,8 +898,7 @@ protected static class Flat5List<T> extends AbstractFlatList<T> implements Compa
       h = h * 31 + Utilities.hash(t1);
       h = h * 31 + Utilities.hash(t2);
       h = h * 31 + Utilities.hash(t3);
-      h = h * 31 + Utilities.hash(t4);
-      return h;
+      return h * 31 + Utilities.hash(t4);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -981,7 +975,7 @@ protected static class Flat5List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 5) {
         // Make a new array of a's runtime type, but my contents:
@@ -1094,8 +1088,7 @@ protected static class Flat6List<T> extends AbstractFlatList<T> implements Compa
       h = h * 31 + Utilities.hash(t2);
       h = h * 31 + Utilities.hash(t3);
       h = h * 31 + Utilities.hash(t4);
-      h = h * 31 + Utilities.hash(t5);
-      return h;
+      return h * 31 + Utilities.hash(t5);
     }
 
     @Override public int indexOf(@Nullable Object o) {
@@ -1184,7 +1177,7 @@ protected static class Flat6List<T> extends AbstractFlatList<T> implements Compa
       return -1;
     }
 
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     @Override public <T2> @Nullable T2[] toArray(T2 @Nullable [] a) {
       if (castNonNull(a).length < 6) {
         // Make a new array of a's runtime type, but my contents:
diff --git a/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java b/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java
index 9409061b5..74b504892 100644
--- a/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java
+++ b/core/src/main/java/org/apache/calcite/runtime/FlipCoordinatesTransformer.java
@@ -22,7 +22,7 @@
 import org.locationtech.jts.geom.impl.CoordinateArraySequence;
 import org.locationtech.jts.geom.util.GeometryTransformer;
 
-import java.util.stream.Stream;
+import java.util.Arrays;
 
 /** Flips the coordinates of a geometry. */
 public class FlipCoordinatesTransformer extends GeometryTransformer {
@@ -30,7 +30,7 @@ public class FlipCoordinatesTransformer extends GeometryTransformer {
   @Override protected CoordinateSequence transformCoordinates(
       CoordinateSequence coordinateSequence, Geometry parent) {
     Coordinate[] coordinateArray =
-        Stream.of(coordinateSequence.toCoordinateArray())
+        Arrays.stream(coordinateSequence.toCoordinateArray())
             .map(c -> new Coordinate(c.y, c.x))
             .toArray(Coordinate[]::new);
     return new CoordinateArraySequence(coordinateArray);
diff --git a/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java b/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java
index c5d31e39f..0980565d2 100644
--- a/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java
+++ b/core/src/main/java/org/apache/calcite/runtime/FunctionContexts.java
@@ -23,6 +23,9 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkElementIndex;
+
 /** Runtime support for {@link org.apache.calcite.schema.FunctionContext}. */
 public class FunctionContexts {
   private FunctionContexts() {}
@@ -55,17 +58,14 @@ private static class FunctionContextImpl implements FunctionContext {
     }
 
     private @Nullable Object argumentValue(int ordinal) {
-      if (ordinal < 0 || ordinal >= argumentValues.length) {
-        throw new IndexOutOfBoundsException("argument ordinal " + ordinal + " is out of range");
-      }
+      checkElementIndex(
+          ordinal, argumentValues.length, "argument ordinal " + ordinal + " is out of range");
       return argumentValues[ordinal];
     }
 
     @Override public <V> @Nullable V getArgumentValueAs(int ordinal, Class<V> valueClass) {
       final Object v = argumentValue(ordinal);
-      if (v == null) {
-        throw new IllegalArgumentException("value of argument " + ordinal + " is not constant");
-      }
+      checkArgument(v != null, "value of argument %s is not constant", ordinal);
       if (v == NullSentinel.INSTANCE) {
         return null; // value is constant NULL
       }
diff --git a/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java b/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java
index 9323c13de..c4ba87ada 100644
--- a/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java
+++ b/core/src/main/java/org/apache/calcite/runtime/HttpUtils.java
@@ -27,6 +27,8 @@
 import java.nio.charset.StandardCharsets;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Utilities for connecting to REST services such as Splunk via HTTP. */
 public class HttpUtils {
   private HttpUtils() {}
@@ -52,9 +54,7 @@ public static void appendURLEncodedArgs(StringBuilder out, Map<String, String> a
   }
 
   public static void appendURLEncodedArgs(StringBuilder out, CharSequence... args) {
-    if (args.length % 2 != 0) {
-      throw new IllegalArgumentException("args should contain an even number of items");
-    }
+    checkArgument(args.length % 2 == 0, "args should contain an even number of items");
     try {
       int appended = 0;
       for (int i = 0; i < args.length; i += 2) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java b/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java
index 602a65273..9d20e5946 100644
--- a/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/JsonFunctions.java
@@ -27,6 +27,8 @@
 import com.fasterxml.jackson.core.PrettyPrinter;
 import com.fasterxml.jackson.core.util.DefaultIndenter;
 import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
+import com.google.common.base.Strings;
+import com.google.common.collect.ImmutableList;
 import com.jayway.jsonpath.Configuration;
 import com.jayway.jsonpath.DocumentContext;
 import com.jayway.jsonpath.InvalidPathException;
@@ -42,7 +44,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
@@ -318,13 +319,13 @@ public static JsonPathContext jsonApiCommonSyntax(JsonValueContext input, String
             value = context.obj;
             break;
           case WITH_UNCONDITIONAL_ARRAY:
-            value = Collections.singletonList(context.obj);
+            value = ImmutableList.of(context.obj);
             break;
           case WITH_CONDITIONAL_ARRAY:
             if (context.obj instanceof Collection) {
               value = context.obj;
             } else {
-              value = Collections.singletonList(context.obj);
+              value = ImmutableList.of(context.obj);
             }
             break;
           default:
@@ -440,7 +441,7 @@ public static String jsonPretty(JsonValueContext input) {
           .writer(JSON_PRETTY_PRINTER)
           .writeValueAsString(input.obj);
     } catch (Exception e) {
-      throw RESOURCE.exceptionWhileSerializingToJson(Objects.toString(input.obj)).ex(e);
+      throw RESOURCE.exceptionWhileSerializingToJson(String.valueOf(input.obj)).ex(e);
     }
   }
 
@@ -516,13 +517,9 @@ private static Integer calculateDepth(Object o) {
       for (int i = 0; i < size; ++i) {
         Object obj = q.poll();
         if (obj instanceof Map) {
-          for (Object value : ((LinkedHashMap) obj).values()) {
-            q.add(value);
-          }
+          q.addAll(((LinkedHashMap) obj).values());
         } else if (obj instanceof Collection) {
-          for (Object value : (Collection) obj) {
-            q.add(value);
-          }
+          q.addAll((Collection) obj);
         }
       }
       ++depth;
@@ -645,7 +642,7 @@ public static Integer jsonStorageSize(JsonValueContext input) {
     try {
       return JSON_PATH_JSON_PROVIDER.getObjectMapper().writeValueAsBytes(input.obj).length;
     } catch (Exception e) {
-      throw RESOURCE.invalidInputForJsonStorageSize(Objects.toString(input.obj)).ex(e);
+      throw RESOURCE.invalidInputForJsonStorageSize(String.valueOf(input.obj)).ex(e);
     }
   }
 
@@ -702,7 +699,7 @@ private static String jsonModify(JsonValueContext jsonDoc, JsonModifyMode type,
       }
     }
 
-    return result == null || result.isEmpty() ? ctx.jsonString() : result;
+    return Strings.isNullOrEmpty(result) ? ctx.jsonString() : result;
   }
 
   private static void insertToJson(DocumentContext ctx, String path, Object value) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/Matcher.java b/core/src/main/java/org/apache/calcite/runtime/Matcher.java
index 142445c5e..2b5ca3828 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Matcher.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Matcher.java
@@ -21,7 +21,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -38,6 +37,8 @@
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Workspace that partialMatches patterns against an automaton.
  *
@@ -182,7 +183,7 @@ public void addPartialMatches(Collection<PartialMatch<E>> matches) {
     }
 
     public Set<PartialMatch<E>> getPartialMatches() {
-      return ImmutableSet.copyOf(partialMatches);
+      return partialMatches;
     }
 
     public void removePartialMatch(PartialMatch<E> pm) {
@@ -291,14 +292,11 @@ public Builder<E> add(String symbolName, Predicate<MemoryFactory.Memory<E>> pred
     public Matcher<E> build() {
       final Set<String> predicateSymbolsNotInGraph = Sets.newTreeSet(symbolPredicates.keySet());
       predicateSymbolsNotInGraph.removeAll(automaton.symbolNames);
-      if (!predicateSymbolsNotInGraph.isEmpty()) {
-        throw new IllegalArgumentException(
-            "not all predicate symbols ["
-                + predicateSymbolsNotInGraph
-                + "] are in graph ["
-                + automaton.symbolNames
-                + "]");
-      }
+      checkArgument(
+          predicateSymbolsNotInGraph.isEmpty(),
+          "not all predicate symbols [%s] are in graph [%s]",
+          predicateSymbolsNotInGraph,
+          automaton.symbolNames);
       final ImmutableMap.Builder<String, Predicate<MemoryFactory.Memory<E>>> builder =
           ImmutableMap.builder();
       for (String symbolName : automaton.symbolNames) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/PairList.java b/core/src/main/java/org/apache/calcite/runtime/PairList.java
index 25b14725d..c2fbcb03a 100644
--- a/core/src/main/java/org/apache/calcite/runtime/PairList.java
+++ b/core/src/main/java/org/apache/calcite/runtime/PairList.java
@@ -18,7 +18,6 @@
 
 import org.apache.calcite.linq4j.function.Functions;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
 
@@ -249,7 +248,7 @@ public ImmutableMap<T, U> toImmutableMap() {
 
   /** Returns an immutable PairList whose contents are the same as this PairList. */
   public PairList<T, U> immutable() {
-    final List<@Nullable Object> immutableList = ImmutableList.copyOf(list);
+    final List<@Nullable Object> immutableList = list;
     return backedBy(immutableList);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java b/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java
index dcd4644d0..c4b6a912a 100644
--- a/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java
+++ b/core/src/main/java/org/apache/calcite/runtime/ProjectionTransformer.java
@@ -35,8 +35,8 @@
 import org.locationtech.proj4j.CoordinateTransformFactory;
 import org.locationtech.proj4j.ProjCoordinate;
 
+import java.util.Arrays;
 import java.util.Locale;
-import java.util.stream.Stream;
 
 /** Transforms the projection of a geometry. */
 public class ProjectionTransformer extends GeometryTransformer {
@@ -62,7 +62,7 @@ public ProjectionTransformer(int sourceSrid, int targetSrid) {
   @Override protected CoordinateSequence transformCoordinates(
       CoordinateSequence coordinateSequence, Geometry parent) {
     Coordinate[] coordinateArray =
-        Stream.of(coordinateSequence.toCoordinateArray())
+        Arrays.stream(coordinateSequence.toCoordinateArray())
             .map(this::transformCoordinate)
             .toArray(Coordinate[]::new);
     return new CoordinateArraySequence(coordinateArray);
diff --git a/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java b/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java
index 28bb5d3e7..92f6ebbd4 100644
--- a/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java
+++ b/core/src/main/java/org/apache/calcite/runtime/RemovePointOperation.java
@@ -20,6 +20,8 @@
 import org.locationtech.jts.geom.Geometry;
 import org.locationtech.jts.geom.util.GeometryEditor;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Geometry editor operation that removes a point to a geometry. */
 public class RemovePointOperation extends GeometryEditor.CoordinateOperation {
 
@@ -30,9 +32,7 @@ public RemovePointOperation(int index) {
   }
 
   @Override public Coordinate[] edit(Coordinate[] coordinates, Geometry geometry) {
-    if (index < 0 || index > coordinates.length - 1) {
-      throw new IllegalArgumentException("Invalid index: " + index);
-    }
+    checkArgument(index >= 0 && index <= coordinates.length - 1, "Invalid index: %s", index);
     Coordinate[] newCoordinates = new Coordinate[coordinates.length - 1];
     for (int i = 0; i < index; i++) {
       newCoordinates[i] = (Coordinate) coordinates[i].clone();
diff --git a/core/src/main/java/org/apache/calcite/runtime/Resources.java b/core/src/main/java/org/apache/calcite/runtime/Resources.java
index e6716533d..4cad2e0d9 100644
--- a/core/src/main/java/org/apache/calcite/runtime/Resources.java
+++ b/core/src/main/java/org/apache/calcite/runtime/Resources.java
@@ -16,11 +16,11 @@
  */
 package org.apache.calcite.runtime;
 
-import org.checkerframework.checker.initialization.qual.UnderInitialization;
-import org.checkerframework.checker.nullness.qual.Nullable;
-import org.checkerframework.checker.nullness.qual.PolyNull;
-import org.checkerframework.checker.nullness.qual.RequiresNonNull;
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
+import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
+import com.google.common.collect.ImmutableMap;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.annotation.ElementType;
@@ -54,10 +54,10 @@
 import java.util.ResourceBundle;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
-
-import static org.apache.calcite.linq4j.Nullness.castNonNull;
-
-import static java.util.Objects.requireNonNull;
+import org.checkerframework.checker.initialization.qual.UnderInitialization;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.checker.nullness.qual.PolyNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * Defining wrapper classes around resources that allow the compiler to check
@@ -461,9 +461,9 @@ public Map<String, String> getProperties() {
       // could design new annotations if any resource needed more.
       final Property property = method.getAnnotation(Property.class);
       if (property == null) {
-        return Collections.emptyMap();
+        return ImmutableMap.of();
       } else {
-        return Collections.singletonMap(property.name(), property.value());
+        return ImmutableMap.of(property.name(), property.value());
       }
     }
   }
@@ -551,10 +551,7 @@ public static Class getExceptionClass(Type type) {
         }
         if (type instanceof Class) {
           Type superclass = ((Class) type).getGenericSuperclass();
-          if (superclass == null) {
-            throw new IllegalStateException(
-                "Unable to find superclass ExInstWithCause for " + type0);
-          }
+          checkState(superclass != null, "Unable to find superclass ExInstWithCause for %s", type0);
           type = superclass;
         }
       }
diff --git a/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java b/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java
index b7f8543ab..b1e1fcaa8 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SortedMultiMap.java
@@ -16,9 +16,10 @@
  */
 package org.apache.calcite.runtime;
 
+import com.google.common.collect.ImmutableList;
+
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -33,7 +34,7 @@
  */
 public class SortedMultiMap<K, V> extends HashMap<K, List<V>> {
   public void putMulti(K key, V value) {
-    List<V> list = put(key, Collections.singletonList(value));
+    List<V> list = put(key, ImmutableList.of(value));
     if (list == null) {
       return;
     }
diff --git a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java
index e643d612e..f37fec06c 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeFunctions.java
@@ -78,6 +78,8 @@
 import java.util.function.Function;
 import java.util.stream.Stream;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.runtime.SpatialTypeUtils.GEOMETRY_FACTORY;
 import static org.apache.calcite.runtime.SpatialTypeUtils.NO_SRID;
 import static org.apache.calcite.runtime.SpatialTypeUtils.asEwkt;
@@ -92,6 +94,8 @@
 import static org.apache.calcite.runtime.SpatialTypeUtils.fromWkt;
 import static org.apache.calcite.util.Static.RESOURCE;
 
+import static java.util.Comparator.naturalOrder;
+
 /**
  * Helper methods to implement spatial type (ST) functions in generated code.
  *
@@ -601,7 +605,7 @@ public static Geometry ST_MakeEnvelope(
   }
 
   /** Creates a line-string from the given POINTs (or MULTIPOINTs). */
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2) {
     return GEOMETRY_FACTORY.createLineString(
         new Coordinate[] {
@@ -609,7 +613,7 @@ public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2) {
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2, Geometry geom3) {
     return GEOMETRY_FACTORY.createLineString(
         new Coordinate[] {
@@ -617,7 +621,7 @@ public static Geometry ST_MakeLine(Geometry geom1, Geometry geom2, Geometry geom
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(
       Geometry geom1, Geometry geom2, Geometry geom3, Geometry geom4) {
     return GEOMETRY_FACTORY.createLineString(
@@ -629,7 +633,7 @@ public static Geometry ST_MakeLine(
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(
       Geometry geom1, Geometry geom2, Geometry geom3, Geometry geom4, Geometry geom5) {
     return GEOMETRY_FACTORY.createLineString(
@@ -642,7 +646,7 @@ public static Geometry ST_MakeLine(
         });
   }
 
-  @Hints({"SqlKind:ST_MAKE_LINE"})
+  @Hints("SqlKind:ST_MAKE_LINE")
   public static Geometry ST_MakeLine(
       Geometry geom1,
       Geometry geom2,
@@ -662,31 +666,29 @@ public static Geometry ST_MakeLine(
   }
 
   /** Alias for {@link #ST_Point(BigDecimal, BigDecimal)}. */
-  @Hints({"SqlKind:ST_POINT"})
+  @Hints("SqlKind:ST_POINT")
   public static Geometry ST_MakePoint(BigDecimal x, BigDecimal y) {
     return ST_Point(x, y);
   }
 
   /** Alias for {@link #ST_Point(BigDecimal, BigDecimal, BigDecimal)}. */
-  @Hints({"SqlKind:ST_POINT3"})
+  @Hints("SqlKind:ST_POINT3")
   public static Geometry ST_MakePoint(BigDecimal x, BigDecimal y, BigDecimal z) {
     return ST_Point(x, y, z);
   }
 
   /** Constructs a 2D point from coordinates. */
-  @Hints({"SqlKind:ST_POINT"})
+  @Hints("SqlKind:ST_POINT")
   public static Geometry ST_Point(BigDecimal x, BigDecimal y) {
     // NOTE: Combine the double and BigDecimal variants of this function
     return GEOMETRY_FACTORY.createPoint(new Coordinate(x.doubleValue(), y.doubleValue()));
   }
 
   /** Constructs a 3D point from coordinates. */
-  @Hints({"SqlKind:ST_POINT3"})
+  @Hints("SqlKind:ST_POINT3")
   public static Geometry ST_Point(BigDecimal x, BigDecimal y, BigDecimal z) {
-    final Geometry g =
-        GEOMETRY_FACTORY.createPoint(
-            new Coordinate(x.doubleValue(), y.doubleValue(), z.doubleValue()));
-    return g;
+    return GEOMETRY_FACTORY.createPoint(
+        new Coordinate(x.doubleValue(), y.doubleValue(), z.doubleValue()));
   }
 
   // Geometry properties (2D)
@@ -872,8 +874,8 @@ public static Double ST_Z(Geometry geom) {
   public static Double ST_ZMax(Geometry geom) {
     return Arrays.stream(geom.getCoordinates())
         .filter(c -> !Double.isNaN(c.getZ()))
-        .map(c -> c.getZ())
-        .max(Double::compareTo)
+        .map(Coordinate::getZ)
+        .max(naturalOrder())
         .orElse(Double.NaN);
   }
 
@@ -881,8 +883,8 @@ public static Double ST_ZMax(Geometry geom) {
   public static Double ST_ZMin(Geometry geom) {
     return Arrays.stream(geom.getCoordinates())
         .filter(c -> !Double.isNaN(c.getZ()))
-        .map(c -> c.getZ())
-        .min(Double::compareTo)
+        .map(Coordinate::getZ)
+        .min(naturalOrder())
         .orElse(Double.NaN);
   }
 
@@ -942,7 +944,7 @@ private static void ST_Explode(final Geometry geom) {
   // Geometry predicates ======================================================
 
   /** Returns whether {@code geom1} contains {@code geom2}. */
-  @Hints({"SqlKind:ST_CONTAINS"})
+  @Hints("SqlKind:ST_CONTAINS")
   public static boolean ST_Contains(Geometry geom1, Geometry geom2) {
     return geom1.contains(geom2);
   }
@@ -1023,7 +1025,7 @@ public static boolean ST_Within(Geometry geom1, Geometry geom2) {
   }
 
   /** Returns whether {@code geom1} and {@code geom2} are within {@code distance} of each other. */
-  @Hints({"SqlKind:ST_DWITHIN"})
+  @Hints("SqlKind:ST_DWITHIN")
   public static boolean ST_DWithin(Geometry geom1, Geometry geom2, double distance) {
     final double distance1 = geom1.distance(geom2);
     return distance1 <= distance;
@@ -1036,8 +1038,7 @@ public static Geometry ST_Buffer(Geometry geom, double distance, String bufferSt
     BufferStyle style = new BufferStyle(bufferStyle);
     BufferParameters params = style.asBufferParameters();
     double sidedDistance = style.asSidedDistance(distance);
-    Geometry result = new BufferOp(geom, params).getResultGeometry(sidedDistance);
-    return result;
+    return new BufferOp(geom, params).getResultGeometry(sidedDistance);
   }
 
   /** Computes a buffer around {@code geom}. */
@@ -1077,9 +1078,7 @@ public static Geometry ST_Intersection(Geometry geom1, Geometry geom2) {
 
   /** Computes an offset line for {@code linestring}. */
   public static Geometry ST_OffsetCurve(Geometry linestring, double distance, String bufferStyle) {
-    if (!(linestring instanceof LineString)) {
-      throw new IllegalArgumentException("ST_OffsetCurve only accepts LineString");
-    }
+    checkArgument((linestring instanceof LineString), "ST_OffsetCurve only accepts LineString");
     BufferStyle style = new BufferStyle(bufferStyle);
     BufferParameters params = style.asBufferParameters();
     double sidedDistance = style.asSidedDistance(distance);
@@ -1229,8 +1228,7 @@ public static Geometry ST_Scale(Geometry geom, BigDecimal xFactor, BigDecimal yF
   public static Geometry ST_Translate(Geometry geom, BigDecimal x, BigDecimal y) {
     AffineTransformation transformation = new AffineTransformation();
     transformation.translate(x.doubleValue(), y.doubleValue());
-    Geometry translated = transformation.transform(geom);
-    return translated;
+    return transformation.transform(geom);
   }
 
   // Geometry editing functions (2D)
@@ -1558,7 +1556,7 @@ private static Geometry asTriangleEdges(MultiPolygon multiPolygon) {
    * Returns the position of a point on the Hilbert curve, or null if it is not a 2-dimensional
    * point.
    */
-  @Hints({"SqlKind:HILBERT"})
+  @Hints("SqlKind:HILBERT")
   public static @Nullable Long hilbert(Geometry geom) {
     if (geom instanceof Point) {
       final double x = ((Point) geom).getX();
@@ -1569,7 +1567,7 @@ private static Geometry asTriangleEdges(MultiPolygon multiPolygon) {
   }
 
   /** Returns the position of a point on the Hilbert curve. */
-  @Hints({"SqlKind:HILBERT"})
+  @Hints("SqlKind:HILBERT")
   public static long hilbert(BigDecimal x, BigDecimal y) {
     return new HilbertCurve2D(8).toIndex(x.doubleValue(), y.doubleValue());
   }
diff --git a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java
index 69167761a..d8574e20e 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SpatialTypeUtils.java
@@ -216,8 +216,7 @@ public static String asGeoJson(Geometry geometry) {
   public static String asGml(Geometry geometry) {
     GMLWriter gmlWriter = new GMLWriter();
     // remove line breaks and indentation
-    String minified = gmlWriter.write(geometry).replace("\n", "").replace("  ", "");
-    return minified;
+    return gmlWriter.write(geometry).replace("\n", "").replace("  ", "");
   }
 
   /**
diff --git a/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java b/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
index 974fa4668..ef9a34e9d 100644
--- a/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java
@@ -53,6 +53,7 @@
 
 import com.google.common.base.Splitter;
 import com.google.common.base.Strings;
+import com.google.common.base.Utf8;
 import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -107,6 +108,9 @@
 import java.util.function.BinaryOperator;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -224,9 +228,7 @@ private SqlFunctions() {}
    */
   @NonDeterministic
   public static boolean throwUnless(boolean condition, String message) {
-    if (!condition) {
-      throw new IllegalStateException(message);
-    }
+    checkState(condition, message);
     return condition;
   }
 
@@ -808,7 +810,7 @@ public static int charLength(String s) {
 
   /** SQL BIT_LENGTH(string) function. */
   public static int bitLength(String s) {
-    return s.getBytes(UTF_8).length * 8;
+    return Utf8.encodedLength(s) * 8;
   }
 
   /** SQL BIT_LENGTH(binary) function. */
@@ -1930,9 +1932,7 @@ public static double acosh(BigDecimal b0) {
 
   /** SQL <code>ACOSH</code> operator applied to double values. */
   public static double acosh(double b0) {
-    if (b0 < 1) {
-      throw new IllegalArgumentException("Input parameter of acosh cannot be less than 1!");
-    }
+    checkArgument(b0 >= 1, "Input parameter of acosh cannot be less than 1!");
     return Math.log(Math.sqrt(b0 * b0 - 1.0d) + b0);
   }
 
@@ -2006,10 +2006,8 @@ public static double atanh(BigDecimal b) {
 
   /** SQL <code>ATANH</code> operator applied to double values. */
   public static double atanh(double b) {
-    if (Math.abs(b) >= 1) {
-      throw new IllegalArgumentException(
-          "Input parameter of atanh cannot be out of the " + "range (-1, 1)!");
-    }
+    checkArgument(
+        Math.abs(b) < 1, "Input parameter of atanh cannot be out of the " + "range (-1, 1)!");
     final double mult;
     // check the sign bit of the raw representation to handle -0.
     if (Double.doubleToRawLongBits(b) < 0) {
@@ -2730,8 +2728,8 @@ public static BigDecimal toBigDecimal(Number number) {
         : number instanceof BigInteger
             ? new BigDecimal((BigInteger) number)
             : number instanceof Long
-                ? new BigDecimal(number.longValue())
-                : new BigDecimal(number.doubleValue());
+                ? BigDecimal.valueOf(number.longValue())
+                : BigDecimal.valueOf(number.doubleValue());
   }
 
   public static BigDecimal toBigDecimal(Object o) {
@@ -2821,7 +2819,7 @@ public static int timeWithLocalTimeZoneToTime(int v, TimeZone timeZone) {
   public static long timeWithLocalTimeZoneToTimestamp(String date, int v, TimeZone timeZone) {
     final TimeWithTimeZoneString tTZ =
         TimeWithTimeZoneString.fromMillisOfDay(v).withTimeZone(DateTimeUtils.UTC_ZONE);
-    return new TimestampWithTimeZoneString(date + " " + tTZ.toString())
+    return new TimestampWithTimeZoneString(date + " " + tTZ)
         .withTimeZone(timeZone)
         .getLocalTimestampString()
         .getMillisSinceEpoch();
@@ -2830,7 +2828,7 @@ public static long timeWithLocalTimeZoneToTimestamp(String date, int v, TimeZone
   public static long timeWithLocalTimeZoneToTimestampWithLocalTimeZone(String date, int v) {
     final TimeWithTimeZoneString tTZ =
         TimeWithTimeZoneString.fromMillisOfDay(v).withTimeZone(DateTimeUtils.UTC_ZONE);
-    return new TimestampWithTimeZoneString(date + " " + tTZ.toString())
+    return new TimestampWithTimeZoneString(date + " " + tTZ)
         .getLocalTimestampString()
         .getMillisSinceEpoch();
   }
@@ -3067,8 +3065,7 @@ public static int date(long timestampMillis) {
   public static int date(long timestampMillis, String timeZone) {
     // Calcite represents dates as Unix integers (days since epoch).
     return (int)
-        OffsetDateTime.ofInstant(Instant.ofEpochMilli(timestampMillis), ZoneId.of(timeZone))
-            .toLocalDate()
+        LocalDate.ofInstant(Instant.ofEpochMilli(timestampMillis), ZoneId.of(timeZone))
             .toEpochDay();
   }
 
@@ -3108,7 +3105,7 @@ public static long datetime(long millisSinceEpoch, String timeZone) {
     // ZONE and TIMESTAMP, respectively) are represented internally as
     // milliseconds since epoch (or epoch UTC).
     return OffsetDateTime.ofInstant(Instant.ofEpochMilli(millisSinceEpoch), ZoneId.of(timeZone))
-        .atZoneSimilarLocal(ZoneId.of("UTC"))
+        .atZoneSimilarLocal(ZoneOffset.UTC)
         .toInstant()
         .toEpochMilli();
   }
@@ -3170,8 +3167,7 @@ public static long timestamp(int days) {
   public static long timestamp(int days, String timeZone) {
     // Calcite represents TIMESTAMP WITH LOCAL TIME ZONE as Unix integers
     // (milliseconds since epoch).
-    final LocalDateTime localDateTime =
-        LocalDateTime.of(LocalDate.ofEpochDay(days), LocalTime.MIDNIGHT);
+    final LocalDateTime localDateTime = LocalDateTime.of(LocalDate.ofEpochDay(days), LocalTime.MIN);
     final ZoneOffset zoneOffset = ZoneId.of(timeZone).getRules().getOffset(localDateTime);
     return OffsetDateTime.of(localDateTime, zoneOffset).toInstant().toEpochMilli();
   }
@@ -3193,7 +3189,7 @@ public static long timestamp(long millisSinceEpoch, String timeZone) {
     // TIME ZONE and TIMESTAMP, respectively) are represented internally as
     // milliseconds since epoch UTC and epoch.
     final Instant instant = Instant.ofEpochMilli(millisSinceEpoch);
-    final ZoneId utcZone = ZoneId.of("UTC");
+    final ZoneId utcZone = ZoneOffset.UTC;
     return OffsetDateTime.ofInstant(instant, utcZone)
         .atZoneSimilarLocal(ZoneId.of(timeZone))
         .toInstant()
@@ -3227,7 +3223,7 @@ public static int time(long timestampMillis, String timeZone) {
     final Instant instant = Instant.ofEpochMilli(timestampMillis);
     final ZoneId zoneId = ZoneId.of(timeZone);
     return (int)
-        (OffsetDateTime.ofInstant(instant, zoneId).toLocalTime().toNanoOfDay()
+        (LocalTime.ofInstant(instant, zoneId).toNanoOfDay()
             / (1000L * 1000L)); // milli > micro > nano
   }
 
@@ -3882,7 +3878,7 @@ private static AtomicLong getAtomicLong(String key) {
     final List smaller = list1;
     final List bigger = list2;
     boolean hasNull = false;
-    if (smaller.size() > 0 && bigger.size() > 0) {
+    if (!smaller.isEmpty() && !bigger.isEmpty()) {
       final Set smallestSet = new HashSet(smaller);
       hasNull = smallestSet.remove(null);
       for (Object element : bigger) {
@@ -3992,7 +3988,7 @@ public static List arrayPrepend(List list, Object element) {
   public static Long arrayPosition(List list, Object element) {
     final int index = list.indexOf(element);
     if (index != -1) {
-      return Long.valueOf(index + 1L);
+      return index + 1L;
     }
     return 0L;
   }
@@ -4420,9 +4416,7 @@ public static <E extends Comparable> Enumerable<FlatLists.ComparableList<E>> pro
     } else {
       Class<?> beanClass = structObject.getClass();
       try {
-        if (fieldName == null) {
-          throw new IllegalStateException("Field name cannot be null for struct field access");
-        }
+        checkState(fieldName != null, "Field name cannot be null for struct field access");
         Field structField = beanClass.getDeclaredField(fieldName);
         return structField.get(structObject);
       } catch (NoSuchFieldException | IllegalAccessException ex) {
diff --git a/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java b/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
index 844fde77a..9d3d51c7d 100644
--- a/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
+++ b/core/src/main/java/org/apache/calcite/runtime/XmlFunctions.java
@@ -56,6 +56,8 @@
 import javax.xml.xpath.XPathFactory;
 import javax.xml.xpath.XPathFactoryConfigurationException;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -229,9 +231,8 @@ private XmlFunctions() {}
   }
 
   private static SimpleNamespaceContext extractNamespaceContext(String namespace) {
-    if (!VALID_NAMESPACE_PATTERN.matcher(namespace).find()) {
-      throw new IllegalArgumentException("Invalid namespace " + namespace);
-    }
+    checkArgument(
+        VALID_NAMESPACE_PATTERN.matcher(namespace).find(), "Invalid namespace %s", namespace);
     Map<String, String> namespaceMap = new HashMap<>();
     Matcher matcher = EXTRACT_NAMESPACE_PATTERN.matcher(namespace);
     while (matcher.find()) {
diff --git a/core/src/main/java/org/apache/calcite/schema/Schemas.java b/core/src/main/java/org/apache/calcite/schema/Schemas.java
index 29ab7eb8b..96173f99b 100644
--- a/core/src/main/java/org/apache/calcite/schema/Schemas.java
+++ b/core/src/main/java/org/apache/calcite/schema/Schemas.java
@@ -59,6 +59,8 @@
 import java.util.List;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.jdbc.CalciteSchema.LatticeEntry;
 
 import static java.util.Objects.requireNonNull;
@@ -229,9 +231,7 @@ public static <E> Queryable<E> queryable(
       requireNonNull(schema, "schema");
       if (iterator.hasNext()) {
         SchemaPlus next = schema.getSubSchema(name);
-        if (next == null) {
-          throw new IllegalArgumentException("schema " + name + " is not found in " + schema);
-        }
+        checkArgument(next != null, "schema %s is not found in %s", name, schema);
         schema = next;
       } else {
         return queryable(root, schema, clazz, name);
@@ -300,9 +300,7 @@ private static int[] identity(int count) {
       requireNonNull(schema, "schema");
       if (iterator.hasNext()) {
         SchemaPlus next = schema.getSubSchema(name);
-        if (next == null) {
-          throw new IllegalArgumentException("schema " + name + " is not found in " + schema);
-        }
+        checkArgument(next != null, "schema %s is not found in %s", name, schema);
         schema = next;
       } else {
         return schema.getTable(name);
@@ -591,9 +589,7 @@ public static Path path(CalciteSchema rootSchema, Iterable<String> names) {
         return path(builder.build());
       }
       Schema next = schema.getSubSchema(name);
-      if (next == null) {
-        throw new IllegalArgumentException("schema " + name + " is not found in " + schema);
-      }
+      checkArgument(next != null, "schema %s is not found in %s", name, schema);
       schema = next;
     }
   }
@@ -638,9 +634,7 @@ private static class PathImpl extends AbstractList<Pair<String, Schema>> impleme
     }
 
     @Override public Path parent() {
-      if (pairs.isEmpty()) {
-        throw new IllegalArgumentException("at root");
-      }
+      checkArgument(!pairs.isEmpty(), "at root");
       return new PathImpl(pairs.subList(0, pairs.size() - 1));
     }
 
diff --git a/core/src/main/java/org/apache/calcite/schema/Statistics.java b/core/src/main/java/org/apache/calcite/schema/Statistics.java
index 9bedd47fb..60443a444 100644
--- a/core/src/main/java/org/apache/calcite/schema/Statistics.java
+++ b/core/src/main/java/org/apache/calcite/schema/Statistics.java
@@ -60,11 +60,10 @@ public static Statistic of(
       final @Nullable List<ImmutableBitSet> keys,
       final @Nullable List<RelReferentialConstraint> referentialConstraints,
       final @Nullable List<RelCollation> collations) {
-    List<ImmutableBitSet> keysCopy = keys == null ? ImmutableList.of() : ImmutableList.copyOf(keys);
+    List<ImmutableBitSet> keysCopy = keys == null ? ImmutableList.of() : keys;
     List<RelReferentialConstraint> referentialConstraintsCopy =
-        referentialConstraints == null ? null : ImmutableList.copyOf(referentialConstraints);
-    List<RelCollation> collationsCopy =
-        collations == null ? null : ImmutableList.copyOf(collations);
+        referentialConstraints == null ? null : referentialConstraints;
+    List<RelCollation> collationsCopy = collations == null ? null : collations;
 
     return new Statistic() {
       @Override public @Nullable Double getRowCount() {
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java b/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java
index e3b1c893f..7ee700ea1 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/AbstractSchema.java
@@ -26,8 +26,8 @@
 import org.apache.calcite.schema.Schemas;
 import org.apache.calcite.schema.Table;
 
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -123,7 +123,7 @@ protected Map<String, RelProtoDataType> getTypeMap() {
    * @return Multi-map of functions in this schema by name
    */
   protected Multimap<String, Function> getFunctionMultimap() {
-    return ImmutableMultimap.of();
+    return ImmutableListMultimap.of();
   }
 
   @Override public final Collection<Function> getFunctions(String name) {
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java b/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java
index 079dbdeef..379137fe9 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/LongSchemaVersion.java
@@ -20,6 +20,8 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Implementation of SchemaVersion that uses a long value as representation. */
 public class LongSchemaVersion implements SchemaVersion {
   private final long value;
@@ -29,10 +31,10 @@ public LongSchemaVersion(long value) {
   }
 
   @Override public boolean isBefore(SchemaVersion other) {
-    if (!(other instanceof LongSchemaVersion)) {
-      throw new IllegalArgumentException(
-          "Cannot compare a LongSchemaVersion object with a " + other.getClass() + " object.");
-    }
+    checkArgument(
+        (other instanceof LongSchemaVersion),
+        "Cannot compare a LongSchemaVersion object with a %s object.",
+        other.getClass());
 
     return this.value < ((LongSchemaVersion) other).value;
   }
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java b/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
index f3174cc03..91daed665 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/ScalarFunctionImpl.java
@@ -30,6 +30,7 @@
 import org.apache.calcite.schema.TableFunction;
 import org.apache.calcite.sql.SqlOperatorBinding;
 
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMultimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -53,7 +54,8 @@ private ScalarFunctionImpl(Method method, CallImplementor implementor) {
   /** Creates {@link org.apache.calcite.schema.ScalarFunction} for each method in a given class. */
   @Deprecated // to be removed before 2.0
   public static ImmutableMultimap<String, ScalarFunction> createAll(Class<?> clazz) {
-    final ImmutableMultimap.Builder<String, ScalarFunction> builder = ImmutableMultimap.builder();
+    final ImmutableMultimap.Builder<String, ScalarFunction> builder =
+        ImmutableListMultimap.builder();
     for (Method method : clazz.getMethods()) {
       if (method.getDeclaringClass() == Object.class) {
         continue;
@@ -73,7 +75,7 @@ public static ImmutableMultimap<String, ScalarFunction> createAll(Class<?> clazz
    * org.apache.calcite.schema.TableFunction}.
    */
   public static ImmutableMultimap<String, Function> functions(Class<?> clazz) {
-    final ImmutableMultimap.Builder<String, Function> builder = ImmutableMultimap.builder();
+    final ImmutableMultimap.Builder<String, Function> builder = ImmutableListMultimap.builder();
     for (Method method : clazz.getMethods()) {
       if (method.getDeclaringClass() == Object.class) {
         continue;
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java b/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java
index 4a5bade01..07d2912f6 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/ViewTable.java
@@ -33,8 +33,6 @@
 import org.apache.calcite.schema.SchemaPlus;
 import org.apache.calcite.schema.TranslatableTable;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Type;
@@ -59,9 +57,9 @@ public ViewTable(
       @Nullable List<String> viewPath) {
     super(elementType);
     this.viewSql = viewSql;
-    this.schemaPath = ImmutableList.copyOf(schemaPath);
+    this.schemaPath = schemaPath;
     this.protoRowType = rowType;
-    this.viewPath = viewPath == null ? null : ImmutableList.copyOf(viewPath);
+    this.viewPath = viewPath == null ? null : viewPath;
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java b/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java
index 71fe998ee..6298f170f 100644
--- a/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java
+++ b/core/src/main/java/org/apache/calcite/schema/impl/ViewTableMacro.java
@@ -31,7 +31,6 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Type;
-import java.util.Collections;
 import java.util.List;
 
 import static java.util.Objects.requireNonNull;
@@ -66,13 +65,13 @@ public ViewTableMacro(
       @Nullable Boolean modifiable) {
     this.viewSql = viewSql;
     this.schema = schema;
-    this.viewPath = viewPath == null ? null : ImmutableList.copyOf(viewPath);
+    this.viewPath = viewPath == null ? null : viewPath;
     this.modifiable = modifiable;
-    this.schemaPath = schemaPath == null ? null : ImmutableList.copyOf(schemaPath);
+    this.schemaPath = schemaPath == null ? null : schemaPath;
   }
 
   @Override public List<FunctionParameter> getParameters() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   @Override public TranslatableTable apply(List<? extends @Nullable Object> arguments) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
index 4d271d142..8d91b1117 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlBasicTypeNameSpec.java
@@ -216,7 +216,7 @@ public int getPrecision() {
       SqlCollation collation = SqlCollation.COERCIBLE;
 
       Charset charset;
-      if (null == this.charSetName) {
+      if (this.charSetName == null) {
         charset = typeFactory.getDefaultCharset();
       } else {
         String javaCharSetName =
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
index caded025f..ca181cd00 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlBinaryOperator.java
@@ -134,8 +134,7 @@ private RelDataType convertType(SqlValidator validator, SqlCall call, RelDataTyp
     if (SqlTypeUtil.inCharFamily(operandType0) && SqlTypeUtil.inCharFamily(operandType1)) {
       Charset cs0 = operandType0.getCharset();
       Charset cs1 = operandType1.getCharset();
-      assert (null != cs0) && (null != cs1)
-          : "An implicit or explicit charset should have been set";
+      assert cs0 != null && cs1 != null : "An implicit or explicit charset should have been set";
       if (!cs0.equals(cs1)) {
         throw validator.newValidationError(
             call, RESOURCE.incompatibleCharset(getName(), cs0.name(), cs1.name()));
@@ -143,7 +142,7 @@ private RelDataType convertType(SqlValidator validator, SqlCall call, RelDataTyp
 
       SqlCollation collation0 = operandType0.getCollation();
       SqlCollation collation1 = operandType1.getCollation();
-      assert (null != collation0) && (null != collation1)
+      assert collation0 != null && collation1 != null
           : "An implicit or explicit collation should have been set";
 
       // Validation will occur inside getCoercibilityDyadicOperator...
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCall.java b/core/src/main/java/org/apache/calcite/sql/SqlCall.java
index c5ec59a19..aefdb3b5f 100755
--- a/core/src/main/java/org/apache/calcite/sql/SqlCall.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCall.java
@@ -187,7 +187,7 @@ protected String getCallSignature(SqlValidator validator, @Nullable SqlValidator
     for (final SqlNode operand : getOperandList()) {
       final RelDataType argType =
           validator.deriveType(Objects.requireNonNull(scope, "scope"), operand);
-      if (null == argType) {
+      if (argType == null) {
         continue;
       }
       signatureList.add(argType.toString());
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java b/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
index 309eae28c..6ea7727f1 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCallBinding.java
@@ -42,7 +42,6 @@
 import org.apache.calcite.util.Pair;
 
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -106,7 +105,7 @@ public SqlCallBinding(SqlValidator validator, SqlValidatorScope scope, SqlCall c
     if (group != null) {
       int n = 0;
       for (SqlNode groupItem : group) {
-        if (!(groupItem instanceof SqlNodeList) || ((SqlNodeList) groupItem).size() != 0) {
+        if (!(groupItem instanceof SqlNodeList) || !((SqlNodeList) groupItem).isEmpty()) {
           ++n;
         }
       }
@@ -144,7 +143,7 @@ public List<SqlNode> operands() {
         return operandList;
       }
       final SqlOperandCountRange range = checker.getOperandCountRange();
-      final List<SqlNode> list = Lists.newArrayList(operandList);
+      final List<SqlNode> list = new ArrayList<>(operandList);
       while (list.size() < range.getMax()
           && checker.isOptional(list.size())
           && checker.isFixedParameters()) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java
index 068b1b7fd..98bf40080 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java
@@ -133,7 +133,7 @@ public SqlCollation(Coercibility coercibility, Locale locale, Charset charset, S
   }
 
   protected String generateCollationName(@UnderInitialization SqlCollation this, Charset charset) {
-    return charset.name().toUpperCase(Locale.ROOT) + "$" + String.valueOf(locale) + "$" + strength;
+    return charset.name().toUpperCase(Locale.ROOT) + "$" + locale + "$" + strength;
   }
 
   /**
@@ -167,7 +167,7 @@ protected String generateCollationName(@UnderInitialization SqlCollation this, C
   public static SqlCollation getCoercibilityDyadicOperatorThrows(
       SqlCollation col1, SqlCollation col2) {
     SqlCollation ret = getCoercibilityDyadic(col1, col2);
-    if (null == ret) {
+    if (ret == null) {
       throw RESOURCE
           .invalidCompare(
               col1.collationName,
@@ -199,8 +199,8 @@ public static String getCoercibilityDyadicComparison(SqlCollation col1, SqlColla
    */
   protected static @Nullable SqlCollation getCoercibilityDyadic(
       SqlCollation col1, SqlCollation col2) {
-    assert null != col1;
-    assert null != col2;
+    assert col1 != null;
+    assert col2 != null;
     final Coercibility coercibility1 = col1.getCoercibility();
     final Coercibility coercibility2 = col2.getCoercibility();
     switch (coercibility1) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java
index 865e8d472..5124620ee 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollectionTypeNameSpec.java
@@ -99,7 +99,7 @@ public SqlTypeNameSpec getElementTypeName() {
     if (!this.elementTypeName.equalsDeep(that.elementTypeName, litmus)) {
       return litmus.fail("{} != {}", this, spec);
     }
-    if (!Objects.equals(this.collectionTypeName, that.collectionTypeName)) {
+    if (this.collectionTypeName != that.collectionTypeName) {
       return litmus.fail("{} != {}", this, spec);
     }
     return litmus.succeed();
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
index a878d111e..55715bc6e 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
@@ -229,8 +229,7 @@ public RelDataType deriveType(SqlValidator validator, boolean nullable) {
 
     // Fix-up the nullability, default is false.
     final RelDataTypeFactory typeFactory = validator.getTypeFactory();
-    type = fixUpNullability(typeFactory, type, nullable);
-    return type;
+    return fixUpNullability(typeFactory, type, nullable);
   }
 
   // ~ Tools ------------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDialect.java b/core/src/main/java/org/apache/calcite/sql/SqlDialect.java
index b4f53db3a..fd648635f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDialect.java
@@ -522,7 +522,7 @@ public void unparseSqlIntervalQualifier(
         writer.keyword(start);
       }
 
-      if (null != qualifier.timeUnitRange.endUnit) {
+      if (qualifier.timeUnitRange.endUnit != null) {
         writer.keyword("TO");
         final String end = qualifier.timeUnitRange.endUnit.name();
         if ((TimeUnit.SECOND == qualifier.timeUnitRange.endUnit)
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDialects.java b/core/src/main/java/org/apache/calcite/sql/SqlDialects.java
index 88866cd3a..27338e110 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDialects.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDialects.java
@@ -52,19 +52,16 @@ public static SqlDialect.Context createContext(DatabaseMetaData databaseMetaData
     final Casing unquotedCasing = getCasing(databaseMetaData, false);
     final Casing quotedCasing = getCasing(databaseMetaData, true);
     final boolean caseSensitive = isCaseSensitive(databaseMetaData);
-    final SqlDialect.Context c =
-        SqlDialect.EMPTY_CONTEXT
-            .withDatabaseProductName(databaseProductName)
-            .withDatabaseMajorVersion(databaseMajorVersion)
-            .withDatabaseMinorVersion(databaseMinorVersion)
-            .withDatabaseVersion(databaseVersion)
-            .withIdentifierQuoteString(quoteString)
-            .withUnquotedCasing(unquotedCasing)
-            .withQuotedCasing(quotedCasing)
-            .withCaseSensitive(caseSensitive)
-            .withNullCollation(nullCollation);
-
-    return c;
+    return SqlDialect.EMPTY_CONTEXT
+        .withDatabaseProductName(databaseProductName)
+        .withDatabaseMajorVersion(databaseMajorVersion)
+        .withDatabaseMinorVersion(databaseMinorVersion)
+        .withDatabaseVersion(databaseVersion)
+        .withIdentifierQuoteString(quoteString)
+        .withUnquotedCasing(unquotedCasing)
+        .withQuotedCasing(quotedCasing)
+        .withCaseSensitive(caseSensitive)
+        .withNullCollation(nullCollation);
   }
 
   private static String getIdentifierQuoteString(DatabaseMetaData databaseMetaData) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlFunction.java b/core/src/main/java/org/apache/calcite/sql/SqlFunction.java
index fce0b906e..9bea0529f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlFunction.java
@@ -213,7 +213,7 @@ public boolean isQuantifierAllowed() {
   /** Throws a validation error if a DISTINCT or ALL quantifier is present but not allowed. */
   protected void validateQuantifier(SqlValidator validator, SqlCall call) {
     SqlLiteral functionQuantifier = call.getFunctionQuantifier();
-    if ((null != functionQuantifier) && !isQuantifierAllowed()) {
+    if (functionQuantifier != null && !isQuantifierAllowed()) {
       throw validator.newValidationError(
           functionQuantifier, RESOURCE.functionQuantifierNotAllowed(call.getOperator().getName()));
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlHint.java b/core/src/main/java/org/apache/calcite/sql/SqlHint.java
index 1c737c78d..ae79ccde4 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlHint.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlHint.java
@@ -117,7 +117,7 @@ public HintOptionFormat getOptionFormat() {
    */
   public List<String> getOptionList() {
     if (optionFormat == HintOptionFormat.ID_LIST) {
-      return ImmutableList.copyOf(SqlIdentifier.simpleNames(options));
+      return SqlIdentifier.simpleNames(options);
     } else if (optionFormat == HintOptionFormat.LITERAL_LIST) {
       return options.stream()
           .map(
@@ -143,7 +143,7 @@ public Map<String, String> getOptionKVPairs() {
         final SqlNode v = options.get(i + 1);
         attrs.put(getOptionKeyAsString(k), ((SqlLiteral) v).getValueAs(String.class));
       }
-      return ImmutableMap.copyOf(attrs);
+      return attrs;
     } else {
       return ImmutableMap.of();
     }
@@ -151,7 +151,7 @@ public Map<String, String> getOptionKVPairs() {
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
     name.unparse(writer, leftPrec, rightPrec);
-    if (this.options.size() > 0) {
+    if (!this.options.isEmpty()) {
       SqlWriter.Frame frame = writer.startList(SqlWriter.FrameTypeEnum.FUN_CALL, "(", ")");
       for (int i = 0; i < options.size(); i++) {
         SqlNode option = options.get(i);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java b/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
index 72617a912..d6453835f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlIntervalQualifier.java
@@ -471,7 +471,7 @@ private void checkLeadFieldInRange(
 
   private static final BigDecimal[] POWERS10 = {
     ZERO,
-    BigDecimal.valueOf(10),
+    BigDecimal.TEN,
     BigDecimal.valueOf(100),
     BigDecimal.valueOf(1000),
     BigDecimal.valueOf(10000),
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java b/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
index 70b35e4e7..613214a13 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlJdbcFunctionCall.java
@@ -496,14 +496,14 @@ private static String constructFuncList(String... functionNames) {
   }
 
   @Override public SqlNode rewriteCall(SqlValidator validator, SqlCall call) {
-    if (null == lookupMakeCallObj) {
+    if (lookupMakeCallObj == null) {
       throw validator.newValidationError(call, RESOURCE.functionUndefined(getName()));
     }
     return lookupMakeCallObj.getOperator().rewriteCall(validator, call);
   }
 
   public SqlCall getLookupCall() {
-    if (null == lookupCall) {
+    if (lookupCall == null) {
       lookupCall =
           requireNonNull(lookupMakeCallObj, "lookupMakeCallObj")
               .createCall(SqlParserPos.ZERO, requireNonNull(thisOperands, "thisOperands"));
@@ -534,7 +534,7 @@ public SqlCall getLookupCall() {
     // only expected to come here if validator called this method
     SqlCallBinding callBinding = (SqlCallBinding) opBinding;
 
-    if (null == lookupMakeCallObj) {
+    if (lookupMakeCallObj == null) {
       throw callBinding.newValidationError(RESOURCE.functionUndefined(getName()));
     }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java b/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
index f1f174868..c6effd9b3 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlLiteral.java
@@ -721,7 +721,7 @@ public RelDataType createSqlType(RelDataTypeFactory typeFactory) {
       case NULL:
       case BOOLEAN:
         RelDataType ret = typeFactory.createSqlType(typeName);
-        ret = typeFactory.createTypeWithNullability(ret, null == value);
+        ret = typeFactory.createTypeWithNullability(ret, value == null);
         return ret;
       case BINARY:
         bitString = (BitString) requireNonNull(value, "value");
@@ -730,11 +730,11 @@ public RelDataType createSqlType(RelDataTypeFactory typeFactory) {
       case CHAR:
         NlsString string = (NlsString) requireNonNull(value, "value");
         Charset charset = string.getCharset();
-        if (null == charset) {
+        if (charset == null) {
           charset = typeFactory.getDefaultCharset();
         }
         SqlCollation collation = string.getCollation();
-        if (null == collation) {
+        if (collation == null) {
           collation = SqlCollation.COERCIBLE;
         }
         RelDataType type = typeFactory.createSqlType(SqlTypeName.CHAR, string.getValue().length());
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java b/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java
index b64cd2b89..d974ff595 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlMatchRecognize.java
@@ -87,7 +87,7 @@ public SqlMatchRecognize(
     this.strictStart = strictStart;
     this.strictEnd = strictEnd;
     this.patternDefList = Objects.requireNonNull(patternDefList, "patternDefList");
-    Preconditions.checkArgument(patternDefList.size() > 0);
+    Preconditions.checkArgument(!patternDefList.isEmpty());
     this.measureList = Objects.requireNonNull(measureList, "measureList");
     this.after = after;
     this.subsetList = subsetList;
@@ -151,7 +151,7 @@ public SqlMatchRecognize(
         break;
       case OPERAND_PATTERN_DEFINES:
         patternDefList = Objects.requireNonNull((SqlNodeList) operand);
-        Preconditions.checkArgument(patternDefList.size() > 0);
+        Preconditions.checkArgument(!patternDefList.isEmpty());
         break;
       case OPERAND_MEASURES:
         measureList = Objects.requireNonNull((SqlNodeList) operand);
@@ -332,7 +332,7 @@ private SqlMatchRecognizeOperator() {
       pattern.tableRef.unparse(writer, 0, 0);
       final SqlWriter.Frame mrFrame = writer.startFunCall("MATCH_RECOGNIZE");
 
-      if (pattern.partitionList != null && pattern.partitionList.size() > 0) {
+      if (pattern.partitionList != null && !pattern.partitionList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("PARTITION BY");
         final SqlWriter.Frame partitionFrame = writer.startList("", "");
@@ -340,13 +340,13 @@ private SqlMatchRecognizeOperator() {
         writer.endList(partitionFrame);
       }
 
-      if (pattern.orderList != null && pattern.orderList.size() > 0) {
+      if (pattern.orderList != null && !pattern.orderList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("ORDER BY");
         writer.list(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, SqlWriter.COMMA, pattern.orderList);
       }
 
-      if (pattern.measureList != null && pattern.measureList.size() > 0) {
+      if (pattern.measureList != null && !pattern.measureList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("MEASURES");
         final SqlWriter.Frame measureFrame = writer.startList("", "");
@@ -385,7 +385,7 @@ private SqlMatchRecognizeOperator() {
         interval.unparse(writer, 0, 0);
       }
 
-      if (pattern.subsetList != null && pattern.subsetList.size() > 0) {
+      if (pattern.subsetList != null && !pattern.subsetList.isEmpty()) {
         writer.newlineAndIndent();
         writer.sep("SUBSET");
         SqlWriter.Frame subsetFrame = writer.startList("", "");
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlOperator.java
index 3c70aa85e..95dad2d50 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlOperator.java
@@ -47,6 +47,8 @@
 import java.util.Objects;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.util.Static.RESOURCE;
 
@@ -462,13 +464,11 @@ protected void preValidateCall(SqlValidator validator, SqlValidatorScope scope,
   public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
     if (returnTypeInference != null) {
       RelDataType returnType = returnTypeInference.inferReturnType(opBinding);
-      if (returnType == null) {
-        throw new IllegalArgumentException(
-            "Cannot infer return type for "
-                + opBinding.getOperator()
-                + "; operand types: "
-                + opBinding.collectOperandTypes());
-      }
+      checkArgument(
+          returnType != null,
+          "Cannot infer return type for %s; operand types: %s",
+          opBinding.getOperator(),
+          opBinding.collectOperandTypes());
 
       if (operandTypeInference != null
           && opBinding instanceof SqlCallBinding
@@ -656,7 +656,7 @@ public final RelDataType inferReturnType(
    */
   public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     // Check that all of the operands are of the right type.
-    if (null == operandTypeChecker) {
+    if (operandTypeChecker == null) {
       // If you see this you must either give operandTypeChecker a value
       // or override this method.
       throw Util.needToImplement(this);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
index 6afbbd813..05fc110a6 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlOverOperator.java
@@ -25,6 +25,8 @@
 import org.apache.calcite.sql.validate.SqlValidator;
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
@@ -89,10 +91,11 @@ public SqlOverOperator() {
     // can be empty
     SqlNode agg = call.operand(0);
 
-    if (!(agg instanceof SqlCall)) {
-      throw new IllegalStateException(
-          "Argument to SqlOverOperator" + " should be SqlCall, got " + agg.getClass() + ": " + agg);
-    }
+    checkState(
+        (agg instanceof SqlCall),
+        "Argument to SqlOverOperator should be SqlCall, got %s: %s",
+        agg.getClass(),
+        agg);
 
     SqlNode window = call.operand(1);
     SqlWindow w = validator.resolveWindow(window, scope);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
index 6585be6af..55b2b182c 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlPostfixOperator.java
@@ -66,12 +66,12 @@ public SqlPostfixOperator(
       // Determine coercibility and resulting collation name of
       // unary operator if needed.
       RelDataType operandType = validator.getValidatedNodeType(call.operand(0));
-      if (null == operandType) {
+      if (operandType == null) {
         throw new AssertionError("operand's type should have been derived");
       }
       if (SqlTypeUtil.inCharFamily(operandType)) {
         SqlCollation collation = operandType.getCollation();
-        assert null != collation : "An implicit or explicit collation should have been set";
+        assert collation != null : "An implicit or explicit collation should have been set";
         type =
             validator
                 .getTypeFactory()
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
index a691557cf..cfc7e5f87 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlPrefixOperator.java
@@ -68,7 +68,7 @@ public SqlPrefixOperator(
       // Determine coercibility and resulting collation name of
       // unary operator if needed.
       RelDataType operandType = validator.getValidatedNodeType(call.operand(0));
-      if (null == operandType) {
+      if (operandType == null) {
         throw new AssertionError("operand's type should have been derived");
       }
       if (SqlTypeUtil.inCharFamily(operandType)) {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
index 8b9ccf547..b5695687c 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlProcedureCallOperator.java
@@ -20,7 +20,7 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.validate.SqlValidator;
 
-import java.util.Collections;
+import com.google.common.collect.ImmutableList;
 
 /**
  * SqlProcedureCallOperator represents the CALL statement. It takes a single operand which is the
@@ -43,7 +43,7 @@ public SqlProcedureCallOperator() {
     return new SqlSelect(
         SqlParserPos.ZERO,
         null,
-        new SqlNodeList(Collections.singletonList(call.operand(0)), SqlParserPos.ZERO),
+        new SqlNodeList(ImmutableList.of(call.operand(0)), SqlParserPos.ZERO),
         SqlStdOperatorTable.VALUES.createCall(
             SqlParserPos.ZERO,
             SqlStdOperatorTable.ROW.createCall(
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
index 9e4f04229..13bfc08c4 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlRowTypeNameSpec.java
@@ -70,7 +70,7 @@ public SqlRowTypeNameSpec(
     super(new SqlIdentifier(SqlTypeName.ROW.getName(), pos), pos);
     Objects.requireNonNull(fieldNames, "fieldNames");
     Objects.requireNonNull(fieldTypes, "fieldTypes");
-    assert fieldNames.size() > 0; // there must be at least one field.
+    assert !fieldNames.isEmpty(); // there must be at least one field.
     this.fieldNames = fieldNames;
     this.fieldTypes = fieldTypes;
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSelect.java b/core/src/main/java/org/apache/calcite/sql/SqlSelect.java
index 81d2a87db..166f1d594 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSelect.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSelect.java
@@ -296,7 +296,7 @@ public void setHints(@Nullable SqlNodeList hints) {
   @EnsuresNonNullIf(expression = "hints", result = true)
   public boolean hasHints() {
     // The hints may be passed as null explicitly.
-    return this.hints != null && this.hints.size() > 0;
+    return this.hints != null && !this.hints.isEmpty();
   }
 
   @Override public void validate(SqlValidator validator, SqlValidatorScope scope) {
@@ -327,7 +327,7 @@ public boolean hasHints() {
   }
 
   public boolean hasOrderBy() {
-    return orderBy != null && orderBy.size() != 0;
+    return orderBy != null && !orderBy.isEmpty();
   }
 
   public boolean hasWhere() {
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java
index 3b2c095ca..fcb770305 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSelectOperator.java
@@ -197,8 +197,7 @@ public SqlSelect createCall(
       }
     }
     if (select.groupBy != null) {
-      SqlNodeList groupBy =
-          select.groupBy.size() == 0 ? SqlNodeList.SINGLETON_EMPTY : select.groupBy;
+      SqlNodeList groupBy = select.groupBy.isEmpty() ? SqlNodeList.SINGLETON_EMPTY : select.groupBy;
       // if the DISTINCT keyword of GROUP BY is present it can be the only item
       if (groupBy.size() == 1
           && groupBy.get(0) != null
@@ -215,7 +214,7 @@ public SqlSelect createCall(
       writer.sep("HAVING");
       select.having.unparse(writer, 0, 0);
     }
-    if (select.windowDecls.size() > 0) {
+    if (!select.windowDecls.isEmpty()) {
       writer.sep("WINDOW");
       writer.list(SqlWriter.FrameTypeEnum.WINDOW_DECL_LIST, SqlWriter.COMMA, select.windowDecls);
     }
@@ -223,7 +222,7 @@ public SqlSelect createCall(
       writer.sep("QUALIFY");
       select.qualify.unparse(writer, 0, 0);
     }
-    if (select.orderBy != null && select.orderBy.size() > 0) {
+    if (select.orderBy != null && !select.orderBy.isEmpty()) {
       writer.sep("ORDER BY");
       writer.list(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, SqlWriter.COMMA, select.orderBy);
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java b/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java
index 98594a27f..220c00d7f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlSetSemanticsTableOperator.java
@@ -53,14 +53,14 @@ public SqlSetSemanticsTableOperator() {
     call.operand(0).unparse(writer, 0, 0);
 
     SqlNodeList partitionList = call.operand(1);
-    if (partitionList.size() > 0) {
+    if (!partitionList.isEmpty()) {
       writer.sep("PARTITION BY");
       final SqlWriter.Frame partitionFrame = writer.startList("", "");
       partitionList.unparse(writer, 0, 0);
       writer.endList(partitionFrame);
     }
     SqlNodeList orderList = call.operand(2);
-    if (orderList.size() > 0) {
+    if (!orderList.isEmpty()) {
       writer.sep("ORDER BY");
       writer.list(SqlWriter.FrameTypeEnum.ORDER_BY_LIST, SqlWriter.COMMA, orderList);
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java b/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java
index b4b4cb87a..f2c01c55f 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlTableRef.java
@@ -73,7 +73,7 @@ public SqlTableRef(SqlParserPos pos, SqlIdentifier tableName, SqlNodeList hints)
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
     tableName.unparse(writer, leftPrec, rightPrec);
-    if (this.hints != null && this.hints.size() > 0) {
+    if (this.hints != null && !this.hints.isEmpty()) {
       writer.getDialect().unparseTableScanHints(writer, this.hints, leftPrec, rightPrec);
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlUtil.java b/core/src/main/java/org/apache/calcite/sql/SqlUtil.java
index 936e71516..09acbca0a 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlUtil.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlUtil.java
@@ -180,7 +180,7 @@ public static boolean isNullLiteral(@Nullable SqlNode node, boolean allowCast) {
     if (node instanceof SqlLiteral) {
       SqlLiteral literal = (SqlLiteral) node;
       if (literal.getTypeName() == SqlTypeName.NULL) {
-        assert null == literal.getValue();
+        assert literal.getValue() == null;
         return true;
       } else {
         // We don't regard UNKNOWN -- SqlLiteral(null,Boolean) -- as
@@ -401,7 +401,7 @@ public static void unparseSqlIdentifierSyntax(
         }
       }
     }
-    if (null != identifier.getCollation()) {
+    if (identifier.getCollation() != null) {
       identifier.getCollation().unparse(writer);
     }
     writer.endList(frame);
@@ -656,7 +656,7 @@ private static Iterator<SqlOperator> filterRoutinesByParameterTypeAndName(
                   return false;
                 }
               } else {
-                permutedArgTypes = Lists.newArrayList(argTypes);
+                permutedArgTypes = new ArrayList<>(argTypes);
                 while (permutedArgTypes.size() < argTypes.size()) {
                   paramTypes.add(null);
                 }
@@ -850,7 +850,7 @@ public static String getOperatorSignature(SqlOperator op, List<?> typeList) {
   public static String getAliasedSignature(SqlOperator op, String opName, List<?> typeList) {
     StringBuilder ret = new StringBuilder();
     String template = op.getSignatureTemplate(typeList.size());
-    if (null == template) {
+    if (template == null) {
       ret.append("'");
       ret.append(opName);
       ret.append("(");
@@ -928,16 +928,15 @@ public static boolean isCallTo(SqlNode node, SqlOperator operator) {
    */
   public static RelDataType createNlsStringType(RelDataTypeFactory typeFactory, NlsString str) {
     Charset charset = str.getCharset();
-    if (null == charset) {
+    if (charset == null) {
       charset = typeFactory.getDefaultCharset();
     }
     SqlCollation collation = str.getCollation();
-    if (null == collation) {
+    if (collation == null) {
       collation = SqlCollation.COERCIBLE;
     }
     RelDataType type = typeFactory.createSqlType(SqlTypeName.CHAR, str.getValue().length());
-    type = typeFactory.createTypeWithCharsetAndCollation(type, charset, collation);
-    return type;
+    return typeFactory.createTypeWithCharsetAndCollation(type, charset, collation);
   }
 
   /**
@@ -1062,7 +1061,7 @@ public static ImmutableList<SqlNode> getAncestry(
    */
   public static List<RelHint> getRelHint(
       HintStrategyTable hintStrategies, @Nullable SqlNodeList sqlHints) {
-    if (sqlHints == null || sqlHints.size() == 0) {
+    if (sqlHints == null || sqlHints.isEmpty()) {
       return ImmutableList.of();
     }
     final ImmutableList.Builder<RelHint> relHints = ImmutableList.builder();
@@ -1106,7 +1105,7 @@ public static List<RelHint> getRelHint(
   public static RelNode attachRelHint(
       HintStrategyTable hintStrategies, List<RelHint> hints, Hintable rel) {
     final List<RelHint> relHints = hintStrategies.apply(hints, (RelNode) rel);
-    if (relHints.size() > 0) {
+    if (!relHints.isEmpty()) {
       return rel.attachHints(relHints);
     }
     return (RelNode) rel;
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWindow.java b/core/src/main/java/org/apache/calcite/sql/SqlWindow.java
index 235a68763..645ce94ca 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWindow.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWindow.java
@@ -202,7 +202,7 @@ public static SqlWindow create(
   }
 
   @Override public void unparse(SqlWriter writer, int leftPrec, int rightPrec) {
-    if (null != declName) {
+    if (declName != null) {
       declName.unparse(writer, 0, 0);
       writer.keyword("AS");
     }
@@ -322,7 +322,7 @@ static void checkSpecialLiterals(SqlWindow window, SqlValidator validator) {
     Object upperLitType = null;
     SqlOperator lowerOp = null;
     SqlOperator upperOp = null;
-    if (null != lowerBound) {
+    if (lowerBound != null) {
       if (lowerBound.getKind() == SqlKind.LITERAL) {
         lowerLitType = ((SqlLiteral) lowerBound).getValue();
         if (Bound.UNBOUNDED_FOLLOWING == lowerLitType) {
@@ -332,7 +332,7 @@ static void checkSpecialLiterals(SqlWindow window, SqlValidator validator) {
         lowerOp = ((SqlCall) lowerBound).getOperator();
       }
     }
-    if (null != upperBound) {
+    if (upperBound != null) {
       if (upperBound.getKind() == SqlKind.LITERAL) {
         upperLitType = ((SqlLiteral) upperBound).getValue();
         if (Bound.UNBOUNDED_PRECEDING == upperLitType) {
@@ -344,20 +344,20 @@ static void checkSpecialLiterals(SqlWindow window, SqlValidator validator) {
     }
 
     if (Bound.CURRENT_ROW == lowerLitType) {
-      if (null != upperOp) {
+      if (upperOp != null) {
         if (upperOp == PRECEDING_OPERATOR) {
           throw validator.newValidationError(
               castNonNull(upperBound), RESOURCE.currentRowPrecedingError());
         }
       }
-    } else if (null != lowerOp) {
+    } else if (lowerOp != null) {
       if (lowerOp == FOLLOWING_OPERATOR) {
-        if (null != upperOp) {
+        if (upperOp != null) {
           if (upperOp == PRECEDING_OPERATOR) {
             throw validator.newValidationError(
                 castNonNull(upperBound), RESOURCE.followingBeforePrecedingError());
           }
-        } else if (null != upperLitType) {
+        } else if (upperLitType != null) {
           if (Bound.CURRENT_ROW == upperLitType) {
             throw validator.newValidationError(
                 castNonNull(upperBound), RESOURCE.currentRowFollowingError());
@@ -451,7 +451,7 @@ public SqlWindow overlay(SqlWindow that, SqlValidator validator) {
     // 711 rule 10e
     final SqlNode lowerBound = that.getLowerBound();
     final SqlNode upperBound = that.getUpperBound();
-    if ((null != lowerBound) || (null != upperBound)) {
+    if (lowerBound != null || upperBound != null) {
       throw validator.newValidationError(that.isRows, RESOURCE.refWindowWithFrame());
     }
 
@@ -586,7 +586,7 @@ public boolean isAllowPartial() {
     }
 
     // 6.10 rule 6a Function RANK & DENSE_RANK require ORDER BY clause
-    if (orderList.size() == 0
+    if (orderList.isEmpty()
         && !SqlValidatorUtil.containsMonotonic(scope)
         && windowCall != null
         && windowCall.getOperator().requiresOrder()) {
@@ -602,7 +602,7 @@ public boolean isAllowPartial() {
       SqlTypeFamily orderTypeFam = null;
 
       // SQL03 7.10 Rule 11a
-      if (orderList.size() > 0) {
+      if (!orderList.isEmpty()) {
         // if order by is a compound list then range not allowed
         if (orderList.size() > 1 && !isRows()) {
           throw validator.newValidationError(isRows, RESOURCE.compoundOrderByProhibitsRange());
@@ -626,7 +626,7 @@ public boolean isAllowPartial() {
 
       // Validate across boundaries. 7.10 Rule 8 a-d
       checkSpecialLiterals(this, validator);
-    } else if (orderList.size() == 0
+    } else if (orderList.isEmpty()
         && !SqlValidatorUtil.containsMonotonic(scope)
         && windowCall != null
         && windowCall.getOperator().requiresOrder()) {
@@ -645,7 +645,7 @@ private static void validateFrameBoundary(
       @Nullable SqlTypeFamily orderTypeFam,
       SqlValidator validator,
       SqlValidatorScope scope) {
-    if (null == bound) {
+    if (bound == null) {
       return;
     }
     bound.validate(validator, scope);
@@ -831,13 +831,13 @@ private SqlWindowOperator() {
       if (window.refName != null) {
         window.refName.unparse(writer, 0, 0);
       }
-      if (window.partitionList.size() > 0) {
+      if (!window.partitionList.isEmpty()) {
         writer.sep("PARTITION BY");
         final SqlWriter.Frame partitionFrame = writer.startList("", "");
         window.partitionList.unparse(writer, 0, 0);
         writer.endList(partitionFrame);
       }
-      if (window.orderList.size() > 0) {
+      if (!window.orderList.isEmpty()) {
         writer.sep("ORDER BY");
         final SqlWriter.Frame orderFrame = writer.startList("", "");
         window.orderList.unparse(writer, 0, 0);
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java b/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java
index 53b38293f..61fc532a2 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java
@@ -30,7 +30,6 @@
 import org.apache.calcite.sql.validate.SqlValidator;
 
 import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -124,7 +123,7 @@ protected abstract static class AbstractOperandMetadata implements SqlOperandMet
     final int mandatoryParamCount;
 
     AbstractOperandMetadata(List<String> paramNames, int mandatoryParamCount) {
-      this.paramNames = ImmutableList.copyOf(paramNames);
+      this.paramNames = paramNames;
       this.mandatoryParamCount = mandatoryParamCount;
       Preconditions.checkArgument(
           mandatoryParamCount >= 0 && mandatoryParamCount <= paramNames.size());
diff --git a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
index 101f680af..544f58f9a 100644
--- a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
+++ b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisor.java
@@ -45,7 +45,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
@@ -144,7 +143,7 @@ public List<SqlMoniker> getCompletionHints(String sql, int cursor, String[] repl
     }
 
     if (wordStart < 0) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
 
     // Search forwards to the end of the word we should remove. Eat up
@@ -171,12 +170,12 @@ public List<SqlMoniker> getCompletionHints(String sql, int cursor, String[] repl
     }
 
     if (word.isEmpty()) {
-      return ImmutableList.copyOf(completionHints);
+      return completionHints;
     }
 
     // If cursor was part of the way through a word, only include hints
     // which start with that word in the result.
-    final ImmutableList.Builder<SqlMoniker> result = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<SqlMoniker> result = ImmutableList.builder();
     Casing preferredCasing = getPreferredCasing(word);
 
     boolean ignoreCase = preferredCasing != Casing.UNCHANGED;
@@ -197,7 +196,7 @@ public List<SqlMoniker> getCompletionHints0(String sql, int cursor) {
     String simpleSql = simplifySql(sql, cursor);
     int idx = simpleSql.indexOf(HINT_TOKEN);
     if (idx < 0) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     SqlParserPos pos = new SqlParserPos(1, idx + 1);
     return getCompletionHints(simpleSql, pos);
diff --git a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java
index 7943aa1c6..29b69d6ec 100644
--- a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction.java
@@ -34,6 +34,7 @@
 import org.apache.calcite.sql.validate.SqlMoniker;
 import org.apache.calcite.util.BuiltInMethod;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -41,7 +42,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /** Table function that returns completion hints for a given SQL statement. */
@@ -66,7 +66,7 @@ public class SqlAdvisorGetHintsFunction implements TableFunction, ImplementableF
       RexImpTable.createImplementor(
           (translator, call, operands) ->
               Expressions.call(
-                  GET_COMPLETION_HINTS, Iterables.concat(Collections.singleton(ADVISOR), operands)),
+                  GET_COMPLETION_HINTS, Iterables.concat(ImmutableSet.of(ADVISOR), operands)),
           NullPolicy.ANY,
           false);
 
diff --git a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java
index 57d6a9be5..131ef6ed3 100644
--- a/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java
+++ b/core/src/main/java/org/apache/calcite/sql/advise/SqlAdvisorGetHintsFunction2.java
@@ -34,6 +34,7 @@
 import org.apache.calcite.sql.validate.SqlMoniker;
 import org.apache.calcite.util.BuiltInMethod;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -41,7 +42,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -69,7 +69,7 @@ public class SqlAdvisorGetHintsFunction2 implements TableFunction, Implementable
       RexImpTable.createImplementor(
           (translator, call, operands) ->
               Expressions.call(
-                  GET_COMPLETION_HINTS, Iterables.concat(Collections.singleton(ADVISOR), operands)),
+                  GET_COMPLETION_HINTS, Iterables.concat(ImmutableSet.of(ADVISOR), operands)),
           NullPolicy.ANY,
           false);
 
diff --git a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java
index d6f7b1f87..a2172d611 100644
--- a/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/ddl/SqlCreateFunction.java
@@ -68,7 +68,7 @@ public SqlCreateFunction(
     name.unparse(writer, 0, 0);
     writer.keyword("AS");
     className.unparse(writer, 0, 0);
-    if (usingList.size() > 0) {
+    if (!usingList.isEmpty()) {
       writer.keyword("USING");
       final SqlWriter.Frame frame = writer.startList(SqlWriter.FrameTypeEnum.SIMPLE);
       for (Pair<SqlLiteral, SqlLiteral> using : pairs()) {
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
index 63b2560a4..00b55e2f5 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/BigQuerySqlDialect.java
@@ -46,8 +46,6 @@
 import org.apache.calcite.util.format.FormatModel;
 import org.apache.calcite.util.format.FormatModels;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Arrays;
@@ -74,103 +72,102 @@ public class BigQuerySqlDialect extends SqlDialect {
   public static final SqlDialect DEFAULT = new BigQuerySqlDialect(DEFAULT_CONTEXT);
 
   private static final List<String> RESERVED_KEYWORDS =
-      ImmutableList.copyOf(
-          Arrays.asList(
-              "ALL",
-              "AND",
-              "ANY",
-              "ARRAY",
-              "AS",
-              "ASC",
-              "ASSERT_ROWS_MODIFIED",
-              "AT",
-              "BETWEEN",
-              "BY",
-              "CASE",
-              "CAST",
-              "COLLATE",
-              "CONTAINS",
-              "CREATE",
-              "CROSS",
-              "CUBE",
-              "CURRENT",
-              "DEFAULT",
-              "DEFINE",
-              "DESC",
-              "DISTINCT",
-              "ELSE",
-              "END",
-              "ENUM",
-              "ESCAPE",
-              "EXCEPT",
-              "EXCLUDE",
-              "EXISTS",
-              "EXTRACT",
-              "FALSE",
-              "FETCH",
-              "FOLLOWING",
-              "FOR",
-              "FROM",
-              "FULL",
-              "GROUP",
-              "GROUPING",
-              "GROUPS",
-              "HASH",
-              "HAVING",
-              "IF",
-              "IGNORE",
-              "IN",
-              "INNER",
-              "INTERSECT",
-              "INTERVAL",
-              "INTO",
-              "IS",
-              "JOIN",
-              "LATERAL",
-              "LEFT",
-              "LIKE",
-              "LIMIT",
-              "LOOKUP",
-              "MERGE",
-              "NATURAL",
-              "NEW",
-              "NO",
-              "NOT",
-              "NULL",
-              "NULLS",
-              "OF",
-              "ON",
-              "OR",
-              "ORDER",
-              "OUTER",
-              "OVER",
-              "PARTITION",
-              "PRECEDING",
-              "PROTO",
-              "RANGE",
-              "RECURSIVE",
-              "RESPECT",
-              "RIGHT",
-              "ROLLUP",
-              "ROWS",
-              "SELECT",
-              "SET",
-              "SOME",
-              "STRUCT",
-              "TABLESAMPLE",
-              "THEN",
-              "TO",
-              "TREAT",
-              "TRUE",
-              "UNBOUNDED",
-              "UNION",
-              "UNNEST",
-              "USING",
-              "WHEN",
-              "WHERE",
-              "WINDOW",
-              "WITH",
-              "WITHIN"));
+      Arrays.asList(
+          "ALL",
+          "AND",
+          "ANY",
+          "ARRAY",
+          "AS",
+          "ASC",
+          "ASSERT_ROWS_MODIFIED",
+          "AT",
+          "BETWEEN",
+          "BY",
+          "CASE",
+          "CAST",
+          "COLLATE",
+          "CONTAINS",
+          "CREATE",
+          "CROSS",
+          "CUBE",
+          "CURRENT",
+          "DEFAULT",
+          "DEFINE",
+          "DESC",
+          "DISTINCT",
+          "ELSE",
+          "END",
+          "ENUM",
+          "ESCAPE",
+          "EXCEPT",
+          "EXCLUDE",
+          "EXISTS",
+          "EXTRACT",
+          "FALSE",
+          "FETCH",
+          "FOLLOWING",
+          "FOR",
+          "FROM",
+          "FULL",
+          "GROUP",
+          "GROUPING",
+          "GROUPS",
+          "HASH",
+          "HAVING",
+          "IF",
+          "IGNORE",
+          "IN",
+          "INNER",
+          "INTERSECT",
+          "INTERVAL",
+          "INTO",
+          "IS",
+          "JOIN",
+          "LATERAL",
+          "LEFT",
+          "LIKE",
+          "LIMIT",
+          "LOOKUP",
+          "MERGE",
+          "NATURAL",
+          "NEW",
+          "NO",
+          "NOT",
+          "NULL",
+          "NULLS",
+          "OF",
+          "ON",
+          "OR",
+          "ORDER",
+          "OUTER",
+          "OVER",
+          "PARTITION",
+          "PRECEDING",
+          "PROTO",
+          "RANGE",
+          "RECURSIVE",
+          "RESPECT",
+          "RIGHT",
+          "ROLLUP",
+          "ROWS",
+          "SELECT",
+          "SET",
+          "SOME",
+          "STRUCT",
+          "TABLESAMPLE",
+          "THEN",
+          "TO",
+          "TREAT",
+          "TRUE",
+          "UNBOUNDED",
+          "UNION",
+          "UNNEST",
+          "USING",
+          "WHEN",
+          "WHERE",
+          "WINDOW",
+          "WITH",
+          "WITHIN");
 
   /**
    * An unquoted BigQuery identifier must start with a letter and be followed by zero or more
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java
index db6de9ae2..901e36a24 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/Db2SqlDialect.java
@@ -68,7 +68,7 @@ public Db2SqlDialect(Context context) {
         throw new AssertionError("Unsupported type: " + qualifier.timeUnitRange);
     }
 
-    if (null != qualifier.timeUnitRange.endUnit) {
+    if (qualifier.timeUnitRange.endUnit != null) {
       throw new AssertionError("Unsupported end unit: " + qualifier.timeUnitRange.endUnit);
     }
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java
index d3b4f45b8..e2edbfaab 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/FireboltSqlDialect.java
@@ -37,8 +37,6 @@
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.util.RelToSqlConverterUtil;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Arrays;
@@ -63,117 +61,116 @@ public FireboltSqlDialect(Context context) {
 
   /** Reserved Keywords for Firebolt. */
   private static final List<String> RESERVED_KEYWORDS =
-      ImmutableList.copyOf(
-          Arrays.asList(
-              "ALL",
-              "ALTER",
-              "AND",
-              "ARRAY",
-              "BETWEEN",
-              "BIGINT",
-              "BOOL",
-              "BOOLEAN",
-              "BOTH",
-              "CASE",
-              "CAST",
-              "CHAR",
-              "CONCAT",
-              "COPY",
-              "CREATE",
-              "CROSS",
-              "CURRENT_DATE",
-              "CURRENT_TIMESTAMP",
-              "DATABASE",
-              "DATE",
-              "DATETIME",
-              "DECIMAL",
-              "DELETE",
-              "DESCRIBE",
-              "DISTINCT",
-              "DOUBLE",
-              "DOUBLECOLON",
-              "DOW",
-              "DOY",
-              "DROP",
-              "EMPTY_IDENTIFIER",
-              "EPOCH",
-              "EXCEPT",
-              "EXECUTE",
-              "EXISTS",
-              "EXPLAIN",
-              "EXTRACT",
-              "FALSE",
-              "FETCH",
-              "FIRST",
-              "FLOAT",
-              "FROM",
-              "FULL",
-              "GENERATE",
-              "GROUP",
-              "HAVING",
-              "IF",
-              "ILIKE",
-              "IN",
-              "INNER",
-              "INSERT",
-              "INT",
-              "INTEGER",
-              "INTERSECT",
-              "INTERVAL",
-              "IS",
-              "ISNULL",
-              "JOIN",
-              "JOIN_TYPE",
-              "LEADING",
-              "LEFT",
-              "LIKE",
-              "LIMIT",
-              "LIMIT_DISTINCT",
-              "LOCALTIMESTAMP",
-              "LONG",
-              "NATURAL",
-              "NEXT",
-              "NOT",
-              "NULL",
-              "NUMERIC",
-              "OFFSET",
-              "ON",
-              "ONLY",
-              "OR",
-              "ORDER",
-              "OUTER",
-              "OVER",
-              "PARTITION",
-              "PRECISION",
-              "PREPARE",
-              "PRIMARY",
-              "QUARTER",
-              "RIGHT",
-              "ROW",
-              "ROWS",
-              "SAMPLE",
-              "SELECT",
-              "SET",
-              "SHOW",
-              "TEXT",
-              "TIME",
-              "TIMESTAMP",
-              "TOP",
-              "TRAILING",
-              "TRIM",
-              "TRUE",
-              "TRUNCATE",
-              "UNION",
-              "UNKNOWN_CHAR",
-              "UNNEST",
-              "UNTERMINATED_STRING",
-              "UPDATE",
-              "USING",
-              "VARCHAR",
-              "WEEK",
-              "WHEN",
-              "WHERE",
-              "WITH"));
+      Arrays.asList(
+          "ALL",
+          "ALTER",
+          "AND",
+          "ARRAY",
+          "BETWEEN",
+          "BIGINT",
+          "BOOL",
+          "BOOLEAN",
+          "BOTH",
+          "CASE",
+          "CAST",
+          "CHAR",
+          "CONCAT",
+          "COPY",
+          "CREATE",
+          "CROSS",
+          "CURRENT_DATE",
+          "CURRENT_TIMESTAMP",
+          "DATABASE",
+          "DATE",
+          "DATETIME",
+          "DECIMAL",
+          "DELETE",
+          "DESCRIBE",
+          "DISTINCT",
+          "DOUBLE",
+          "DOUBLECOLON",
+          "DOW",
+          "DOY",
+          "DROP",
+          "EMPTY_IDENTIFIER",
+          "EPOCH",
+          "EXCEPT",
+          "EXECUTE",
+          "EXISTS",
+          "EXPLAIN",
+          "EXTRACT",
+          "FALSE",
+          "FETCH",
+          "FIRST",
+          "FLOAT",
+          "FROM",
+          "FULL",
+          "GENERATE",
+          "GROUP",
+          "HAVING",
+          "IF",
+          "ILIKE",
+          "IN",
+          "INNER",
+          "INSERT",
+          "INT",
+          "INTEGER",
+          "INTERSECT",
+          "INTERVAL",
+          "IS",
+          "ISNULL",
+          "JOIN",
+          "JOIN_TYPE",
+          "LEADING",
+          "LEFT",
+          "LIKE",
+          "LIMIT",
+          "LIMIT_DISTINCT",
+          "LOCALTIMESTAMP",
+          "LONG",
+          "NATURAL",
+          "NEXT",
+          "NOT",
+          "NULL",
+          "NUMERIC",
+          "OFFSET",
+          "ON",
+          "ONLY",
+          "OR",
+          "ORDER",
+          "OUTER",
+          "OVER",
+          "PARTITION",
+          "PRECISION",
+          "PREPARE",
+          "PRIMARY",
+          "QUARTER",
+          "RIGHT",
+          "ROW",
+          "ROWS",
+          "SAMPLE",
+          "SELECT",
+          "SET",
+          "SHOW",
+          "TEXT",
+          "TIME",
+          "TIMESTAMP",
+          "TOP",
+          "TRAILING",
+          "TRIM",
+          "TRUE",
+          "TRUNCATE",
+          "UNION",
+          "UNKNOWN_CHAR",
+          "UNNEST",
+          "UNTERMINATED_STRING",
+          "UPDATE",
+          "USING",
+          "VARCHAR",
+          "WEEK",
+          "WHEN",
+          "WHERE",
+          "WITH");
 
   /**
    * An unquoted Firebolt identifier must start with a letter and be followed by zero or more
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
index 9882359b5..004b611e9 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/JethroDataSqlDialect.java
@@ -102,7 +102,7 @@ public JethroDataSqlDialect(Context context) {
         }
       }
     }
-    LOGGER.debug("Unsupported function in jethro: " + operator + " with params " + paramTypes);
+    LOGGER.debug("Unsupported function in jethro: {} with params {}", operator, paramTypes);
     return false;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
index 48e292fee..5f1451ad1 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/MssqlSqlDialect.java
@@ -40,6 +40,8 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** A <code>SqlDialect</code> implementation for the Microsoft SQL Server database. */
@@ -147,9 +149,7 @@ public MssqlSqlDialect(Context context) {
 
   @Override public void unparseCall(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
     if (call.getOperator() == SqlStdOperatorTable.SUBSTRING) {
-      if (call.operandCount() != 3) {
-        throw new IllegalArgumentException("MSSQL SUBSTRING requires FROM and FOR arguments");
-      }
+      checkArgument(call.operandCount() == 3, "MSSQL SUBSTRING requires FROM and FOR arguments");
       SqlUtil.unparseFunctionSyntax(MSSQL_SUBSTRING, writer, call, false);
     } else {
       switch (call.getKind()) {
@@ -260,7 +260,7 @@ private static void unparseFloor(SqlWriter writer, SqlCall call) {
         throw new AssertionError("Unsupported type: " + qualifier.timeUnitRange);
     }
 
-    if (null != qualifier.timeUnitRange.endUnit) {
+    if (qualifier.timeUnitRange.endUnit != null) {
       throw new AssertionError("End unit is not supported now: " + qualifier.timeUnitRange.endUnit);
     }
   }
@@ -290,7 +290,7 @@ private static void unparseFloorWithUnit(
     call.operand(0).unparse(writer, 0, 0);
     writer.print(", 126)");
 
-    if (offset.length() > 0) {
+    if (!offset.isEmpty()) {
       writer.print("+'" + offset + "'");
     }
     writer.endList(frame);
diff --git a/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java b/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
index a828ca3e6..dd1a50fae 100644
--- a/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
+++ b/core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java
@@ -239,7 +239,7 @@ public MysqlSqlDialect(Context context) {
 
       case WITHIN_GROUP:
         final List<SqlNode> operands = call.getOperandList();
-        if (operands.size() <= 0 || operands.get(0).getKind() != SqlKind.LISTAGG) {
+        if (operands.isEmpty() || operands.get(0).getKind() != SqlKind.LISTAGG) {
           super.unparseCall(writer, call, leftPrec, rightPrec);
           return;
         }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java
index c97b7aaeb..52060f58c 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlCase.java
@@ -83,7 +83,7 @@ public static SqlCase createSwitched(
       SqlNodeList whenList,
       SqlNodeList thenList,
       @Nullable SqlNode elseClause) {
-    if (null != value) {
+    if (value != null) {
       for (int i = 0; i < whenList.size(); i++) {
         SqlNode e = whenList.get(i);
         final SqlCall call;
@@ -96,7 +96,7 @@ public static SqlCase createSwitched(
       }
     }
 
-    if (null == elseClause) {
+    if (elseClause == null) {
       elseClause = SqlLiteral.createNull(pos);
     }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
index a0d951d9c..48282b1f0 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlCaseOperator.java
@@ -262,7 +262,7 @@ private static RelDataType inferTypeFromValidator(SqlCallBinding callBinding) {
     }
 
     RelDataType ret = typeFactory.leastRestrictive(argTypes);
-    if (null == ret) {
+    if (ret == null) {
       boolean coerced = false;
       if (callBinding.isTypeCoercionEnabled()) {
         TypeCoercion typeCoercion = callBinding.getValidator().getTypeCoercion();
@@ -271,7 +271,7 @@ private static RelDataType inferTypeFromValidator(SqlCallBinding callBinding) {
         // nullability when deducing the common type. Use the deduced type
         // (with the correct nullability) in SqlValidator
         // instead of the commonType as the return type.
-        if (null != commonType) {
+        if (commonType != null) {
           coerced = typeCoercion.caseWhenCoercion(callBinding);
           if (coerced) {
             ret = SqlTypeUtil.deriveType(callBinding);
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java
index fcc9b6621..9b8164287 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlCovarAggFunction.java
@@ -51,7 +51,7 @@ public SqlCovarAggFunction(SqlKind kind) {
         false,
         Optionality.FORBIDDEN);
     Preconditions.checkArgument(
-        SqlKind.COVAR_AVG_AGG_FUNCTIONS.contains(kind), "unsupported sql kind: " + kind);
+        SqlKind.COVAR_AVG_AGG_FUNCTIONS.contains(kind), "unsupported sql kind: %s", kind);
   }
 
   @Deprecated // to be removed before 2.0
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
index 67e7d9c5a..05c6a2573 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlInOperator.java
@@ -128,11 +128,11 @@ private static SqlBinaryOperator of(SqlKind kind) {
       // First check that the expressions in the IN list are compatible
       // with each other. Same rules as the VALUES operator (per
       // SQL:2003 Part 2 Section 8.4, <in predicate>).
-      if (null == rightType && validator.config().typeCoercionEnabled()) {
+      if (rightType == null && validator.config().typeCoercionEnabled()) {
         // Do implicit type cast if it is allowed to.
         rightType = validator.getTypeCoercion().getWiderTypeFor(rightTypeList, true);
       }
-      if (null == rightType) {
+      if (rightType == null) {
         throw validator.newValidationError(right, RESOURCE.incompatibleTypesInList());
       }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java
index 266d80a4d..a7979e326 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlJsonValueFunction.java
@@ -55,7 +55,7 @@ public SqlJsonValueFunction(String name) {
         name,
         SqlKind.OTHER_FUNCTION,
         ReturnTypes.cascade(
-            opBinding -> explicitTypeSpec(opBinding).orElse(getDefaultType(opBinding)),
+            opBinding -> explicitTypeSpec(opBinding).orElseGet(() -> getDefaultType(opBinding)),
             SqlTypeTransforms.FORCE_NULLABLE),
         null,
         OperandTypes.family(
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
index fa15d2b0a..32bbb6503 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibrary.java
@@ -30,6 +30,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -111,9 +113,7 @@ public static List<SqlLibrary> parse(String libraryNameList) {
     if (!libraryNameList.isEmpty()) {
       for (String libraryName : libraryNameList.split(",")) {
         @Nullable SqlLibrary library = SqlLibrary.of(libraryName);
-        if (library == null) {
-          throw new IllegalArgumentException("unknown library '" + libraryName + "'");
-        }
+        checkArgument(library != null, "unknown library '%s'", libraryName);
         list.add(library);
       }
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
index 3ffd8d72b..127facf5d 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java
@@ -86,7 +86,7 @@ private SqlLibraryOperators() {}
    * <p>This operator is for SQL (and AST); for internal use (RexNode and Aggregate) use {@code
    * AGG_M2M}.
    */
-  @LibraryOperator(libraries = {CALCITE})
+  @LibraryOperator(libraries = CALCITE)
   public static final SqlFunction AGGREGATE =
       SqlBasicAggFunction.create(
           "AGGREGATE", SqlKind.AGGREGATE_FN, ReturnTypes.ARG0, OperandTypes.MEASURE);
@@ -96,7 +96,7 @@ private SqlLibraryOperators() {}
    * from {@code tz1} to {@code tz2}. This function is only on Redshift, but we list it in
    * PostgreSQL because Redshift does not have its own library.
    */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction CONVERT_TIMEZONE =
       SqlBasicFunction.create(
           "CONVERT_TIMEZONE",
@@ -105,7 +105,7 @@ private SqlLibraryOperators() {}
           SqlFunctionCategory.TIMEDATE);
 
   /** THE "DATE_ADD(date, interval)" function (BigQuery) adds the interval to the date. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_ADD =
       SqlBasicFunction.create(
               SqlKind.DATE_ADD, ReturnTypes.ARG0_NULLABLE, OperandTypes.DATE_INTERVAL)
@@ -115,7 +115,7 @@ private SqlLibraryOperators() {}
    * THE "DATE_DIFF(date, date2, timeUnit)" function (BigQuery) returns the number of timeUnit in
    * (date - date2).
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_DIFF =
       new SqlTimestampDiffFunction(
           "DATE_DIFF",
@@ -161,7 +161,7 @@ private SqlLibraryOperators() {}
    * <p>Not to be confused with standard {@link SqlStdOperatorTable#CONVERT}, which converts a
    * string from one character set to another.
    */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction MSSQL_CONVERT =
       SqlBasicFunction.create(
               SqlKind.CAST,
@@ -191,7 +191,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
   }
 
   /** The "DATE_PART(timeUnit, datetime)" function (Databricks, Postgres, Redshift, Snowflake). */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction DATE_PART =
       new SqlExtractFunction("DATE_PART") {
         @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
@@ -203,14 +203,14 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
    * The "DATE_SUB(date, interval)" function (BigQuery); subtracts interval from the date,
    * independent of any time zone.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_SUB =
       SqlBasicFunction.create(
               SqlKind.DATE_SUB, ReturnTypes.ARG0_NULLABLE, OperandTypes.DATE_INTERVAL)
           .withFunctionType(SqlFunctionCategory.TIMEDATE);
 
   /** The "DATEPART(timeUnit, datetime)" function (Microsoft SQL Server). */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction DATEPART =
       new SqlExtractFunction("DATEPART") {
         @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {
@@ -237,7 +237,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
       };
 
   /** The "DECODE(v, v1, result1, [v2, result2, ...], resultN)" function. */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction DECODE =
       SqlBasicFunction.create(SqlKind.DECODE, DECODE_RETURN_TYPE, OperandTypes.VARIADIC);
 
@@ -271,7 +271,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
   }
 
   /** The "NVL(value, value)" function. */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlBasicFunction NVL =
       SqlBasicFunction.create(
           SqlKind.NVL,
@@ -279,11 +279,11 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
           OperandTypes.SAME_SAME);
 
   /** The "IFNULL(value, value)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction IFNULL = NVL.withName("IFNULL");
 
   /** The "LENGTH(string)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction LENGTH = SqlStdOperatorTable.CHAR_LENGTH.withName("LENGTH");
 
   /** The "LPAD(original_value, return_length[, pattern])" function. */
@@ -327,7 +327,7 @@ private static SqlCall transformConvert(SqlValidator validator, SqlCall call) {
           .withFunctionType(SqlFunctionCategory.STRING);
 
   /** The "SPLIT(string [, delimiter])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction SPLIT =
       SqlBasicFunction.create(
               "SPLIT",
@@ -368,7 +368,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** The "ENDS_WITH(value1, value2)" function (BigQuery). */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ENDS_WITH =
       SqlBasicFunction.create(
           "ENDS_WITH",
@@ -377,7 +377,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** The "STARTS_WITH(value1, value2)" function (BigQuery). */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction STARTS_WITH =
       SqlBasicFunction.create(
           "STARTS_WITH",
@@ -386,11 +386,11 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** BigQuery's "SUBSTR(string, position [, substringLength ])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction SUBSTR_BIG_QUERY = SUBSTR.withKind(SqlKind.SUBSTR_BIG_QUERY);
 
   /** MySQL's "SUBSTR(string, position [, substringLength ])" function. */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction SUBSTR_MYSQL = SUBSTR.withKind(SqlKind.SUBSTR_MYSQL);
 
   /**
@@ -405,11 +405,11 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>If {@code position} &lt; 0, treat {@code position} as "length(string) + position + 1".
    * </ul>
    */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction SUBSTR_ORACLE = SUBSTR.withKind(SqlKind.SUBSTR_ORACLE);
 
   /** PostgreSQL's "SUBSTR(string, position [, substringLength ])" function. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction SUBSTR_POSTGRESQL = SUBSTR.withKind(SqlKind.SUBSTR_POSTGRESQL);
 
   /** The "GREATEST(value, value)" function. */
@@ -432,7 +432,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "CEIL(value)" function. Identical to the standard <code>CEIL</code> function except the
    * return type should be a double if the operand is an integer.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction CEIL_BIG_QUERY =
       new SqlFloorFunction(SqlKind.CEIL)
           .withName("CEIL_BIG_QUERY")
@@ -442,7 +442,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "FLOOR(value)" function. Identical to the stadnard <code>FLOOR</code> function except the
    * return type should be a double if the operand is an integer.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FLOOR_BIG_QUERY =
       new SqlFloorFunction(SqlKind.FLOOR)
           .withName("FLOOR_BIG_QUERY")
@@ -459,40 +459,40 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
   @LibraryOperator(libraries = {BIG_QUERY, ORACLE, POSTGRESQL})
   public static final SqlFunction TRANSLATE3 = new SqlTranslate3Function();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_TYPE = new SqlJsonTypeFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_DEPTH = new SqlJsonDepthFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_LENGTH = new SqlJsonLengthFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_KEYS = new SqlJsonKeysFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_PRETTY = new SqlJsonPrettyFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_REMOVE = new SqlJsonRemoveFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_STORAGE_SIZE = new SqlJsonStorageSizeFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_INSERT = new SqlJsonModifyFunction("JSON_INSERT");
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_REPLACE = new SqlJsonModifyFunction("JSON_REPLACE");
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction JSON_SET = new SqlJsonModifyFunction("JSON_SET");
 
   @LibraryOperator(libraries = {MYSQL, ORACLE})
   public static final SqlFunction REGEXP_REPLACE = new SqlRegexpReplaceFunction();
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction COMPRESS =
       SqlBasicFunction.create(
           "COMPRESS",
@@ -500,28 +500,28 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.STRING,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction EXTRACT_VALUE =
       SqlBasicFunction.create(
           "EXTRACTVALUE",
           ReturnTypes.VARCHAR_2000.andThen(SqlTypeTransforms.FORCE_NULLABLE),
           OperandTypes.STRING_STRING);
 
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction XML_TRANSFORM =
       SqlBasicFunction.create(
           "XMLTRANSFORM",
           ReturnTypes.VARCHAR_2000.andThen(SqlTypeTransforms.FORCE_NULLABLE),
           OperandTypes.STRING_STRING);
 
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction EXTRACT_XML =
       SqlBasicFunction.create(
           "EXTRACT",
           ReturnTypes.VARCHAR_2000.andThen(SqlTypeTransforms.FORCE_NULLABLE),
           OperandTypes.STRING_STRING_OPTIONAL_STRING);
 
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction EXISTS_NODE =
       SqlBasicFunction.create(
           "EXISTSNODE",
@@ -532,7 +532,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "BOOL_AND(condition)" aggregate function, PostgreSQL and Redshift's equivalent to {@link
    * SqlStdOperatorTable#EVERY}.
    */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlAggFunction BOOL_AND =
       new SqlMinMaxAggFunction("BOOL_AND", SqlKind.MIN, OperandTypes.BOOLEAN);
 
@@ -540,7 +540,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "BOOL_OR(condition)" aggregate function, PostgreSQL and Redshift's equivalent to {@link
    * SqlStdOperatorTable#SOME}.
    */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlAggFunction BOOL_OR =
       new SqlMinMaxAggFunction("BOOL_OR", SqlKind.MAX, OperandTypes.BOOLEAN);
 
@@ -548,7 +548,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "LOGICAL_AND(condition)" aggregate function, BigQuery's equivalent to {@link
    * SqlStdOperatorTable#EVERY}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction LOGICAL_AND =
       new SqlMinMaxAggFunction("LOGICAL_AND", SqlKind.MIN, OperandTypes.BOOLEAN);
 
@@ -556,7 +556,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "LOGICAL_OR(condition)" aggregate function, BigQuery's equivalent to {@link
    * SqlStdOperatorTable#SOME}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction LOGICAL_OR =
       new SqlMinMaxAggFunction("LOGICAL_OR", SqlKind.MAX, OperandTypes.BOOLEAN);
 
@@ -566,7 +566,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *
    * <p>{@code COUNTIF(b)} is equivalent to {@code COUNT(*) FILTER (WHERE b)}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction COUNTIF =
       SqlBasicAggFunction.create(SqlKind.COUNTIF, ReturnTypes.BIGINT, OperandTypes.BOOLEAN)
           .withDistinct(Optionality.FORBIDDEN);
@@ -618,7 +618,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * <p>{@code GROUP_CONCAT(v ORDER BY x, y SEPARATOR s)} is implemented by rewriting to {@code
    * LISTAGG(v, s) WITHIN GROUP (ORDER BY x, y)}.
    */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlAggFunction GROUP_CONCAT =
       SqlBasicAggFunction.create(
               SqlKind.GROUP_CONCAT,
@@ -633,14 +633,14 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "MAX_BY(value, comp)" aggregate function, Spark's equivalent to {@link
    * SqlStdOperatorTable#ARG_MAX}.
    */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlAggFunction MAX_BY = SqlStdOperatorTable.ARG_MAX.withName("MAX_BY");
 
   /**
    * The "MIN_BY(condition)" aggregate function, Spark's equivalent to {@link
    * SqlStdOperatorTable#ARG_MIN}.
    */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlAggFunction MIN_BY = SqlStdOperatorTable.ARG_MIN.withName("MIN_BY");
 
   /**
@@ -648,7 +648,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * SqlStdOperatorTable#PERCENTILE_CONT}, but uses an {@code OVER} clause rather than {@code WITHIN
    * GROUP}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction PERCENTILE_CONT2 =
       SqlBasicAggFunction.create(
               "PERCENTILE_CONT",
@@ -665,7 +665,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * SqlStdOperatorTable#PERCENTILE_DISC}, but uses an {@code OVER} clause rather than {@code WITHIN
    * GROUP}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlAggFunction PERCENTILE_DISC2 =
       SqlBasicAggFunction.create(
               "PERCENTILE_DISC",
@@ -687,7 +687,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code DATE(timestamp)}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE =
       SqlBasicFunction.create(
           "DATE",
@@ -721,7 +721,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code DATETIME(timestampLtz[, timeZone])}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME =
       SqlBasicFunction.create(
           "DATETIME",
@@ -757,7 +757,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code TIME(timestamp)}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME =
       SqlBasicFunction.create(
           "TIME",
@@ -787,7 +787,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code TIMESTAMP(timestamp[, timeZone])}
    * </ul>
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP =
       SqlBasicFunction.create(
           "TIMESTAMP",
@@ -811,7 +811,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.TIMEDATE);
 
   /** The "CURRENT_DATETIME([timezone])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction CURRENT_DATETIME =
       SqlBasicFunction.create(
           "CURRENT_DATETIME",
@@ -823,7 +823,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "DATE_FROM_UNIX_DATE(integer)" function; returns a DATE value a given number of seconds
    * after 1970-01-01.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_FROM_UNIX_DATE =
       SqlBasicFunction.create(
           "DATE_FROM_UNIX_DATE",
@@ -832,7 +832,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.TIMEDATE);
 
   /** The "UNIX_DATE(date)" function; returns the number of days since 1970-01-01. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_DATE =
       SqlBasicFunction.create(
           "UNIX_DATE",
@@ -844,7 +844,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "MONTHNAME(datetime)" function; returns the name of the month, in the current locale, of a
    * TIMESTAMP or DATE argument.
    */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction MONTHNAME =
       SqlBasicFunction.create(
           "MONTHNAME",
@@ -856,7 +856,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    * The "DAYNAME(datetime)" function; returns the name of the day of the week, in the current
    * locale, of a TIMESTAMP or DATE argument.
    */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction DAYNAME =
       SqlBasicFunction.create(
           "DAYNAME", ReturnTypes.VARCHAR_2000, OperandTypes.DATETIME, SqlFunctionCategory.TIMEDATE);
@@ -885,7 +885,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.CBSTRING_INTEGER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction SPACE =
       SqlBasicFunction.create(
           "SPACE",
@@ -893,7 +893,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.INTEGER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction STRCMP =
       SqlBasicFunction.create(
           "STRCMP",
@@ -909,7 +909,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           OperandTypes.CHARACTER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlFunction DIFFERENCE =
       SqlBasicFunction.create(
           "DIFFERENCE",
@@ -918,12 +918,12 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
           SqlFunctionCategory.STRING);
 
   /** The case-insensitive variant of the LIKE operator. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlSpecialOperator ILIKE =
       new SqlLikeOperator("ILIKE", SqlKind.LIKE, false, false);
 
   /** The case-insensitive variant of the NOT LIKE operator. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlSpecialOperator NOT_ILIKE =
       new SqlLikeOperator("NOT ILIKE", SqlKind.LIKE, true, false);
 
@@ -985,7 +985,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *
    * <p>It is assigned {@link SqlKind#CONCAT2} to make it not equal to {@link #CONCAT_FUNCTION}.
    */
-  @LibraryOperator(libraries = {ORACLE})
+  @LibraryOperator(libraries = ORACLE)
   public static final SqlFunction CONCAT2 =
       SqlBasicFunction.create(
               "CONCAT",
@@ -1032,7 +1032,7 @@ static RelDataType deriveTypeSplit(SqlOperatorBinding operatorBinding, RelDataTy
    *   <li>{@code CONCAT_WS(null, null, null)} returns "".
    * </ul>
    */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction CONCAT_WS_MSSQL =
       SqlBasicFunction.create(
               "CONCAT_WS",
@@ -1055,7 +1055,7 @@ private static RelDataType arrayReturnType(SqlOperatorBinding opBinding) {
    * The "ARRAY(exp, ...)" function (Spark); compare with the standard array value constructor,
    * "ARRAY [exp, ...]".
    */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY =
       SqlBasicFunction.create(
           "ARRAY", SqlLibraryOperators::arrayReturnType, OperandTypes.SAME_VARIADIC);
@@ -1075,7 +1075,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
   }
 
   /** The "ARRAY_APPEND(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_APPEND =
       SqlBasicFunction.create(
           SqlKind.ARRAY_APPEND,
@@ -1083,12 +1083,12 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_COMPACT(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_COMPACT =
       SqlBasicFunction.create(SqlKind.ARRAY_COMPACT, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_CONCAT(array [, array]*)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_CONCAT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_CONCAT,
@@ -1096,19 +1096,19 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.AT_LEAST_ONE_SAME_VARIADIC);
 
   /** The "ARRAY_CONTAINS(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_CONTAINS =
       SqlBasicFunction.create(
           SqlKind.ARRAY_CONTAINS, ReturnTypes.BOOLEAN_NULLABLE, OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_DISTINCT(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_DISTINCT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_DISTINCT, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_EXCEPT(array1, array2)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_EXCEPT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_EXCEPT,
@@ -1118,7 +1118,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.family(SqlTypeFamily.ARRAY, SqlTypeFamily.ARRAY)));
 
   /** The "ARRAY_INTERSECT(array1, array2)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_INTERSECT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_INTERSECT,
@@ -1128,7 +1128,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.family(SqlTypeFamily.ARRAY, SqlTypeFamily.ARRAY)));
 
   /** The "ARRAY_JOIN(array, delimiter [, nullText ])" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_JOIN =
       SqlBasicFunction.create(
           SqlKind.ARRAY_JOIN,
@@ -1136,31 +1136,31 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.STRING_ARRAY_CHARACTER_OPTIONAL_CHARACTER);
 
   /** The "ARRAY_LENGTH(array)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_LENGTH =
       SqlBasicFunction.create(
           SqlKind.ARRAY_LENGTH, ReturnTypes.INTEGER_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_MAX(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_MAX =
       SqlBasicFunction.create(
           SqlKind.ARRAY_MAX, ReturnTypes.TO_COLLECTION_ELEMENT_FORCE_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_MAX(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_MIN =
       SqlBasicFunction.create(
           SqlKind.ARRAY_MIN, ReturnTypes.TO_COLLECTION_ELEMENT_FORCE_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_POSITION(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_POSITION =
       SqlBasicFunction.create(
           SqlKind.ARRAY_POSITION, ReturnTypes.BIGINT_NULLABLE, OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_PREPEND(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_PREPEND =
       SqlBasicFunction.create(
           SqlKind.ARRAY_PREPEND,
@@ -1168,13 +1168,13 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_REMOVE(array, element)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_REMOVE =
       SqlBasicFunction.create(
           SqlKind.ARRAY_REMOVE, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY_ELEMENT);
 
   /** The "ARRAY_REPEAT(element, count)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_REPEAT =
       SqlBasicFunction.create(
           SqlKind.ARRAY_REPEAT,
@@ -1185,17 +1185,17 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.typeName(SqlTypeName.INTEGER)));
 
   /** The "ARRAY_REVERSE(array)" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_REVERSE =
       SqlBasicFunction.create(SqlKind.ARRAY_REVERSE, ReturnTypes.ARG0_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_SIZE(array)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_SIZE =
       SqlBasicFunction.create(SqlKind.ARRAY_SIZE, ReturnTypes.INTEGER_NULLABLE, OperandTypes.ARRAY);
 
   /** The "ARRAY_UNION(array1, array2)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAY_UNION =
       SqlBasicFunction.create(
           SqlKind.ARRAY_UNION,
@@ -1205,7 +1205,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
               OperandTypes.family(SqlTypeFamily.ARRAY, SqlTypeFamily.ARRAY)));
 
   /** The "ARRAY_TO_STRING(array, delimiter [, nullText ])" function. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction ARRAY_TO_STRING =
       SqlBasicFunction.create(
           SqlKind.ARRAY_TO_STRING,
@@ -1213,7 +1213,7 @@ private static RelDataType arrayAppendPrependReturnType(SqlOperatorBinding opBin
           OperandTypes.STRING_ARRAY_CHARACTER_OPTIONAL_CHARACTER);
 
   /** The "ARRAYS_OVERLAP(array1, array2)" function (Spark). */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAYS_OVERLAP =
       SqlBasicFunction.create(
           SqlKind.ARRAYS_OVERLAP,
@@ -1231,7 +1231,7 @@ private static RelDataType deriveTypeArraysZip(SqlOperatorBinding opBinding) {
 
     final List<String> indexes =
         IntStream.range(0, argComponentTypes.size())
-            .mapToObj(i -> String.valueOf(i))
+            .mapToObj(String::valueOf)
             .collect(Collectors.toList());
     final RelDataType structType =
         opBinding.getTypeFactory().createStructType(argComponentTypes, indexes);
@@ -1240,7 +1240,7 @@ private static RelDataType deriveTypeArraysZip(SqlOperatorBinding opBinding) {
   }
 
   /** The "ARRAYS_ZIP(array, ...)" function (Spark). */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction ARRAYS_ZIP =
       SqlBasicFunction.create(
           SqlKind.ARRAYS_ZIP,
@@ -1249,7 +1249,7 @@ private static RelDataType deriveTypeArraysZip(SqlOperatorBinding opBinding) {
           OperandTypes.SAME_VARIADIC);
 
   /** The "SORT_ARRAY(array)" function (Spark). */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction SORT_ARRAY =
       SqlBasicFunction.create(
           SqlKind.SORT_ARRAY,
@@ -1276,24 +1276,24 @@ private static RelDataType deriveTypeMapConcat(SqlOperatorBinding opBinding) {
   }
 
   /** The "MAP_CONCAT(map [, map]*)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_CONCAT =
       SqlBasicFunction.create(
           SqlKind.MAP_CONCAT, SqlLibraryOperators::deriveTypeMapConcat, OperandTypes.SAME_VARIADIC);
 
   /** The "MAP_ENTRIES(map)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_ENTRIES =
       SqlBasicFunction.create(
           SqlKind.MAP_ENTRIES, ReturnTypes.TO_MAP_ENTRIES_NULLABLE, OperandTypes.MAP);
 
   /** The "MAP_KEYS(map)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_KEYS =
       SqlBasicFunction.create(SqlKind.MAP_KEYS, ReturnTypes.TO_MAP_KEYS_NULLABLE, OperandTypes.MAP);
 
   /** The "MAP_VALUES(map)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_VALUES =
       SqlBasicFunction.create(
           SqlKind.MAP_VALUES, ReturnTypes.TO_MAP_VALUES_NULLABLE, OperandTypes.MAP);
@@ -1310,7 +1310,7 @@ private static RelDataType deriveTypeMapFromArrays(SqlOperatorBinding opBinding)
   }
 
   /** The "MAP_FROM_ARRAYS(keysArray, valuesArray)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_FROM_ARRAYS =
       SqlBasicFunction.create(
           SqlKind.MAP_FROM_ARRAYS,
@@ -1329,7 +1329,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   }
 
   /** The "MAP_FROM_ENTRIES(arrayOfEntries)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction MAP_FROM_ENTRIES =
       SqlBasicFunction.create(
           SqlKind.MAP_FROM_ENTRIES,
@@ -1337,7 +1337,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.MAP_FROM_ENTRIES);
 
   /** The "STR_TO_MAP(string[, stringDelimiter[, keyValueDelimiter]])" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction STR_TO_MAP =
       SqlBasicFunction.create(
           SqlKind.STR_TO_MAP,
@@ -1358,7 +1358,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.STRING,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlFunction TO_BASE64 =
       SqlBasicFunction.create(
           "TO_BASE64",
@@ -1366,7 +1366,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.STRING.or(OperandTypes.BINARY),
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FROM_BASE32 =
       SqlBasicFunction.create(
           "FROM_BASE32",
@@ -1374,7 +1374,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.CHARACTER,
           SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TO_BASE32 =
       SqlBasicFunction.create(
           "TO_BASE32",
@@ -1385,7 +1385,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The "FROM_HEX(varchar)" function; converts a hexadecimal-encoded {@code varchar} into bytes.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FROM_HEX =
       SqlBasicFunction.create(
           "FROM_HEX",
@@ -1394,7 +1394,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           SqlFunctionCategory.STRING);
 
   /** The "TO_HEX(binary)" function; converts {@code binary} into a hexadecimal varchar. */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TO_HEX =
       SqlBasicFunction.create(
           "TO_HEX", ReturnTypes.VARCHAR_NULLABLE, OperandTypes.BINARY, SqlFunctionCategory.STRING);
@@ -1439,7 +1439,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "PARSE_TIME(string, string)" function (BigQuery); converts a string representation of time
    * to a TIME value.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_TIME =
       SqlBasicFunction.create(
           "PARSE_TIME",
@@ -1451,7 +1451,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "PARSE_DATE(string, string)" function (BigQuery); Converts a string representation of date
    * to a DATE object.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_DATE =
       SqlBasicFunction.create(
           "PARSE_DATE",
@@ -1465,7 +1465,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    *
    * <p>In BigQuery, the "TIMESTAMP" datatype maps to Calcite's TIMESTAMP_WITH_LOCAL_TIME_ZONE
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_TIMESTAMP =
       SqlBasicFunction.create(
           "PARSE_TIMESTAMP",
@@ -1480,7 +1480,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction PARSE_DATETIME =
       SqlBasicFunction.create(
           "PARSE_DATETIME",
@@ -1492,7 +1492,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "FORMAT_TIME(string, time)" function (BigQuery); Formats a time object according to the
    * specified string.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_TIME =
       SqlBasicFunction.create(
           "FORMAT_TIME",
@@ -1504,7 +1504,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "FORMAT_DATE(string, date)" function (BigQuery); Formats a date object according to the
    * specified string.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_DATE =
       SqlBasicFunction.create(
           "FORMAT_DATE",
@@ -1518,7 +1518,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    *
    * <p>In BigQuery, the "TIMESTAMP" datatype maps to Calcite's TIMESTAMP_WITH_LOCAL_TIME_ZONE
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_TIMESTAMP =
       SqlBasicFunction.create(
           "FORMAT_TIMESTAMP",
@@ -1543,7 +1543,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction FORMAT_DATETIME =
       SqlBasicFunction.create(
           "FORMAT_DATETIME",
@@ -1569,7 +1569,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * but in Calcite the second argument can be any interval expression, not just an interval
    * literal.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlBasicFunction TIMESTAMP_ADD2 =
       SqlBasicFunction.create(
               SqlKind.TIMESTAMP_ADD, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIMESTAMP_INTERVAL)
@@ -1582,7 +1582,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>{@code TIMESTAMP_DIFF(t1, t2, unit)} is equivalent to {@code TIMESTAMPDIFF(unit, t2, t1)}
    * and {@code (t1 - t2) unit}.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_DIFF3 =
       new SqlTimestampDiffFunction(
           "TIMESTAMP_DIFF",
@@ -1592,7 +1592,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIME_ADD(time, interval)" function (BigQuery); adds interval expression to the specified
    * time expression.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_ADD =
       SqlBasicFunction.create(
               SqlKind.TIME_ADD, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIME_INTERVAL)
@@ -1602,7 +1602,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIME_DIFF(time, time, timeUnit)" function (BigQuery); returns the number of timeUnit
    * between the two time expressions.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_DIFF =
       new SqlTimestampDiffFunction(
           "TIME_DIFF",
@@ -1612,7 +1612,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "DATE_TRUNC(date, timeUnit)" function (BigQuery); truncates a DATE value to the beginning
    * of a timeUnit.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATE_TRUNC =
       SqlBasicFunction.create(
               "DATE_TRUNC",
@@ -1632,7 +1632,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>In BigQuery, the syntax is "TIME_SUB(time, INTERVAL int64 date_part)" but in Calcite the
    * second argument can be any interval expression, not just an interval literal.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_SUB =
       SqlBasicFunction.create(
               SqlKind.TIME_SUB, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIME_INTERVAL)
@@ -1642,7 +1642,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIME_TRUNC(time, timeUnit)" function (BigQuery); truncates a TIME value to the beginning
    * of a timeUnit.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIME_TRUNC =
       SqlBasicFunction.create(
           "TIME_TRUNC",
@@ -1660,7 +1660,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>In BigQuery, the syntax is "TIMESTAMP_SUB(timestamp, INTERVAL int64 date_part)" but in
    * Calcite the second argument can be any interval expression, not just an interval literal.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlBasicFunction TIMESTAMP_SUB =
       SqlBasicFunction.create(
               SqlKind.TIMESTAMP_SUB, ReturnTypes.ARG0_NULLABLE, OperandTypes.TIMESTAMP_INTERVAL)
@@ -1675,7 +1675,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>A synonym for {@link #TIMESTAMP_SUB}, which supports both {@code TIMESTAMP} and {@code
    * TIMESTAMP WITH LOCAL TIME ZONE} operands.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_SUB = TIMESTAMP_SUB.withName("DATETIME_SUB");
 
   /**
@@ -1685,7 +1685,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP WITH LOCAL TIME ZONE} type of Calcite is called {@code
    * TIMESTAMP} in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_TRUNC =
       SqlBasicFunction.create(
           "TIMESTAMP_TRUNC",
@@ -1703,7 +1703,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_TRUNC =
       SqlBasicFunction.create(
           "DATETIME_TRUNC",
@@ -1718,7 +1718,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIMESTAMP_SECONDS(bigint)" function; returns a TIMESTAMP value a given number of seconds
    * after 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_SECONDS =
       SqlBasicFunction.create(
           "TIMESTAMP_SECONDS",
@@ -1730,7 +1730,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIMESTAMP_MILLIS(bigint)" function; returns a TIMESTAMP value a given number of
    * milliseconds after 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_MILLIS =
       SqlBasicFunction.create(
           "TIMESTAMP_MILLIS",
@@ -1742,7 +1742,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "TIMESTAMP_MICROS(bigint)" function; returns a TIMESTAMP value a given number of
    * micro-seconds after 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TIMESTAMP_MICROS =
       SqlBasicFunction.create(
           "TIMESTAMP_MICROS",
@@ -1753,7 +1753,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The "UNIX_SECONDS(bigint)" function; returns the number of seconds since 1970-01-01 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_SECONDS =
       SqlBasicFunction.create(
           "UNIX_SECONDS",
@@ -1765,7 +1765,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "UNIX_MILLIS(bigint)" function; returns the number of milliseconds since 1970-01-01
    * 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_MILLIS =
       SqlBasicFunction.create(
           "UNIX_MILLIS",
@@ -1777,7 +1777,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "UNIX_MICROS(bigint)" function; returns the number of microseconds since 1970-01-01
    * 00:00:00.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction UNIX_MICROS =
       SqlBasicFunction.create(
           "UNIX_MICROS",
@@ -1789,7 +1789,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "DATETIME_ADD(timestamp, interval)" function (BigQuery). As {@code TIMESTAMP_ADD}, returns
    * a Calcite {@code TIMESTAMP} (which BigQuery calls a {@code DATETIME}).
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_ADD = TIMESTAMP_ADD2.withName("DATETIME_ADD");
 
   /**
@@ -1798,7 +1798,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * <p>Note that the {@code TIMESTAMP} type of Calcite and Standard SQL is called {@code DATETIME}
    * in BigQuery.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction DATETIME_DIFF =
       new SqlTimestampDiffFunction(
           "DATETIME_DIFF",
@@ -1822,18 +1822,18 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
       SqlBasicFunction.create(
           "CHR", ReturnTypes.CHAR, OperandTypes.INTEGER, SqlFunctionCategory.STRING);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction TANH =
       SqlBasicFunction.create(
           "TANH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The "COTH(value)" function; returns the hyperbolic cotangent of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction COTH =
       SqlBasicFunction.create(
           "COTH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction COSH =
       SqlBasicFunction.create(
           "COSH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
@@ -1841,13 +1841,13 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The {@code ACOSH(numeric)} function; returns the inverse hyperbolic cosine of {@code value}.
    */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction ACOSH =
       SqlBasicFunction.create(
           "ACOSH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The {@code ASINH(numeric)} function; returns the inverse hyperbolic sine of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction ASINH =
       SqlBasicFunction.create(
           "ASINH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
@@ -1855,34 +1855,34 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
   /**
    * The {@code ATANH(numeric)} function; returns the inverse hyperbolic tangent of {@code value}.
    */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction ATANH =
       SqlBasicFunction.create(
           "ATANH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The "COTH(value)" function; returns the hyperbolic secant of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction SECH =
       SqlBasicFunction.create(
           "SECH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
   /** The "COTH(value)" function; returns the hyperbolic cosecant of {@code value}. */
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction CSCH =
       SqlBasicFunction.create(
           "CSCH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction SINH =
       SqlBasicFunction.create(
           "SINH", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction CSC =
       SqlBasicFunction.create(
           "CSC", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {ALL})
+  @LibraryOperator(libraries = ALL)
   public static final SqlFunction SEC =
       SqlBasicFunction.create(
           "SEC", ReturnTypes.DOUBLE_NULLABLE, OperandTypes.NUMERIC, SqlFunctionCategory.NUMERIC);
@@ -1925,7 +1925,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * @see SqlStdOperatorTable#LN
    * @see SqlStdOperatorTable#LOG10
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction LOG =
       SqlBasicFunction.create(
           "LOG",
@@ -1933,32 +1933,32 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.NUMERIC_OPTIONAL_NUMERIC,
           SqlFunctionCategory.NUMERIC);
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction POW = SqlStdOperatorTable.POWER.withName("POW");
 
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction TRUNC = SqlStdOperatorTable.TRUNCATE.withName("TRUNC");
 
   /** Infix "::" cast operator used by PostgreSQL, for example {@code '100'::INTEGER}. */
-  @LibraryOperator(libraries = {POSTGRESQL})
+  @LibraryOperator(libraries = POSTGRESQL)
   public static final SqlOperator INFIX_CAST = new SqlCastOperator();
 
   /**
    * The "SAFE_CAST(expr AS type)" function; identical to CAST(), except that if conversion fails,
    * it returns NULL instead of raising an error.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlFunction SAFE_CAST = new SqlCastFunction("SAFE_CAST", SqlKind.SAFE_CAST);
 
   /** The "TRY_CAST(expr AS type)" function, equivalent to SAFE_CAST. */
-  @LibraryOperator(libraries = {MSSQL})
+  @LibraryOperator(libraries = MSSQL)
   public static final SqlFunction TRY_CAST = new SqlCastFunction("TRY_CAST", SqlKind.SAFE_CAST);
 
   /**
    * The "OFFSET(index)" array subscript operator used by BigQuery. The index starts at 0 and
    * produces an error if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator OFFSET =
       new SqlItemOperator("OFFSET", OperandTypes.ARRAY, 0, false);
 
@@ -1966,7 +1966,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "ORDINAL(index)" array subscript operator used by BigQuery. The index starts at 1 and
    * produces an error if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator ORDINAL =
       new SqlItemOperator("ORDINAL", OperandTypes.ARRAY, 1, false);
 
@@ -1974,7 +1974,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "SAFE_OFFSET(index)" array subscript operator used by BigQuery. The index starts at 0 and
    * returns null if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator SAFE_OFFSET =
       new SqlItemOperator("SAFE_OFFSET", OperandTypes.ARRAY, 0, true);
 
@@ -1982,12 +1982,12 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
    * The "SAFE_ORDINAL(index)" array subscript operator used by BigQuery. The index starts at 1 and
    * returns null if the index is out of range.
    */
-  @LibraryOperator(libraries = {BIG_QUERY})
+  @LibraryOperator(libraries = BIG_QUERY)
   public static final SqlOperator SAFE_ORDINAL =
       new SqlItemOperator("SAFE_ORDINAL", OperandTypes.ARRAY, 1, true);
 
   /** NULL-safe "&lt;=&gt;" equal operator used by MySQL, for example {@code 1<=>NULL}. */
-  @LibraryOperator(libraries = {MYSQL})
+  @LibraryOperator(libraries = MYSQL)
   public static final SqlOperator NULL_SAFE_EQUAL =
       new SqlBinaryOperator(
           "<=>",
@@ -1999,7 +1999,7 @@ private static RelDataType deriveTypeMapFromEntries(SqlOperatorBinding opBinding
           OperandTypes.COMPARABLE_UNORDERED_COMPARABLE_UNORDERED);
 
   /** The "BIT_LENGTH(string or binary)" function. */
-  @LibraryOperator(libraries = {SPARK})
+  @LibraryOperator(libraries = SPARK)
   public static final SqlFunction BIT_LENGTH =
       SqlBasicFunction.create(
           "BIT_LENGTH",
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
index 35e16351b..08d3acd9b 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLikeOperator.java
@@ -35,6 +35,8 @@
 import org.apache.calcite.sql.validate.SqlValidatorScope;
 import org.apache.calcite.util.Litmus;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * An operator describing the <code>LIKE</code> and <code>SIMILAR</code> operators.
  *
@@ -79,10 +81,11 @@ public class SqlLikeOperator extends SqlSpecialOperator {
         ReturnTypes.BOOLEAN_NULLABLE,
         InferTypes.FIRST_KNOWN,
         OperandTypes.STRING_SAME_SAME_SAME);
-    if (!caseSensitive && kind != SqlKind.LIKE) {
-      throw new IllegalArgumentException(
-          "Only (possibly negated) " + SqlKind.LIKE + " can be made case-insensitive, not " + kind);
-    }
+    checkArgument(
+        caseSensitive || kind == SqlKind.LIKE,
+        "Only (possibly negated) %s can be made case-insensitive, not %s",
+        SqlKind.LIKE,
+        kind);
 
     this.negated = negated;
     this.caseSensitive = caseSensitive;
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
index 7f77800e2..23521f29e 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlLiteralChainOperator.java
@@ -183,7 +183,7 @@ private static boolean argTypesValid(SqlCallBinding callBinding) {
   /** Concatenates the operands of a call to this operator. */
   public static SqlLiteral concatenateOperands(SqlCall call) {
     final List<SqlNode> operandList = call.getOperandList();
-    assert operandList.size() > 0;
+    assert !operandList.isEmpty();
     assert operandList.get(0) instanceof SqlLiteral : operandList.get(0).getClass();
     return SqlUtil.concatenateLiterals(Util.cast(operandList, SqlLiteral.class));
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
index 22b15bbcb..4b686da7c 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlMapValueConstructor.java
@@ -55,7 +55,7 @@ public SqlMapValueConstructor() {
 
   @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     final List<RelDataType> argTypes = SqlTypeUtil.deriveType(callBinding, callBinding.operands());
-    if (argTypes.size() == 0) {
+    if (argTypes.isEmpty()) {
       throw callBinding.newValidationError(RESOURCE.mapRequiresTwoOrMoreArgs());
     }
     if (argTypes.size() % 2 > 0) {
@@ -63,7 +63,7 @@ public SqlMapValueConstructor() {
     }
     final Pair<@Nullable RelDataType, @Nullable RelDataType> componentType =
         getComponentTypes(callBinding.getTypeFactory(), argTypes);
-    if (null == componentType.left || null == componentType.right) {
+    if (componentType.left == null || componentType.right == null) {
       if (throwOnFailure) {
         throw callBinding.newValidationError(RESOURCE.needSameTypeParameter());
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
index 76da570fb..6ebe25e0e 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetQueryConstructor.java
@@ -71,7 +71,7 @@ protected SqlMultisetQueryConstructor(String name, SqlKind kind, SqlTypeTransfor
   @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     final List<RelDataType> argTypes = SqlTypeUtil.deriveType(callBinding, callBinding.operands());
     final RelDataType componentType = callBinding.getTypeFactory().leastRestrictive(argTypes);
-    if (null == componentType) {
+    if (componentType == null) {
       if (throwOnFailure) {
         throw callBinding.newValidationError(RESOURCE.needSameTypeParameter());
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
index 23c2b8009..3545dc1e9 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlMultisetValueConstructor.java
@@ -80,11 +80,11 @@ protected SqlMultisetValueConstructor(String name, SqlKind kind) {
 
   @Override public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {
     final List<RelDataType> argTypes = SqlTypeUtil.deriveType(callBinding, callBinding.operands());
-    if (argTypes.size() == 0) {
+    if (argTypes.isEmpty()) {
       throw callBinding.newValidationError(RESOURCE.requireAtLeastOneArg());
     }
     final RelDataType componentType = getComponentType(callBinding.getTypeFactory(), argTypes);
-    if (null == componentType) {
+    if (componentType == null) {
       if (throwOnFailure) {
         throw callBinding.newValidationError(RESOURCE.needSameTypeParameter());
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java
index 99daf2791..d02e6e0a0 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlRegrCountAggFunction.java
@@ -30,6 +30,6 @@
 public class SqlRegrCountAggFunction extends SqlCountAggFunction {
   public SqlRegrCountAggFunction(SqlKind kind) {
     super("REGR_COUNT", OperandTypes.NUMERIC_NUMERIC);
-    Preconditions.checkArgument(SqlKind.REGR_COUNT == kind, "unsupported sql kind: " + kind);
+    Preconditions.checkArgument(SqlKind.REGR_COUNT == kind, "unsupported sql kind: %s", kind);
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java b/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
index 0fdd04bad..d7ad3968a 100644
--- a/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
+++ b/core/src/main/java/org/apache/calcite/sql/fun/SqlRollupOperator.java
@@ -85,7 +85,7 @@ private static void unparseCube(SqlWriter writer, SqlCall call) {
           operand2.unparse(writer, 0, 0);
         }
         writer.endList(frame2);
-      } else if (operand instanceof SqlNodeList && ((SqlNodeList) operand).size() == 0) {
+      } else if (operand instanceof SqlNodeList && ((SqlNodeList) operand).isEmpty()) {
         writer.keyword("()");
       } else {
         operand.unparse(writer, 0, 0);
diff --git a/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java b/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java
index fbec5c9c4..21802a3d5 100644
--- a/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java
+++ b/core/src/main/java/org/apache/calcite/sql/parser/SqlParseException.java
@@ -18,8 +18,9 @@
 
 import org.apache.calcite.util.CalciteParserException;
 
+import com.google.common.collect.ImmutableList;
+
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Set;
 import java.util.TreeSet;
 
@@ -115,7 +116,7 @@ public SqlParserPos getPos() {
    */
   public Collection<String> getExpectedTokenNames() {
     if (expectedTokenSequences == null) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     int maxLength = 0;
     for (int[] expectedTokenSequence : expectedTokenSequences) {
diff --git a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
index 6818bde6e..f22514429 100644
--- a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
+++ b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserPos.java
@@ -188,7 +188,7 @@ public static SqlParserPos sum(final SqlNode[] nodes) {
    * beginning of the first to the end of the last.
    */
   public static SqlParserPos sum(final List<? extends SqlNode> nodes) {
-    if (nodes.size() == 0) {
+    if (nodes.isEmpty()) {
       throw new AssertionError();
     }
     SqlParserPos pos0 = nodes.get(0).getParserPosition();
@@ -209,7 +209,7 @@ public static SqlParserPos sum(final List<? extends SqlNode> nodes) {
   public static SqlParserPos sum(Iterable<SqlParserPos> poses) {
     final List<SqlParserPos> list =
         poses instanceof List ? (List<SqlParserPos>) poses : Lists.newArrayList(poses);
-    if (list.size() == 0) {
+    if (list.isEmpty()) {
       throw new AssertionError();
     }
     final SqlParserPos pos0 = list.get(0);
diff --git a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
index d1ae7544d..962e6061e 100644
--- a/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
+++ b/core/src/main/java/org/apache/calcite/sql/parser/SqlParserUtil.java
@@ -363,8 +363,7 @@ public static SqlIntervalLiteral parseIntervalLiteral(
       SqlParserPos pos, int sign, String s, SqlIntervalQualifier intervalQualifier) {
     if (s.equals("")) {
       throw SqlUtil.newContextException(
-          pos,
-          RESOURCE.illegalIntervalLiteral(s + " " + intervalQualifier.toString(), pos.toString()));
+          pos, RESOURCE.illegalIntervalLiteral(s + " " + intervalQualifier, pos.toString()));
     }
     return SqlLiteral.createInterval(sign, s, intervalQualifier, pos);
   }
@@ -484,7 +483,7 @@ public static byte[] parseBinaryString(String s) {
     s = s.replace("\f", "");
     s = s.replace("'", "");
 
-    if (s.length() == 0) {
+    if (s.isEmpty()) {
       return new byte[0];
     }
     assert (s.length() & 1) == 0; // must be even nbr of hex digits
@@ -551,7 +550,7 @@ public static String toCase(String s, Casing casing) {
    * trim("aBaac123AabC","abBcC")} returns {@code "123A"}.
    */
   public static String trim(String s, String chars) {
-    if (s.length() == 0) {
+    if (s.isEmpty()) {
       return "";
     }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java b/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
index 4b8662444..06c20a18a 100644
--- a/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
+++ b/core/src/main/java/org/apache/calcite/sql/pretty/SqlPrettyWriter.java
@@ -49,6 +49,8 @@
 import java.util.Set;
 import java.util.function.Consumer;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -525,9 +527,7 @@ public void newlineAndIndent(int indent) {
   }
 
   void indent(int indent) {
-    if (indent < 0) {
-      throw new IllegalArgumentException("negative indent " + indent);
-    }
+    checkArgument(indent >= 0, "negative indent %s", indent);
     Spaces.append(buf, indent);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java b/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java
index 2111caad2..6d1597f70 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ApplySqlType.java
@@ -48,7 +48,7 @@ abstract class ApplySqlType extends AbstractSqlType {
           if (withDetail) {
             sb.append(type.getFullTypeString());
           } else {
-            sb.append(type.toString());
+            sb.append(type);
           }
         });
     sb.append('>');
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java b/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
index 295432567..44dd1a174 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ArraySqlType.java
@@ -20,6 +20,8 @@
 import org.apache.calcite.rel.type.RelDataTypeFamily;
 import org.apache.calcite.rel.type.RelDataTypePrecedenceList;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.sql.type.NonNullableAccessors.getComponentTypeOrThrow;
 
 import static java.util.Objects.requireNonNull;
@@ -46,7 +48,7 @@ public ArraySqlType(RelDataType elementType, boolean isNullable) {
     if (withDetail) {
       sb.append(elementType.getFullTypeString());
     } else {
-      sb.append(elementType.toString());
+      sb.append(elementType);
     }
     sb.append(" ARRAY");
   }
@@ -73,12 +75,8 @@ public ArraySqlType(RelDataType elementType, boolean isNullable) {
       }
 
       @Override public int compareTypePrecedence(RelDataType type1, RelDataType type2) {
-        if (!containsType(type1)) {
-          throw new IllegalArgumentException("must contain type: " + type1);
-        }
-        if (!containsType(type2)) {
-          throw new IllegalArgumentException("must contain type: " + type2);
-        }
+        checkArgument(containsType(type1), "must contain type: %s", type1);
+        checkArgument(containsType(type2), "must contain type: %s", type2);
         return getComponentType()
             .getPrecedenceList()
             .compareTypePrecedence(getComponentTypeOrThrow(type1), getComponentTypeOrThrow(type2));
diff --git a/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java
index 2faec6cfd..3e196d79b 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/AssignableOperandTypeChecker.java
@@ -52,7 +52,7 @@ public class AssignableOperandTypeChecker implements SqlOperandTypeChecker {
    */
   public AssignableOperandTypeChecker(
       List<RelDataType> paramTypes, @Nullable List<String> paramNames) {
-    this.paramTypes = ImmutableList.copyOf(paramTypes);
+    this.paramTypes = paramTypes;
     this.paramNames = paramNames == null ? null : ImmutableList.copyOf(paramNames);
   }
 
diff --git a/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
index 8dda0bedd..0b5625e0a 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/CompositeOperandTypeChecker.java
@@ -357,7 +357,7 @@ private boolean coerceOperands(SqlCallBinding callBinding, boolean repeat) {
     // collect SqlTypeFamily and data type of all the operands.
     List<SqlTypeFamily> families =
         allowedRules.stream()
-            .filter(r -> r instanceof ImplicitCastOperandTypeChecker)
+            .filter(ImplicitCastOperandTypeChecker.class::isInstance)
             // All the rules are SqlSingleOperandTypeChecker.
             .map(r -> ((ImplicitCastOperandTypeChecker) r).getOperandSqlTypeFamily(0))
             .collect(Collectors.toList());
diff --git a/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java
index 936f6472b..6f1d02557 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/CompositeSingleOperandTypeChecker.java
@@ -54,7 +54,7 @@ public class CompositeSingleOperandTypeChecker extends CompositeOperandTypeCheck
 
   @Override public boolean checkSingleOperandType(
       SqlCallBinding callBinding, SqlNode node, int iFormalOperand, boolean throwOnFailure) {
-    assert allowedRules.size() >= 1;
+    assert !allowedRules.isEmpty();
 
     final ImmutableList<? extends SqlSingleOperandTypeChecker> rules = getRules();
     if (composition == Composition.SEQUENCE) {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
index e56acda72..5deee7a68 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/FamilyOperandTypeChecker.java
@@ -31,6 +31,8 @@
 import java.util.List;
 import java.util.function.Predicate;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
@@ -68,10 +70,9 @@ public class FamilyOperandTypeChecker
   @Override public boolean checkSingleOperandType(
       SqlCallBinding callBinding, SqlNode node, int iFormalOperand, boolean throwOnFailure) {
     Util.discard(iFormalOperand);
-    if (families.size() != 1) {
-      throw new IllegalStateException(
-          "Cannot use as SqlSingleOperandTypeChecker without exactly one family");
-    }
+    checkState(
+        families.size() == 1,
+        "Cannot use as SqlSingleOperandTypeChecker without exactly one family");
     return checkSingleOperandType(
         callBinding, node, iFormalOperand, families.get(0), throwOnFailure);
   }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java b/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java
index 74eb54798..079183e9a 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/IntervalSqlType.java
@@ -97,12 +97,12 @@ public IntervalSqlType combine(RelDataTypeFactoryImpl typeFactory, IntervalSqlTy
       secondPrec =
           SqlIntervalQualifier.combineStartPrecisionPreservingDefault(
               typeFactory.getTypeSystem(), this.intervalQualifier, that.intervalQualifier);
-    } else if (null == thisEnd || thisEnd.ordinal() < thatStart.ordinal()) {
+    } else if (thisEnd == null || thisEnd.ordinal() < thatStart.ordinal()) {
       thisEnd = thatStart;
     }
 
-    if (null != thatEnd) {
-      if (null == thisEnd || thisEnd.ordinal() < thatEnd.ordinal()) {
+    if (thatEnd != null) {
+      if (thisEnd == null || thisEnd.ordinal() < thatEnd.ordinal()) {
         thisEnd = thatEnd;
       }
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java
index 2f84df4f7..3558f8541 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/MultisetOperandTypeChecker.java
@@ -56,7 +56,7 @@ public class MultisetOperandTypeChecker implements SqlOperandTypeChecker {
                 ImmutableList.of(
                     getComponentTypeOrThrow(SqlTypeUtil.deriveType(callBinding, op0)),
                     getComponentTypeOrThrow(SqlTypeUtil.deriveType(callBinding, op1))));
-    if (null == biggest) {
+    if (biggest == null) {
       if (throwOnFailure) {
         throw callBinding.newError(
             RESOURCE.typeNotComparable(
diff --git a/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java b/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java
index 6c377a245..cdfc10c90 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/MultisetSqlType.java
@@ -20,6 +20,8 @@
 import org.apache.calcite.rel.type.RelDataTypeFamily;
 import org.apache.calcite.rel.type.RelDataTypePrecedenceList;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.sql.type.NonNullableAccessors.getComponentTypeOrThrow;
 
 /** MultisetSqlType represents a standard SQL2003 multiset type. */
@@ -47,7 +49,7 @@ public MultisetSqlType(RelDataType elementType, boolean isNullable) {
     if (withDetail) {
       sb.append(elementType.getFullTypeString());
     } else {
-      sb.append(elementType.toString());
+      sb.append(elementType);
     }
     sb.append(" MULTISET");
   }
@@ -81,12 +83,8 @@ public MultisetSqlType(RelDataType elementType, boolean isNullable) {
       }
 
       @Override public int compareTypePrecedence(RelDataType type1, RelDataType type2) {
-        if (!containsType(type1)) {
-          throw new IllegalArgumentException("must contain type: " + type1);
-        }
-        if (!containsType(type2)) {
-          throw new IllegalArgumentException("must contain type: " + type2);
-        }
+        checkArgument(containsType(type1), "must contain type: %s", type1);
+        checkArgument(containsType(type2), "must contain type: %s", type2);
         return getComponentType()
             .getPrecedenceList()
             .compareTypePrecedence(getComponentTypeOrThrow(type1), getComponentTypeOrThrow(type2));
diff --git a/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java b/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
index 0ee4b0e4d..3f0cff646 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java
@@ -818,7 +818,7 @@ public static SqlCall stripSeparator(SqlCall call) {
         }
 
         ret = typeFactory.createSqlType(typeName, typePrecision);
-        if (null != pickedCollation) {
+        if (pickedCollation != null) {
           RelDataType pickedType;
           if (getCollation(argType0).equals(pickedCollation)) {
             pickedType = argType0;
@@ -1016,7 +1016,7 @@ private static RelDataType multivalentStringWithSepSumPrecision(SqlOperatorBindi
         RelDataType multisetType = recordMultisetType.getComponentType();
         assert multisetType != null : "expected a multiset type: " + recordMultisetType;
         final List<RelDataTypeField> fields = multisetType.getFieldList();
-        assert fields.size() > 0;
+        assert !fields.isEmpty();
         final RelDataType firstColType = fields.get(0).getType();
         return opBinding.getTypeFactory().createMultisetType(firstColType, -1);
       };
@@ -1138,5 +1138,5 @@ private static RelDataType multivalentStringWithSepSumPrecision(SqlOperatorBindi
       };
 
   public static final SqlReturnTypeInference PERCENTILE_DISC_CONT =
-      opBinding -> opBinding.getCollationType();
+      SqlOperatorBinding::getCollationType;
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
index f616e878f..945fe2d92 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeChecker.java
@@ -32,6 +32,8 @@
 import java.util.Collections;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -62,10 +64,9 @@ protected boolean checkOperandTypesImpl(
       SqlOperatorBinding operatorBinding,
       boolean throwOnFailure,
       @Nullable SqlCallBinding callBinding) {
-    if (throwOnFailure && callBinding == null) {
-      throw new IllegalArgumentException(
-          "callBinding must be non-null in case throwOnFailure=true");
-    }
+    checkArgument(
+        !throwOnFailure || callBinding != null,
+        "callBinding must be non-null in case throwOnFailure=true");
     int nOperandsActual = nOperands;
     if (nOperandsActual == -1) {
       nOperandsActual = operatorBinding.getOperandCount();
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java
index de3844946..4b3d6e908 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SameOperandTypeExceptLastOperandChecker.java
@@ -29,6 +29,8 @@
 import java.util.Collections;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -52,10 +54,9 @@ public SameOperandTypeExceptLastOperandChecker(int nOperands, String lastOperand
       SqlOperatorBinding operatorBinding,
       boolean throwOnFailure,
       @Nullable SqlCallBinding callBinding) {
-    if (throwOnFailure && callBinding == null) {
-      throw new IllegalArgumentException(
-          "callBinding must be non-null in case throwOnFailure=true");
-    }
+    checkArgument(
+        !throwOnFailure || callBinding != null,
+        "callBinding must be non-null in case throwOnFailure=true");
     int nOperandsActual = nOperands;
     if (nOperandsActual == -1) {
       nOperandsActual = operatorBinding.getOperandCount();
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java b/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java
index f86928912..786b10f43 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SetopOperandTypeChecker.java
@@ -109,7 +109,7 @@ public class SetopOperandTypeChecker implements SqlOperandTypeChecker {
           for (int j = 0; j < callBinding.getOperandCount(); j++) {
             TypeCoercion typeCoercion = validator.getTypeCoercion();
             RelDataType widenType = typeCoercion.getWiderTypeFor(columnIthTypes, true);
-            if (null != widenType) {
+            if (widenType != null) {
               coerced =
                   typeCoercion.rowTypeCoercion(
                           callBinding.getScope(), callBinding.operand(j), i, widenType)
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
index 91e6030d3..8e01f0eb8 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeAssignmentRule.java
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.sql.type;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 
 import java.util.EnumSet;
@@ -45,7 +44,7 @@ public class SqlTypeAssignmentRule implements SqlTypeMappingRule {
    *     type
    */
   private SqlTypeAssignmentRule(Map<SqlTypeName, ImmutableSet<SqlTypeName>> map) {
-    this.map = ImmutableMap.copyOf(map);
+    this.map = map;
   }
 
   static {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
index 6470f05b4..1e777d20e 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeCoercionRule.java
@@ -16,7 +16,6 @@
  */
 package org.apache.calcite.sql.type;
 
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -97,7 +96,7 @@ public class SqlTypeCoercionRule implements SqlTypeMappingRule {
    *     type
    */
   private SqlTypeCoercionRule(Map<SqlTypeName, ImmutableSet<SqlTypeName>> map) {
-    this.map = ImmutableMap.copyOf(map);
+    this.map = map;
   }
 
   static {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
index 9caf3e202..63055bab6 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeFactoryImpl.java
@@ -140,7 +140,7 @@ public SqlTypeFactoryImpl(RelDataTypeSystem typeSystem) {
       List<RelDataType> types, SqlTypeMappingRule mappingRule) {
     requireNonNull(types, "types");
     requireNonNull(mappingRule, "mappingRule");
-    checkArgument(types.size() >= 1, "types.size >= 1");
+    checkArgument(!types.isEmpty(), "types.size >= 1");
 
     RelDataType type0 = types.get(0);
     if (type0.getSqlTypeName() != null) {
diff --git a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java
index 9f890d5ea..403884866 100644
--- a/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java
+++ b/core/src/main/java/org/apache/calcite/sql/type/SqlTypeMappingRules.java
@@ -25,7 +25,7 @@
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 
-import java.util.HashMap;
+import java.util.EnumMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
@@ -66,9 +66,8 @@ public static class Builder {
 
     /** Creates an empty {@link Builder}. */
     Builder() {
-      this.map = new HashMap<>();
-      this.sets =
-          CacheBuilder.newBuilder().build(CacheLoader.from(set -> Sets.immutableEnumSet(set)));
+      this.map = new EnumMap<>(SqlTypeName.class);
+      this.sets = CacheBuilder.newBuilder().build(CacheLoader.from(Sets::immutableEnumSet));
     }
 
     /** Add a map entry to the existing {@link Builder} mapping. */
diff --git a/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java b/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java
index 6423a859d..3b942f785 100644
--- a/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java
+++ b/core/src/main/java/org/apache/calcite/sql/util/ChainedSqlOperatorTable.java
@@ -50,7 +50,7 @@ public ChainedSqlOperatorTable(List<SqlOperatorTable> tableList) {
 
   /** Internal constructor; call {@link SqlOperatorTables#chain}. */
   protected ChainedSqlOperatorTable(ImmutableList<SqlOperatorTable> tableList) {
-    this.tableList = ImmutableList.copyOf(tableList);
+    this.tableList = tableList.asList();
   }
 
   // ~ Methods ----------------------------------------------------------------
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java b/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
index df7107f2b..1521f2a83 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/AggregatingSelectScope.java
@@ -30,7 +30,6 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSortedMultiset;
 
 import java.util.Collection;
@@ -258,7 +257,7 @@ public static class Resolved {
       this.groupExprList = ImmutableList.copyOf(groupExprList);
       this.groupSet = ImmutableBitSet.range(groupExprList.size());
       this.groupSets = ImmutableSortedMultiset.copyOf(groupSets);
-      this.groupExprProjection = ImmutableMap.copyOf(groupExprProjection);
+      this.groupExprProjection = groupExprProjection;
     }
 
     /** Returns whether a field should be nullable due to grouping sets. */
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java b/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java
index 6233a8e29..d682d9a6d 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/CyclicDefinitionException.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.sql.validate;
 
-import com.google.common.collect.ImmutableList;
-
 import java.util.List;
 
 /** Thrown when an object, such as a view, is found to have a cylic definition. */
@@ -29,6 +27,6 @@ public class CyclicDefinitionException extends RuntimeException {
   public CyclicDefinitionException(int depth, List<String> path) {
     super("Cyclic object definition: " + path);
     this.depth = depth;
-    this.path = ImmutableList.copyOf(path);
+    this.path = path;
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java b/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java
index b2d581494..0a43d855c 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/ProcedureNamespace.java
@@ -27,6 +27,8 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Namespace whose contents are defined by the result of a call to a user-defined procedure. */
@@ -53,15 +55,15 @@ public class ProcedureNamespace extends AbstractNamespace {
     final RelDataType type = validator.deriveTypeImpl(scope, call);
     final SqlOperator operator = call.getOperator();
     final SqlCallBinding callBinding = new SqlCallBinding(validator, scope, call);
-    if (!(operator instanceof SqlTableFunction)) {
-      throw new IllegalArgumentException(
-          "Argument must be a table function: " + operator.getNameAsId());
-    }
+    checkArgument(
+        (operator instanceof SqlTableFunction),
+        "Argument must be a table function: %s",
+        operator.getNameAsId());
     final SqlTableFunction tableFunction = (SqlTableFunction) operator;
-    if (type.getSqlTypeName() != SqlTypeName.CURSOR) {
-      throw new IllegalArgumentException(
-          "Table function should have CURSOR " + "type, not " + type);
-    }
+    checkArgument(
+        type.getSqlTypeName() == SqlTypeName.CURSOR,
+        "Table function should have CURSOR type, not %s",
+        type);
     final SqlReturnTypeInference rowTypeInference = tableFunction.getRowTypeInference();
     return requireNonNull(
         rowTypeInference.inferReturnType(callBinding),
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java b/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
index 40263e4ce..c952a5f71 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SelectScope.java
@@ -159,7 +159,7 @@ public class SelectScope extends ListScope {
 
     // TODO: compare fully qualified names
     final SqlNodeList orderList = getOrderList();
-    if (orderList.size() > 0) {
+    if (!orderList.isEmpty()) {
       SqlNode order0 = orderList.get(0);
       monotonicity = SqlMonotonicity.INCREASING;
       if ((order0 instanceof SqlCall)
@@ -182,7 +182,7 @@ public class SelectScope extends ListScope {
       if (children.size() == 1) {
         final SqlValidatorNamespace child = children.get(0).namespace;
         final List<Pair<SqlNode, SqlMonotonicity>> monotonicExprs = child.getMonotonicExprs();
-        if (monotonicExprs.size() > 0) {
+        if (!monotonicExprs.isEmpty()) {
           orderList.add(monotonicExprs.get(0).left);
         }
       }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
index 1d3ee5b22..8dd122bd2 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlNameMatchers.java
@@ -150,7 +150,7 @@ private static class LiberalNameMatcher extends BaseMatcher {
     @Override protected boolean listMatches(List<String> list0, List<String> list1) {
       final boolean b = super.listMatches(list0, list1);
       if (b) {
-        matchedNames = ImmutableList.copyOf(list1);
+        matchedNames = list1;
       }
       return b;
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java
index 304000f0c..966b755dc 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlNonNullableAccessors.java
@@ -28,8 +28,6 @@
 
 import org.apiguardian.api.API;
 
-import java.util.Objects;
-
 import static java.util.Objects.requireNonNull;
 
 /** This class provides non-nullable accessors for common getters. */
@@ -38,7 +36,7 @@ private SqlNonNullableAccessors() {}
 
   private static String safeToString(Object obj) {
     try {
-      return Objects.toString(obj);
+      return String.valueOf(obj);
     } catch (Throwable e) {
       return "Error in toString: " + e;
     }
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java
index da856fc96..08594db67 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlQualified.java
@@ -50,7 +50,7 @@ private SqlQualified(
   }
 
   @Override public String toString() {
-    return "{id: " + identifier.toString() + ", prefix: " + prefixLength + "}";
+    return "{id: " + identifier + ", prefix: " + prefixLength + "}";
   }
 
   public static SqlQualified create(
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
index 2998fe190..452820d76 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlUserDefinedTableMacro.java
@@ -40,6 +40,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * User-defined table macro.
  *
@@ -128,16 +130,12 @@ public TranslatableTable getTable(SqlOperatorBinding callBinding) {
           if (callBinding.isOperandLiteral(i, true)) {
             value = callBinding.getOperandLiteralValue(i, type);
           } else {
-            if (failOnNonLiteral) {
-              throw new IllegalArgumentException(
-                  "All arguments of call to macro "
-                      + opName
-                      + " should be literal. Actual argument #"
-                      + parameter.getOrdinal()
-                      + " ("
-                      + parameter.getName()
-                      + ") is not literal");
-            }
+            checkArgument(
+                !failOnNonLiteral,
+                "All arguments of call to macro %s should be literal. Actual argument #%s (%s) is not literal",
+                opName,
+                parameter.getOrdinal(),
+                parameter.getName());
             if (type.isNullable()) {
               value = null;
             } else {
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
index 9844e3dfe..fe9d4524e 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java
@@ -850,11 +850,11 @@ private void lookupJoinHints(
     SqlNode right = join.getRight();
     SqlNode condition = join.getCondition();
     lookupFromHints(left, scope, pos, hintList);
-    if (hintList.size() > 0) {
+    if (!hintList.isEmpty()) {
       return;
     }
     lookupFromHints(right, scope, pos, hintList);
-    if (hintList.size() > 0) {
+    if (!hintList.isEmpty()) {
       return;
     }
     final JoinConditionType conditionType = join.getConditionType();
@@ -886,7 +886,7 @@ public final void lookupNameCompletionHints(
     // Remove the last part of name - it is a dummy
     List<String> subNames = Util.skipLast(names);
 
-    if (subNames.size() > 0) {
+    if (!subNames.isEmpty()) {
       // If there's a prefix, resolve it to a namespace.
       SqlValidatorNamespace ns = null;
       for (String name : subNames) {
@@ -1708,7 +1708,7 @@ protected SqlSelect createSourceSelectForDelete(SqlDelete call) {
   @Nullable
   RelDataType getTableConstructorRowType(SqlCall values, SqlValidatorScope scope) {
     final List<SqlNode> rows = values.getOperandList();
-    assert rows.size() >= 1;
+    assert !rows.isEmpty();
     final List<RelDataType> rowTypes = new ArrayList<>();
     for (final SqlNode row : rows) {
       assert row.getKind() == SqlKind.ROW;
@@ -2385,7 +2385,7 @@ private SqlNode registerFrom(
           tableScope = new TableScope(parentScope, node);
         }
         tableScope.addChild(newNs, requireNonNull(alias, "alias"), forceNullable);
-        if (extendList != null && extendList.size() != 0) {
+        if (extendList != null && !extendList.isEmpty()) {
           return enclosingNode;
         }
         return newNode;
@@ -2506,7 +2506,7 @@ private SqlNode registerFrom(
             extendList,
             forceNullable,
             lateral);
-        if (extendList != null && extendList.size() != 0) {
+        if (extendList != null && !extendList.isEmpty()) {
           return enclosingNode;
         }
         return newNode;
@@ -3433,7 +3433,7 @@ private RelDataType validateCommonInputJoinColumn(
       final RelCrossType crossType = (RelCrossType) rowType;
       rowTypes = new ArrayList<>(crossType.getTypes());
     } else {
-      rowTypes = Collections.singleton(rowType);
+      rowTypes = ImmutableSet.of(rowType);
     }
     for (RelDataType rowType0 : rowTypes) {
       if (nameMatcher.frequency(rowType0.getFieldNames(), name) > 1) {
@@ -3853,7 +3853,7 @@ private static SqlModality deduceModality(SqlNode query) {
 
     // Make sure that ORDER BY is possible.
     final SqlNodeList orderList = select.getOrderList();
-    if (orderList != null && orderList.size() > 0) {
+    if (orderList != null && !orderList.isEmpty()) {
       switch (modality) {
         case STREAM:
           if (!hasSortedPrefix(scope, orderList)) {
@@ -4189,7 +4189,7 @@ protected void validateGroupClause(SqlSelect select) {
       aggregatingScope = (AggregatingSelectScope) selectScope;
     }
     for (SqlNode groupItem : groupList) {
-      if (groupItem instanceof SqlNodeList && ((SqlNodeList) groupItem).size() == 0) {
+      if (groupItem instanceof SqlNodeList && ((SqlNodeList) groupItem).isEmpty()) {
         continue;
       }
       validateGroupItem(groupScope, aggregatingScope, groupItem);
@@ -4993,7 +4993,7 @@ protected void validateValues(
 
     final List<SqlNode> operands = node.getOperandList();
     for (SqlNode operand : operands) {
-      if (!(operand.getKind() == SqlKind.ROW)) {
+      if (operand.getKind() != SqlKind.ROW) {
         throw Util.needToImplement("Values function where operands are scalars");
       }
 
@@ -5059,7 +5059,7 @@ protected void validateValues(
                   }
                 });
 
-        if (null == type) {
+        if (type == null) {
           throw newValidationError(
               node, RESOURCE.incompatibleValueType(SqlStdOperatorTable.VALUES.getName()));
         }
@@ -5278,7 +5278,7 @@ SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {
             RESOURCE.intervalMustBeNonNegative(
                 intervalValue != null ? intervalValue : interval.toString()));
       }
-      if (orderBy == null || orderBy.size() == 0) {
+      if (orderBy == null || orderBy.isEmpty()) {
         throw newValidationError(interval, RESOURCE.cannotUseWithinWithoutOrderBy());
       }
 
@@ -5302,7 +5302,7 @@ SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {
     validateDefinitions(matchRecognize, scope);
 
     SqlNodeList subsets = matchRecognize.getSubsetList();
-    if (subsets != null && subsets.size() > 0) {
+    if (subsets != null && !subsets.isEmpty()) {
       for (SqlNode node : subsets) {
         List<SqlNode> operands = ((SqlCall) node).getOperandList();
         String leftString = ((SqlIdentifier) operands.get(0)).getSimple();
@@ -5339,7 +5339,7 @@ SqlValidatorNamespace lookupFieldNamespace(RelDataType rowType, String name) {
         });
 
     final RelDataType rowType = typeBuilder.build();
-    if (matchRecognize.getMeasureList().size() == 0) {
+    if (matchRecognize.getMeasureList().isEmpty()) {
       ns.setType(getNamespaceOrThrow(matchRecognize.getTableRef()).getRowType());
     } else {
       ns.setType(rowType);
@@ -5396,8 +5396,7 @@ private SqlNode navigationInMeasure(SqlNode node, boolean allRows) {
       node = SqlStdOperatorTable.AS.createCall(SqlParserPos.ZERO, newNode, ops.get(1));
     }
 
-    node = new NavigationExpander().go(node);
-    return node;
+    return new NavigationExpander().go(node);
   }
 
   private void validateDefinitions(SqlMatchRecognize mr, MatchRecognizeScope scope) {
@@ -5677,8 +5676,7 @@ private SqlNode navigationInDefine(SqlNode node, String alpha) {
     Set<String> prefix = node.accept(new PatternValidator(false));
     Util.discard(prefix);
     node = new NavigationExpander().go(node);
-    node = new NavigationReplacer(alpha).go(node);
-    return node;
+    return new NavigationReplacer(alpha).go(node);
   }
 
   @Override public void validateAggregateParams(
@@ -5738,7 +5736,7 @@ private SqlNode navigationInDefine(SqlNode node, String alpha) {
     final SqlAggFunction op = (SqlAggFunction) aggCall.getOperator();
     switch (op.requiresGroupOrder()) {
       case MANDATORY:
-        if (orderList == null || orderList.size() == 0) {
+        if (orderList == null || orderList.isEmpty()) {
           throw newValidationError(
               aggCall, RESOURCE.aggregateMissingWithinGroupClause(op.getName()));
         }
@@ -5752,7 +5750,7 @@ private SqlNode navigationInDefine(SqlNode node, String alpha) {
         }
         break;
       case FORBIDDEN:
-        if (orderList != null && orderList.size() != 0) {
+        if (orderList != null && !orderList.isEmpty()) {
           throw newValidationError(
               aggCall, RESOURCE.withinGroupClauseIllegalInAggregate(op.getName()));
         }
@@ -5890,7 +5888,7 @@ public SqlNode extendedExpandGroupBy(SqlNode expr, SqlValidatorScope scope, SqlS
 
   @Override public List<@Nullable List<String>> getFieldOrigins(SqlNode sqlQuery) {
     if (sqlQuery instanceof SqlExplain) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     final RelDataType rowType = getValidatedNodeType(sqlQuery);
     final int fieldCount = rowType.getFieldCount();
@@ -6244,8 +6242,7 @@ private class DeriveTypeVisitor implements SqlVisitor<RelDataType> {
         }
         type = field.getType();
       }
-      type = SqlTypeUtil.addCharsetAndCollation(type, getTypeFactory());
-      return type;
+      return SqlTypeUtil.addCharsetAndCollation(type, getTypeFactory());
     }
 
     @Override public RelDataType visit(SqlDataTypeSpec dataType) {
@@ -6683,7 +6680,7 @@ private static class NavigationExpander extends NavigationModifier {
         return newInnerNode;
       }
 
-      if (operands.size() > 0) {
+      if (!operands.isEmpty()) {
         for (SqlNode node : operands) {
           if (node != null) {
             SqlNode newNode = node.accept(new NavigationExpander());
@@ -6844,7 +6841,7 @@ private class PatternValidator extends SqlBasicVisitor<@Nullable Set<String>> {
             }
             break;
           default:
-            if (operands.size() == 0
+            if (operands.isEmpty()
                 || !(operands.get(0) instanceof SqlCall)
                 || ((SqlCall) operands.get(0)).getOperator() != SqlStdOperatorTable.CLASSIFIER) {
               if (vars.isEmpty()) {
@@ -6937,7 +6934,7 @@ private class Permute {
             }
           }
           rowType = b.build();
-          this.sources = ImmutableList.copyOf(sources);
+          this.sources = sources;
           this.trivial = left.trivial && right.trivial && (names == null || names.isEmpty());
           break;
 
@@ -6961,7 +6958,7 @@ void permute(List<SqlNode> selectItems, PairList<String, RelDataType> fields) {
         return;
       }
 
-      final List<SqlNode> oldSelectItems = ImmutableList.copyOf(selectItems);
+      final List<SqlNode> oldSelectItems = selectItems;
       selectItems.clear();
       selectItems.addAll(oldSelectItems.subList(0, offset));
       final PairList<String, RelDataType> oldFields = fields.immutable();
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
index 25943ab13..465e4a09d 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorScope.java
@@ -244,7 +244,7 @@ public int stepCount() {
 
     /** Returns the steps in this path. */
     public List<Step> steps() {
-      ImmutableList.Builder<Step> paths = new ImmutableList.Builder<>();
+      ImmutableList.Builder<Step> paths = ImmutableList.builder();
       build(paths);
       return paths.build();
     }
@@ -346,7 +346,7 @@ class Resolve {
       this.scope = scope;
       assert !(scope instanceof TableScope);
       this.path = requireNonNull(path, "path");
-      this.remainingNames = ImmutableList.copyOf(remainingNames);
+      this.remainingNames = remainingNames;
     }
 
     /** The row type of the found namespace, nullable if the lookup has looked into outer joins. */
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
index 26b7cb035..1fabb12a8 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorUtil.java
@@ -71,7 +71,6 @@
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
@@ -263,7 +262,7 @@ public static void checkCharsetAndCollateConsistentIfCharType(RelDataType type)
           // todo: enable this checking when we have a charset to
           //   collation mapping
           throw new Error(
-              type.toString()
+              type
                   + " was found to have charset '"
                   + strCharset.name()
                   + "' and a mismatched collation charset '"
@@ -636,7 +635,7 @@ private static void addFields(
    * namespace, never null, may represent a schema, table, column, etc.
    */
   public static SqlValidatorNamespace lookup(SqlValidatorScope scope, List<String> names) {
-    assert names.size() > 0;
+    assert !names.isEmpty();
     final SqlNameMatcher nameMatcher = scope.getValidator().getCatalogReader().nameMatcher();
     final SqlValidatorScope.ResolvedImpl resolved = new SqlValidatorScope.ResolvedImpl();
     scope.resolve(ImmutableList.of(names.get(0)), nameMatcher, false, resolved);
@@ -849,7 +848,7 @@ private static ImmutableBitSet analyzeGroupExpr(
                 scope, groupAnalyzer, ((SqlCall) expandedGroupExpr).getOperandList()));
       case OTHER:
         if (expandedGroupExpr instanceof SqlNodeList
-            && ((SqlNodeList) expandedGroupExpr).size() == 0) {
+            && ((SqlNodeList) expandedGroupExpr).isEmpty()) {
           return ImmutableBitSet.of();
         }
         break;
@@ -1164,7 +1163,7 @@ public static Pair<SqlNode, RelDataType> validateExprWithRowType(
         new SqlSelect(
             SqlParserPos.ZERO,
             null,
-            new SqlNodeList(Collections.singletonList(expr), SqlParserPos.ZERO),
+            new SqlNodeList(ImmutableList.of(expr), SqlParserPos.ZERO),
             new SqlIdentifier(tableName, SqlParserPos.ZERO),
             null,
             null,
@@ -1213,7 +1212,7 @@ public static CalciteCatalogReader createSingleTableCatalogReader(
 
     // prepare root schema
     final ExplicitRowTypeTable table = new ExplicitRowTypeTable(rowType);
-    final Map<String, Table> tableMap = Collections.singletonMap(tableName, table);
+    final Map<String, Table> tableMap = ImmutableMap.of(tableName, table);
     CalciteSchema schema =
         CalciteSchema.createRootSchema(false, false, "", new ExplicitTableSchema(tableMap));
 
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java b/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
index bc284fdd0..b3d53ee40 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/implicit/AbstractTypeCoercion.java
@@ -551,17 +551,17 @@ private RelDataType getTightestCommonTypeOrThrow(
       return null;
     }
     RelDataType resultType = getTightestCommonType(type1, type2);
-    if (null == resultType) {
+    if (resultType == null) {
       resultType = getWiderTypeForDecimal(type1, type2);
     }
-    if (null == resultType && stringPromotion) {
+    if (resultType == null && stringPromotion) {
       resultType = promoteToVarChar(type1, type2);
     }
-    if (null == resultType) {
+    if (resultType == null) {
       if (SqlTypeUtil.isArray(type1) && SqlTypeUtil.isArray(type2)) {
         RelDataType valType =
             getWiderTypeForTwo(type1.getComponentType(), type2.getComponentType(), stringPromotion);
-        if (null != valType) {
+        if (valType != null) {
           resultType = factory.createArrayType(valType, -1);
         }
       }
@@ -612,7 +612,7 @@ private RelDataType getTightestCommonTypeOrThrow(
     List<RelDataType> target = stringPromotion ? partitionByCharacter(typeList) : typeList;
     for (RelDataType tp : target) {
       resultType = getWiderTypeForTwo(tp, resultType, stringPromotion);
-      if (null == resultType) {
+      if (resultType == null) {
         return null;
       }
     }
@@ -651,7 +651,7 @@ boolean canImplicitTypeCast(List<RelDataType> types, List<SqlTypeFamily> familie
     }
     for (Pair<RelDataType, SqlTypeFamily> pair : Pair.zip(types, families)) {
       RelDataType implicitType = implicitCast(pair.left, pair.right);
-      if (null == implicitType) {
+      if (implicitType == null) {
         return false;
       }
       needed = pair.left != implicitType || needed;
diff --git a/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java b/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
index 4523a3386..14714afd5 100644
--- a/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
+++ b/core/src/main/java/org/apache/calcite/sql/validate/implicit/TypeCoercionImpl.java
@@ -237,7 +237,7 @@ protected boolean binaryArithmeticWithStrings(
       // Binary comparison operator like: = > >= < <=
       if (kind.belongsTo(SqlKind.BINARY_COMPARISON)) {
         final RelDataType commonType = commonTypeForBinaryComparison(type1, type2);
-        if (null != commonType) {
+        if (commonType != null) {
           coerced = coerceOperandsType(binding.getScope(), binding.getCall(), commonType);
         }
       }
@@ -247,7 +247,7 @@ protected boolean binaryArithmeticWithStrings(
       final List<RelDataType> operandTypes =
           Util.range(operandCnt).stream().map(binding::getOperandType).collect(Collectors.toList());
       final RelDataType commonType = commonTypeForComparison(operandTypes);
-      if (null != commonType) {
+      if (commonType != null) {
         coerced = coerceOperandsType(binding.getScope(), binding.getCall(), commonType);
       }
     }
@@ -404,7 +404,7 @@ protected boolean booleanEquality(SqlCallBinding binding, RelDataType left, RelD
     // Entering this method means we have already got a wider type, recompute it here
     // just to make the interface more clear.
     RelDataType widerType = getWiderTypeFor(argTypes, true);
-    if (null != widerType) {
+    if (widerType != null) {
       boolean coerced = false;
       for (int i = 0; i < thenList.size(); i++) {
         coerced = coerceColumnType(scope, thenList, i, widerType) || coerced;
@@ -554,7 +554,7 @@ protected boolean booleanEquality(SqlCallBinding binding, RelDataType left, RelD
     for (int i = 0; i < operandTypes.size(); i++) {
       RelDataType implicitType = implicitCast(operandTypes.get(i), expectedFamilies.get(i));
       coerced =
-          null != implicitType
+          implicitType != null
                   && operandTypes.get(i) != implicitType
                   && coerceOperandType(binding.getScope(), binding.getCall(), i, implicitType)
               || coerced;
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java
index 7378add79..74fb5d6b0 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/AggConverter.java
@@ -460,7 +460,7 @@ private void translateAgg(
     final RelDataType type = bb.getValidator().deriveType(bb.scope, call);
     boolean distinct = false;
     SqlLiteral quantifier = call.getFunctionQuantifier();
-    if ((null != quantifier) && (quantifier.getValue() == SqlSelectKeyword.DISTINCT)) {
+    if (quantifier != null && (quantifier.getValue() == SqlSelectKeyword.DISTINCT)) {
       distinct = true;
     }
     boolean approximate = false;
@@ -470,7 +470,7 @@ private void translateAgg(
       approximate = true;
     }
     final RelCollation collation;
-    if (orderList == null || orderList.size() == 0) {
+    if (orderList == null || orderList.isEmpty()) {
       collation = RelCollations.EMPTY;
     } else {
       try {
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java b/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java
index a852bdb3a..e77d8e929 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/CorrelateProjectExtractor.java
@@ -95,7 +95,7 @@ public CorrelateProjectExtractor(RelBuilderFactory factory) {
     Set<RexNode> callsWithCorrelationInRight =
         findCorrelationDependentCalls(correlate.getCorrelationId(), right);
     boolean isTrivialCorrelation =
-        callsWithCorrelationInRight.stream().allMatch(exp -> exp instanceof RexFieldAccess);
+        callsWithCorrelationInRight.stream().allMatch(RexFieldAccess.class::isInstance);
     // Early exit condition
     if (isTrivialCorrelation) {
       if (correlate.getLeft().equals(left) && correlate.getRight().equals(right)) {
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java b/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
index 0781a4c09..d720761ae 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/RelDecorrelator.java
@@ -93,6 +93,7 @@
 import org.apache.calcite.util.mapping.Mappings;
 import org.apache.calcite.util.trace.CalciteTrace;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedMap;
@@ -110,7 +111,6 @@
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -225,9 +225,7 @@ public static RelNode decorrelateQuery(RelNode rootRel, RelBuilder relBuilder) {
     }
 
     // Re-propagate the hints.
-    newRootRel = RelOptUtil.propagateRelHints(newRootRel, true);
-
-    return newRootRel;
+    return RelOptUtil.propagateRelHints(newRootRel, true);
   }
 
   private void setCurrent(@Nullable RelNode root, @Nullable Correlate corRel) {
@@ -287,16 +285,14 @@ protected RelNode decorrelate(RelNode root) {
     root = planner.findBestExp();
     if (SQL2REL_LOGGER.isDebugEnabled()) {
       SQL2REL_LOGGER.debug(
-          "Plan before extracting correlated computations:\n"
-  + RelOptUtil.toString(root));
+          "Plan before extracting correlated computations:\n{}", RelOptUtil.toString(root));
     }
     root = root.accept(new CorrelateProjectExtractor(f));
     // Necessary to update cm (CorrelMap) since CorrelateProjectExtractor above may modify the plan
     this.cm = new CorelMapBuilder().build(root);
     if (SQL2REL_LOGGER.isDebugEnabled()) {
       SQL2REL_LOGGER.debug(
-          "Plan after extracting correlated computations:\n"
-  + RelOptUtil.toString(root));
+          "Plan after extracting correlated computations:\n{}", RelOptUtil.toString(root));
     }
     // Perform decorrelation.
     map.clear();
@@ -400,7 +396,7 @@ protected RexNode removeCorrelationExpr(
   public @Nullable Frame decorrelateRel(RelNode rel, boolean isCorVarDefined) {
     RelNode newRel = rel.copy(rel.getTraitSet(), rel.getInputs());
 
-    if (rel.getInputs().size() > 0) {
+    if (!rel.getInputs().isEmpty()) {
       List<RelNode> oldInputs = rel.getInputs();
       List<RelNode> newInputs = new ArrayList<>();
       for (int i = 0; i < oldInputs.size(); ++i) {
@@ -1184,7 +1180,7 @@ private static boolean isWidening(RelDataType type, RelDataType type1) {
       return null;
     }
 
-    assert rel.getRequiredColumns().cardinality() <= rightFrame.corDefOutputs.keySet().size();
+    assert rel.getRequiredColumns().cardinality() <= rightFrame.corDefOutputs.size();
 
     // Change correlator rel into a join.
     // Join all the correlated variables produced by this correlator rel
@@ -1980,7 +1976,7 @@ static RemoveCorrelationForScalarProjectRuleConfig config(
         right = right.stripped();
 
         // check filter input contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2040,7 +2036,7 @@ static RemoveCorrelationForScalarProjectRuleConfig config(
         nullIndicatorPos = left.getRowType().getFieldCount() + rightJoinKeys.get(0).getIndex();
       } else if (d.cm.mapRefRelToCorRef.containsKey(project)) {
         // check filter input contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2189,7 +2185,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
       for (AggregateCall aggCall : aggCalls) {
         ++k;
         if ((aggCall.getAggregation() instanceof SqlCountAggFunction)
-            && (aggCall.getArgList().size() == 0)) {
+            && aggCall.getArgList().isEmpty()) {
           isCountStar.add(k);
         }
       }
@@ -2206,7 +2202,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
         right = right.stripped();
 
         // check filter input contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2302,7 +2298,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
         joinCond = d.removeCorrelationExpr(filter.getCondition(), false);
       } else if (d.cm.mapRefRelToCorRef.containsKey(aggInputProject)) {
         // check rightInput contains no correlation
-        if (RelOptUtil.getVariablesUsed(right).size() > 0) {
+        if (!RelOptUtil.getVariablesUsed(right).isEmpty()) {
           return;
         }
 
@@ -2422,7 +2418,7 @@ static RemoveCorrelationForScalarAggregateRuleConfig config(
         if (isCountStar.contains(k)) {
           // this is a count(*), transform it to count(nullIndicator)
           // the null indicator is located at the end
-          argList = Collections.singletonList(nullIndicatorPos);
+          argList = ImmutableList.of(nullIndicatorPos);
         } else {
           argList = new ArrayList<>();
 
@@ -2753,7 +2749,7 @@ private CorelMap(
         Map<RexFieldAccess, CorRef> mapFieldAccessToCorRef) {
       this.mapRefRelToCorRef = mapRefRelToCorRef;
       this.mapCorToCorRel = mapCorToCorRel;
-      this.mapFieldAccessToCorRef = ImmutableMap.copyOf(mapFieldAccessToCorRef);
+      this.mapFieldAccessToCorRef = mapFieldAccessToCorRef;
     }
 
     @Override public String toString() {
@@ -2950,6 +2946,6 @@ protected RelDecorrelator getVisitor() {
 
   /** Returns the rules applied on the rel after decorrelation, never null. */
   protected Collection<RelOptRule> getPostDecorrelateRules() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java b/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
index 671a210eb..cbe565540 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java
@@ -72,17 +72,19 @@
 import org.apache.calcite.util.mapping.Mappings;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.math.BigDecimal;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Transformer that walks over a tree of relational expressions, replacing each {@link RelNode} with
  * a 'slimmed down' relational expression that projects only the columns required by its consumer.
@@ -162,11 +164,9 @@ public RelFieldTrimmer(
   public RelNode trim(RelNode root) {
     final int fieldCount = root.getRowType().getFieldCount();
     final ImmutableBitSet fieldsUsed = ImmutableBitSet.range(fieldCount);
-    final Set<RelDataTypeField> extraFields = Collections.emptySet();
+    final Set<RelDataTypeField> extraFields = ImmutableSet.of();
     final TrimResult trimResult = dispatchTrimFields(root, fieldsUsed, extraFields);
-    if (!trimResult.right.isIdentity()) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(trimResult.right.isIdentity());
     if (SqlToRelConverter.SQL2REL_LOGGER.isDebugEnabled()) {
       SqlToRelConverter.SQL2REL_LOGGER.debug(
           RelOptUtil.dumpPlan(
@@ -352,13 +352,11 @@ public TrimResult trimFields(
     for (RelNode input : rel.getInputs()) {
       ImmutableBitSet inputFieldsUsed = ImmutableBitSet.range(input.getRowType().getFieldCount());
       TrimResult trimResult = dispatchTrimFields(input, inputFieldsUsed, extraFields);
-      if (!trimResult.right.isIdentity()) {
-        throw new IllegalArgumentException(
-            "Expected identity mapping after processing RelNode "
-                + input
-                + "; but got "
-                + trimResult.right);
-      }
+      checkArgument(
+          trimResult.right.isIdentity(),
+          "Expected identity mapping after processing RelNode %s; but got %s",
+          input,
+          trimResult.right);
       newInputs.add(trimResult.left);
     }
     RelNode newRel = rel.copy(rel.getTraitSet(), newInputs);
@@ -605,7 +603,7 @@ public TrimResult trimFields(
     }
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     TrimResult trimResult = trimChild(sort, input, inputFieldsUsed.build(), inputExtraFields);
     RelNode newInput = trimResult.left;
     final Mapping inputMapping = trimResult.right;
@@ -641,7 +639,7 @@ public TrimResult trimFields(
     }
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     final TrimResult trimResult =
         trimChild(exchange, input, inputFieldsUsed.build(), inputExtraFields);
     final RelNode newInput = trimResult.left;
@@ -679,7 +677,7 @@ public TrimResult trimFields(
     }
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     TrimResult trimResult =
         trimChild(sortExchange, input, inputFieldsUsed.build(), inputExtraFields);
     RelNode newInput = trimResult.left;
@@ -760,7 +758,7 @@ public TrimResult trimFields(
       // on-demand fields.
       Set<RelDataTypeField> inputExtraFields =
           RelDataTypeImpl.extra(inputRowType) == null
-              ? Collections.emptySet()
+              ? ImmutableSet.of()
               : combinedInputExtraFields;
       inputExtraFieldCounts.add(inputExtraFields.size());
       TrimResult trimResult = trimChild(join, input, inputFieldsUsed.build(), inputExtraFields);
@@ -956,7 +954,7 @@ public TrimResult trimFields(
 
     // Create input with trimmed columns.
     final RelNode input = aggregate.getInput();
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     final TrimResult trimResult =
         trimChild(aggregate, input, inputFieldsUsed.build(), inputExtraFields);
     final RelNode newInput = trimResult.left;
@@ -1042,7 +1040,7 @@ public TrimResult trimFields(
     final ImmutableBitSet inputFieldsUsed = ImmutableBitSet.range(inputFieldCount);
 
     // Create input with trimmed columns.
-    final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+    final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
     TrimResult trimResult = trimChild(modifier, input, inputFieldsUsed, inputExtraFields);
     RelNode newInput = trimResult.left;
     final Mapping inputMapping = trimResult.right;
@@ -1054,7 +1052,7 @@ public TrimResult trimFields(
 
     LogicalTableModify newModifier = modifier;
     if (newInput != input) {
-      newModifier = modifier.copy(modifier.getTraitSet(), Collections.singletonList(newInput));
+      newModifier = modifier.copy(modifier.getTraitSet(), ImmutableList.of(newInput));
     }
     assert newModifier.getClass() == modifier.getClass();
 
@@ -1080,7 +1078,7 @@ public TrimResult trimFields(
       ImmutableBitSet inputFieldsUsed = ImmutableBitSet.range(inputFieldCount);
 
       // Create input with trimmed columns.
-      final Set<RelDataTypeField> inputExtraFields = Collections.emptySet();
+      final Set<RelDataTypeField> inputExtraFields = ImmutableSet.of();
       TrimResult trimResult = trimChildRestore(tabFun, input, inputFieldsUsed, inputExtraFields);
       assert trimResult.right.isIdentity();
       newInputs.add(trimResult.left);
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java b/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
index a04cbd6a6..198f0dcfa 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/RelStructuredTypeFlattener.java
@@ -80,7 +80,6 @@
 import org.apache.calcite.util.Util;
 import org.apache.calcite.util.mapping.Mappings;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.SortedSetMultimap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -97,6 +96,8 @@
 import java.util.SortedMap;
 import java.util.SortedSet;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 // TODO jvs 10-Feb-2005:  factor out generic rewrite helper, with the
@@ -194,7 +195,7 @@ private RelNode getCurrentRelOrThrow() {
   }
 
   public void updateRelInMap(SortedSetMultimap<RelNode, CorrelationId> mapRefRelToCorVar) {
-    for (RelNode rel : Lists.newArrayList(mapRefRelToCorVar.keySet())) {
+    for (RelNode rel : new ArrayList<>(mapRefRelToCorVar.keySet())) {
       if (oldToNewRelMap.containsKey(rel)) {
         SortedSet<CorrelationId> corVarSet = mapRefRelToCorVar.removeAll(rel);
         mapRefRelToCorVar.putAll(oldToNewRelMap.get(rel), corVarSet);
@@ -237,11 +238,11 @@ private RelNode tryRestructure(RelNode root, RelNode flattened) {
       // client.
       RelNode restructured =
           relBuilder.push(flattened).projectNamed(structuringExps, resultFieldNames, true).build();
-      restructured = RelOptUtil.copyRelHints(flattened, restructured);
+      return RelOptUtil.copyRelHints(flattened, restructured);
       // REVIEW jvs 23-Mar-2005:  How do we make sure that this
       // implementation stays in Java?  Fennel can't handle
       // structured types.
-      return restructured;
+
     } else {
       return flattened;
     }
@@ -846,7 +847,7 @@ private class RewriteRelVisitor extends RelVisitor {
           dispatcher.invokeVisitor(RelStructuredTypeFlattener.this, currentRel, visitMethodName);
       currentRel = null;
       if (!found) {
-        if (p.getInputs().size() == 0) {
+        if (p.getInputs().isEmpty()) {
           // for leaves, it's usually safe to assume that
           // no transformation is required
           rewriteGeneric(p);
@@ -954,16 +955,15 @@ private RelDataType removeDistinct(RelDataType type) {
           int oldOrdinal = ((RexInputRef) firstOp).getIndex();
           int newInnerOrdinal = getNewInnerOrdinal(firstOp, literalString);
           Ord<RelDataType> newField = getNewFieldForOldInput(oldOrdinal, newInnerOrdinal);
-          RexInputRef newRef = rexBuilder.makeInputRef(newField.e, newField.i);
-          return newRef;
+          return rexBuilder.makeInputRef(newField.e, newField.i);
+
         } else {
           RexNode newFirstOp = firstOp.accept(this);
           if (newFirstOp instanceof RexInputRef) {
             int newRefOrdinal =
                 ((RexInputRef) newFirstOp).getIndex() + getNewInnerOrdinal(firstOp, literalString);
             RelDataTypeField newField = getNewInputFieldByNewOrdinal(newRefOrdinal);
-            RexInputRef newRef = rexBuilder.makeInputRef(newField.getType(), newRefOrdinal);
-            return newRef;
+            return rexBuilder.makeInputRef(newField.getType(), newRefOrdinal);
           }
         }
       }
@@ -996,9 +996,7 @@ private RexNode flattenComparison(
       final PairList<RexNode, String> flattenedExps = PairList.of();
       flattenProjections(this, exprs, null, "", flattenedExps);
       int n = flattenedExps.size() / 2;
-      if (n == 0) {
-        throw new IllegalArgumentException("exprs must be non-empty");
-      }
+      checkArgument(n != 0, "exprs must be non-empty");
       boolean negate = false;
       if (op.getKind() == SqlKind.NOT_EQUALS) {
         negate = true;
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
index 09ca6019c..4514d2995 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java
@@ -645,11 +645,11 @@ public static boolean isOrdered(SqlNode query) {
     switch (query.getKind()) {
       case SELECT:
         SqlNodeList orderList = ((SqlSelect) query).getOrderList();
-        return orderList != null && orderList.size() > 0;
+        return orderList != null && !orderList.isEmpty();
       case WITH:
         return isOrdered(((SqlWith) query).body);
       case ORDER_BY:
-        return ((SqlOrderBy) query).orderList.size() > 0;
+        return !((SqlOrderBy) query).orderList.isEmpty();
       default:
         return false;
     }
@@ -899,7 +899,7 @@ protected void convertOrder(
     // we can't represent the real collation.
     //
     // If it is the top node, use the real collation, but don't trim fields.
-    if (orderExprList.size() > 0 && !bb.top) {
+    if (!orderExprList.isEmpty() && !bb.top) {
       final List<RexNode> exprs = new ArrayList<>();
       final RelDataType rowType = bb.root().getRowType();
       final int fieldCount = rowType.getFieldCount() - orderExprList.size();
@@ -1595,7 +1595,7 @@ public RelNode convertToSingleValueSubq(SqlNode query, RelNode plan) {
       SqlNodeList selectList = select.getSelectList();
       SqlNodeList groupList = select.getGroup();
 
-      if ((selectList.size() == 1) && ((groupList == null) || (groupList.size() == 0))) {
+      if ((selectList.size() == 1) && ((groupList == null) || groupList.isEmpty())) {
         SqlNode selectExpr = selectList.get(0);
         if (selectExpr instanceof SqlCall) {
           SqlCall selectExprCall = (SqlCall) selectExpr;
@@ -1887,7 +1887,7 @@ private RexLiteral convertLiteral(SqlLiteral sqlLiteral, Blackboard bb, RelDataT
   }
 
   private static boolean isRowConstructor(SqlNode node) {
-    if (!(node.getKind() == SqlKind.ROW)) {
+    if (node.getKind() != SqlKind.ROW) {
       return false;
     }
     SqlCall call = (SqlCall) node;
@@ -2031,7 +2031,7 @@ private void findSubQueries(
    * @return Converted expression
    */
   public RexNode convertExpression(SqlNode node) {
-    Map<String, RelDataType> nameToTypeMap = Collections.emptyMap();
+    Map<String, RelDataType> nameToTypeMap = ImmutableMap.of();
     final ParameterScope scope = new ParameterScope((SqlValidatorImpl) validator(), nameToTypeMap);
     final Blackboard bb = createBlackboard(scope, null, false);
     replaceSubQueries(bb, node, RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);
@@ -2105,7 +2105,7 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
         // ROW_NUMBER() expects specific kind of framing.
         rows = true;
       }
-    } else if (orderList.size() == 0) {
+    } else if (orderList.isEmpty()) {
       // Without ORDER BY, there must be no bracketing.
       sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);
       sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);
@@ -2125,7 +2125,7 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
     }
     final RexNode lowerBound = bb.convertExpression(requireNonNull(sqlLowerBound, "sqlLowerBound"));
     final RexNode upperBound = bb.convertExpression(requireNonNull(sqlUpperBound, "sqlUpperBound"));
-    if (orderList.size() == 0 && !rows) {
+    if (orderList.isEmpty() && !rows) {
       // A logical range requires an ORDER BY clause. Use the implicit
       // ordering of this relation. There must be one, otherwise it would
       // have failed validation.
@@ -2175,7 +2175,7 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {
   }
 
   protected void convertFrom(Blackboard bb, @Nullable SqlNode from) {
-    convertFrom(bb, from, Collections.emptyList());
+    convertFrom(bb, from, ImmutableList.of());
   }
 
   /**
@@ -2334,7 +2334,7 @@ private void convertUnnest(Blackboard bb, SqlCall call, @Nullable List<String> f
           final String alias = SqlValidatorUtil.alias(node, i);
           exprs.add(relBuilder.alias(e, alias));
         });
-    RelNode child = (null != bb.root) ? bb.root : LogicalValues.createOneRow(cluster);
+    RelNode child = bb.root != null ? bb.root : LogicalValues.createOneRow(cluster);
     RelNode uncollect;
     if (validator().config().conformance().allowAliasUnnestItems()) {
       uncollect =
@@ -2350,7 +2350,7 @@ private void convertUnnest(Blackboard bb, SqlCall call, @Nullable List<String> f
           relBuilder
               .push(child)
               .project(exprs)
-              .uncollect(Collections.emptyList(), operator.withOrdinality)
+              .uncollect(ImmutableList.of(), operator.withOrdinality)
               .let(r -> fieldNames == null ? r : r.rename(fieldNames))
               .build();
     }
@@ -2543,7 +2543,7 @@ protected void convertPivot(Blackboard bb, SqlPivot pivot) {
     // 3. Gather columns used as arguments to aggregate functions.
     pivotBb.agg = aggConverter;
     final List<@Nullable String> aggAliasList = new ArrayList<>();
-    assert aggConverter.aggCalls.size() == 0;
+    assert aggConverter.aggCalls.isEmpty();
     pivot.forEachAgg(
         (alias, call) -> {
           call.accept(aggConverter);
@@ -2661,7 +2661,7 @@ private void convertIdentifier(
     RelOptTable table =
         SqlValidatorUtil.getRelOptTable(fromNamespace, catalogReader, datasetName, usedDataset);
     assert table != null : "getRelOptTable returned null for " + fromNamespace;
-    if (extendedColumns != null && extendedColumns.size() > 0) {
+    if (extendedColumns != null && !extendedColumns.isEmpty()) {
       final SqlValidatorTable validatorTable = table.unwrapOrThrow(SqlValidatorTable.class);
       final List<RelDataTypeField> extendedFields =
           SqlValidatorUtil.getExtendedColumns(validator(), validatorTable, extendedColumns);
@@ -3007,7 +3007,7 @@ private boolean isSubQueryNonCorrelated(RelNode subq, Blackboard bb) {
    * @return List of system fields
    */
   protected List<RelDataTypeField> getSystemFields() {
-    return Collections.emptyList();
+    return ImmutableList.of();
   }
 
   private void convertJoin(Blackboard bb, SqlJoin join) {
@@ -3072,8 +3072,7 @@ private RexNode convertUsingCondition(
       SqlJoin join, SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace) {
     final SqlNodeList list =
         requireNonNull((SqlNodeList) join.getCondition(), () -> "getCondition for join " + join);
-    return convertUsing(
-        leftNamespace, rightNamespace, ImmutableList.copyOf(SqlIdentifier.simpleNames(list)));
+    return convertUsing(leftNamespace, rightNamespace, SqlIdentifier.simpleNames(list));
   }
 
   /**
@@ -3116,7 +3115,7 @@ private Pair<RexNode, RelNode> convertOnCondition(
     bb.setRoot(ImmutableList.of(leftRel, rightRel));
     replaceSubQueries(bb, condition, RelOptUtil.Logic.UNKNOWN_AS_FALSE);
     final RelNode newRightRel =
-        bb.root == null || bb.registered.size() == 0 ? rightRel : bb.reRegister(rightRel);
+        bb.root == null || bb.registered.isEmpty() ? rightRel : bb.reRegister(rightRel);
     bb.setRoot(ImmutableList.of(leftRel, newRightRel));
     RexNode conditionExp = bb.convertExpression(condition);
     if (conditionExp instanceof RexInputRef && newRightRel != rightRel) {
@@ -3939,7 +3938,7 @@ protected void collectInsertTargets(
         RelDataTypeField field =
             SqlValidatorUtil.getTargetField(
                 tableRowType, typeFactory, id, catalogReader, targetTable);
-        assert field != null : "column " + id.toString() + " not found";
+        assert field != null : "column " + id + " not found";
         targetColumnNames.add(field.getName());
       }
     }
@@ -4048,7 +4047,7 @@ private RelNode convertMerge(SqlMerge call) {
         RelDataTypeField field =
             SqlValidatorUtil.getTargetField(
                 targetRowType, typeFactory, id, catalogReader, targetTable);
-        assert field != null : "column " + id.toString() + " not found";
+        assert field != null : "column " + id + " not found";
         targetColumnNameList.add(field.getName());
       }
     }
@@ -4231,7 +4230,7 @@ private RelNode convertMultisets(final List<SqlNode> operands, Blackboard bb) {
           final SqlNodeList list = new SqlNodeList(call.getOperandList(), call.getParserPosition());
           CollectNamespace nss = getNamespaceOrNull(call);
           Blackboard usedBb;
-          if (null != nss) {
+          if (nss != null) {
             usedBb = createBlackboard(nss.getScope(), null, false);
           } else {
             usedBb =
@@ -4264,7 +4263,7 @@ private RelNode convertMultisets(final List<SqlNode> operands, Blackboard bb) {
           continue;
       }
 
-      if (lastList.size() > 0) {
+      if (!lastList.isEmpty()) {
         joinList.add(lastList);
       }
       lastList = new ArrayList<>();
@@ -4274,7 +4273,7 @@ private RelNode convertMultisets(final List<SqlNode> operands, Blackboard bb) {
       joinList.add(relBuilder.build());
     }
 
-    if (joinList.size() == 0) {
+    if (joinList.isEmpty()) {
       joinList.add(lastList);
     }
 
@@ -4569,7 +4568,7 @@ private void convertValuesImpl(
           rowConstructor.getOperandList(),
           (operand, i) ->
               exps.add(tmpBb.convertExpression(operand), SqlValidatorUtil.alias(operand, i)));
-      RelNode in = (null == tmpBb.root) ? LogicalValues.createOneRow(cluster) : tmpBb.root;
+      RelNode in = tmpBb.root == null ? LogicalValues.createOneRow(cluster) : tmpBb.root;
       relBuilder.push(in).project(exps.leftList(), exps.rightList());
     }
 
@@ -4803,7 +4802,7 @@ public RelNode reRegister(RelNode root) {
      *     are not leaves, but set expressions are.
      */
     public void setRoot(RelNode root, boolean leaf) {
-      setRoot(Collections.singletonList(root), root, root instanceof LogicalJoin);
+      setRoot(ImmutableList.of(root), root, root instanceof LogicalJoin);
       if (leaf) {
         leaves.put(root, root.getRowType().getFieldCount());
       }
@@ -5752,7 +5751,7 @@ private static class AggregateFinder extends SqlBasicVisitor<Void> {
         final SqlNode aggCall = call.getOperandList().get(0);
         final SqlNodeList distinctList = (SqlNodeList) call.getOperandList().get(1);
         list.add(aggCall);
-        distinctList.getList().forEach(this.distinctList::add);
+        this.distinctList.addAll(distinctList.getList());
         return null;
       }
 
@@ -5960,7 +5959,7 @@ private class NestedJsonFunctionRelRewriter extends RelShuttleImpl {
     @Override public RelNode visit(LogicalProject project) {
       final Set<Integer> jsonInputFields = findJsonInputs(project.getInput());
       final Set<Integer> requiredJsonFieldsFromParent =
-          stack.size() > 0 ? requiredJsonOutputFromParent(stack.getLast()) : Collections.emptySet();
+          !stack.isEmpty() ? requiredJsonOutputFromParent(stack.getLast()) : ImmutableSet.of();
 
       final List<RexNode> originalProjections = project.getProjects();
       final ImmutableList.Builder<RexNode> newProjections = ImmutableList.builder();
@@ -5984,7 +5983,7 @@ private class NestedJsonFunctionRelRewriter extends RelShuttleImpl {
 
     private Set<Integer> requiredJsonOutputFromParent(RelNode relNode) {
       if (!(relNode instanceof Aggregate)) {
-        return Collections.emptySet();
+        return ImmutableSet.of();
       }
       final Aggregate aggregate = (Aggregate) relNode;
       final List<AggregateCall> aggregateCalls = aggregate.getAggCallList();
@@ -6001,7 +6000,7 @@ private Set<Integer> requiredJsonOutputFromParent(RelNode relNode) {
 
     private Set<Integer> findJsonInputs(RelNode relNode) {
       if (!(relNode instanceof Aggregate)) {
-        return Collections.emptySet();
+        return ImmutableSet.of();
       }
       final Aggregate aggregate = (Aggregate) relNode;
       final List<AggregateCall> aggregateCalls = aggregate.getAggCallList();
diff --git a/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java b/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
index 56fe1ae18..f5aa8c89e 100644
--- a/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
+++ b/core/src/main/java/org/apache/calcite/sql2rel/StandardConvertletTable.java
@@ -643,7 +643,7 @@ protected RexNode convertCast(
       validator.setValidatedNodeType(left, type);
       return cx.convertExpression(left);
     }
-    if (null != dataType.getCollectionsTypeName()) {
+    if (dataType.getCollectionsTypeName() != null) {
       RelDataType argComponentType = arg.getType().getComponentType();
 
       // arg.getType() may be ANY
@@ -682,7 +682,7 @@ protected RexNode convertFloorCeil(SqlRexContext cx, SqlCall call) {
       RexNode rexInterval = cx.convertExpression(literal);
 
       final RexBuilder rexBuilder = cx.getRexBuilder();
-      RexNode zero = rexBuilder.makeExactLiteral(BigDecimal.valueOf(0));
+      RexNode zero = rexBuilder.makeExactLiteral(BigDecimal.ZERO);
       RexNode cond = ge(rexBuilder, rexInterval, zero);
 
       RexNode pad = rexBuilder.makeExactLiteral(val.subtract(BigDecimal.ONE));
diff --git a/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java b/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java
index 4c35c6951..dd050591c 100644
--- a/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java
+++ b/core/src/main/java/org/apache/calcite/statistic/MapSqlStatisticProvider.java
@@ -21,6 +21,7 @@
 import org.apache.calcite.plan.RelOptTable;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 
@@ -142,7 +143,7 @@ private static List<String> columnNames(RelOptTable table, List<Integer> columns
   private static class Initializer {
     final ImmutableMap.Builder<String, Double> cardinalityMapBuilder = ImmutableMap.builder();
     final ImmutableMultimap.Builder<String, ImmutableList<String>> keyMapBuilder =
-        ImmutableMultimap.builder();
+        ImmutableListMultimap.builder();
 
     Initializer put(String schema, String table, int count, Object... keys) {
       String qualifiedName = Arrays.asList(schema, table).toString();
diff --git a/core/src/main/java/org/apache/calcite/tools/Hoist.java b/core/src/main/java/org/apache/calcite/tools/Hoist.java
index a94b41249..03338fe7d 100644
--- a/core/src/main/java/org/apache/calcite/tools/Hoist.java
+++ b/core/src/main/java/org/apache/calcite/tools/Hoist.java
@@ -26,7 +26,6 @@
 import org.apache.calcite.sql.util.SqlShuttle;
 
 import com.google.common.base.Preconditions;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -169,7 +168,7 @@ public static class Hoisted {
 
     Hoisted(String originalSql, List<Variable> variables) {
       this.originalSql = originalSql;
-      this.variables = ImmutableList.copyOf(variables);
+      this.variables = variables;
     }
 
     @Override public String toString() {
diff --git a/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java b/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java
index 773f68cdf..76b03d448 100644
--- a/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java
+++ b/core/src/main/java/org/apache/calcite/tools/PigRelBuilder.java
@@ -35,6 +35,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /** Extension to {@link RelBuilder} for Pig relational operators. */
@@ -161,14 +163,10 @@ public PigRelBuilder group(
   }
 
   protected void validateGroupList(List<GroupKey> groupKeyList) {
-    if (groupKeyList.isEmpty()) {
-      throw new IllegalArgumentException("must have at least one group");
-    }
+    checkArgument(!groupKeyList.isEmpty(), "must have at least one group");
     final int groupCount = groupKeyList.get(0).groupKeyCount();
     for (GroupKey groupKey : groupKeyList) {
-      if (groupKey.groupKeyCount() != groupCount) {
-        throw new IllegalArgumentException("group key size mismatch");
-      }
+      checkArgument(groupKey.groupKeyCount() == groupCount, "group key size mismatch");
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/tools/RelBuilder.java b/core/src/main/java/org/apache/calcite/tools/RelBuilder.java
index dcaf658d6..3d4d7ab15 100644
--- a/core/src/main/java/org/apache/calcite/tools/RelBuilder.java
+++ b/core/src/main/java/org/apache/calcite/tools/RelBuilder.java
@@ -154,12 +154,15 @@
 import java.util.function.UnaryOperator;
 import java.util.stream.Collectors;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 import static org.apache.calcite.rel.rules.AggregateRemoveRule.canFlattenStatic;
 import static org.apache.calcite.sql.SqlKind.UNION;
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
 
 /**
  * Builder for relational expressions.
@@ -198,7 +201,7 @@ protected RelBuilder(
     final RexExecutor executor =
         context
             .maybeUnwrap(RexExecutor.class)
-            .orElse(Util.first(cluster.getPlanner().getExecutor(), RexUtil.EXECUTOR));
+            .orElseGet(() -> Util.first(cluster.getPlanner().getExecutor(), RexUtil.EXECUTOR));
     final RelOptPredicateList predicates = RelOptPredicateList.EMPTY;
     this.simplifier = new RexSimplify(cluster.getRexBuilder(), predicates, executor);
   }
@@ -294,9 +297,7 @@ public <R> R let(Function<RelBuilder, R> consumer) {
    * RelNodes on the stack.
    */
   @Override public String toString() {
-    return stack.stream()
-        .map(frame -> RelOptUtil.toString(frame.rel))
-        .collect(Collectors.joining(""));
+    return stack.stream().map(frame -> RelOptUtil.toString(frame.rel)).collect(joining());
   }
 
   /** Returns the type factory. */
@@ -578,13 +579,11 @@ private RexNode field(int inputCount, int inputOrdinal, int fieldOrdinal, boolea
     final Frame frame = peek_(inputCount, inputOrdinal);
     final RelNode input = frame.rel;
     final RelDataType rowType = input.getRowType();
-    if (fieldOrdinal < 0 || fieldOrdinal > rowType.getFieldCount()) {
-      throw new IllegalArgumentException(
-          "field ordinal ["
-              + fieldOrdinal
-              + "] out of range; input fields are: "
-              + rowType.getFieldNames());
-    }
+    checkArgument(
+        fieldOrdinal >= 0 && fieldOrdinal <= rowType.getFieldCount(),
+        "field ordinal [%s] out of range; input fields are: %s",
+        fieldOrdinal,
+        rowType.getFieldNames());
     final RelDataTypeField field = rowType.getFieldList().get(fieldOrdinal);
     final int offset = inputOffset(inputCount, inputOrdinal);
     final RexInputRef ref =
@@ -1399,14 +1398,12 @@ public GroupKey groupKey(
       boolean indicator,
       @Nullable ImmutableList<ImmutableBitSet> groupSets) {
     Aggregate.checkIndicator(indicator);
-    return groupKey_(
-        groupSet, groupSets == null ? ImmutableList.of(groupSet) : ImmutableList.copyOf(groupSets));
+    return groupKey_(groupSet, groupSets == null ? ImmutableList.of(groupSet) : groupSets.asList());
   }
 
   private GroupKey groupKey_(ImmutableBitSet groupSet, ImmutableList<ImmutableBitSet> groupSets) {
-    if (groupSet.length() > peek().getRowType().getFieldCount()) {
-      throw new IllegalArgumentException("out of bounds: " + groupSet);
-    }
+    checkArgument(
+        groupSet.length() <= peek().getRowType().getFieldCount(), "out of bounds: %s", groupSet);
     requireNonNull(groupSets, "groupSets");
     final ImmutableList<RexNode> nodes = fields(groupSet);
     return groupKey_(nodes, Util.transform(groupSets, this::fields));
@@ -1887,9 +1884,7 @@ public RelBuilder snapshot(RexNode period) {
    * @return RexCall to CURSOR function
    */
   public RexNode cursor(int inputCount, int ordinal) {
-    if (inputCount <= ordinal || ordinal < 0) {
-      throw new IllegalArgumentException("bad input count or ordinal");
-    }
+    checkArgument(inputCount > ordinal && ordinal >= 0, "bad input count or ordinal");
     // Refer to the "ordinal"th input as if it were a field
     // (because that's how things are laid out inside a TableFunctionScan)
     final RelNode input = peek(inputCount, ordinal);
@@ -1905,9 +1900,7 @@ public RelBuilder functionScan(SqlOperator operator, int inputCount, RexNode...
   /** Creates a {@link TableFunctionScan}. */
   public RelBuilder functionScan(
       SqlOperator operator, int inputCount, Iterable<? extends RexNode> operands) {
-    if (inputCount < 0 || inputCount > stack.size()) {
-      throw new IllegalArgumentException("bad input count");
-    }
+    checkArgument(inputCount >= 0 && inputCount <= stack.size(), "bad input count");
 
     // Gets inputs.
     final List<RelNode> inputs = new ArrayList<>();
@@ -2086,13 +2079,11 @@ public RelBuilder projectExcept(Iterable<RexNode> expressions) {
     List<RexNode> allExpressions = new ArrayList<>(fields());
     Set<RexNode> excludeExpressions = new HashSet<>();
     for (RexNode excludeExp : expressions) {
-      if (!excludeExpressions.add(excludeExp)) {
-        throw new IllegalArgumentException(
-            "Input list contains duplicates. Expression " + excludeExp + " exists multiple times.");
-      }
-      if (!allExpressions.remove(excludeExp)) {
-        throw new IllegalArgumentException("Expression " + excludeExp.toString() + " not found.");
-      }
+      checkArgument(
+          excludeExpressions.add(excludeExp),
+          "Input list contains duplicates. Expression %s exists multiple times.",
+          excludeExp);
+      checkArgument(allExpressions.remove(excludeExp), "Expression %s not found.", excludeExp);
     }
     return this.project(allExpressions);
   }
@@ -2198,7 +2189,7 @@ private RelBuilder project_(
 
     // Simplify expressions.
     if (config.simplify()) {
-      nodeList.replaceAll(e -> simplifier.simplifyPreservingType(e));
+      nodeList.replaceAll(simplifier::simplifyPreservingType);
     }
 
     // Replace null names with generated aliases.
@@ -2261,7 +2252,7 @@ private RelBuilder project_(
     // N times.
     final int rowCount;
     if (config.simplifyValues()
-        && nodeList.stream().allMatch(e -> e instanceof RexLiteral)
+        && nodeList.stream().allMatch(RexLiteral.class::isInstance)
         && (rowCount = fixedRowCount(frame)) >= 0) {
       RelNode unused = build();
       final RelDataTypeFactory.Builder typeBuilder = getTypeFactory().builder();
@@ -2276,11 +2267,7 @@ private RelBuilder project_(
 
     final RelNode project =
         struct.projectFactory.createProject(
-            frame.rel,
-            ImmutableList.copyOf(hints),
-            ImmutableList.copyOf(nodeList),
-            fieldNameList,
-            variables);
+            frame.rel, ImmutableList.copyOf(hints), nodeList, fieldNameList, variables);
     stack.pop();
     stack.push(new Frame(project, fields.build()));
     return this;
@@ -2548,10 +2535,10 @@ private RelBuilder aggregate_(GroupKeyImpl groupKey, final ImmutableList<AggCall
       for (ImmutableList<RexNode> nodeList : groupKey.nodeLists) {
         final ImmutableBitSet groupSet2 =
             ImmutableBitSet.of(registrar.registerExpressions(nodeList));
-        if (!groupSet.contains(groupSet2)) {
-          throw new IllegalArgumentException(
-              "group set element " + nodeList + " must be a subset of group key");
-        }
+        checkArgument(
+            groupSet.contains(groupSet2),
+            "group set element %s must be a subset of group key",
+            nodeList);
         groupSetList.add(groupSet2);
       }
       final ImmutableSortedMultiset<ImmutableBitSet> groupSetMultiset =
@@ -2560,13 +2547,11 @@ private RelBuilder aggregate_(GroupKeyImpl groupKey, final ImmutableList<AggCall
           || !ImmutableBitSet.ORDERING.isStrictlyOrdered(groupSetMultiset)) {
         return rewriteAggregateWithDuplicateGroupSets(groupSet, groupSetMultiset, aggCalls);
       }
-      groupSets = ImmutableList.copyOf(groupSetMultiset.elementSet());
-      if (registrar.extraNodes.size() > sizeBefore) {
-        throw new IllegalArgumentException(
-            "group sets contained expressions "
-                + "not in group key: "
-                + Util.skip(registrar.extraNodes, sizeBefore));
-      }
+      groupSets = groupSetMultiset.elementSet().asList();
+      checkArgument(
+          registrar.extraNodes.size() <= sizeBefore,
+          "group sets contained expressions not in group key: %s",
+          Util.skip(registrar.extraNodes, sizeBefore));
     } else {
       groupSets = ImmutableList.of(groupSet);
     }
@@ -2874,7 +2859,7 @@ private RelBuilder setOp(boolean all, SqlKind kind, int n) {
 
     if (config.simplifyValues()
         && kind == UNION
-        && inputs.stream().allMatch(r -> r instanceof Values)) {
+        && inputs.stream().allMatch(Values.class::isInstance)) {
       List<RelDataType> inputTypes = Util.transform(inputs, RelNode::getRowType);
       RelDataType rowType = getTypeFactory().leastRestrictive(inputTypes);
       requireNonNull(rowType, () -> "leastRestrictive(" + inputTypes + ")");
@@ -3308,22 +3293,18 @@ public RelBuilder as(final String alias) {
    */
   public RelBuilder values(@Nullable String[] fieldNames, @Nullable Object... values) {
     requireNonNull(fieldNames, "fieldNames");
-    if (fieldNames.length == 0
-        || values.length % fieldNames.length != 0
-        || values.length < fieldNames.length) {
-      throw new IllegalArgumentException("Value count must be a positive multiple of field count");
-    }
+    checkArgument(
+        fieldNames.length != 0
+            && values.length % fieldNames.length == 0
+            && values.length >= fieldNames.length,
+        "Value count must be a positive multiple of field count");
     final int rowCount = values.length / fieldNames.length;
     for (Ord<@Nullable String> fieldName : Ord.zip(fieldNames)) {
-      if (allNull(values, fieldName.i, fieldNames.length)) {
-        throw new IllegalArgumentException(
-            "All values of field '"
-                + fieldName.e
-                + "' (field index "
-                + fieldName.i
-                + ")"
-                + " are null; cannot deduce type");
-      }
+      checkArgument(
+          !allNull(values, fieldName.i, fieldNames.length),
+          "All values of field '%s' (field index %s) are null; cannot deduce type",
+          fieldName.e,
+          fieldName.i);
     }
     final ImmutableList<ImmutableList<RexLiteral>> tupleList = tupleList(fieldNames.length, values);
     assert tupleList.size() == rowCount;
@@ -3414,8 +3395,7 @@ public RelBuilder empty() {
   public RelBuilder values(RelDataType rowType, Object... columnValues) {
     final ImmutableList<ImmutableList<RexLiteral>> tupleList =
         tupleList(rowType.getFieldCount(), columnValues);
-    RelNode values =
-        struct.valuesFactory.createValues(cluster, rowType, ImmutableList.copyOf(tupleList));
+    RelNode values = struct.valuesFactory.createValues(cluster, rowType, tupleList.asList());
     push(values);
     return this;
   }
@@ -3549,14 +3529,14 @@ public RelBuilder sortLimit(
       @Nullable RexNode fetchNode,
       Iterable<? extends RexNode> nodes) {
     if (offsetNode != null) {
-      if (!(offsetNode instanceof RexLiteral || offsetNode instanceof RexDynamicParam)) {
-        throw new IllegalArgumentException("OFFSET node must be RexLiteral or RexDynamicParam");
-      }
+      checkArgument(
+          (offsetNode instanceof RexLiteral || offsetNode instanceof RexDynamicParam),
+          "OFFSET node must be RexLiteral or RexDynamicParam");
     }
     if (fetchNode != null) {
-      if (!(fetchNode instanceof RexLiteral || fetchNode instanceof RexDynamicParam)) {
-        throw new IllegalArgumentException("FETCH node must be RexLiteral or RexDynamicParam");
-      }
+      checkArgument(
+          (fetchNode instanceof RexLiteral || fetchNode instanceof RexDynamicParam),
+          "FETCH node must be RexLiteral or RexDynamicParam");
     }
 
     final Registrar registrar = new Registrar(fields(), ImmutableList.of());
@@ -3857,10 +3837,11 @@ public RelBuilder pivot(
         values,
         (alias, expressions) -> {
           final List<RexNode> expressionList = ImmutableList.copyOf(expressions);
-          if (expressionList.size() != axisList.size()) {
-            throw new IllegalArgumentException(
-                "value count must match axis count [" + expressionList + "], [" + axisList + "]");
-          }
+          checkArgument(
+              expressionList.size() == axisList.size(),
+              "value count must match axis count [%s], [%s]",
+              expressionList,
+              axisList);
           aggCalls.forEach(
               aggCall -> {
                 final String alias2 = alias + "_" + ((AggCallPlus) aggCall).alias();
@@ -3946,22 +3927,16 @@ public RelBuilder unpivot(
     // Check that counts match.
     map.forEach(
         (valueList, inputMeasureList) -> {
-          if (inputMeasureList.size() != measureNameList.size()) {
-            throw new IllegalArgumentException(
-                "Number of measures ("
-                    + inputMeasureList.size()
-                    + ") must match number of measure names ("
-                    + measureNameList.size()
-                    + ")");
-          }
-          if (valueList.size() != axisNameList.size()) {
-            throw new IllegalArgumentException(
-                "Number of axis values ("
-                    + valueList.size()
-                    + ") match match number of axis names ("
-                    + axisNameList.size()
-                    + ")");
-          }
+          checkArgument(
+              inputMeasureList.size() == measureNameList.size(),
+              "Number of measures (%s) must match number of measure names (%s)",
+              inputMeasureList.size(),
+              measureNameList.size());
+          checkArgument(
+              valueList.size() == axisNameList.size(),
+              "Number of axis values (%s) match match number of axis names (%s)",
+              valueList.size(),
+              axisNameList.size());
         });
 
     final RelDataType leftRowType = peek().getRowType();
@@ -3976,7 +3951,7 @@ public RelBuilder unpivot(
                 }));
 
     // Create "VALUES (('commission'), ('salary')) AS t (remuneration_type)"
-    values(ImmutableList.copyOf(map.leftList()), axisNameList);
+    values(map.leftList(), axisNameList);
 
     join(JoinRelType.INNER);
 
@@ -4253,10 +4228,10 @@ private boolean checkIfCorrelated(
       return true;
     }
     CorrelationId id = Iterables.getOnlyElement(variablesSet);
-    if (!RelOptUtil.notContainsCorrelation(leftNode, id, Litmus.IGNORE)) {
-      throw new IllegalArgumentException(
-          "variable " + id + " must not be used by left input to correlation");
-    }
+    checkArgument(
+        RelOptUtil.notContainsCorrelation(leftNode, id, Litmus.IGNORE),
+        "variable %s must not be used by left input to correlation",
+        id);
     switch (joinType) {
       case RIGHT:
       case FULL:
@@ -4319,15 +4294,15 @@ private class AggCallImpl implements AggCallPlus {
       if (distinct) {
         b.append("DISTINCT ");
       }
-      if (preOperands.size() > 0) {
+      if (!preOperands.isEmpty()) {
         b.append(preOperands.get(0));
         for (int i = 1; i < preOperands.size(); i++) {
           b.append(", ");
           b.append(preOperands.get(i));
         }
-        b.append(operands.size() > 0 ? "; " : ";");
+        b.append(!operands.isEmpty() ? "; " : ";");
       }
-      if (operands.size() > 0) {
+      if (!operands.isEmpty()) {
         b.append(operands.get(0));
         for (int i = 1; i < operands.size(); i++) {
           b.append(", ");
@@ -4375,12 +4350,9 @@ private class AggCallImpl implements AggCallPlus {
     @Override public AggregateCall aggregateCall(Registrar registrar, ImmutableBitSet groupSet, RelNode r) {
       List<Integer> args = registrar.registerExpressions(this.operands);
       final int filterArg = this.filter == null ? -1 : registrar.registerExpression(this.filter);
-      if (this.distinct && !this.aggFunction.isQuantifierAllowed()) {
-        throw new IllegalArgumentException("DISTINCT not allowed");
-      }
-      if (this.filter != null && !this.aggFunction.allowsFilter()) {
-        throw new IllegalArgumentException("FILTER not allowed");
-      }
+      checkArgument(
+          !this.distinct || this.aggFunction.isQuantifierAllowed(), "DISTINCT not allowed");
+      checkArgument(this.filter == null || this.aggFunction.allowsFilter(), "FILTER not allowed");
       final @Nullable ImmutableBitSet distinctKeys =
           this.distinctKeys == null
               ? null
@@ -4394,7 +4366,7 @@ private class AggCallImpl implements AggCallPlus {
                               orderKey,
                               RelFieldCollation.Direction.ASCENDING,
                               null,
-                              Collections.emptyList()))
+                              ImmutableList.of()))
                   .collect(Collectors.toList()));
       if (aggFunction instanceof SqlCountAggFunction && !distinct) {
         args = args.stream().filter(r::fieldIsNullable).collect(Util.toImmutableList());
@@ -5064,7 +5036,7 @@ List<RelFieldCollation> registerFieldCollations(Iterable<? extends RexNode> orde
           fieldCollations.add(collation);
         }
       }
-      return ImmutableList.copyOf(fieldCollations);
+      return fieldCollations;
     }
 
     /** Returns the number of fields added. */
diff --git a/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java b/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java
index 11242c824..1ccb3161d 100644
--- a/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java
+++ b/core/src/main/java/org/apache/calcite/util/BarfingInvocationHandler.java
@@ -81,7 +81,7 @@ protected UnsupportedOperationException noMethod(Method method) {
             + "."
             + method.getName()
             + "("
-            + buf.toString()
+            + buf
             + ")";
     return new UnsupportedOperationException(signature);
   }
diff --git a/core/src/main/java/org/apache/calcite/util/Benchmark.java b/core/src/main/java/org/apache/calcite/util/Benchmark.java
index 0f6a47add..2814aef72 100644
--- a/core/src/main/java/org/apache/calcite/util/Benchmark.java
+++ b/core/src/main/java/org/apache/calcite/util/Benchmark.java
@@ -104,7 +104,7 @@ private void printDurations() {
         y += x * x;
       }
       final double stddev = Math.sqrt(y / count);
-      if (durations.size() == 0) {
+      if (durations.isEmpty()) {
         LOGGER.debug("{}: {}", desc, "no runs");
       } else {
         LOGGER.debug(
diff --git a/core/src/main/java/org/apache/calcite/util/BitString.java b/core/src/main/java/org/apache/calcite/util/BitString.java
index 02690e8d6..ea5159164 100644
--- a/core/src/main/java/org/apache/calcite/util/BitString.java
+++ b/core/src/main/java/org/apache/calcite/util/BitString.java
@@ -45,7 +45,7 @@ public class BitString {
   // ~ Constructors -----------------------------------------------------------
 
   protected BitString(String bits, int bitCount) {
-    assert bits.replace("1", "").replace("0", "").length() == 0
+    assert bits.replace("1", "").replace("0", "").isEmpty()
         : "bit string '" + bits + "' contains digits other than {0, 1}";
     this.bits = bits;
     this.bitCount = bitCount;
@@ -141,7 +141,7 @@ public static byte[] toByteArrayFromBitString(String bits, int bitCount) {
     }
     int byteCount = (bitCount + 7) / 8;
     byte[] srcBytes;
-    if (bits.length() > 0) {
+    if (!bits.isEmpty()) {
       BigInteger bigInt = new BigInteger(bits, 2);
       srcBytes = bigInt.toByteArray();
     } else {
diff --git a/core/src/main/java/org/apache/calcite/util/ChunkList.java b/core/src/main/java/org/apache/calcite/util/ChunkList.java
index 407b47aa1..60a16aab2 100644
--- a/core/src/main/java/org/apache/calcite/util/ChunkList.java
+++ b/core/src/main/java/org/apache/calcite/util/ChunkList.java
@@ -25,6 +25,9 @@
 import java.util.ListIterator;
 import java.util.NoSuchElementException;
 
+import static com.google.common.base.Preconditions.checkPositionIndex;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -183,9 +186,7 @@ private static <E> void setElement(E[] chunk, int index, @Nullable E element) {
   }
 
   private ChunkListIterator locate(int index) {
-    if (index < 0 || index > size) {
-      throw new IndexOutOfBoundsException();
-    }
+    checkPositionIndex(index, size);
     if (first == null) {
       // Create an iterator positioned before the first element.
       return new ChunkListIterator(null, 0, 0, -1, 0);
@@ -285,9 +286,7 @@ private E[] currentChunk() {
     }
 
     @Override public void remove() {
-      if (lastRet < 0) {
-        throw new IllegalStateException();
-      }
+      checkState(lastRet >= 0);
       --size;
       --cursor;
       if (end == start + 1) {
@@ -364,9 +363,7 @@ private E[] currentChunk() {
     }
 
     @Override public void set(E e) {
-      if (lastRet < 0) {
-        throw new IllegalStateException();
-      }
+      checkState(lastRet >= 0);
       E[] c = currentChunk();
       int p = lastRet;
       int s = start;
diff --git a/core/src/main/java/org/apache/calcite/util/CompositeMap.java b/core/src/main/java/org/apache/calcite/util/CompositeMap.java
index 0239e77f8..119f0b49d 100644
--- a/core/src/main/java/org/apache/calcite/util/CompositeMap.java
+++ b/core/src/main/java/org/apache/calcite/util/CompositeMap.java
@@ -58,7 +58,7 @@ private static <E> ImmutableList<E> list(E e, E[] es) {
   }
 
   @Override public int size() {
-    return keySet().size();
+    return this.size();
   }
 
   @Override public boolean isEmpty() {
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java b/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
index 68d94dd5e..b27409636 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableBitSet.java
@@ -49,6 +49,8 @@
 import java.util.function.IntPredicate;
 import java.util.stream.Collector;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -234,12 +236,8 @@ public static ImmutableBitSet fromBitSet(BitSet input) {
    * @return Bit set
    */
   public static ImmutableBitSet range(int fromIndex, int toIndex) {
-    if (fromIndex > toIndex) {
-      throw new IllegalArgumentException();
-    }
-    if (toIndex < 0) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(fromIndex <= toIndex);
+    checkArgument(toIndex >= 0);
     if (fromIndex == toIndex) {
       return EMPTY;
     }
@@ -889,9 +887,7 @@ public ImmutableBitSet permute(Map<Integer, Integer> map) {
     final Builder builder = builder();
     for (int i = nextSetBit(0); i >= 0; i = nextSetBit(i + 1)) {
       Integer value = map.get(i);
-      if (value == null) {
-        throw new NullPointerException("Index " + i + " is not mapped in " + map);
-      }
+      requireNonNull(value, "Index " + i + " is not mapped in " + map);
       builder.set(value);
     }
     return builder.build();
@@ -1014,9 +1010,7 @@ private Builder(long[] words) {
      * <p>After calling this method, the Builder cannot be used again.
      */
     public ImmutableBitSet build() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       if (words.length == 0) {
         return EMPTY;
       }
@@ -1031,9 +1025,7 @@ public ImmutableBitSet build() {
      * <p>After calling this method, the Builder may be used again.
      */
     public ImmutableBitSet buildAndReset() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       if (words.length == 0) {
         return EMPTY;
       }
@@ -1069,9 +1061,7 @@ public ImmutableBitSet build(ImmutableBitSet bitSet) {
     }
 
     public Builder set(int bit) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       int wordIndex = wordIndex(bit);
       if (wordIndex >= words.length) {
         words = Arrays.copyOf(words, wordIndex + 1);
@@ -1081,9 +1071,7 @@ public Builder set(int bit) {
     }
 
     public boolean get(int bitIndex) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       if (bitIndex < 0) {
         throw new IndexOutOfBoundsException("bitIndex < 0: " + bitIndex);
       }
@@ -1092,9 +1080,7 @@ public boolean get(int bitIndex) {
     }
 
     private void trim(int wordCount) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       while (wordCount > 0 && words[wordCount - 1] == 0L) {
         --wordCount;
       }
@@ -1109,9 +1095,7 @@ private void trim(int wordCount) {
     }
 
     public Builder clear(int bit) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       int wordIndex = wordIndex(bit);
       if (wordIndex < words.length) {
         words[wordIndex] &= ~(1L << bit);
@@ -1125,29 +1109,21 @@ public Builder clear(int bit) {
      * set.
      */
     public boolean wouldEqual(ImmutableBitSet bitSet) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       return Arrays.equals(words, bitSet.words);
     }
 
     /** Returns the number of set bits. */
     public int cardinality() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       return countBits(words);
     }
 
     /** Merges another builder. Does not modify the other builder. */
     public Builder combine(Builder builder) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       long[] otherWords = builder.words;
-      if (otherWords == null) {
-        throw new IllegalArgumentException("Given builder is empty");
-      }
+      checkArgument(otherWords != null, "Given builder is empty");
       if (this.words.length < otherWords.length) {
         // Right has more bits. Copy the right and OR in the words of the
         // previous left.
@@ -1191,16 +1167,9 @@ public Builder removeAll(ImmutableBitSet bitSet) {
 
     /** Sets a range of bits, from {@code from} to {@code to} - 1. */
     public Builder set(int fromIndex, int toIndex) {
-      if (fromIndex > toIndex) {
-        throw new IllegalArgumentException(
-            "fromIndex(" + fromIndex + ")" + " > toIndex(" + toIndex + ")");
-      }
-      if (toIndex < 0) {
-        throw new IllegalArgumentException("toIndex(" + toIndex + ") < 0");
-      }
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(fromIndex <= toIndex, "fromIndex(%s) > toIndex(%s)", fromIndex, toIndex);
+      checkArgument(toIndex >= 0, "toIndex(%s) < 0", toIndex);
+      checkArgument(words != null, "can only use builder once");
       if (fromIndex < toIndex) {
         // Increase capacity if necessary
         int startWordIndex = wordIndex(fromIndex);
@@ -1227,16 +1196,12 @@ public Builder set(int fromIndex, int toIndex) {
     }
 
     public boolean isEmpty() {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       return words.length == 0;
     }
 
     public void intersect(ImmutableBitSet that) {
-      if (words == null) {
-        throw new IllegalArgumentException("can only use builder once");
-      }
+      checkArgument(words != null, "can only use builder once");
       int x = Math.min(words.length, that.words.length);
       for (int i = 0; i < x; i++) {
         words[i] &= that.words[i];
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java b/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java
index 20070c88c..0605e0848 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableNullableList.java
@@ -37,7 +37,7 @@
  * @param <E> Element type
  */
 public class ImmutableNullableList<E> extends AbstractList<E> {
-  private static final List SINGLETON_NULL = Collections.singletonList(null);
+  private static final List SINGLETON_NULL = ImmutableList.of(null);
 
   private final E[] elements;
 
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java b/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java
index 006b16c8f..a012c7707 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableNullableMap.java
@@ -37,7 +37,7 @@
  */
 public abstract class ImmutableNullableMap<K, V> extends AbstractMap<K, V> {
 
-  private static final Map<Integer, Integer> SINGLETON_MAP = Collections.singletonMap(0, 0);
+  private static final Map<Integer, Integer> SINGLETON_MAP = ImmutableMap.of(0, 0);
 
   private ImmutableNullableMap() {}
 
@@ -50,7 +50,7 @@ private ImmutableNullableMap() {}
   public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
     if (map instanceof ImmutableNullableMap
         || map instanceof ImmutableMap
-        || map == Collections.emptyMap()
+        || map == ImmutableMap.of()
         || map == Collections.emptyNavigableMap()
         || map.getClass() == SINGLETON_MAP.getClass()) {
       return (Map<K, V>) map;
@@ -93,7 +93,7 @@ public static <K, V> Map<K, V> copyOf(Map<? extends K, ? extends V> map) {
   public static <K, V> Map<K, V> copyOf(SortedMap<? extends K, ? extends V> map) {
     if (map instanceof ImmutableNullableMap
         || map instanceof ImmutableMap
-        || map == Collections.emptyMap()
+        || map == ImmutableMap.of()
         || map == Collections.emptyNavigableMap()) {
       return (Map<K, V>) map;
     }
diff --git a/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java b/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java
index 716e56e79..6c53565d8 100644
--- a/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java
+++ b/core/src/main/java/org/apache/calcite/util/ImmutableNullableSet.java
@@ -52,7 +52,7 @@ public class ImmutableNullableSet<E> extends AbstractSet<E> {
   private static final Set SINGLETON_NULL =
       new ImmutableNullableSet(ImmutableSet.of(NullSentinel.INSTANCE));
 
-  private static final Set<Integer> SINGLETON = Collections.singleton(0);
+  private static final Set<Integer> SINGLETON = ImmutableSet.of(0);
 
   private final ImmutableSet<Object> elements;
 
@@ -90,7 +90,7 @@ private ImmutableNullableSet(ImmutableSet<Object> elements) {
   public static <E> Set<E> copyOf(Iterable<? extends E> elements) {
     if (elements instanceof ImmutableNullableSet
         || elements instanceof ImmutableSet
-        || elements == Collections.emptySet()
+        || elements == ImmutableSet.of()
         || elements == Collections.emptySortedSet()
         || elements == SINGLETON_NULL
         || elements.getClass() == SINGLETON.getClass()) {
diff --git a/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java b/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java
index fabfea6d3..a5c87229e 100644
--- a/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java
+++ b/core/src/main/java/org/apache/calcite/util/MonotonicSupplier.java
@@ -21,6 +21,8 @@
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -40,16 +42,12 @@ public class MonotonicSupplier<E> implements Consumer<E>, Supplier<E> {
    * <p>Sets the value once and for all.
    */
   @Override public void accept(E e) {
-    if (this.e != null) {
-      throw new IllegalArgumentException("accept has been called already");
-    }
+    checkArgument(this.e == null, "accept has been called already");
     this.e = requireNonNull(e, "element must not be null");
   }
 
   @Override public E get() {
-    if (e == null) {
-      throw new IllegalArgumentException("accept has not been called");
-    }
+    checkArgument(e != null, "accept has not been called");
     return e;
   }
 }
diff --git a/core/src/main/java/org/apache/calcite/util/NlsString.java b/core/src/main/java/org/apache/calcite/util/NlsString.java
index 633e2093e..cae3a28e8 100644
--- a/core/src/main/java/org/apache/calcite/util/NlsString.java
+++ b/core/src/main/java/org/apache/calcite/util/NlsString.java
@@ -42,6 +42,8 @@
 import java.util.Locale;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.util.Static.RESOURCE;
 
 import static java.util.Objects.requireNonNull;
@@ -137,13 +139,10 @@ private NlsString(
       this.charsetName = null;
       this.charset = null;
     }
-    if ((stringValue != null) == (bytesValue != null)) {
-      throw new IllegalArgumentException("Specify stringValue or bytesValue");
-    }
+    checkArgument(
+        (stringValue != null) != (bytesValue != null), "Specify stringValue or bytesValue");
     if (bytesValue != null) {
-      if (charset == null) {
-        throw new IllegalArgumentException("Bytes value requires charset");
-      }
+      checkArgument(charset != null, "Bytes value requires charset");
       SqlUtil.validateCharset(bytesValue, charset);
     } else {
       //noinspection ConstantConditions
@@ -246,9 +245,9 @@ public String asSql(boolean prefix, boolean suffix, SqlDialect dialect) {
 
     // NOTE jvs 3-Feb-2005:  see FRG-78 for why this should go away
     if (false) {
-      if (suffix && (null != collation)) {
+      if (suffix && collation != null) {
         ret.append(" ");
-        ret.append(collation.toString());
+        ret.append(collation);
       }
     }
     return ret.toString();
@@ -281,12 +280,11 @@ public static NlsString concat(List<NlsString> args) {
     for (int i = 1; i < args.size(); i++) {
       final NlsString arg = args.get(i);
       length += arg.getValue().length();
-      if (!((arg.charsetName == null) || arg.charsetName.equals(charSetName))) {
-        throw new IllegalArgumentException("mismatched charsets");
-      }
-      if (!((arg.collation == null) || arg.collation.equals(collation))) {
-        throw new IllegalArgumentException("mismatched collations");
-      }
+      checkArgument(
+          ((arg.charsetName == null) || arg.charsetName.equals(charSetName)),
+          "mismatched charsets");
+      checkArgument(
+          ((arg.collation == null) || arg.collation.equals(collation)), "mismatched collations");
     }
 
     StringBuilder sb = new StringBuilder(length);
diff --git a/core/src/main/java/org/apache/calcite/util/NumberUtil.java b/core/src/main/java/org/apache/calcite/util/NumberUtil.java
index 5a8c6cab6..fa3059e0c 100644
--- a/core/src/main/java/org/apache/calcite/util/NumberUtil.java
+++ b/core/src/main/java/org/apache/calcite/util/NumberUtil.java
@@ -116,7 +116,7 @@ public static BigDecimal toBigDecimal(Number number, int scale) {
     } else if (number instanceof BigInteger) {
       return new BigDecimal((BigInteger) number);
     } else {
-      return new BigDecimal(number.longValue());
+      return BigDecimal.valueOf(number.longValue());
     }
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java b/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
index 7a80d85f4..8191b2e30 100644
--- a/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
+++ b/core/src/main/java/org/apache/calcite/util/PartiallyOrderedSet.java
@@ -26,7 +26,6 @@
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -366,7 +365,7 @@ private static <T> void replace(List<T> list, T remove, T add) {
    * @param fail Whether to throw an assertion error
    * @return Whether valid
    */
-  @SuppressWarnings({"ConstantConditions"})
+  @SuppressWarnings("ConstantConditions")
   public boolean isValid(boolean fail) {
     // Top has no parents.
     // Bottom has no children.
@@ -450,7 +449,7 @@ public boolean isValid(boolean fail) {
           }
         }
         if (lt12 && lt21) {
-          if (!(node1 == node2)) {
+          if (node1 != node2) {
             assert !fail
                 : "node "
                     + node1.e
@@ -631,17 +630,17 @@ public void out(StringBuilder buf) {
     if (node == null) {
       if (hypothetical) {
         if (parentFunction != null) {
-          final ImmutableList.Builder<E> list = new ImmutableList.Builder<>();
+          final ImmutableList.Builder<E> list = ImmutableList.builder();
           closure(parentFunction, e, list, new HashSet<>());
           return list.build();
         } else {
-          return ImmutableList.copyOf(strip(findParents(e)));
+          return strip(findParents(e)).asList();
         }
       } else {
         return null;
       }
     } else {
-      return ImmutableList.copyOf(strip(node.parentList));
+      return strip(node.parentList);
     }
   }
 
@@ -753,12 +752,12 @@ private List<E> descendants(E e, boolean up) {
       c = up ? node.childList : node.parentList;
     }
     if (c.size() == 1 && c.iterator().next().e == null) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     final Deque<Node<E>> deque = new ArrayDeque<>(c);
 
     final Set<Node<E>> seen = new HashSet<>();
-    final ImmutableList.Builder<E> list = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<E> list = ImmutableList.builder();
     while (!deque.isEmpty()) {
       Node<E> node1 = deque.pop();
       list.add(node1.e);
diff --git a/core/src/main/java/org/apache/calcite/util/Permutation.java b/core/src/main/java/org/apache/calcite/util/Permutation.java
index 9332ab365..57972ae67 100644
--- a/core/src/main/java/org/apache/calcite/util/Permutation.java
+++ b/core/src/main/java/org/apache/calcite/util/Permutation.java
@@ -28,6 +28,8 @@
 import java.util.Arrays;
 import java.util.Iterator;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Represents a mapping which reorders elements in an array. */
 public class Permutation implements Mapping, Mappings.TargetMapping {
   // ~ Instance fields --------------------------------------------------------
@@ -67,13 +69,9 @@ public Permutation(int[] targets) {
     Arrays.fill(sources, -1);
     for (int i = 0; i < targets.length; i++) {
       int target = targets[i];
-      if (target < 0 || target >= sources.length) {
-        throw new IllegalArgumentException("target out of range");
-      }
-      if (sources[target] != -1) {
-        throw new IllegalArgumentException(
-            "more than one permutation element maps to position " + target);
-      }
+      checkArgument(target >= 0 && target < sources.length, "target out of range");
+      checkArgument(
+          sources[target] == -1, "more than one permutation element maps to position %s", target);
       sources[target] = i;
     }
     assert isValid(true);
diff --git a/core/src/main/java/org/apache/calcite/util/Puffin.java b/core/src/main/java/org/apache/calcite/util/Puffin.java
index 0a4f19059..f22891402 100644
--- a/core/src/main/java/org/apache/calcite/util/Puffin.java
+++ b/core/src/main/java/org/apache/calcite/util/Puffin.java
@@ -302,7 +302,7 @@ private static class ProgramImpl<G, F> implements Program<G> {
 
     @SuppressWarnings("Convert2MethodRef")
     private final LoadingCache<String, Pattern> patternCache0 =
-        CacheBuilder.newBuilder().build(CacheLoader.from(regex -> Pattern.compile(regex)));
+        CacheBuilder.newBuilder().build(CacheLoader.from(Pattern::compile));
 
     private final Function<String, Pattern> patternCache = patternCache0::getUnchecked;
 
diff --git a/core/src/main/java/org/apache/calcite/util/RangeSets.java b/core/src/main/java/org/apache/calcite/util/RangeSets.java
index 88bd7810d..6014edcda 100644
--- a/core/src/main/java/org/apache/calcite/util/RangeSets.java
+++ b/core/src/main/java/org/apache/calcite/util/RangeSets.java
@@ -43,7 +43,7 @@ private RangeSets() {}
   public static <C extends Comparable<C>> RangeSet<C> minus(RangeSet<C> rangeSet, Range<C> range) {
     final TreeRangeSet<C> mutableRangeSet = TreeRangeSet.create(rangeSet);
     mutableRangeSet.remove(range);
-    return mutableRangeSet.equals(rangeSet) ? rangeSet : ImmutableRangeSet.copyOf(mutableRangeSet);
+    return mutableRangeSet.equals(rangeSet) ? rangeSet : mutableRangeSet;
   }
 
   /** Returns the unrestricted range set. */
diff --git a/core/src/main/java/org/apache/calcite/util/ReflectUtil.java b/core/src/main/java/org/apache/calcite/util/ReflectUtil.java
index 070306c39..2e2844cff 100644
--- a/core/src/main/java/org/apache/calcite/util/ReflectUtil.java
+++ b/core/src/main/java/org/apache/calcite/util/ReflectUtil.java
@@ -29,11 +29,12 @@
 import java.lang.reflect.Modifier;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 /** Static utilities for Java reflection. */
@@ -253,7 +254,7 @@ private static boolean invokeVisitorInternal(
    */
   public static @Nullable Method lookupVisitMethod(
       Class<?> visitorClass, Class<?> visiteeClass, String visitMethodName) {
-    return lookupVisitMethod(visitorClass, visiteeClass, visitMethodName, Collections.emptyList());
+    return lookupVisitMethod(visitorClass, visiteeClass, visitMethodName, ImmutableList.of());
   }
 
   /**
@@ -372,8 +373,7 @@ ReflectiveVisitDispatcher<R, E> createDispatcher(
           Class<? extends R> visitorClass,
           Class<? extends E> visiteeClass,
           String visitMethodName) {
-        return lookupVisitMethod(
-            visitorClass, visiteeClass, visitMethodName, Collections.emptyList());
+        return lookupVisitMethod(visitorClass, visiteeClass, visitMethodName, ImmutableList.of());
       }
 
       @Override public @Nullable Method lookupVisitMethod(
@@ -454,7 +454,7 @@ public static <E extends Object, T> MethodDispatcher<T> createMethodDispatcher(
       final Class<E> arg0Clazz,
       final Class... otherArgClasses) {
     final List<Class> otherArgClassList = ImmutableList.copyOf(otherArgClasses);
-    @SuppressWarnings({"unchecked"})
+    @SuppressWarnings("unchecked")
     final ReflectiveVisitDispatcher<ReflectiveVisitor, E> dispatcher =
         createDispatcher((Class<ReflectiveVisitor>) visitor.getClass(), arg0Clazz);
     return new MethodDispatcher<T>() {
@@ -480,9 +480,7 @@ public static <E extends Object, T> MethodDispatcher<T> createMethodDispatcher(
       }
 
       private Method lookupMethod(final Object arg0) {
-        if (!arg0Clazz.isInstance(arg0)) {
-          throw new IllegalArgumentException();
-        }
+        checkArgument(arg0Clazz.isInstance(arg0));
         Method method =
             dispatcher.lookupVisitMethod(
                 visitor.getClass(),
diff --git a/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java b/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java
index 9562d0331..e1c233352 100644
--- a/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java
+++ b/core/src/main/java/org/apache/calcite/util/SimpleNamespaceContext.java
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.util;
 
+import com.google.common.collect.ImmutableSet;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.Collections;
@@ -62,7 +64,7 @@ public SimpleNamespaceContext(Map<String, String> bindings) {
 
   private Set<String> getPrefixesSet(String namespaceUri) {
     Set<String> prefixes = this.namespaceUriToPrefixes.get(namespaceUri);
-    return prefixes != null ? Collections.unmodifiableSet(prefixes) : Collections.emptySet();
+    return prefixes != null ? Collections.unmodifiableSet(prefixes) : ImmutableSet.of();
   }
 
   private void bindNamespaceUri(String prefix, String namespaceUri) {
diff --git a/core/src/main/java/org/apache/calcite/util/Template.java b/core/src/main/java/org/apache/calcite/util/Template.java
index 36e437c5a..c1ed7f4dc 100644
--- a/core/src/main/java/org/apache/calcite/util/Template.java
+++ b/core/src/main/java/org/apache/calcite/util/Template.java
@@ -16,8 +16,6 @@
  */
 package org.apache.calcite.util;
 
-import com.google.common.collect.ImmutableList;
-
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.text.MessageFormat;
@@ -26,6 +24,8 @@
 import java.util.Locale;
 import java.util.Map;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * String template.
  *
@@ -104,7 +104,7 @@ public static Template of(String pattern, Locale locale) {
 
   private Template(String pattern, List<String> parameterNames, Locale locale) {
     super(pattern, locale);
-    this.parameterNames = ImmutableList.copyOf(parameterNames);
+    this.parameterNames = parameterNames;
   }
 
   /**
@@ -179,9 +179,7 @@ private static String process(String pattern, List<String> parameterNames) {
         }
       }
     }
-    if (braceStack == 0 && part != 0) {
-      throw new IllegalArgumentException("Unmatched braces in the pattern.");
-    }
+    checkArgument(braceStack != 0 || part == 0, "Unmatched braces in the pattern.");
     return segments[0].toString();
   }
 
@@ -198,11 +196,11 @@ private static void makeFormat(StringBuilder[] segments, List<String> parameterN
     segments[0].append("{");
     segments[0].append(parameterOrdinal);
     final String two = segments[2].toString();
-    if (two.length() > 0) {
+    if (!two.isEmpty()) {
       segments[0].append(",").append(two);
     }
     final String three = segments[3].toString();
-    if (three.length() > 0) {
+    if (!three.isEmpty()) {
       segments[0].append(",").append(three);
     }
     segments[0].append("}");
diff --git a/core/src/main/java/org/apache/calcite/util/TimeString.java b/core/src/main/java/org/apache/calcite/util/TimeString.java
index 0eafd5794..315c1ed79 100644
--- a/core/src/main/java/org/apache/calcite/util/TimeString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimeString.java
@@ -114,7 +114,7 @@ public TimeString withFraction(String fraction) {
     while (fraction.endsWith("0")) {
       fraction = fraction.substring(0, fraction.length() - 1);
     }
-    if (fraction.length() > 0) {
+    if (!fraction.isEmpty()) {
       v = v + "." + fraction;
     }
     return new TimeString(v);
diff --git a/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java b/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java
index 56c600b31..863253eb6 100644
--- a/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimeWithTimeZoneString.java
@@ -45,7 +45,7 @@ public class TimeWithTimeZoneString implements Comparable<TimeWithTimeZoneString
   public TimeWithTimeZoneString(TimeString localTime, TimeZone timeZone) {
     this.localTime = localTime;
     this.timeZone = timeZone;
-    this.v = localTime.toString() + " " + timeZone.getID();
+    this.v = localTime + " " + timeZone.getID();
   }
 
   /** Creates a TimeWithTimeZoneString. */
@@ -62,7 +62,7 @@ public TimeWithTimeZoneString(String v) {
    * time-zone.
    */
   public TimeWithTimeZoneString(int h, int m, int s, String timeZone) {
-    this(DateTimeStringUtils.hms(new StringBuilder(), h, m, s).toString() + " " + timeZone);
+    this(DateTimeStringUtils.hms(new StringBuilder(), h, m, s) + " " + timeZone);
   }
 
   /**
@@ -108,7 +108,7 @@ public TimeWithTimeZoneString withFraction(String fraction) {
     while (fraction.endsWith("0")) {
       fraction = fraction.substring(0, fraction.length() - 1);
     }
-    if (fraction.length() > 0) {
+    if (!fraction.isEmpty()) {
       v = v + "." + fraction;
     }
     v = v + this.v.substring(8); // time-zone
diff --git a/core/src/main/java/org/apache/calcite/util/TimestampString.java b/core/src/main/java/org/apache/calcite/util/TimestampString.java
index e1bbdc4c5..4b2fa20c4 100644
--- a/core/src/main/java/org/apache/calcite/util/TimestampString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimestampString.java
@@ -111,7 +111,7 @@ public TimestampString withFraction(String fraction) {
     while (fraction.endsWith("0")) {
       fraction = fraction.substring(0, fraction.length() - 1);
     }
-    if (fraction.length() > 0) {
+    if (!fraction.isEmpty()) {
       v = v + "." + fraction;
     }
     return new TimestampString(v);
diff --git a/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java b/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java
index 5736fb09f..9124479d6 100644
--- a/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java
+++ b/core/src/main/java/org/apache/calcite/util/TimestampWithTimeZoneString.java
@@ -45,7 +45,7 @@ public class TimestampWithTimeZoneString implements Comparable<TimestampWithTime
   public TimestampWithTimeZoneString(TimestampString localDateTime, TimeZone timeZone) {
     this.localDateTime = localDateTime;
     this.timeZone = timeZone;
-    this.v = localDateTime.toString() + " " + timeZone.getID();
+    this.v = localDateTime + " " + timeZone.getID();
   }
 
   /** Creates a TimestampWithTimeZoneString. */
@@ -64,7 +64,7 @@ public TimestampWithTimeZoneString(String v) {
   public TimestampWithTimeZoneString(
       int year, int month, int day, int h, int m, int s, String timeZone) {
     this(
-        DateTimeStringUtils.ymdhms(new StringBuilder(), year, month, day, h, m, s).toString()
+        DateTimeStringUtils.ymdhms(new StringBuilder(), year, month, day, h, m, s)
             + " "
             + timeZone);
   }
diff --git a/core/src/main/java/org/apache/calcite/util/Util.java b/core/src/main/java/org/apache/calcite/util/Util.java
index 5403d68e6..dd5e86123 100644
--- a/core/src/main/java/org/apache/calcite/util/Util.java
+++ b/core/src/main/java/org/apache/calcite/util/Util.java
@@ -31,6 +31,7 @@
 import org.apache.calcite.sql.util.SqlBasicVisitor;
 
 import com.google.common.base.Preconditions;
+import com.google.common.base.Strings;
 import com.google.common.base.Throwables;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
@@ -114,6 +115,8 @@
 import java.util.regex.Pattern;
 import java.util.stream.Collector;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 import static java.util.Objects.requireNonNull;
@@ -615,8 +618,7 @@ public static String stripDoubleQuotes(String value) {
     String s4 = Util.replace(s5, "\\r", "\r");
     String s3 = Util.replace(s4, "\\n", "\n");
     String s2 = Util.replace(s3, "\\\"", "\"");
-    String s1 = Util.replace(s2, "\\\\", "\\");
-    return s1;
+    return Util.replace(s2, "\\\\", "\\");
   }
 
   /**
@@ -718,7 +720,7 @@ public static <T> List<T> toList(Iterator<T> iter) {
 
   /** Returns whether s == null or if s.length() == 0. */
   public static boolean isNullOrEmpty(@Nullable String s) {
-    return (null == s) || (s.length() == 0);
+    return Strings.isNullOrEmpty(s);
   }
 
   /**
@@ -1036,7 +1038,7 @@ public static void permAssert(boolean b, String description) {
   public static RuntimeException needToImplement(@Nullable Object o) {
     String description = null;
     if (o != null) {
-      description = o.getClass().toString() + ": " + o.toString();
+      description = o.getClass() + ": " + o;
     }
     throw new UnsupportedOperationException(description);
   }
@@ -2249,9 +2251,7 @@ public static List<String> stringToList(String s) {
     int i = 0;
     for (; ; ) {
       char c = s.charAt(i);
-      if (c != '"') {
-        throw new IllegalArgumentException();
-      }
+      checkArgument(c == '"');
       for (; ; ) {
         c = s.charAt(++i);
         if (c == '"') {
@@ -2263,9 +2263,7 @@ public static List<String> stringToList(String s) {
           if (c == '.') {
             break;
           }
-          if (c != '"') {
-            throw new IllegalArgumentException();
-          }
+          checkArgument(c == '"');
         }
         b.append(c);
       }
@@ -2854,9 +2852,7 @@ private static class QuotientList<E> extends AbstractList<E> implements RandomAc
     private final int size;
 
     QuotientList(List<E> list, int n, int k) {
-      if (k < 0 || n <= 0 || k >= n) {
-        throw new IllegalArgumentException("n must be positive; k must be between 0 and n - 1");
-      }
+      checkArgument(k >= 0 && n > 0 && k < n, "n must be positive; k must be between 0 and n - 1");
       this.list = list;
       this.n = n;
       this.k = k;
diff --git a/core/src/main/java/org/apache/calcite/util/XmlOutput.java b/core/src/main/java/org/apache/calcite/util/XmlOutput.java
index 3630cb33a..5c970713c 100644
--- a/core/src/main/java/org/apache/calcite/util/XmlOutput.java
+++ b/core/src/main/java/org/apache/calcite/util/XmlOutput.java
@@ -565,7 +565,7 @@ public String escapeString(String s) {
         String escape;
         // codes >= 128 (e.g. Euro sign) are always escaped
         if (c > 127) {
-          escape = "&#" + Integer.toString(c) + ";";
+          escape = "&#" + c + ";";
         } else if (c >= requireNonNull(translationTable, "translationTable").length) {
           escape = null;
         } else {
diff --git a/core/src/main/java/org/apache/calcite/util/format/FormatModels.java b/core/src/main/java/org/apache/calcite/util/format/FormatModels.java
index e1e2cd485..41ce998b7 100644
--- a/core/src/main/java/org/apache/calcite/util/format/FormatModels.java
+++ b/core/src/main/java/org/apache/calcite/util/format/FormatModels.java
@@ -17,7 +17,6 @@
 package org.apache.calcite.util.format;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 
 import java.util.Date;
 import java.util.LinkedHashMap;
@@ -239,7 +238,7 @@ private static class FormatModelImpl implements FormatModel {
 
     FormatModelImpl(Pattern pattern, Map<String, FormatElement> elementMap) {
       this.pattern = requireNonNull(pattern, "pattern");
-      this.elementMap = ImmutableMap.copyOf(elementMap);
+      this.elementMap = elementMap;
     }
 
     @Override public Map<String, FormatElement> getElementMap() {
@@ -306,7 +305,7 @@ private static class CompositeFormatElement implements FormatElement {
     private final List<FormatElement> formatElements;
 
     CompositeFormatElement(List<FormatElement> formatElements, String description) {
-      this.formatElements = ImmutableList.copyOf(formatElements);
+      this.formatElements = formatElements;
       this.description = requireNonNull(description, "description");
     }
 
diff --git a/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java b/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java
index dc09e69bc..82d10ec72 100644
--- a/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java
+++ b/core/src/main/java/org/apache/calcite/util/graph/DefaultDirectedGraph.java
@@ -33,6 +33,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
 
 /**
@@ -98,9 +100,7 @@ private String toString(Ordering<V> vertexOrdering, Ordering<E> edgeOrdering) {
   protected final VertexInfo<V, E> getVertex(V vertex) {
     @SuppressWarnings("argument.type.incompatible")
     final VertexInfo<V, E> info = vertexMap.get(vertex);
-    if (info == null) {
-      throw new IllegalArgumentException("no vertex " + vertex);
-    }
+    checkArgument(info != null, "no vertex %s", vertex);
     return info;
   }
 
diff --git a/core/src/main/java/org/apache/calcite/util/graph/Graphs.java b/core/src/main/java/org/apache/calcite/util/graph/Graphs.java
index c2fbae549..868a587f6 100644
--- a/core/src/main/java/org/apache/calcite/util/graph/Graphs.java
+++ b/core/src/main/java/org/apache/calcite/util/graph/Graphs.java
@@ -162,7 +162,7 @@ private void findPathsExcluding(
           if (target.equals(to)) {
             // We found a path.
             prefix.add(target);
-            list.add(ImmutableList.copyOf(prefix));
+            list.add(prefix);
             prefix.remove(prefix.size() - 1);
           } else if (excludedNodes.contains(target)) {
             // ignore it
diff --git a/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java b/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
index 2e6bca2a6..5727d427e 100644
--- a/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
+++ b/core/src/main/java/org/apache/calcite/util/mapping/MappingType.java
@@ -162,22 +162,22 @@ public boolean isBijection() {
 
   /** Constraint that every source has at least one target. */
   public boolean isMandatoryTarget() {
-    return !((ordinal() & OPTIONAL_TARGET) == OPTIONAL_TARGET);
+    return (ordinal() & OPTIONAL_TARGET) != OPTIONAL_TARGET;
   }
 
   /** Constraint that every source has at most one target. */
   public boolean isSingleTarget() {
-    return !((ordinal() & MULTIPLE_TARGET) == MULTIPLE_TARGET);
+    return (ordinal() & MULTIPLE_TARGET) != MULTIPLE_TARGET;
   }
 
   /** Constraint that every target has at least one source. */
   public boolean isMandatorySource() {
-    return !((ordinal() & OPTIONAL_SOURCE) == OPTIONAL_SOURCE);
+    return (ordinal() & OPTIONAL_SOURCE) != OPTIONAL_SOURCE;
   }
 
   /** Constraint that every target has at most one source. */
   public boolean isSingleSource() {
-    return !((ordinal() & MULTIPLE_SOURCE) == MULTIPLE_SOURCE);
+    return (ordinal() & MULTIPLE_SOURCE) != MULTIPLE_SOURCE;
   }
 
   /** Allow less than one source for a given target. */
diff --git a/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java b/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
index 76a92d06e..dad32c8d4 100644
--- a/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
+++ b/core/src/main/java/org/apache/calcite/util/mapping/Mappings.java
@@ -37,6 +37,10 @@
 import java.util.Map;
 import java.util.function.IntFunction;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
+import static java.util.Objects.requireNonNull;
+
 /**
  * Utility functions related to mappings.
  *
@@ -105,9 +109,7 @@ public static Mapping invert(Mapping mapping) {
    * @return Mapping mapping3 such that mapping1 = mapping2 . mapping3
    */
   public static Mapping divide(Mapping mapping1, Mapping mapping2) {
-    if (mapping1.getSourceCount() != mapping2.getSourceCount()) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(mapping1.getSourceCount() == mapping2.getSourceCount());
     Mapping remaining =
         create(
             MappingType.INVERSE_SURJECTION, mapping2.getTargetCount(), mapping1.getTargetCount());
@@ -132,9 +134,7 @@ public static Mapping divide(Mapping mapping1, Mapping mapping2) {
    * @return Mapping mapping3 such that mapping1 = mapping2 . mapping3
    */
   public static Mapping multiply(Mapping mapping1, Mapping mapping2) {
-    if (mapping1.getTargetCount() != mapping2.getSourceCount()) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(mapping1.getTargetCount() == mapping2.getSourceCount());
     Mapping product =
         create(
             MappingType.INVERSE_SURJECTION, mapping1.getSourceCount(), mapping2.getTargetCount());
@@ -319,10 +319,7 @@ public static List<Integer> asListNonNull(final TargetMapping mapping) {
     return new AbstractList<Integer>() {
       @Override public Integer get(int source) {
         int target = mapping.getTargetOpt(source);
-        if (target < 0) {
-          throw new IllegalArgumentException(
-              "Element " + source + " is not found in mapping " + mapping);
-        }
+        checkArgument(target >= 0, "Element %s is not found in mapping %s", source, mapping);
         return target;
       }
 
@@ -404,9 +401,7 @@ public static Mapping bijection(Map<Integer, Integer> targets) {
     int[] ints = new int[targets.size()];
     for (int i = 0; i < targets.size(); i++) {
       Integer value = targets.get(i);
-      if (value == null) {
-        throw new NullPointerException("Index " + i + " is not mapped in " + targets);
-      }
+      requireNonNull(value, "Index " + i + " is not mapped in " + targets);
       ints[i] = value;
     }
     return new Permutation(ints);
@@ -620,9 +615,7 @@ public static TargetMapping offsetSource(final TargetMapping mapping, final int
    */
   public static TargetMapping offsetSource(
       final TargetMapping mapping, final int offset, final int sourceCount) {
-    if (sourceCount < mapping.getSourceCount() + offset) {
-      throw new IllegalArgumentException("new source count too low");
-    }
+    checkArgument(sourceCount >= mapping.getSourceCount() + offset, "new source count too low");
     return target(
         (IntFunction<@Nullable Integer>)
             source -> {
@@ -662,9 +655,7 @@ public static TargetMapping offsetTarget(final TargetMapping mapping, final int
    */
   public static TargetMapping offsetTarget(
       final TargetMapping mapping, final int offset, final int targetCount) {
-    if (targetCount < mapping.getTargetCount() + offset) {
-      throw new IllegalArgumentException("new target count too low");
-    }
+    checkArgument(targetCount >= mapping.getTargetCount() + offset, "new target count too low");
     return target(
         (IntFunction<@Nullable Integer>)
             source -> {
@@ -690,9 +681,7 @@ public static TargetMapping offsetTarget(
    */
   public static TargetMapping offset(
       final TargetMapping mapping, final int offset, final int sourceCount) {
-    if (sourceCount < mapping.getSourceCount() + offset) {
-      throw new IllegalArgumentException("new source count too low");
-    }
+    checkArgument(sourceCount >= mapping.getSourceCount() + offset, "new source count too low");
     return target(
         (IntFunction<@Nullable Integer>)
             source -> {
@@ -1311,10 +1300,7 @@ static class SurjectionWithInverse extends PartialMapping {
     @Override public void set(int source, int target) {
       assert isValid();
       final int prevTarget = targets[source];
-      if (prevTarget != -1) {
-        throw new IllegalArgumentException(
-            "source #" + source + " is already mapped to target #" + target);
-      }
+      checkArgument(prevTarget == -1, "source #%s is already mapped to target #%s", source, target);
       targets[source] = target;
       sources[target] = source;
     }
@@ -1568,15 +1554,11 @@ private static class PartialFunctionImpl extends AbstractMapping implements Targ
 
     PartialFunctionImpl(int sourceCount, int targetCount, MappingType mappingType) {
       super();
-      if (sourceCount < 0) {
-        throw new IllegalArgumentException("Sources must be finite");
-      }
+      checkArgument(sourceCount >= 0, "Sources must be finite");
       this.sourceCount = sourceCount;
       this.targetCount = targetCount;
       this.mappingType = mappingType;
-      if (!mappingType.isSingleTarget()) {
-        throw new IllegalArgumentException("Must have at most one target");
-      }
+      checkArgument(mappingType.isSingleTarget(), "Must have at most one target");
       this.targets = new int[sourceCount];
       Arrays.fill(targets, -1);
     }
@@ -1649,12 +1631,11 @@ private void advance() {
     }
 
     @Override public void set(int source, int target) {
-      if ((target < 0) && mappingType.isMandatorySource()) {
-        throw new IllegalArgumentException("Target is required");
-      }
-      if ((target >= targetCount) && (targetCount >= 0)) {
-        throw new IllegalArgumentException("Target must be less than target count, " + targetCount);
-      }
+      checkArgument(target >= 0 || !mappingType.isMandatorySource(), "Target is required");
+      checkArgument(
+          target < targetCount || targetCount < 0,
+          "Target must be less than target count, %s",
+          targetCount);
       targets[source] = target;
     }
 
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java b/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java
index 3b4e819ad..8cc966df8 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/BinaryOperatorConversion.java
@@ -23,6 +23,8 @@
 
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Binary operator conversion utility class; used to convert expressions like {@code exp1 Operator
  * exp2}.
@@ -49,12 +51,10 @@ public BinaryOperatorConversion(final SqlOperator operator, final String druidOp
     if (druidExpressions == null) {
       return null;
     }
-    if (druidExpressions.size() != 2) {
-      throw new IllegalStateException(
-          DruidQuery.format(
-              "Got binary operator[%s] with %s args?",
-              operator.getName(), druidExpressions.size()));
-    }
+    checkState(
+        druidExpressions.size() == 2,
+        DruidQuery.format(
+            "Got binary operator[%s] with %s args?", operator.getName(), druidExpressions.size()));
 
     return DruidQuery.format(
         "(%s %s %s)", druidExpressions.get(0), druidOperator, druidExpressions.get(1));
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java b/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java
index cc05cc861..4025cce4c 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/ComplexMetric.java
@@ -19,6 +19,8 @@
 import org.apache.calcite.rel.core.AggregateCall;
 import org.apache.calcite.sql.SqlKind;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Stores information about available complex metrics in the Druid Adapter. */
 public class ComplexMetric {
 
@@ -35,9 +37,7 @@ public ComplexMetric(String metricName, DruidType type) {
   }
 
   private static void validate(DruidType type) {
-    if (!type.isComplex()) {
-      throw new IllegalArgumentException("Druid type: " + type + " is not complex");
-    }
+    checkArgument(type.isComplex(), "Druid type: %s is not complex", type);
   }
 
   public String getMetricName() {
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
index 351f09243..9cb7bf805 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidDateTimeUtils.java
@@ -98,7 +98,7 @@ protected static List<Interval> toInterval(List<Range<Long>> ranges) {
               return new Interval(start, end, ISOChronology.getInstanceUTC());
             });
     if (LOGGER.isDebugEnabled()) {
-      LOGGER.debug("Converted time ranges " + ranges + " to interval " + intervals);
+      LOGGER.debug("Converted time ranges {} to interval {}", ranges, intervals);
     }
     return intervals;
   }
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
index b48285202..1367822ec 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidJsonFilter.java
@@ -237,7 +237,7 @@ abstract class DruidJsonFilter implements DruidJson {
     if (SqlTypeName.NUMERIC_TYPES.contains(rhsLiteral.getTypeName())) {
       val = String.valueOf(RexLiteral.value(rhsLiteral));
     } else if (SqlTypeName.CHAR_TYPES.contains(rhsLiteral.getTypeName())) {
-      val = String.valueOf(RexLiteral.stringValue(rhsLiteral));
+      val = RexLiteral.stringValue(rhsLiteral);
     } else if (SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE == rhsLiteral.getTypeName()
         || SqlTypeName.TIMESTAMP == rhsLiteral.getTypeName()
         || SqlTypeName.DATE == rhsLiteral.getTypeName()) {
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
index 84416a3dd..41e566ef0 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidQuery.java
@@ -88,6 +88,8 @@
 import java.util.TimeZone;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static java.util.Objects.requireNonNull;
 
 /** Relational expression representing a scan of a Druid data set. */
@@ -975,7 +977,7 @@ protected CalciteConnectionConfig getConnectionConfig() {
       } else {
         filterNode = null;
       }
-      if (aggCall.getArgList().size() == 0) {
+      if (aggCall.getArgList().isEmpty()) {
         fieldName = null;
         expression = null;
       } else {
@@ -1197,9 +1199,7 @@ protected QuerySpec getQuery(
             limit,
             havingJsonFilter);
 
-    if (groupByQuery == null) {
-      throw new IllegalStateException("Cannot plan Druid Query");
-    }
+    checkState(groupByQuery != null, "Cannot plan Druid Query");
     return new QuerySpec(QueryType.GROUP_BY, groupByQuery, queryOutputFieldNames);
   }
 
@@ -1310,9 +1310,9 @@ private static JsonLimit computeSort(
       writeFieldIf(generator, "filter", jsonFilter);
       writeField(generator, "aggregations", aggregations);
       writeFieldIf(
-          generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+          generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
       writeFieldIf(
-          generator, "postAggregations", postAggregations.size() > 0 ? postAggregations : null);
+          generator, "postAggregations", !postAggregations.isEmpty() ? postAggregations : null);
       writeField(generator, "intervals", intervals);
       generator.writeFieldName("context");
       // The following field is necessary to conform with SQL semantics (CALCITE-1589)
@@ -1365,12 +1365,12 @@ private static JsonLimit computeSort(
       writeField(generator, "granularity", Granularities.all());
       writeField(generator, "dimension", groupByKeyDims.get(0));
       writeFieldIf(
-          generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+          generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
       generator.writeStringField("metric", topNMetricColumnName);
       writeFieldIf(generator, "filter", jsonFilter);
       writeField(generator, "aggregations", aggregations);
       writeFieldIf(
-          generator, "postAggregations", postAggregations.size() > 0 ? postAggregations : null);
+          generator, "postAggregations", !postAggregations.isEmpty() ? postAggregations : null);
       writeField(generator, "intervals", intervals);
       generator.writeNumberField("threshold", limit.limit);
       generator.writeEndObject();
@@ -1400,12 +1400,12 @@ private static JsonLimit computeSort(
       writeField(generator, "granularity", Granularities.all());
       writeField(generator, "dimensions", groupByKeyDims);
       writeFieldIf(
-          generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+          generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
       writeFieldIf(generator, "limitSpec", limit);
       writeFieldIf(generator, "filter", jsonFilter);
       writeField(generator, "aggregations", aggregations);
       writeFieldIf(
-          generator, "postAggregations", postAggregations.size() > 0 ? postAggregations : null);
+          generator, "postAggregations", !postAggregations.isEmpty() ? postAggregations : null);
       writeField(generator, "intervals", intervals);
       writeFieldIf(
           generator,
@@ -1460,7 +1460,7 @@ public String toQuery() {
         writeField(generator, "intervals", intervals);
         writeFieldIf(generator, "filter", jsonFilter);
         writeFieldIf(
-            generator, "virtualColumns", virtualColumnList.size() > 0 ? virtualColumnList : null);
+            generator, "virtualColumns", !virtualColumnList.isEmpty() ? virtualColumnList : null);
         writeField(generator, "columns", columns);
         generator.writeStringField("resultFormat", "compactedList");
         if (fetchLimit != null) {
@@ -1657,7 +1657,7 @@ public static class QuerySpec {
     QuerySpec(QueryType queryType, String queryString, List<String> fieldNames) {
       this.queryType = requireNonNull(queryType, "queryType");
       this.queryString = requireNonNull(queryString, "queryString");
-      this.fieldNames = ImmutableList.copyOf(fieldNames);
+      this.fieldNames = fieldNames;
     }
 
     @Override public int hashCode() {
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
index efc387f13..580b19f4c 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidRules.java
@@ -58,14 +58,12 @@
 import org.apache.commons.lang3.tuple.Triple;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 
 import org.immutables.value.Value;
 import org.joda.time.Interval;
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -415,7 +413,7 @@ private static Pair<List<RexNode>, List<RexNode>> splitProjects(
       }
       final List<RexNode> belowNodes = new ArrayList<>();
       final List<RelDataType> belowTypes = new ArrayList<>();
-      final List<Integer> positions = Lists.newArrayList(visitor.inputPosReferenced);
+      final List<Integer> positions = new ArrayList<>(visitor.inputPosReferenced);
       for (int i : positions) {
         final RexNode node = rexBuilder.makeInputRef(input, i);
         belowNodes.add(node);
@@ -606,7 +604,7 @@ protected DruidAggregateProjectRule(DruidAggregateProjectRuleConfig config) {
           aggregate.copy(aggregate.getTraitSet(), ImmutableList.of(newProject));
       List<Integer> filterRefs = getFilterRefs(aggregate.getAggCallList());
       final DruidQuery query2;
-      if (filterRefs.size() > 0) {
+      if (!filterRefs.isEmpty()) {
         query2 =
             optimizeFilteredAggregations(
                 call, query, (Project) newProject, (Aggregate) newAggregate);
@@ -670,7 +668,7 @@ private static DruidQuery optimizeFilteredAggregations(
       Set<Integer> uniqueFilterRefs = getUniqueFilterRefs(aggregate.getAggCallList());
 
       // One of the pre-conditions for this method
-      assert uniqueFilterRefs.size() > 0;
+      assert !uniqueFilterRefs.isEmpty();
 
       List<AggregateCall> newCalls = new ArrayList<>();
 
@@ -766,7 +764,7 @@ private static List<RelNode> constructNewNodes(
         // This is required so that each RelNode is linked to the one before it
         if (startIndex < oldNodes.size()) {
           RelNode next = oldNodes.get(startIndex);
-          newNodes.add(next.copy(next.getTraitSet(), Collections.singletonList(filter)));
+          newNodes.add(next.copy(next.getTraitSet(), ImmutableList.of(filter)));
           startIndex++;
         }
       }
@@ -778,7 +776,7 @@ private static List<RelNode> constructNewNodes(
 
       // Add the trailing nodes (need to link them)
       for (RelNode node : trailingNodes) {
-        newNodes.add(node.copy(node.getTraitSet(), Collections.singletonList(Util.last(newNodes))));
+        newNodes.add(node.copy(node.getTraitSet(), ImmutableList.of(Util.last(newNodes))));
       }
 
       return newNodes;
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
index a470aea58..9253d7ab3 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchema.java
@@ -23,7 +23,6 @@
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 
 import java.util.HashMap;
@@ -66,7 +65,7 @@ public DruidSchema(String url, String coordinatorUrl, boolean discoverTables) {
 
       tableMap =
           Maps.asMap(
-              ImmutableSet.copyOf(tableNames),
+              tableNames,
               CacheBuilder.newBuilder().build(CacheLoader.from(name -> table(name, connection))));
     }
 
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java
index 958588214..85175e417 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidSchemaFactory.java
@@ -62,7 +62,7 @@ public class DruidSchemaFactory implements SchemaFactory {
     // "tables" is a hidden attribute, copied in from the enclosing custom
     // schema
     final boolean containsTables =
-        operand.get("tables") instanceof List && ((List) operand.get("tables")).size() > 0;
+        operand.get("tables") instanceof List && !((List) operand.get("tables")).isEmpty();
     return new DruidSchema(url, coordinatorUrl, !containsTables);
   }
 }
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
index b0b1d24b0..d54421cf8 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTable.java
@@ -165,7 +165,7 @@ static Table create(
         druidSchema,
         dataSourceName,
         new MapRelProtoDataType(fields, timestampColumnName),
-        ImmutableSet.copyOf(metricNameSet),
+        metricNameSet,
         timestampColumnName,
         intervals,
         complexMetrics,
diff --git a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
index 7cb068e0e..015efd257 100644
--- a/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
+++ b/druid/src/main/java/org/apache/calcite/adapter/druid/DruidTableFactory.java
@@ -37,6 +37,8 @@
 import java.util.Map;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Implementation of {@link TableFactory} for Druid.
  *
@@ -62,9 +64,7 @@ private DruidTableFactory() {}
     if (timestampInfo != null) {
       if (timestampInfo instanceof Map) {
         Map map = (Map) timestampInfo;
-        if (!(map.get("name") instanceof String)) {
-          throw new IllegalArgumentException("timestampColumn array must have name");
-        }
+        checkArgument((map.get("name") instanceof String), "timestampColumn array must have name");
         timestampColumnName = (String) map.get("name");
         if (!(map.get("type") instanceof String)
             || map.get("type").equals("timestamp with local time zone")) {
@@ -113,9 +113,7 @@ private DruidTableFactory() {}
 
         if (metric instanceof Map) {
           Map map2 = (Map) metric;
-          if (!(map2.get("name") instanceof String)) {
-            throw new IllegalArgumentException("metric must have name");
-          }
+          checkArgument((map2.get("name") instanceof String), "metric must have name");
           metricName = (String) map2.get("name");
 
           final String type = (String) map2.get("type");
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
index 8c6cbef1f..0a022e3e7 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchFilter.java
@@ -102,7 +102,7 @@ String translateMatch(RexNode condition)
       }
       generator.flush();
       generator.close();
-      return "{\"query\" : " + writer.toString() + "}";
+      return "{\"query\" : " + writer + "}";
     }
   }
 }
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
index 1c3c91d9d..e21b34fb5 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchJson.java
@@ -27,6 +27,7 @@
 import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
 import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 
 import java.io.IOException;
@@ -48,6 +49,8 @@
 import java.util.function.Predicate;
 import java.util.stream.StreamSupport;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Collections.unmodifiableMap;
 
 /**
@@ -73,7 +76,7 @@ static void visitValueNodes(Aggregations aggregations, Consumer<Map<String, Obje
     aggregations.forEach(a -> visitValueNodes(a, new ArrayList<>(), cons));
     rows.forEach(
         (k, v) -> {
-          if (v.stream().allMatch(val -> val instanceof GroupValue)) {
+          if (v.stream().allMatch(GroupValue.class::isInstance)) {
             v.forEach(
                 tuple -> {
                   Map<String, Object> groupRow = new LinkedHashMap<>(k.keys);
@@ -527,7 +530,7 @@ Object key() {
 
     /** Returns the key associated with the bucket as a string. */
     String keyAsString() {
-      return Objects.toString(key());
+      return String.valueOf(key());
     }
 
     /** Means current bucket has no aggregations. */
@@ -595,7 +598,7 @@ static class GroupValue extends MultiValue {
 
     /** Constructs a {@link GroupValue} instance with a single value. */
     static GroupValue of(String name, Object value) {
-      return new GroupValue(name, Collections.singletonMap("value", value));
+      return new GroupValue(name, ImmutableMap.of("value", value));
     }
   }
 
@@ -685,9 +688,7 @@ private static boolean isMissingBucket(JsonNode key) {
     private static Bucket parseBucket(JsonParser parser, String name, ObjectNode node)
         throws JsonProcessingException {
 
-      if (!node.has("key")) {
-        throw new IllegalArgumentException("No 'key' attribute for " + node);
-      }
+      checkArgument(node.has("key"), "No 'key' attribute for %s", node);
 
       final JsonNode keyNode = node.get("key");
       final Object key;
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java
index 445617541..b5099562f 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchMapping.java
@@ -18,7 +18,6 @@
 
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
-import com.google.common.collect.ImmutableMap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -53,7 +52,7 @@ class ElasticsearchMapping {
     final Map<String, Datatype> transformed =
         mapping.entrySet().stream()
             .collect(Collectors.toMap(Map.Entry::getKey, e -> new Datatype(e.getValue())));
-    this.mapping = ImmutableMap.copyOf(transformed);
+    this.mapping = transformed;
   }
 
   /**
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
index 5ddc100fa..d1deb4e0c 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchProject.java
@@ -137,6 +137,6 @@ public class ElasticsearchProject extends Project implements ElasticsearchRel {
     }
 
     implementor.list.removeIf(l -> l.startsWith("\"_source\""));
-    implementor.add("{" + query.toString() + "}");
+    implementor.add("{" + query + "}");
   }
 }
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
index 526409f8e..f85f08b96 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchema.java
@@ -24,6 +24,7 @@
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 
 import org.elasticsearch.client.Request;
@@ -33,7 +34,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UncheckedIOException;
-import java.util.Collections;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
@@ -81,7 +81,7 @@ public ElasticsearchSchema(RestClient client, ObjectMapper mapper, String index)
         throw new UncheckedIOException("Couldn't get indices", e);
       }
     } else {
-      this.tableMap = createTables(Collections.singleton(index));
+      this.tableMap = createTables(ImmutableSet.of(index));
     }
   }
 
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java
index 6ba29456d..44d642ed2 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchSchemaFactory.java
@@ -135,8 +135,7 @@ public ElasticsearchSchemaFactory() {}
         final List<String> configHosts =
             mapper.readValue((String) map.get("hosts"), new TypeReference<List<String>>() {});
 
-        hosts =
-            configHosts.stream().map(host -> HttpHost.create(host)).collect(Collectors.toList());
+        hosts = configHosts.stream().map(HttpHost::create).collect(Collectors.toList());
       } else if (map.containsKey("coordinates")) {
         final Map<String, Integer> coordinates =
             mapper.readValue(
@@ -227,7 +226,7 @@ private static RestClient connect(
                             .setSSLHostnameVerifier((host, session) -> true));
               }
 
-              if (pathPrefix != null && !pathPrefix.isEmpty()) {
+              if (!Strings.isNullOrEmpty(pathPrefix)) {
                 builder.setPathPrefix(pathPrefix);
               }
               return builder.build();
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
index 057e806c7..f235ca1a4 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTable.java
@@ -43,7 +43,6 @@
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -143,7 +142,7 @@ private Enumerable<Object> find(
     }
 
     final Function1<ElasticsearchJson.SearchHit, Object> getter =
-        ElasticsearchEnumerators.getter(fields, ImmutableMap.copyOf(mappings));
+        ElasticsearchEnumerators.getter(fields, mappings);
 
     Iterable<ElasticsearchJson.SearchHit> iter;
     if (offset == null) {
@@ -280,7 +279,7 @@ private Enumerable<Object> aggregate(
       query.put("track_total_hits", true);
     }
 
-    ElasticsearchJson.Result res = transport.search(Collections.emptyMap()).apply(query);
+    ElasticsearchJson.Result res = transport.search(ImmutableMap.of()).apply(query);
 
     final List<Map<String, Object>> result = new ArrayList<>();
     if (res.aggregations() != null) {
@@ -312,7 +311,7 @@ private Enumerable<Object> aggregate(
     }
 
     final Function1<ElasticsearchJson.SearchHit, Object> getter =
-        ElasticsearchEnumerators.getter(fields, ImmutableMap.copyOf(mapping));
+        ElasticsearchEnumerators.getter(fields, mapping);
 
     ElasticsearchJson.SearchHits hits =
         new ElasticsearchJson.SearchHits(
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java
index 5e2232363..fe2bec8dc 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/ElasticsearchTransport.java
@@ -49,7 +49,6 @@
 import java.io.UncheckedIOException;
 import java.net.URI;
 import java.net.URISyntaxException;
-import java.util.Collections;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
@@ -189,7 +188,7 @@ void closeScroll(Iterable<String> scrollIds) {
   }
 
   Function<ObjectNode, ElasticsearchJson.Result> search() {
-    return search(Collections.emptyMap());
+    return search(ImmutableMap.of());
   }
 
   /** Search request using HTTP post. */
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
index 36d206316..d235e4161 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/PredicateAnalyzer.java
@@ -45,6 +45,8 @@
 import java.util.Objects;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.adapter.elasticsearch.QueryBuilders.boolQuery;
 import static org.apache.calcite.adapter.elasticsearch.QueryBuilders.existsQuery;
 import static org.apache.calcite.adapter.elasticsearch.QueryBuilders.rangeQuery;
@@ -747,9 +749,7 @@ private SimpleQueryExpression(NamedFieldExpression rel) {
     }
 
     @Override public QueryBuilder builder() {
-      if (builder == null) {
-        throw new IllegalStateException("Builder was not initialized");
-      }
+      checkState(builder != null, "Builder was not initialized");
       return builder;
     }
 
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
index 9f03e3a55..8ebdd76b6 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/QueryBuilders.java
@@ -23,6 +23,8 @@
 import java.util.List;
 import java.util.Objects;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Utility class to generate elastic search queries. Most query builders have been copied from ES
  * distribution. The reason we have separate definition is high-level client dependency on core
@@ -433,9 +435,7 @@ RangeQueryBuilder format(String format) {
     }
 
     @Override void writeJson(final JsonGenerator generator) throws IOException {
-      if (lt == null && gt == null) {
-        throw new IllegalStateException("Either lower or upper bound should be provided");
-      }
+      checkState(lt != null || gt != null, "Either lower or upper bound should be provided");
 
       generator.writeStartObject();
       generator.writeFieldName("range");
diff --git a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
index 844713a44..b775ef1eb 100644
--- a/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
+++ b/elasticsearch/src/main/java/org/apache/calcite/adapter/elasticsearch/Scrolling.java
@@ -19,9 +19,10 @@
 import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.AbstractSequentialIterator;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterators;
 
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.Objects;
 import java.util.function.Consumer;
@@ -60,12 +61,12 @@ Iterator<ElasticsearchJson.SearchHit> query(ObjectNode query) {
 
     query.put("size", fetchSize);
     final ElasticsearchJson.Result first =
-        transport.search(Collections.singletonMap("scroll", "1m")).apply(query);
+        transport.search(ImmutableMap.of("scroll", "1m")).apply(query);
 
     AutoClosingIterator iterator =
         new AutoClosingIterator(
             new SequentialIterator(first, transport, limit),
-            scrollId -> transport.closeScroll(Collections.singleton(scrollId)));
+            scrollId -> transport.closeScroll(ImmutableSet.of(scrollId)));
 
     Iterator<ElasticsearchJson.SearchHit> result = flatten(iterator);
     // apply limit
diff --git a/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java b/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
index 127321b7d..d6f085d62 100644
--- a/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
+++ b/file/src/main/java/org/apache/calcite/adapter/file/CsvEnumerator.java
@@ -310,47 +310,47 @@ abstract static class RowConverter<E> {
       }
       switch (fieldType.getSqlTypeName()) {
         case BOOLEAN:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Boolean.parseBoolean(string);
         case TINYINT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Byte.parseByte(string);
         case SMALLINT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Short.parseShort(string);
         case INTEGER:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Integer.parseInt(string);
         case BIGINT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Long.parseLong(string);
         case FLOAT:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Float.parseFloat(string);
         case DOUBLE:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return Double.parseDouble(string);
         case DECIMAL:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           return parseDecimal(fieldType.getPrecision(), fieldType.getScale(), string);
         case DATE:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           try {
@@ -360,7 +360,7 @@ abstract static class RowConverter<E> {
             return null;
           }
         case TIME:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           try {
@@ -370,7 +370,7 @@ abstract static class RowConverter<E> {
             return null;
           }
         case TIMESTAMP:
-          if (string.length() == 0) {
+          if (string.isEmpty()) {
             return null;
           }
           try {
@@ -415,15 +415,14 @@ protected static BigDecimal parseDecimal(int precision, int scale, String string
     }
     // Throws an exception if the parsed value has more digits to the left of the decimal point
     // than the specified value.
-    if (result.precision() - result.scale() > precision - scale) {
-      throw new IllegalArgumentException(
-          String.format(
-              Locale.ROOT,
-              "Decimal value %s exceeds declared precision (%d) and scale (%d).",
-              result,
-              precision,
-              scale));
-    }
+    checkArgument(
+        result.precision() - result.scale() <= precision - scale,
+        String.format(
+            Locale.ROOT,
+            "Decimal value %s exceeds declared precision (%d) and scale (%d).",
+            result,
+            precision,
+            scale));
     return result;
   }
 
diff --git a/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java b/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
index c34702324..d03630bbe 100644
--- a/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
+++ b/file/src/main/java/org/apache/calcite/adapter/file/FileReader.java
@@ -162,7 +162,7 @@ Elements getHeadings() throws FileReaderException {
       // first row must contain headings
       Elements headings = iterator.next("th");
       // if not, generate some default column names
-      if (headings.size() == 0) {
+      if (headings.isEmpty()) {
         // rewind and peek at the first row of data
         iterator = new FileReaderIterator(this.tableElement.select("tr"));
         Elements firstRow = iterator.next("td");
diff --git a/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java b/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
index 4e39f80ed..2059134e7 100644
--- a/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
+++ b/file/src/main/java/org/apache/calcite/adapter/file/FileRowConverter.java
@@ -279,7 +279,7 @@ String read(Element cell) {
         while (m.find()) {
           allMatches.add(m.group());
         }
-        if (allMatches.size() != 0) {
+        if (!allMatches.isEmpty()) {
           return allMatches.get(this.matchSeq);
         } else {
           return null;
@@ -328,7 +328,7 @@ private java.util.Date parseDate(String string) {
 
     @SuppressWarnings("JavaUtilDate")
     private Object toObject(FileFieldType fieldType, String string) {
-      if ((string == null) || (string.length() == 0)) {
+      if ((string == null) || string.isEmpty()) {
         return null;
       }
 
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
index cb13de730..4ffadd338 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeFilter.java
@@ -38,11 +38,11 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
@@ -78,7 +78,7 @@ public class GeodeFilter extends Filter implements GeodeRel {
   @Override public void implement(GeodeImplementContext geodeImplementContext) {
     // first call the input down the tree.
     geodeImplementContext.visitChild(getInput());
-    geodeImplementContext.addPredicates(Collections.singletonList(match));
+    geodeImplementContext.addPredicates(ImmutableList.of(match));
   }
 
   /** Translates {@link RexNode} expressions into Geode expression strings. */
@@ -110,14 +110,14 @@ private static String literalValue(RexLiteral literal) {
         case TIMESTAMP:
         case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
           assert valueComparable instanceof TimestampString;
-          return "TIMESTAMP '" + valueComparable.toString() + "'";
+          return "TIMESTAMP '" + valueComparable + "'";
         case DATE:
           assert valueComparable instanceof DateString;
-          return "DATE '" + valueComparable.toString() + "'";
+          return "DATE '" + valueComparable + "'";
         case TIME:
         case TIME_WITH_LOCAL_TIME_ZONE:
           assert valueComparable instanceof TimeString;
-          return "TIME '" + valueComparable.toString() + "'";
+          return "TIME '" + valueComparable + "'";
         default:
           return String.valueOf(literal.getValue3());
       }
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
index b3dd08d93..4257f6200 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/rel/GeodeTable.java
@@ -185,7 +185,7 @@ public Enumerable<Object> query(
     final String oqlQuery = queryBuilder.toString();
 
     Hook.QUERY_PLAN.run(oqlQuery);
-    LOGGER.info("OQL: " + oqlQuery);
+    LOGGER.info("OQL: {}", oqlQuery);
 
     return new AbstractEnumerable<Object>() {
       @Override public Enumerator<Object> enumerator() {
diff --git a/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java b/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
index 08ee3d1fc..37a9335e2 100644
--- a/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
+++ b/geode/src/main/java/org/apache/calcite/adapter/geode/util/GeodeUtils.java
@@ -80,15 +80,11 @@ public static synchronized ClientCache createClientCache(
     if (locatorPort != currentLocatorPort
         || !StringUtils.equalsIgnoreCase(currentLocatorHost, locatorHost)) {
       LOGGER.info(
-          "Close existing ClientCache ["
-              + currentLocatorHost
-              + ":"
-              + currentLocatorPort
-              + "] for new Locator connection at: ["
-              + locatorHost
-              + ":"
-              + locatorPort
-              + "]");
+          "Close existing ClientCache [{}:{}] for new Locator connection at: [{}:{}]",
+          currentLocatorHost,
+          currentLocatorPort,
+          locatorHost,
+          locatorPort);
       currentLocatorHost = locatorHost;
       currentLocatorPort = locatorPort;
       closeClientCache();
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
index 66916c761..ab34e87c5 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/IndexCondition.java
@@ -93,19 +93,15 @@ private IndexCondition(
         implicitCollation != null
             ? implicitCollation
             : deduceImplicitCollation(fieldNames, indexColumnNames);
-    this.pushDownConditions =
-        pushDownConditions == null ? ImmutableList.of() : ImmutableList.copyOf(pushDownConditions);
+    this.pushDownConditions = pushDownConditions == null ? ImmutableList.of() : pushDownConditions;
     this.remainderConditions =
-        remainderConditions == null
-            ? ImmutableList.of()
-            : ImmutableList.copyOf(remainderConditions);
+        remainderConditions == null ? ImmutableList.of() : remainderConditions;
     this.queryType = queryType;
-    this.pointQueryKey =
-        pointQueryKey == null ? ImmutableList.of() : ImmutableList.copyOf(pointQueryKey);
+    this.pointQueryKey = pointQueryKey == null ? ImmutableList.of() : pointQueryKey;
     this.rangeQueryLowerOp = Objects.requireNonNull(rangeQueryLowerOp, "rangeQueryLowerOp");
     this.rangeQueryUpperOp = Objects.requireNonNull(rangeQueryUpperOp, "rangeQueryUpperOp");
-    this.rangeQueryLowerKey = ImmutableList.copyOf(rangeQueryLowerKey);
-    this.rangeQueryUpperKey = ImmutableList.copyOf(rangeQueryUpperKey);
+    this.rangeQueryLowerKey = rangeQueryLowerKey;
+    this.rangeQueryUpperKey = rangeQueryUpperKey;
   }
 
   static IndexCondition create(
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java
index 49afe4624..a33f7a7b8 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbFilterTranslator.java
@@ -192,17 +192,8 @@ private IndexCondition findPushDownCondition(List<RexNode> rexNodeList, KeyMeta
             remainderRexNodeList,
             ">=",
             ">");
-    condition =
-        handleRangeQuery(
-            condition,
-            keyMeta,
-            leftMostKeyNodes,
-            pushDownRexNodeList,
-            remainderRexNodeList,
-            "<=",
-            "<");
-
-    return condition;
+    return handleRangeQuery(
+        condition, keyMeta, leftMostKeyNodes, pushDownRexNodeList, remainderRexNodeList, "<=", "<");
   }
 
   /**
@@ -219,8 +210,7 @@ private IndexCondition findPushDownCondition(List<RexNode> rexNodeList, KeyMeta
   private List<InternalRexNode> analyzePrefixMatches(List<RexNode> rexNodeList, KeyMeta keyMeta) {
     return rexNodeList.stream()
         .map(rexNode -> translateMatch2(rexNode, keyMeta))
-        .filter(Optional::isPresent)
-        .map(Optional::get)
+        .flatMap(Optional::stream)
         .collect(Collectors.toList());
   }
 
@@ -243,7 +233,7 @@ private static IndexCondition handlePointQuery(
       List<RexNode> remainderRexNodeList) {
     Optional<InternalRexNode> leftMostEqOpNode = findFirstOp(leftMostKeyNodes, "=");
     if (leftMostEqOpNode.isPresent()) {
-      InternalRexNode node = leftMostEqOpNode.get();
+      InternalRexNode node = leftMostEqOpNode.orElseThrow();
 
       List<InternalRexNode> matchNodes = Lists.newArrayList(node);
       findSubsequentMatches(matchNodes, keyMeta.getNumOfColumns(), keyOrdToNodesMap, "=");
@@ -312,10 +302,10 @@ private static IndexCondition handleRangeQuery(
       String... opList) {
     Optional<InternalRexNode> node = findFirstOp(leftMostKeyNodes, opList);
     if (node.isPresent()) {
-      pushDownRexNodeList.add(node.get().node);
-      remainderRexNodeList.remove(node.get().node);
-      List<Object> key = createKey(Lists.newArrayList(node.get()));
-      ComparisonOperator op = ComparisonOperator.parse(node.get().op);
+      pushDownRexNodeList.add(node.orElseThrow().node);
+      remainderRexNodeList.remove(node.orElseThrow().node);
+      List<Object> key = createKey(Lists.newArrayList(node.orElseThrow()));
+      ComparisonOperator op = ComparisonOperator.parse(node.orElseThrow().op);
       if (ComparisonOperator.isLowerBoundOp(opList)) {
         return condition
             .withQueryType(QueryType.getRangeQuery(keyMeta.isSecondaryKey()))
@@ -364,8 +354,7 @@ private Optional<InternalRexNode> translateBinary(
     if (expression.isPresent()) {
       return expression;
     }
-    expression = translateBinary2(rop, right, left, call, keyMeta);
-    return expression;
+    return translateBinary2(rop, right, left, call, keyMeta);
   }
 
   /** Translates a call to a binary operator. Returns null on failure. */
@@ -411,7 +400,8 @@ private static Optional<InternalRexNode> translateOp2(
     // left-prefix index length should be less than search value literal.
     // For example, we cannot leverage index of EMAIL(3) upon search value
     // `someone@apache.org`, because the value length is longer than 3.
-    if (keyMeta.getVarLen(name).isPresent() && keyMeta.getVarLen(name).get() < value.length()) {
+    if (keyMeta.getVarLen(name).isPresent()
+        && keyMeta.getVarLen(name).orElseThrow() < value.length()) {
       return Optional.empty();
     }
     node.fieldName = name;
@@ -451,7 +441,7 @@ private static void findSubsequentMatches(
     for (int i = nodes.size(); i < numOfKeyColumns; i++) {
       Optional<InternalRexNode> eqOpNode = findFirstOp(keyOrdToNodesMap.get(i), op);
       if (eqOpNode.isPresent()) {
-        nodes.add(eqOpNode.get());
+        nodes.add(eqOpNode.orElseThrow());
       } else {
         break;
       }
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java
index 404823118..43b9493a6 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbRules.java
@@ -260,7 +260,7 @@ protected boolean collationsCompatible(
       if (sortFieldCollations.size() > implicitFieldCollations.size()) {
         return false;
       }
-      if (sortFieldCollations.size() == 0) {
+      if (sortFieldCollations.isEmpty()) {
         return true;
       }
 
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java
index 76f68a567..9feb0c1cc 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbSort.java
@@ -72,9 +72,8 @@ public class InnodbSort extends Sort implements InnodbRel {
     // field collation should be in a series of ascending or descending collations
     checkState(
         allDesc || allNonDesc,
-        "ordering should be in a "
-            + "series of ascending or descending collations "
-            + sortCollations);
+        "ordering should be in a series of ascending or descending collations %s",
+        sortCollations);
     implementor.setAscOrder(!allDesc);
   }
 }
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java
index 0f5c691c8..9cfca08fd 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbTableScan.java
@@ -112,11 +112,11 @@ private Optional<String> getForceIndexName(final List<RelHint> hints) {
         if (!hint.listOptions.isEmpty()) {
           Set<String> indexesNameSet = innodbTable.getIndexesNameSet();
           Optional<String> forceIndexName = hint.listOptions.stream().findFirst();
-          if (!forceIndexName.isPresent()) {
+          if (forceIndexName.isEmpty()) {
             return Optional.empty();
           }
           for (String indexName : indexesNameSet) {
-            if (indexName != null && indexName.equalsIgnoreCase(forceIndexName.get())) {
+            if (indexName != null && indexName.equalsIgnoreCase(forceIndexName.orElseThrow())) {
               return Optional.of(indexName);
             }
           }
diff --git a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java
index fec65615b..5af86369f 100644
--- a/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java
+++ b/innodb/src/main/java/org/apache/calcite/adapter/innodb/InnodbToEnumerableConverter.java
@@ -41,11 +41,11 @@
 import org.apache.calcite.util.Util;
 
 import com.alibaba.innodb.java.reader.comparator.ComparisonOperator;
+import com.google.common.collect.ImmutableList;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.AbstractList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
@@ -181,7 +181,7 @@ private static <T> Expression constantArrayList(List<T> values, Class clazz) {
    */
   private static <T> List<Expression> constantList(List<T> values) {
     if (values.isEmpty()) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
     return Util.transform(values, Expressions::constant);
   }
diff --git a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java
index 218e889f6..25c387f93 100644
--- a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java
+++ b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaStreamTable.java
@@ -41,7 +41,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import java.util.Collections;
 import java.util.Properties;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -81,7 +80,7 @@ public class KafkaStreamTable implements ScannableTable, StreamableTable {
           consumerConfig.putAll(tableOptions.getConsumerParams());
         }
         Consumer consumer = new KafkaConsumer<>(consumerConfig);
-        consumer.subscribe(Collections.singletonList(tableOptions.getTopicName()));
+        consumer.subscribe(ImmutableList.of(tableOptions.getTopicName()));
 
         return new KafkaMessageEnumerator(consumer, tableOptions.getRowConverter(), cancelFlag);
       }
diff --git a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java
index 1e4be7e46..1ab8d2449 100644
--- a/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java
+++ b/kafka/src/main/java/org/apache/calcite/adapter/kafka/KafkaTableFactory.java
@@ -41,9 +41,8 @@ public KafkaTableFactory() {}
     final KafkaTableOptions tableOptionBuilder = new KafkaTableOptions();
 
     tableOptionBuilder.setBootstrapServers(
-        (String) operand.getOrDefault(KafkaTableConstants.SCHEMA_BOOTSTRAP_SERVERS, null));
-    tableOptionBuilder.setTopicName(
-        (String) operand.getOrDefault(KafkaTableConstants.SCHEMA_TOPIC_NAME, null));
+        (String) operand.get(KafkaTableConstants.SCHEMA_BOOTSTRAP_SERVERS));
+    tableOptionBuilder.setTopicName((String) operand.get(KafkaTableConstants.SCHEMA_TOPIC_NAME));
 
     final KafkaRowConverter rowConverter;
     if (operand.containsKey(KafkaTableConstants.SCHEMA_ROW_CONVERTER)) {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java b/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
index 260dd0bf7..b10e65cb9 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java
@@ -68,6 +68,9 @@
 import java.util.Set;
 import java.util.TreeMap;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import static org.apache.calcite.linq4j.Linq4j.CollectionEnumerable;
 import static org.apache.calcite.linq4j.Linq4j.ListEnumerable;
 import static org.apache.calcite.linq4j.Nullness.castNonNull;
@@ -1441,9 +1444,10 @@ public static <TSource, TInner, TResult> Enumerable<TResult> correlateJoin(
       final Enumerable<TSource> outer,
       final Function1<TSource, Enumerable<TInner>> inner,
       final Function2<TSource, ? super @Nullable TInner, TResult> resultSelector) {
-    if (joinType == JoinType.RIGHT || joinType == JoinType.FULL) {
-      throw new IllegalArgumentException("JoinType " + joinType + " is not valid for correlation");
-    }
+    checkArgument(
+        joinType != JoinType.RIGHT && joinType != JoinType.FULL,
+        "JoinType %s is not valid for correlation",
+        joinType);
 
     return new AbstractEnumerable<TResult>() {
       @Override public Enumerator<TResult> enumerator() {
@@ -1980,9 +1984,10 @@ private static <TSource, TInner, TResult> Enumerable<TResult> nestedLoopJoinOpti
       final Predicate2<TSource, TInner> predicate,
       Function2<? super TSource, ? super @Nullable TInner, TResult> resultSelector,
       final JoinType joinType) {
-    if (joinType == JoinType.RIGHT || joinType == JoinType.FULL) {
-      throw new IllegalArgumentException("JoinType " + joinType + " is unsupported");
-    }
+    checkArgument(
+        joinType != JoinType.RIGHT && joinType != JoinType.FULL,
+        "JoinType %s is unsupported",
+        joinType);
 
     return new AbstractEnumerable<TResult>() {
       @Override public Enumerator<TResult> enumerator() {
@@ -2617,7 +2622,7 @@ public static <TSource, TKey> Enumerable<TSource> orderBy(
                   // for first entry, use a singleton list to save space
                   // when we go from 1 to 2 elements, switch to array list
                   if (l == null) {
-                    return Collections.singletonList(o);
+                    return ImmutableList.of(o);
                   }
                   if (l.size() == 1) {
                     l = new ArrayList<>(l);
@@ -2664,7 +2669,7 @@ public static <TSource, TKey> Enumerable<TSource> orderBy(
   /** Sorts the elements of a sequence in descending order according to a key. */
   public static <TSource, TKey extends Comparable> Enumerable<TSource> orderByDescending(
       Enumerable<TSource> source, Function1<TSource, TKey> keySelector) {
-    return orderBy(source, keySelector, Collections.reverseOrder());
+    return orderBy(source, keySelector, Comparator.reverseOrder());
   }
 
   /** Sorts the elements of a sequence in descending order by using a specified comparer. */
@@ -3017,9 +3022,7 @@ public static <TSource> TSource single(Enumerable<TSource> source) {
       if (os.moveNext()) {
         toRet = os.current();
 
-        if (os.moveNext()) {
-          throw new IllegalStateException();
-        }
+        checkState(!os.moveNext());
       }
       if (toRet != null) {
         return toRet;
@@ -3438,7 +3441,7 @@ static <TSource, TKey, TElement> LookupImpl<TKey, TElement> toLookup_(
         List<TElement> list = map.get(key);
         if (list == null) {
           // for first entry, use a singleton list to save space
-          list = Collections.singletonList(elementSelector.apply(o));
+          list = ImmutableList.of(elementSelector.apply(o));
         } else {
           if (list.size() == 1) {
             // when we go from 1 to 2 elements, switch to array list
@@ -4130,7 +4133,7 @@ private boolean advance() {
                   new CartesianProductJoinEnumerator<>(
                       resultSelector,
                       Linq4j.enumerator(lefts),
-                      Linq4j.enumerator(Collections.singletonList(null)));
+                      Linq4j.enumerator(ImmutableList.of(null)));
               return true;
             }
             if (!getLeftEnumerator().moveNext()) {
@@ -4184,7 +4187,7 @@ private boolean advance() {
                   ? new CartesianProductJoinEnumerator<>(
                       resultSelector,
                       Linq4j.enumerator(lefts),
-                      Linq4j.enumerator(Collections.singletonList(rights.get(0))))
+                      Linq4j.enumerator(ImmutableList.of(rights.get(0))))
                   : new CartesianProductJoinEnumerator<>(
                       resultSelector, Linq4j.enumerator(lefts), Linq4j.enumerator(rights));
         } else {
@@ -4223,15 +4226,11 @@ private boolean advanceLeft(TSource left, TKey leftKey) {
         }
         int c = compare(leftKey, leftKey2);
         if (c != 0) {
-          if (c > 0) {
-            throw new IllegalStateException(
-                "mergeJoin assumes inputs sorted in ascending order, "
-                    + "however '"
-                    + leftKey
-                    + "' is greater than '"
-                    + leftKey2
-                    + "'");
-          }
+          checkState(
+              c <= 0,
+              "mergeJoin assumes inputs sorted in ascending order, however '%s' is greater than '%s'",
+              leftKey,
+              leftKey2);
           return true;
         }
         lefts.add(left);
@@ -4260,15 +4259,11 @@ private boolean advanceRight(TInner right, TKey rightKey) {
         }
         int c = compare(rightKey, rightKey2);
         if (c != 0) {
-          if (c > 0) {
-            throw new IllegalStateException(
-                "mergeJoin assumes input sorted in ascending order, "
-                    + "however '"
-                    + rightKey
-                    + "' is greater than '"
-                    + rightKey2
-                    + "'");
-          }
+          checkState(
+              c <= 0,
+              "mergeJoin assumes input sorted in ascending order, however '%s' is greater than '%s'",
+              rightKey,
+              rightKey2);
           return true;
         }
         rights.add(right);
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java b/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
index 28775cc59..75d880e00 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/LookupImpl.java
@@ -151,7 +151,7 @@ class LookupImpl<K, V> extends AbstractEnumerable<Grouping<K, V>> implements Loo
   }
 
   @SuppressWarnings("return.type.incompatible")
-  @Override public Set<Entry<@KeyFor({"this"}) K, Enumerable<V>>> entrySet() {
+  @Override public Set<Entry<@KeyFor("this") K, Enumerable<V>>> entrySet() {
     final Set<Entry<@KeyFor("map") K, List<V>>> entries = map.entrySet();
     return new AbstractSet<Entry<K, Enumerable<V>>>() {
       @Override public Iterator<Entry<K, Enumerable<V>>> iterator() {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java b/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java
index 8a56934a9..5985e7f1e 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/MemoryFactory.java
@@ -20,6 +20,8 @@
 
 import java.util.Arrays;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Contains the State and changes internally. with the {@link #create()} method one can get
  * immutable Snapshots.
@@ -81,17 +83,16 @@ public E get() {
     }
 
     public E get(int position) {
-      if (position < 0 && position < -1 * history) {
-        throw new IllegalArgumentException(
-            "History can only go back "
-                + history
-                + " points in time, you wanted "
-                + Math.abs(position));
-      }
-      if (position > 0 && position > future) {
-        throw new IllegalArgumentException(
-            "Future can only see next " + future + " points in time, you wanted " + position);
-      }
+      checkArgument(
+          position >= 0 || position >= -1 * history,
+          "History can only go back %s points in time, you wanted %s",
+          history,
+          Math.abs(position));
+      checkArgument(
+          position <= 0 || position <= future,
+          "Future can only see next %s points in time, you wanted %s",
+          future,
+          position);
       return (E) this.values[this.offset.plus(position - 1 - future).get()];
     }
   }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java b/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java
index 37402a8a3..804b40f34 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/Nullness.java
@@ -105,7 +105,7 @@ private Nullness() {}
    * @param ref A reference that was @Uninitialized at some point but is now fully initialized
    * @return the argument, cast to have type qualifier @Initialized
    */
-  @SuppressWarnings({"unchecked"})
+  @SuppressWarnings("unchecked")
   @Pure
   public static <T> T castToInitialized(@UnderInitialization T ref) {
     // To throw CheckerFramework off the scent, we put the object into an array,
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java
index 8f3245f7f..b67c42b13 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Functions.java
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.linq4j.function;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.framework.qual.DefaultQualifier;
 import org.checkerframework.framework.qual.TypeUseLocation;
@@ -35,6 +37,8 @@
 import java.util.RandomAccess;
 import java.util.function.IntFunction;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Utilities relating to functions. */
 public abstract class Functions {
   private Functions() {}
@@ -306,7 +310,7 @@ public static <E> List<E> filter(List<E> list, Predicate1<E> predicate) {
         }
       }
       if (hitCount == 0) {
-        return Collections.emptyList();
+        return ImmutableList.of();
       }
       if (missCount == 0) {
         return list;
@@ -345,9 +349,7 @@ public static <E> boolean all(List<? extends E> list, Predicate1<E> predicate) {
    * Returns a list generated by applying a function to each index between 0 and {@code size} - 1.
    */
   public static <E> List<E> generate(final int size, final IntFunction<E> fn) {
-    if (size < 0) {
-      throw new IllegalArgumentException();
-    }
+    checkArgument(size >= 0);
     return new GeneratingList<>(size, fn);
   }
 
@@ -579,10 +581,7 @@ private static final class Ignore<@Nullable R, T0, T1>
 
     @DefaultQualifier(
         value = Nullable.class,
-        locations = {
-          TypeUseLocation.LOWER_BOUND,
-          TypeUseLocation.UPPER_BOUND,
-        })
+        locations = {TypeUseLocation.LOWER_BOUND, TypeUseLocation.UPPER_BOUND})
     static final Ignore INSTANCE = new Ignore<>();
   }
 
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java
index 3123e4173..d467ddfe0 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/function/Parameter.java
@@ -51,7 +51,7 @@
  * will be mandatory.
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.PARAMETER})
+@Target(ElementType.PARAMETER)
 public @interface Parameter {
   /**
    * The name of the parameter.
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
index 090bcf633..69277406d 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/BlockBuilder.java
@@ -106,7 +106,7 @@ public Expression append(String name, BlockStatement block) {
    *     this if the expression has side-effects or a time-dependent value.
    */
   public Expression append(String name, BlockStatement block, boolean optimize) {
-    if (statements.size() > 0) {
+    if (!statements.isEmpty()) {
       Statement lastStatement = statements.get(statements.size() - 1);
       if (lastStatement instanceof GotoStatement) {
         // convert "return expr;" into "expr;"
@@ -199,7 +199,7 @@ public Expression append(String name, Expression expression) {
    * more than once.
    */
   public Expression append(String name, Expression expression, boolean optimize) {
-    if (statements.size() > 0) {
+    if (!statements.isEmpty()) {
       Statement lastStatement = statements.get(statements.size() - 1);
       if (lastStatement instanceof GotoStatement) {
         // convert "return expr;" into "expr;"
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
index 6ec4b9af8..03f9ff843 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/DeterministicCodeOptimizer.java
@@ -171,8 +171,7 @@ && isMethodDeterministic(methodCallExpression.method)) {
       List<Expression> expressions) {
     Expression result = super.visit(methodCallExpression, targetExpression, expressions);
 
-    result = tryOptimizeMethodCall((MethodCallExpression) result);
-    return result;
+    return tryOptimizeMethodCall((MethodCallExpression) result);
   }
 
   @Override public Expression visit(MemberExpression memberExpression, @Nullable Expression expression) {
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
index 048326092..606e7c5b9 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Expressions.java
@@ -38,7 +38,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
 
@@ -63,7 +62,7 @@ public static String toString(List<? extends Node> expressions, String sep, bool
 
   /** Converts an expression to Java source code. */
   public static String toString(Node expression) {
-    return toString(Collections.singletonList(expression), "", true);
+    return toString(ImmutableList.of(expression), "", true);
   }
 
   /**
@@ -203,7 +202,7 @@ public static BinaryExpression andAssign(
    * Creates an expression that represents applying an array index operator to an array of rank one.
    */
   public static IndexExpression arrayIndex(Expression array, Expression indexExpression) {
-    return new IndexExpression(array, Collections.singletonList(indexExpression));
+    return new IndexExpression(array, ImmutableList.of(indexExpression));
   }
 
   /**
@@ -250,7 +249,7 @@ public static BlockStatement block(
       @Nullable Type type, Iterable<? extends Statement> expressions) {
     List<Statement> list = toList(expressions);
     if (type == null) {
-      if (list.size() > 0) {
+      if (!list.isEmpty()) {
         type = list.get(list.size() - 1).getType();
       } else {
         type = Void.TYPE;
@@ -1102,7 +1101,7 @@ public static ForStatement for_(
       @Nullable Expression condition,
       @Nullable Expression post,
       Statement body) {
-    return new ForStatement(Collections.singletonList(declaration), condition, post, body);
+    return new ForStatement(ImmutableList.of(declaration), condition, post, body);
   }
 
   /** Creates a ForEachExpression with the given body. */
@@ -2552,7 +2551,7 @@ private static <T> List<T> toList(Iterable<? extends T> iterable) {
 
   private static <T> List<T> toList(T[] ts) {
     if (ts.length == 0) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     } else {
       return Arrays.asList(ts);
     }
@@ -2598,9 +2597,9 @@ static List<Node> acceptNodes(List<Node> nodes, Shuttle shuttle) {
   static List<Expression> acceptParameterExpressions(
       List<ParameterExpression> parameterExpressions, Shuttle shuttle) {
     if (parameterExpressions.isEmpty()) {
-      return Collections.emptyList(); // short cut
+      return ImmutableList.of(); // short cut
     }
-    final ImmutableList.Builder<Expression> parameterExpressions1 = new ImmutableList.Builder<>();
+    final ImmutableList.Builder<Expression> parameterExpressions1 = ImmutableList.builder();
     for (ParameterExpression parameterExpression : parameterExpressions) {
       parameterExpressions1.add(parameterExpression.accept(shuttle));
     }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
index fe9a3a012..cc3bc7557 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Primitive.java
@@ -952,17 +952,17 @@ && ordinal() >= primitive.ordinal()
   public Number number(Number value) {
     switch (this) {
       case BYTE:
-        return Byte.valueOf(value.byteValue());
+        return value.byteValue();
       case DOUBLE:
-        return Double.valueOf(value.doubleValue());
+        return value.doubleValue();
       case FLOAT:
-        return Float.valueOf(value.floatValue());
+        return value.floatValue();
       case INT:
-        return Integer.valueOf(value.intValue());
+        return value.intValue();
       case LONG:
-        return Long.valueOf(value.longValue());
+        return value.longValue();
       case SHORT:
-        return Short.valueOf(value.shortValue());
+        return value.shortValue();
       default:
         throw new AssertionError(this + ": " + value);
     }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
index 09a8d526f..55165a8bc 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/Types.java
@@ -18,6 +18,8 @@
 
 import org.apache.calcite.linq4j.Enumerator;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.lang.reflect.Array;
@@ -31,7 +33,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
@@ -90,9 +91,9 @@ public static Type of(Type type, Type... typeArguments) {
   private static <T> List<T> toList(T[] ts) {
     switch (ts.length) {
       case 0:
-        return Collections.emptyList();
+        return ImmutableList.of();
       case 1:
-        return Collections.singletonList(ts[0]);
+        return ImmutableList.of(ts[0]);
       default:
         return Arrays.asList(ts.clone());
     }
diff --git a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
index c97ea6d0c..efbc3fb9a 100644
--- a/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
+++ b/linq4j/src/main/java/org/apache/calcite/linq4j/tree/VisitorImpl.java
@@ -34,8 +34,7 @@ public VisitorImpl() {
 
   @Override public R visit(BinaryExpression binaryExpression) {
     R r0 = binaryExpression.expression0.accept(this);
-    R r1 = binaryExpression.expression1.accept(this);
-    return r1;
+    return binaryExpression.expression1.accept(this);
   }
 
   @Override public R visit(BlockStatement blockStatement) {
diff --git a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
index 489d7e62b..d6927693c 100644
--- a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
+++ b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoAggregate.java
@@ -158,7 +158,7 @@ public MongoAggregate(
   private static String toMongo(
       SqlAggFunction aggregation, List<String> inNames, List<Integer> args) {
     if (aggregation == SqlStdOperatorTable.COUNT) {
-      if (args.size() == 0) {
+      if (args.isEmpty()) {
         return "{$sum: 1}";
       } else {
         assert args.size() == 1;
diff --git a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
index a452cfaed..7a36b0665 100644
--- a/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
+++ b/mongodb/src/main/java/org/apache/calcite/adapter/mongodb/MongoRules.java
@@ -216,7 +216,7 @@ protected RexToMongoTranslator(JavaTypeFactory typeFactory, List<String> inField
         return sb.toString();
       }
       throw new IllegalArgumentException(
-          "Translation of " + call.toString() + " is not supported by MongoProject");
+          "Translation of " + call + " is not supported by MongoProject");
     }
 
     private static String stripQuotes(String s) {
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java
index ac5fea049..d35557eef 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigAggregate.java
@@ -104,7 +104,7 @@ private String getPigGroupBy(Implementor implementor) {
     final String relAlias = implementor.getPigRelationAlias(this);
     final List<RelDataTypeField> allFields = getInput().getRowType().getFieldList();
     final List<Integer> groupedFieldIndexes = groupSet.asList();
-    if (groupedFieldIndexes.size() < 1) {
+    if (groupedFieldIndexes.isEmpty()) {
       return relAlias + " = GROUP " + relAlias + " ALL;";
     } else {
       final List<String> groupedFieldNames = new ArrayList<>(groupedFieldIndexes.size());
@@ -175,7 +175,7 @@ private String getPigAggregateCall(String relAlias, AggregateCall aggCall) {
 
   private static PigAggFunction toPigAggFunc(AggregateCall aggCall) {
     return PigAggFunction.valueOf(
-        aggCall.getAggregation().getKind(), aggCall.getArgList().size() < 1);
+        aggCall.getAggregation().getKind(), aggCall.getArgList().isEmpty());
   }
 
   private List<String> getArgNames(String relAlias, AggregateCall aggCall) {
diff --git a/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java b/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java
index eb681b881..8a7f35957 100644
--- a/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java
+++ b/pig/src/main/java/org/apache/calcite/adapter/pig/PigJoin.java
@@ -33,6 +33,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Implementation of {@link org.apache.calcite.rel.core.Join} in {@link PigRel#CONVENTION Pig
  * calling convention}.
@@ -86,13 +88,9 @@ public PigJoin(
    * Only supports simple equi-joins with single column on both sides of <code>=</code>.
    */
   private String getPigJoinStatement(Implementor implementor) {
-    if (!getCondition().isA(SqlKind.EQUALS)) {
-      throw new IllegalArgumentException("Only equi-join are supported");
-    }
+    checkArgument(getCondition().isA(SqlKind.EQUALS), "Only equi-join are supported");
     List<RexNode> operands = ((RexCall) getCondition()).getOperands();
-    if (operands.size() != 2) {
-      throw new IllegalArgumentException("Only equi-join are supported");
-    }
+    checkArgument(operands.size() == 2, "Only equi-join are supported");
     List<Integer> leftKeys = new ArrayList<>(1);
     List<Integer> rightKeys = new ArrayList<>(1);
     List<Boolean> filterNulls = new ArrayList<>(1);
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/Ast.java b/piglet/src/main/java/org/apache/calcite/piglet/Ast.java
index 3a7301504..e9b395188 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/Ast.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/Ast.java
@@ -225,7 +225,7 @@ public ValuesStmt(
         SqlParserPos pos, Identifier target, Schema schema, List<List<Node>> tupleList) {
       super(pos, Op.VALUES, target);
       this.schema = schema;
-      this.tupleList = ImmutableList.copyOf(tupleList);
+      this.tupleList = tupleList;
     }
   }
 
@@ -404,7 +404,7 @@ public static class GroupStmt extends Assignment1 {
     public GroupStmt(SqlParserPos pos, Identifier target, Identifier source, List<Node> keys) {
       super(pos, Op.GROUP, target, source);
       this.keys = keys;
-      assert keys == null || keys.size() >= 1;
+      assert keys == null || !keys.isEmpty();
     }
   }
 
@@ -511,7 +511,7 @@ public static class Call extends Node {
 
     private Call(SqlParserPos pos, Op op, ImmutableList<Node> operands) {
       super(pos, op);
-      this.operands = ImmutableList.copyOf(operands);
+      this.operands = operands.asList();
     }
 
     public Call(SqlParserPos pos, Op op, Iterable<? extends Node> operands) {
@@ -571,7 +571,7 @@ public static class Schema extends Node {
 
     public Schema(SqlParserPos pos, List<FieldSchema> fieldSchemaList) {
       super(pos, Op.SCHEMA);
-      this.fieldSchemaList = ImmutableList.copyOf(fieldSchemaList);
+      this.fieldSchemaList = fieldSchemaList;
     }
   }
 
@@ -608,7 +608,7 @@ public static class TupleType extends Type {
 
     public TupleType(SqlParserPos pos, List<FieldSchema> fieldSchemaList) {
       super(pos, Op.TUPLE_TYPE);
-      this.fieldSchemaList = ImmutableList.copyOf(fieldSchemaList);
+      this.fieldSchemaList = fieldSchemaList;
     }
   }
 
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
index 872d30673..c643590a7 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelBuilder.java
@@ -54,7 +54,6 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -502,8 +501,7 @@ public RelBuilder multiSetFlatten() {
     // [CALCITE-3193] Add RelBuilder.uncollect method, and interface
     // UncollectFactory, to instantiate Uncollect
     Uncollect uncollect =
-        Uncollect.create(
-            cluster.traitSetOf(Convention.NONE), build(), false, Collections.emptyList());
+        Uncollect.create(cluster.traitSetOf(Convention.NONE), build(), false, ImmutableList.of());
     push(uncollect);
     return this;
   }
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
index 27a2f168f..8b74da9ec 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelExVisitor.java
@@ -73,6 +73,8 @@
 import java.util.Deque;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Visits pig expression plans and converts them into corresponding RexNodes. */
 class PigRelExVisitor extends LogicalExpressionVisitor {
   /** Stack used during post-order walking process when processing a Pig expression plan. */
@@ -217,10 +219,8 @@ private ImmutableList<RexNode> buildBinaryOperands() {
               break;
             }
           }
-          if (index < 0) {
-            throw new IllegalArgumentException(
-                "field [" + fullAlias + "] not found; input fields are: " + fieldNames);
-          }
+          checkArgument(
+              index >= 0, "field [%s] not found; input fields are: %s", fullAlias, fieldNames);
         }
         inputRef = builder.field(inputCount, inputOrdinal, index);
       }
@@ -375,7 +375,7 @@ private static int optSize(List<Operator> list) {
   @Override public void visit(DereferenceExpression op) throws FrontendException {
     final RexNode parentField = stack.pop();
     List<Integer> cols = op.getBagColumns();
-    assert cols != null && cols.size() > 0;
+    assert cols != null && !cols.isEmpty();
 
     if (parentField.getType() instanceof MultisetSqlType) {
       // Calcite does not support projection on Multiset type. We build
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java
index 8b36e2044..303b08d5a 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpInnerVisitor.java
@@ -46,6 +46,8 @@
 import java.util.Deque;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * Visits Pig logical operators of Pig inner logical plans (in {@link
  * org.apache.pig.newplan.logical.relational.LOForEach}) and converts them into corresponding
@@ -86,7 +88,7 @@ class PigRelOpInnerVisitor extends PigRelOpVisitor {
     final List<Integer> multisetFlattens = new ArrayList<>();
     final List<String> flattenOutputAliases = new ArrayList<>();
     doGenerateWithoutMultisetFlatten(gen, multisetFlattens, flattenOutputAliases);
-    if (multisetFlattens.size() > 0) {
+    if (!multisetFlattens.isEmpty()) {
       builder.multiSetFlatten(multisetFlattens, flattenOutputAliases);
     }
   }
@@ -110,7 +112,7 @@ private void makeCorrelates() throws FrontendException {
         corRels.add(0, builder.build());
       }
 
-      assert corRels.size() > 0;
+      assert !corRels.isEmpty();
       builder.push(corRels.get(0));
       builder.collect();
       // Now collapse these rels to a single multiset row and join them together
@@ -144,10 +146,10 @@ private void doGenerateWithoutMultisetFlatten(
     final List<RexNode> innerCols = new ArrayList<>(); // For projection expressions
     final List<String> fieldAlias = new ArrayList<>(); // For projection names/alias
 
-    if (gen.getOutputPlanSchemas() == null) {
-      throw new IllegalArgumentException(
-          "Generate statement at line " + gen.getLocation().line() + " produces empty schema");
-    }
+    checkArgument(
+        gen.getOutputPlanSchemas() != null,
+        "Generate statement at line %s produces empty schema",
+        gen.getLocation().line());
 
     for (int i = 0; i < pigProjections.size(); i++) {
       final LogicalSchema outputFieldSchema = gen.getOutputPlanSchemas().get(i);
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
index e80ca50d8..c05de04c2 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelOpVisitor.java
@@ -72,11 +72,12 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Visits Pig logical operators and converts them into corresponding relational algebra plans. */
 class PigRelOpVisitor extends PigRelOpWalker.PlanPreVisitor {
   // The relational algebra builder customized for Pig
@@ -291,7 +292,7 @@ private void processCube(GroupType groupType, LOCogroup loCogroup) throws Fronte
     preprocessCogroup(loCogroup, true);
 
     // Generate the group set for the corresponding group type.
-    ImmutableList.Builder<ImmutableBitSet> groupsetBuilder = new ImmutableList.Builder<>();
+    ImmutableList.Builder<ImmutableBitSet> groupsetBuilder = ImmutableList.builder();
     List<Integer> keyIndexs = new ArrayList<>();
     groupsetBuilder.add(ImmutableBitSet.of(keyIndexs));
     int groupCount = loCogroup.getExpressionPlans().get(0).size();
@@ -401,7 +402,7 @@ private List<RexNode> getGroupRowOperands(List<RexNode> fieldRels, boolean isCub
           cubeRowFields.add(field);
         }
       }
-      return ImmutableList.copyOf(cubeRowFields);
+      return cubeRowFields;
     }
     return rowFields;
   }
@@ -500,7 +501,7 @@ private static GroupType getGroupType(LOCogroup pigGroup) {
     boolean[] innerFlags = new boolean[numInputs];
     for (int i = 0; i < numInputs; i++) {
       // Adding empty join keys
-      joinPlans.put(i, Collections.emptyList());
+      joinPlans.put(i, ImmutableList.of());
       innerFlags[i] = true;
     }
     joinInternal(joinPlans, innerFlags);
@@ -568,11 +569,9 @@ private static JoinRelType getJoinType(boolean leftInner, boolean rightInner) {
     // support UNION of input with different schemas, so we need to make sure to have inputs
     // with same schema first.
     LogicalSchema unionSchema = loUnion.getSchema();
-    if (unionSchema == null) {
-      throw new IllegalArgumentException(
-          "UNION on incompatible types is not supported. "
-              + "Please consider using ONSCHEMA option");
-    }
+    checkArgument(
+        unionSchema != null,
+        "UNION on incompatible types is not supported. " + "Please consider using ONSCHEMA option");
     // First get the shared schema
     int numInputs = loUnion.getInputs().size();
     RelDataType unionRelType = PigTypes.convertSchema(unionSchema);
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java b/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java
index 3541fc530..8f800b30c 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigRelSqlUdfs.java
@@ -51,7 +51,6 @@
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 import static org.apache.calcite.piglet.PigTypes.TYPE_FACTORY;
@@ -318,9 +317,7 @@ public static Tuple buildBag(Object... elements) {
     if (elements != null) {
       // The first input contains a list of rows for the bag
       final List bag =
-          (elements[0] instanceof List)
-              ? (List) elements[0]
-              : Collections.singletonList(elements[0]);
+          (elements[0] instanceof List) ? (List) elements[0] : ImmutableList.of(elements[0]);
       for (Object row : bag) {
         tupleList.add(tupleFactory.newTuple(Arrays.asList(row)));
       }
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java b/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
index dc814d499..ff4628a6b 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigToSqlAggregateRule.java
@@ -396,7 +396,7 @@ private static List<Integer> getAggColumns(RexCall pigAggCall) {
 
   private static List<Integer> getColsFromMultisetProjection(RexCall multisetProjection) {
     final List<Integer> columns = new ArrayList<>();
-    assert multisetProjection.getOperands().size() >= 1;
+    assert !multisetProjection.getOperands().isEmpty();
     for (int i = 1; i < multisetProjection.getOperands().size(); i++) {
       final RexLiteral indexLiteral = (RexLiteral) multisetProjection.getOperands().get(i);
       columns.add(((BigDecimal) indexLiteral.getValue()).intValue());
diff --git a/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java b/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java
index 184d2a0df..1e8e80634 100644
--- a/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java
+++ b/piglet/src/main/java/org/apache/calcite/piglet/PigTypes.java
@@ -28,6 +28,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /** Utility methods for converting Pig data types to SQL types. */
 class PigTypes {
   private PigTypes() {}
@@ -122,9 +124,10 @@ static RelDataType convertSchemaField(
       case DataType.TUPLE:
         {
           if (pigField.alias != null && pigField.alias.equals(PIG_TUPLE_WRAPPER)) {
-            if (pigField.schema == null || pigField.schema.size() != 1) {
-              throw new IllegalArgumentException("Expect one subfield from " + pigField.schema);
-            }
+            checkArgument(
+                pigField.schema != null && pigField.schema.size() == 1,
+                "Expect one subfield from %s",
+                pigField.schema);
             return convertSchemaField(pigField.schema.getField(0), nullable);
           }
           return convertSchema(pigField.schema, nullable);
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
index 5279d48f0..db7e880e5 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/FilesTableFunction.java
@@ -158,7 +158,7 @@ private Enumerable<String> sourceMacOs() {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
         JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
-        final List<String> fieldNames = ImmutableList.copyOf(rowType.getFieldNames());
+        final List<String> fieldNames = rowType.getFieldNames();
         final String osName = System.getProperty("os.name");
         final String osVersion = System.getProperty("os.version");
         Util.discard(osVersion);
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java
index ca502b3db..0906a0334 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/GitCommitsTableFunction.java
@@ -75,7 +75,7 @@ public static ScannableTable eval(boolean b) {
                 objects = new Object[9];
                 for (; ; ) {
                   final String line = e.current();
-                  if (line.length() == 0) {
+                  if (line.isEmpty()) {
                     break; // next line will be start of comments
                   }
                   if (line.startsWith("commit ")) {
@@ -120,7 +120,7 @@ public static ScannableTable eval(boolean b) {
                     return true;
                   }
                   final String line = e.current();
-                  if (line.length() == 0) {
+                  if (line.isEmpty()) {
                     // We're seeing the empty line at the end of message
                     objects[8] = b.toString();
                     b.setLength(0);
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java
index da13c673c..93c9ea83a 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/PsTableFunction.java
@@ -56,7 +56,7 @@ public static ScannableTable eval(boolean b) {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
         JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
-        final List<String> fieldNames = ImmutableList.copyOf(rowType.getFieldNames());
+        final List<String> fieldNames = rowType.getFieldNames();
         final String[] args;
         final String osName = System.getProperty("os.name");
         final String osVersion = System.getProperty("os.version");
diff --git a/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java b/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
index 2626a1893..3d0a09f46 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/os/VmstatTableFunction.java
@@ -49,7 +49,7 @@ public static ScannableTable eval(boolean b) {
       @Override public Enumerable<@Nullable Object[]> scan(DataContext root) {
         JavaTypeFactory typeFactory = root.getTypeFactory();
         final RelDataType rowType = getRowType(typeFactory);
-        final List<String> fieldNames = ImmutableList.copyOf(rowType.getFieldNames());
+        final List<String> fieldNames = rowType.getFieldNames();
         final String[] args;
         final String osName = System.getProperty("os.name");
         final String osVersion = System.getProperty("os.version");
diff --git a/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java b/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
index fe479d404..6be630545 100644
--- a/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
+++ b/plus/src/main/java/org/apache/calcite/adapter/tpcds/TpcdsSchema.java
@@ -206,11 +206,13 @@ private RelDataType type(RelDataTypeFactory typeFactory, Column column) {
           return typeFactory.createSqlType(SqlTypeName.BIGINT);
         case DECIMAL:
           return typeFactory.createSqlType(
-              SqlTypeName.DECIMAL, type.getPrecision().get(), type.getScale().get());
+              SqlTypeName.DECIMAL,
+              type.getPrecision().orElseThrow(),
+              type.getScale().orElseThrow());
         case VARCHAR:
-          return typeFactory.createSqlType(SqlTypeName.VARCHAR, type.getPrecision().get());
+          return typeFactory.createSqlType(SqlTypeName.VARCHAR, type.getPrecision().orElseThrow());
         case CHAR:
-          return typeFactory.createSqlType(SqlTypeName.CHAR, type.getPrecision().get());
+          return typeFactory.createSqlType(SqlTypeName.CHAR, type.getPrecision().orElseThrow());
         default:
           throw new AssertionError(type.getBase() + ": " + column);
       }
diff --git a/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java b/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java
index c81318f4b..9f544178d 100644
--- a/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java
+++ b/redis/src/main/java/org/apache/calcite/adapter/redis/RedisSchema.java
@@ -24,7 +24,6 @@
 
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 
 import java.util.ArrayList;
@@ -63,9 +62,7 @@ class RedisSchema extends AbstractSchema {
             .map(e -> e.name)
             .collect(Collectors.toSet());
     tableMap =
-        Maps.asMap(
-            ImmutableSet.copyOf(tableNames),
-            CacheBuilder.newBuilder().build(CacheLoader.from(this::table)));
+        Maps.asMap(tableNames, CacheBuilder.newBuilder().build(CacheLoader.from(this::table)));
     return tableMap;
   }
 
diff --git a/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java b/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
index 5cbe360d8..f236501cb 100644
--- a/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
+++ b/spark/src/main/java/org/apache/calcite/adapter/spark/SparkRules.java
@@ -447,8 +447,7 @@ public static void main(String[] args) {
                       if (!x.startsWith("a")) {
                         return Collections.emptyIterator();
                       }
-                      return Collections.singletonList(
-                              Pair.of(x.toUpperCase(Locale.ROOT), x.length()))
+                      return ImmutableList.of(Pair.of(x.toUpperCase(Locale.ROOT), x.length()))
                           .iterator();
                     })
             .take(5)
diff --git a/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java b/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
index 0e7302975..9c52f14ed 100644
--- a/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
+++ b/splunk/src/main/java/org/apache/calcite/adapter/splunk/SplunkDriver.java
@@ -31,6 +31,8 @@
 import java.util.Map;
 import java.util.Properties;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 /**
  * JDBC driver for Splunk.
  *
@@ -59,20 +61,14 @@ protected SplunkDriver() {
     SplunkConnection splunkConnection;
     try {
       String url1 = info.getProperty("url");
-      if (url1 == null) {
-        throw new IllegalArgumentException("Must specify 'url' property");
-      }
+      checkArgument(url1 != null, "Must specify 'url' property");
       if (url1.equals("mock")) {
         splunkConnection = new MockSplunkConnection();
       } else {
         String user = info.getProperty("user");
-        if (user == null) {
-          throw new IllegalArgumentException("Must specify 'user' property");
-        }
+        checkArgument(user != null, "Must specify 'user' property");
         String password = info.getProperty("password");
-        if (password == null) {
-          throw new IllegalArgumentException("Must specify 'password' property");
-        }
+        checkArgument(password != null, "Must specify 'password' property");
         URL url2 = new URL(url1);
         splunkConnection = new SplunkConnectionImpl(url2, user, password);
       }
diff --git a/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java b/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java
index ab3827926..bae9b74a5 100644
--- a/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java
+++ b/splunk/src/main/java/org/apache/calcite/adapter/splunk/search/SplunkConnectionImpl.java
@@ -46,6 +46,8 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.runtime.HttpUtils.appendURLEncodedArgs;
 import static org.apache.calcite.runtime.HttpUtils.post;
 
@@ -204,10 +206,10 @@ public static void parseArgs(String[] args, Map<String, String> map) {
       String argName = args[i++];
       String argValue = i < args.length ? args[i] : "";
 
-      if (!argName.startsWith("-")) {
-        throw new IllegalArgumentException(
-            "invalid argument name: " + argName + ". Argument names must start with -");
-      }
+      checkArgument(
+          argName.startsWith("-"),
+          "invalid argument name: %s. Argument names must start with -",
+          argName);
       map.put(argName.substring(1), argValue);
     }
   }
diff --git a/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java b/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
index 171bf95d7..d768a3f74 100644
--- a/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
+++ b/splunk/src/main/java/org/apache/calcite/adapter/splunk/util/StringUtils.java
@@ -16,6 +16,8 @@
  */
 package org.apache.calcite.adapter.splunk.util;
 
+import com.google.common.base.Strings;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -108,7 +110,7 @@ public static List<String> decodeList(CharSequence encoded, char delim) {
   }
 
   public static boolean parseBoolean(String str, boolean defaultVal, boolean missingVal) {
-    if (str == null || str.isEmpty()) {
+    if (Strings.isNullOrEmpty(str)) {
       return missingVal;
     }
     if (str.equalsIgnoreCase("t")
diff --git a/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java b/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
index 0a777a03c..ee02a1a3e 100644
--- a/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
+++ b/testkit/src/main/java/org/apache/calcite/sql/parser/SqlParserTest.java
@@ -2539,7 +2539,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * naturally arise whenever a production uses "&lt;IDENTIFIER&gt;") are removed, but reserved
    * words such as "AND" remain.
    */
-  @Test void testExceptionCleanup() {
+  @Test void exceptionCleanup() {
     sql("select 0.5e1^.1^ from sales.emps")
         .fails(
             "(?s).*Encountered \".1\" at line 1, column 13.\n"
@@ -2550,7 +2550,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
                 + ".*");
   }
 
-  @Test void testInvalidToken() {
+  @Test void invalidToken() {
     // Causes problems to the test infrastructure because the token mgr
     // throws a java.lang.Error. The usual case is that the parser throws
     // an exception.
@@ -2559,12 +2559,12 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   }
 
   // TODO: should fail in parser
-  @Test void testStarAsFails() {
+  @Test void starAsFails() {
     sql("select * as x from emp").ok("SELECT * AS `X`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testFromStarFails() {
+  @Test void fromStarFails() {
     sql("select * from sales^.^*").fails("(?s)Encountered \"\\. \\*\" at .*");
     sql("select emp.empno AS x from sales^.^*").fails("(?s)Encountered \"\\. \\*\" at .*");
     sql("select * from emp^.^*").fails("(?s)Encountered \"\\. \\*\" at .*");
@@ -2572,13 +2572,13 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql("select emp.empno AS x from ^*^").fails("(?s)Encountered \"\\*\" at .*");
   }
 
-  @Test void testPercentileCont() {
+  @Test void percentileCont() {
     sql("select percentile_cont(.5) within group (order by 3) from t")
         .ok("SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY 3)\n"
   + "FROM `T`");
   }
 
-  @Test void testPercentileDisc() {
+  @Test void percentileDisc() {
     sql("select percentile_disc(.5) within group (order by 3) from t")
         .ok("SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY 3)\n"
   + "FROM `T`");
@@ -2588,7 +2588,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * Tests BigQuery's variant of PERCENTILE_CONT, which uses OVER rather than WITHIN GROUP, and
    * allows RESPECT/IGNORE NULLS inside the parentheses.
    */
-  @Test void testPercentileContBigQuery() {
+  @Test void percentileContBigQuery() {
     sql("select percentile_cont(x, .5) over() from unnest(array[1,2,3,4]) as x")
         .withDialect(BIG_QUERY)
         .ok("SELECT (PERCENTILE_CONT(x, 0.5) OVER ())\n"
@@ -2609,7 +2609,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * Tests BigQuery's variant of PERCENTILE_DISC, which uses OVER rather than WITHIN GROUP, and
    * allows RESPECT/IGNORE NULLS inside the parentheses.
    */
-  @Test void testPercentileDiscBigQuery() {
+  @Test void percentileDiscBigQuery() {
     sql("select percentile_disc(x, .5) over() from unnest(array[1,2,3,4]) as x")
         .withDialect(BIG_QUERY)
         .ok("SELECT (PERCENTILE_DISC(x, 0.5) OVER ())\n"
@@ -2626,7 +2626,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
                 + "FROM UNNEST((ARRAY[1, NULL, 3, 4])) AS x");
   }
 
-  @Test void testHyphenatedTableName() {
+  @Test void hyphenatedTableName() {
     sql("select * from bigquery^-^foo-bar.baz")
         .fails("(?s)Encountered \"-\" at .*")
         .withDialect(BIG_QUERY)
@@ -2724,7 +2724,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .fails("(?s)Encountered \"-\" at .*");
   }
 
-  @Test void testHyphenatedColumnName() {
+  @Test void hyphenatedColumnName() {
     // While BigQuery allows hyphenated table names, no dialect allows
     // hyphenated column names; they are parsed as arithmetic minus.
     final String expected = "SELECT (`FOO` - `BAR`)\n"
@@ -2734,14 +2734,14 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql("select foo-bar from emp").ok(expected).withDialect(BIG_QUERY).ok(expectedBigQuery);
   }
 
-  @Test void testDerivedColumnList() {
+  @Test void derivedColumnList() {
     sql("select * from emp as e (empno, gender) where true")
         .ok("SELECT *\n"
   + "FROM `EMP` AS `E` (`EMPNO`, `GENDER`)\n"
   + "WHERE TRUE");
   }
 
-  @Test void testDerivedColumnListInJoin() {
+  @Test void derivedColumnListInJoin() {
     final String sql =
         "select * from emp as e (empno, gender)\n"
             + " join dept as d (deptno, dname) on emp.deptno = dept.deptno";
@@ -2756,7 +2756,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
    * Test case that does not reproduce but is related to <a href="https://issues.apache.org/jira/browse/CALCITE-2637">[CALCITE-2637] Prefix '-' operator
    * failed between BETWEEN and AND</a>.
    */
-  @Test void testBetweenAnd() {
+  @Test void betweenAnd() {
     final String sql = "select * from emp\n"
   + "where deptno between - DEPTNO + 1 and 5";
     final String expected =
@@ -2766,7 +2766,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql(sql).ok(expected);
   }
 
-  @Test void testBetweenAnd2() {
+  @Test void betweenAnd2() {
     final String sql = "select * from emp\n"
   + "where deptno between - DEPTNO + 1 and - empno - 3";
     final String expected =
@@ -2778,40 +2778,40 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   }
 
   @Disabled
-  @Test void testDerivedColumnListNoAs() {
+  @Test void derivedColumnListNoAs() {
     sql("select * from emp e (empno, gender) where true").ok("foo");
   }
 
   // jdbc syntax
   @Disabled
-  @Test void testEmbeddedCall() {
+  @Test void embeddedCall() {
     expr("{call foo(?, ?)}").ok("foo");
   }
 
   @Disabled
-  @Test void testEmbeddedFunction() {
+  @Test void embeddedFunction() {
     expr("{? = call bar (?, ?)}").ok("foo");
   }
 
-  @Test void testColumnAliasWithAs() {
+  @Test void columnAliasWithAs() {
     sql("select 1 as foo from emp").ok("SELECT 1 AS `FOO`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testColumnAliasWithoutAs() {
+  @Test void columnAliasWithoutAs() {
     sql("select 1 foo from emp").ok("SELECT 1 AS `FOO`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testEmbeddedDate() {
+  @Test void embeddedDate() {
     expr("{d '1998-10-22'}").ok("DATE '1998-10-22'");
   }
 
-  @Test void testEmbeddedTime() {
+  @Test void embeddedTime() {
     expr("{t '16:22:34'}").ok("TIME '16:22:34'");
   }
 
-  @Test void testEmbeddedTimestamp() {
+  @Test void embeddedTimestamp() {
     expr("{ts '1998-10-22 16:22:34'}").ok("TIMESTAMP '1998-10-22 16:22:34'");
   }
 
@@ -2821,7 +2821,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   + "FROM `T`");
   }
 
-  @Test void testBooleanPrecedenceAndAssociativity() {
+  @Test void booleanPrecedenceAndAssociativity() {
     sql("select * from t where true and false")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -2842,7 +2842,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   + "WHERE (1 AND TRUE)");
   }
 
-  @Test void testLessThanAssociativity() {
+  @Test void lessThanAssociativity() {
     expr("NOT a = b").ok("(NOT (`A` = `B`))");
 
     // comparison operators are left-associative
@@ -2886,7 +2886,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .ok("((NOT (NOT (`A` = `B`))) OR (NOT (NOT (`C` = `D`))))");
   }
 
-  @Test void testIsBooleans() {
+  @Test void isBooleans() {
     String[] inOuts = {"NULL", "TRUE", "FALSE", "UNKNOWN"};
 
     for (String inOut : inOuts) {
@@ -2902,7 +2902,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     }
   }
 
-  @Test void testIsBooleanPrecedenceAndAssociativity() {
+  @Test void isBooleanPrecedenceAndAssociativity() {
     sql("select * from t where x is unknown is not unknown")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -2935,14 +2935,14 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql(sql).ok(expected);
   }
 
-  @Test void testEqualNotEqual() {
+  @Test void equalNotEqual() {
     expr("'abc'=123").ok("('abc' = 123)");
     expr("'abc'<>123").ok("('abc' <> 123)");
     expr("'abc'<>123='def'<>456").ok("((('abc' <> 123) = 'def') <> 456)");
     expr("'abc'<>123=('def'<>456)").ok("(('abc' <> 123) = ('def' <> 456))");
   }
 
-  @Test void testBangEqualIsBad() {
+  @Test void bangEqualIsBad() {
     // Quoth www.ocelot.ca:
     //   "Other relators besides '=' are what you'd expect if
     //   you've used any programming language: > and >= and < and <=. The
@@ -2955,7 +2955,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .fails("Bang equal '!=' is not allowed under the current SQL conformance level");
   }
 
-  @Test void testBetween() {
+  @Test void between() {
     sql("select * from t where price between 1 and 2")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -3038,13 +3038,13 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
         .ok("VALUES (ROW((`A` BETWEEN ASYMMETRIC ((`B` OR (`C` AND `D`)) OR `E`) AND `F`)))");
   }
 
-  @Test void testOperateOnColumn() {
+  @Test void operateOnColumn() {
     sql("select c1*1,c2  + 2,c3/3,c4-4,c5*c4  from t")
         .ok("SELECT (`C1` * 1), (`C2` + 2), (`C3` / 3), (`C4` - 4), (`C5` * `C4`)\n"
   + "FROM `T`");
   }
 
-  @Test void testRow() {
+  @Test void row() {
     sql("select t.r.\"EXPR$1\", t.r.\"EXPR$0\" from (select (1,2) r from sales.depts) t")
         .ok(
             "SELECT `T`.`R`.`EXPR$1`, `T`.`R`.`EXPR$0`\n"
@@ -3095,7 +3095,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
     sql(whereRow2).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(whereExpected);
   }
 
-  @Test void testRowValueExpression() {
+  @Test void rowValueExpression() {
     final String expected0 =
         "INSERT INTO \"EMPS\"\n"
   + "VALUES (ROW(1, 'Fred')),\n"
@@ -3127,7 +3127,7 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
                 + "WHERE (`DEPT`.`DEPTNO` = `EMP`.`DEPTNO`)), `EMP`.`ENAME`))");
   }
 
-  @Test void testRowWithDot() {
+  @Test void rowWithDot() {
     sql("select (1,2).a from c.t").ok("SELECT ((ROW(1, 2)).`A`)\n"
   + "FROM `C`.`T`");
     sql("select row(1,2).a from c.t").ok("SELECT ((ROW(1, 2)).`A`)\n"
@@ -3137,19 +3137,19 @@ protected static SortedSet<String> keywords(@Nullable String dialect) {
   + "FROM `TBL`");
   }
 
-  @Test void testDotAfterParenthesizedIdentifier() {
+  @Test void dotAfterParenthesizedIdentifier() {
     sql("select (a).c.d from c.t").ok("SELECT ((`A`.`C`).`D`)\n"
   + "FROM `C`.`T`");
   }
 
-  @Test void testPeriod() {
+  @Test void period() {
     // We don't have a PERIOD constructor currently;
     // ROW constructor is sufficient for now.
     expr("period (date '1969-01-05', interval '2-3' year to month)")
         .ok("(ROW(DATE '1969-01-05', INTERVAL '2-3' YEAR TO MONTH))");
   }
 
-  @Test void testOverlaps() {
+  @Test void overlaps() {
     final String[] ops = {
       "overlaps", "equals", "precedes", "succeeds", "immediately precedes", "immediately succeeds"
     };
@@ -3183,35 +3183,35 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Parses a list of statements (that contains only one statement). */
-  @Test void testStmtListWithSelect() {
+  @Test void stmtListWithSelect() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept").list().ok(expected);
   }
 
-  @Test void testStmtListWithSelectAndSemicolon() {
+  @Test void stmtListWithSelectAndSemicolon() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept;").list().ok(expected);
   }
 
-  @Test void testStmtListWithTwoSelect() {
+  @Test void stmtListWithTwoSelect() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept ; select * from emp, dept").list().ok(expected, expected);
   }
 
-  @Test void testStmtListWithTwoSelectSemicolon() {
+  @Test void stmtListWithTwoSelectSemicolon() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
     sql("select * from emp, dept ; select * from emp, dept;").list().ok(expected, expected);
   }
 
-  @Test void testStmtListWithSelectDelete() {
+  @Test void stmtListWithSelectDelete() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`";
@@ -3219,7 +3219,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select * from emp, dept; delete from emp").list().ok(expected, expected1);
   }
 
-  @Test void testStmtListWithSelectDeleteUpdate() {
+  @Test void stmtListWithSelectDeleteUpdate() {
     final String sql =
         "select * from emp, dept; " + "delete from emp; " + "update emps set empno = empno + 1";
     final String expected = "SELECT *\n"
@@ -3230,7 +3230,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).list().ok(expected, expected1, expected2);
   }
 
-  @Test void testStmtListWithSemiColonInComment() {
+  @Test void stmtListWithSemiColonInComment() {
     final String sql =
         "" + "select * from emp, dept; // comment with semicolon ; values 1\n"
   + "values 2";
@@ -3241,7 +3241,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).list().ok(expected, expected1);
   }
 
-  @Test void testStmtListWithSemiColonInWhere() {
+  @Test void stmtListWithSemiColonInWhere() {
     final String expected = "SELECT *\n"
   + "FROM `EMP`\n"
   + "WHERE (`NAME` LIKE 'toto;')";
@@ -3251,7 +3251,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected, expected1);
   }
 
-  @Test void testStmtListWithInsertSelectInsert() {
+  @Test void stmtListWithInsertSelectInsert() {
     final String sql =
         "insert into dept (name, deptno) values ('a', 123); "
             + "select * from emp where name like 'toto;'; "
@@ -3267,14 +3267,14 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Should fail since the first statement lacks semicolon. */
-  @Test void testStmtListWithoutSemiColon1() {
+  @Test void stmtListWithoutSemiColon1() {
     sql("select * from emp where name like 'toto' " + "^delete^ from emp")
         .list()
         .fails("(?s).*Encountered \"delete\" at .*");
   }
 
   /** Should fail since the third statement lacks semicolon. */
-  @Test void testStmtListWithoutSemiColon2() {
+  @Test void stmtListWithoutSemiColon2() {
     sql("select * from emp where name like 'toto'; "
             + "delete from emp; "
             + "insert into dept (name, deptno) values ('a', 123) "
@@ -3283,7 +3283,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"select\" at .*");
   }
 
-  @Test void testIsDistinctFrom() {
+  @Test void isDistinctFrom() {
     sql("select x is distinct from y from t")
         .ok("SELECT (`X` IS DISTINCT FROM `Y`)\n"
   + "FROM `T`");
@@ -3314,7 +3314,7 @@ void checkPeriodPredicate(Checker checker) {
   + "WHERE ((TRUE IS DISTINCT FROM TRUE) IS TRUE)");
   }
 
-  @Test void testIsNotDistinct() {
+  @Test void isNotDistinct() {
     sql("select x is not distinct from y from t")
         .ok("SELECT (`X` IS NOT DISTINCT FROM `Y`)\n"
   + "FROM `T`");
@@ -3325,7 +3325,7 @@ void checkPeriodPredicate(Checker checker) {
   + "WHERE (TRUE IS NOT DISTINCT FROM TRUE)");
   }
 
-  @Test void testFloor() {
+  @Test void floor() {
     expr("floor(1.5)").ok("FLOOR(1.5)");
     expr("floor(x)").ok("FLOOR(`X`)");
 
@@ -3378,7 +3378,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok("FLOOR((`X` + INTERVAL '1:20' MINUTE TO SECOND) TO MILLENNIUM)");
   }
 
-  @Test void testCeil() {
+  @Test void ceil() {
     expr("ceil(3453.2)").ok("CEIL(3453.2)");
     expr("ceil(x)").ok("CEIL(`X`)");
     expr("ceil(x to second)").ok("CEIL(`X` TO SECOND)");
@@ -3430,7 +3430,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok("CEIL((`X` + INTERVAL '1:20' MINUTE TO SECOND) TO MILLENNIUM)");
   }
 
-  @Test void testCast() {
+  @Test void cast() {
     expr("cast(x as boolean)").ok("CAST(`X` AS BOOLEAN)");
     expr("cast(x as integer)").ok("CAST(`X` AS INTEGER)");
     expr("cast(x as varchar(1))").ok("CAST(`X` AS VARCHAR(1))");
@@ -3465,7 +3465,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("cast('foo' as bar)").ok("CAST('foo' AS `BAR`)");
   }
 
-  @Test void testCastFails() {
+  @Test void castFails() {
     expr("cast(x as time with ^time^ zone)").fails("(?s).*Encountered \"time\" at .*");
     expr("cast(x as time(0) with ^time^ zone)").fails("(?s).*Encountered \"time\" at .*");
     expr("cast(x as timestamp with ^time^ zone)").fails("(?s).*Encountered \"time\" at .*");
@@ -3480,7 +3480,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test for MSSQL CONVERT parsing, with focus on iffy DATE type and testing that the extra "style"
    * operand is parsed Other tests are defined in functions.iq
    */
-  @Test void testMssqlConvert() {
+  @Test void mssqlConvert() {
     expr("CONVERT(VARCHAR(5), 'xx')").same();
     expr("CONVERT(VARCHAR(5), 'xx')").same();
     expr("CONVERT(VARCHAR(5), NULL)").same();
@@ -3489,7 +3489,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("CONVERT(DATE, 'xx')").same();
   }
 
-  @Test void testLikeAndSimilar() {
+  @Test void likeAndSimilar() {
     sql("select * from t where x like '%abc%'")
         .ok("SELECT *\n"
   + "FROM `T`\n"
@@ -3580,7 +3580,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`A` LIKE `B` ESCAPE `C`)) ESCAPE `D`)))");
   }
 
-  @Test void testIlike() {
+  @Test void ilike() {
     // The ILIKE operator is only valid when the PostgreSQL function library is
     // enabled ('fun=postgresql'). But the parser can always parse it.
     final String expected = "SELECT *\n"
@@ -3596,7 +3596,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql1).ok(expected1);
   }
 
-  @Test void testRlike() {
+  @Test void rlike() {
     // The RLIKE operator is valid when the HIVE or SPARK function library is
     // enabled ('fun=spark' or 'fun=hive'). But the parser can always parse it.
     final String expected =
@@ -3614,7 +3614,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql1).ok(expected1);
   }
 
-  @Test void testArithmeticOperators() {
+  @Test void arithmeticOperators() {
     expr("1-2+3*4/5/6-7").ok("(((1 - 2) + (((3 * 4) / 5) / 6)) - 7)");
     expr("power(2,3)").ok("POWER(2, 3)");
     expr("aBs(-2.3e-2)").ok("ABS(-2.3E-2)");
@@ -3623,7 +3623,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("log10(- -.2  )").ok("LOG10(0.2)");
   }
 
-  @Test void testExists() {
+  @Test void exists() {
     sql("select * from dept where exists (select 1 from emp where emp.deptno = dept.deptno)")
         .ok(
             "SELECT *\n"
@@ -3633,7 +3633,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`EMP`.`DEPTNO` = `DEPT`.`DEPTNO`)))");
   }
 
-  @Test void testExistsInWhere() {
+  @Test void existsInWhere() {
     sql("select * from emp where 1 = 2 and exists (select 1 from dept) and 3 = 4")
         .ok(
             "SELECT *\n"
@@ -3642,7 +3642,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`))) AND (3 = 4))");
   }
 
-  @Test void testUnique() {
+  @Test void unique() {
     sql("select * from dept where unique (select 1 from emp where emp.deptno = dept.deptno)")
         .ok(
             "SELECT *\n"
@@ -3652,7 +3652,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`EMP`.`DEPTNO` = `DEPT`.`DEPTNO`)))");
   }
 
-  @Test void testUniqueInWhere() {
+  @Test void uniqueInWhere() {
     sql("select * from emp where 1 = 2 and unique (select 1 from dept) and 3 = 4")
         .ok(
             "SELECT *\n"
@@ -3661,7 +3661,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`))) AND (3 = 4))");
   }
 
-  @Test void testNotUnique() {
+  @Test void notUnique() {
     sql("select * from dept where not not unique (select * from emp) and true")
         .ok(
             "SELECT *\n"
@@ -3670,17 +3670,17 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMP`)))) AND TRUE)");
   }
 
-  @Test void testFromWithAs() {
+  @Test void fromWithAs() {
     sql("select 1 from emp as e where 1").ok("SELECT 1\n"
   + "FROM `EMP` AS `E`\n"
   + "WHERE 1");
   }
 
-  @Test void testConcat() {
+  @Test void concat() {
     expr("'a' || 'b'").ok("('a' || 'b')");
   }
 
-  @Test void testCStyleEscapedString() {
+  @Test void cStyleEscapedString() {
     expr("E'Apache\\tCalcite'").ok("_UTF16'Apache\tCalcite'");
     expr("E'Apache\\bCalcite'").ok("_UTF16'Apache\bCalcite'");
     expr("E'Apache\\fCalcite'").ok("_UTF16'Apache\fCalcite'");
@@ -3719,11 +3719,11 @@ void checkPeriodPredicate(Checker checker) {
     expr("^E'AB\\U0000006G'^").fails(RESOURCE.unicodeEscapeMalformed(2).str());
   }
 
-  @Test void testReverseSolidus() {
+  @Test void reverseSolidus() {
     expr("'\\'").same();
   }
 
-  @Test void testSubstring() {
+  @Test void substring() {
     expr("substring('a'\nFROM \t  1)").ok("SUBSTRING('a', 1)");
     expr("substring('a' FROM 1 FOR 3)").ok("SUBSTRING('a', 1, 3)");
     expr("substring('a' FROM 'reg' FOR '\\')").ok("SUBSTRING('a', 'reg', '\\')");
@@ -3733,7 +3733,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("substring('a' , 1)").ok("SUBSTRING('a', 1)");
   }
 
-  @Test void testFunction() {
+  @Test void function() {
     sql("select substring('Eggs and ham', 1, 3 + 2) || ' benedict' from emp")
         .ok("SELECT (SUBSTRING('Eggs and ham', 1, (3 + 2)) || ' benedict')\n"
   + "FROM `EMP`");
@@ -3747,7 +3747,7 @@ void checkPeriodPredicate(Checker checker) {
                 + " - (6 * LOG10(((7 / ABS(8)) + 9))))) * POWER(10, 11)))");
   }
 
-  @Test void testFunctionWithDistinct() {
+  @Test void functionWithDistinct() {
     expr("count(DISTINCT 1)").ok("COUNT(DISTINCT 1)");
     expr("count(ALL 1)").ok("COUNT(ALL 1)");
     expr("count(1)").ok("COUNT(1)");
@@ -3756,15 +3756,15 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `EMP`");
   }
 
-  @Test void testFunctionCallWithDot() {
+  @Test void functionCallWithDot() {
     expr("foo(a,b).c").ok("(`FOO`(`A`, `B`).`C`)");
   }
 
-  @Test void testFunctionInFunction() {
+  @Test void functionInFunction() {
     expr("ln(power(2,2))").ok("LN(POWER(2, 2))");
   }
 
-  @Test void testFunctionNamedArgument() {
+  @Test void functionNamedArgument() {
     expr("foo(x => 1)").ok("`FOO`(`X` => 1)");
     expr("foo(x => 1, \"y\" => 'a', z => x <= y)")
         .ok("`FOO`(`X` => 1, `y` => 'a', `Z` => (`X` <= `Y`))");
@@ -3772,7 +3772,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("foo(a => 1, x.y ^=>^ 2, c => 3)").fails("(?s).*Encountered \"=>\" at .*");
   }
 
-  @Test void testFunctionDefaultArgument() {
+  @Test void functionDefaultArgument() {
     sql("foo(1, DEFAULT, default, 'default', \"default\", 3)")
         .expression()
         .ok("`FOO`(1, DEFAULT, DEFAULT, 'default', `default`, 3)");
@@ -3812,7 +3812,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s)Incorrect syntax near the keyword 'DEFAULT' at .*");
   }
 
-  @Test void testAggregateFilter() {
+  @Test void aggregateFilter() {
     final String sql =
         "select\n"
             + " sum(sal) filter (where gender = 'F') as femaleSal,\n"
@@ -3828,7 +3828,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testGroup() {
+  @Test void group() {
     sql("select deptno, min(foo) as x from emp group by deptno, gender")
         .ok(
             "SELECT `DEPTNO`, MIN(`FOO`) AS `X`\n"
@@ -3836,7 +3836,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "GROUP BY `DEPTNO`, `GENDER`");
   }
 
-  @Test void testGroupEmpty() {
+  @Test void groupEmpty() {
     sql("select count(*) from emp group by ()")
         .ok("SELECT COUNT(*)\n"
   + "FROM `EMP`\n"
@@ -3867,7 +3867,7 @@ void checkPeriodPredicate(Checker checker) {
   + "GROUP BY (`EMPNO` + `DEPTNO`)");
   }
 
-  @Test void testHavingAfterGroup() {
+  @Test void havingAfterGroup() {
     final String sql =
         "select deptno from emp group by deptno, emp\n"
             + "having count(*) > 5 and 1 = 2 order by 5, 2";
@@ -3880,21 +3880,21 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testHavingBeforeGroupFails() {
+  @Test void havingBeforeGroupFails() {
     final String sql =
         "select deptno from emp\n"
   + "having count(*) > 5 and deptno < 4 ^group^ by deptno, emp";
     sql(sql).fails("(?s).*Encountered \"group\" at .*");
   }
 
-  @Test void testHavingNoGroup() {
+  @Test void havingNoGroup() {
     sql("select deptno from emp having count(*) > 5")
         .ok("SELECT `DEPTNO`\n"
   + "FROM `EMP`\n"
   + "HAVING (COUNT(*) > 5)");
   }
 
-  @Test void testGroupingSets() {
+  @Test void groupingSets() {
     sql("select deptno from emp\n"
   + "group by grouping sets (deptno, (deptno, gender), ())")
         .ok(
@@ -3935,7 +3935,7 @@ void checkPeriodPredicate(Checker checker) {
   + "GROUP BY GROUPING SETS(())");
   }
 
-  @Test void testGroupByCube() {
+  @Test void groupByCube() {
     final String sql = "select deptno from emp\n"
   + "group by cube ((a, b), (c, d))";
     final String expected =
@@ -3945,7 +3945,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testGroupByAllOrDistinct() {
+  @Test void groupByAllOrDistinct() {
     final String sql = "select deptno from emp\n"
   + "group by all cube (a, b), rollup (a, b)";
     final String expected =
@@ -3971,7 +3971,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql2).ok(expected2);
   }
 
-  @Test void testGroupByCube2() {
+  @Test void groupByCube2() {
     final String sql = "select deptno from emp\n"
   + "group by cube ((a, b), (c, d)) order by a";
     final String expected =
@@ -3986,7 +3986,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql2).fails("(?s)Encountered \"\\)\" at .*");
   }
 
-  @Test void testGroupByRollup() {
+  @Test void groupByRollup() {
     final String sql = "select deptno from emp\n"
   + "group by rollup (deptno, deptno + 1, gender)";
     final String expected =
@@ -4001,7 +4001,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql1).fails("(?s)Encountered \", rollup\" at .*");
   }
 
-  @Test void testGrouping() {
+  @Test void grouping() {
     final String sql =
         "select deptno, grouping(deptno) from emp\n"
             + "group by grouping sets (deptno, (deptno, gender), ())";
@@ -4012,7 +4012,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWith() {
+  @Test void with() {
     final String sql =
         "with femaleEmps as (select * from emps where gender = 'F')"
             + "select deptno from femaleEmps";
@@ -4024,7 +4024,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWith2() {
+  @Test void with2() {
     final String sql =
         "with femaleEmps as (select * from emps where gender = 'F'),\n"
             + "marriedFemaleEmps(x, y) as (select * from femaleEmps where maritaStatus = 'M')\n"
@@ -4039,7 +4039,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithFails() {
+  @Test void withFails() {
     final String sql =
         "with femaleEmps as ^select^ *\n"
             + "from emps where gender = 'F'\n"
@@ -4047,7 +4047,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).fails("(?s)Encountered \"select\" at .*");
   }
 
-  @Test void testWithValues() {
+  @Test void withValues() {
     final String sql = "with v(i,c) as (values (1, 'a'), (2, 'bb'))\n"
   + "select c, i from v";
     final String expected =
@@ -4057,7 +4057,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithNestedFails() {
+  @Test void withNestedFails() {
     // SQL standard does not allow WITH to contain WITH
     final String sql =
         "with emp2 as (select * from emp)\n"
@@ -4070,7 +4070,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5299">[CALCITE-5299] JDBC
    * adapter sometimes adds unnecessary parentheses around SELECT in WITH body</a>.
    */
-  @Test void testWithSelect() {
+  @Test void withSelect() {
     final String sql = "with emp2 as (select * from emp)\n"
   + "select * from emp2\n";
     final String expected = "WITH `EMP2` AS (SELECT *\n"
@@ -4083,7 +4083,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5299">[CALCITE-5299] JDBC
    * adapter sometimes adds unnecessary parentheses around SELECT in WITH body</a>.
    */
-  @Test void testWithOrderBy() {
+  @Test void withOrderBy() {
     final String sql =
         "with emp2 as (select * from emp)\n"
   + "select * from emp2 order by deptno\n";
@@ -4095,7 +4095,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithNestedInSubQuery() {
+  @Test void withNestedInSubQuery() {
     // SQL standard does not allow sub-query to contain WITH but we do
     final String sql =
         "with emp2 as (select * from emp)\n"
@@ -4110,7 +4110,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWithUnion() {
+  @Test void withUnion() {
     // Per the standard WITH ... SELECT ... UNION is valid even without parens.
     final String sql =
         "with emp2 as (select * from emp)\n"
@@ -4131,7 +4131,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsUnion() {
+  @Test void withAsUnion() {
     final String sql =
         "with emp2 as (select * from emp union select * from emp)\n"
   + "select * from emp2\n";
@@ -4149,7 +4149,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsOrderBy() {
+  @Test void withAsOrderBy() {
     final String sql =
         "with emp2 as (select * from emp order by deptno)\n"
   + "select * from emp2\n";
@@ -4165,7 +4165,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsJoin() {
+  @Test void withAsJoin() {
     final String sql =
         "with emp2 as (select * from emp e1 join emp e2 on e1.deptno = e2.deptno)\n"
             + "select * from emp2\n";
@@ -4181,7 +4181,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5252">[CALCITE-5252] JDBC
    * adapter sometimes miss parentheses around SELECT in WITH_ITEM body</a>.
    */
-  @Test void testWithAsNestedInSubQuery() {
+  @Test void withAsNestedInSubQuery() {
     final String sql =
         "with emp3 as (with emp2 as (select * from emp) select * from emp2)\n"
             + "select * from emp3\n";
@@ -4193,7 +4193,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testIdentifier() {
+  @Test void identifier() {
     expr("ab").ok("`AB`");
     expr("     \"a  \"\" b!c\"").ok("`a  \" b!c`");
     expr("     ^`^a  \" b!c`").fails("(?s).*Encountered.*");
@@ -4208,7 +4208,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("VALUES \"a\".b").node(isQuoted(1, false));
   }
 
-  @Test void testBackTickIdentifier() {
+  @Test void backTickIdentifier() {
     SqlParserFixture f = fixture().withConfig(c -> c.withQuoting(Quoting.BACK_TICK)).expression();
     f.sql("ab").ok("`AB`");
     f.sql("     `a  \" b!c`").ok("`a  \" b!c`");
@@ -4226,7 +4226,7 @@ void checkPeriodPredicate(Checker checker) {
     f.sql("VALUES `a``b`").node(isQuoted(0, true));
   }
 
-  @Test void testBackTickBackslashIdentifier() {
+  @Test void backTickBackslashIdentifier() {
     SqlParserFixture f =
         fixture().withConfig(c -> c.withQuoting(Quoting.BACK_TICK_BACKSLASH)).expression();
     f.sql("ab").ok("`AB`");
@@ -4247,7 +4247,7 @@ void checkPeriodPredicate(Checker checker) {
     f.sql("VALUES `a\\`b`").node(isQuoted(0, true));
   }
 
-  @Test void testBracketIdentifier() {
+  @Test void bracketIdentifier() {
     SqlParserFixture f = fixture().withConfig(c -> c.withQuoting(Quoting.BRACKET)).expression();
     f.sql("ab").ok("`AB`");
     f.sql("     [a  \" b!c]").ok("`a  \" b!c`");
@@ -4276,7 +4276,7 @@ void checkPeriodPredicate(Checker checker) {
     f.sql("VALUES [a]").node(isQuoted(0, true));
   }
 
-  @Test void testBackTickQuery() {
+  @Test void backTickQuery() {
     sql("select `x`.`b baz` from `emp` as `x` where `x`.deptno in (10, 20)")
         .withConfig(c -> c.withQuoting(Quoting.BACK_TICK))
         .ok("SELECT `x`.`b baz`\n"
@@ -4288,7 +4288,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4080">[CALCITE-4080] Allow
    * character literals as column aliases, if SqlConformance.allowCharLiteralAlias()</a>.
    */
-  @Test void testSingleQuotedAlias() {
+  @Test void singleQuotedAlias() {
     final String expectingAlias = "Expecting alias, found character literal";
 
     final String sql1 = "select 1 as ^'a b'^ from t";
@@ -4351,19 +4351,19 @@ void checkPeriodPredicate(Checker checker) {
     f5.withConformance(SqlConformanceEnum.SQL_SERVER_2008).fails(sql5b);
   }
 
-  @Test void testInList() {
+  @Test void inList() {
     sql("select * from emp where deptno in (10, 20) and gender = 'F'")
         .ok("SELECT *\n"
   + "FROM `EMP`\n"
   + "WHERE ((`DEPTNO` IN (10, 20)) AND (`GENDER` = 'F'))");
   }
 
-  @Test void testInListEmptyFails() {
+  @Test void inListEmptyFails() {
     sql("select * from emp where deptno in (^)^ and gender = 'F'")
         .fails("(?s).*Encountered \"\\)\" at line 1, column 36\\..*");
   }
 
-  @Test void testInQuery() {
+  @Test void inQuery() {
     sql("select * from emp where deptno in (select deptno from dept)")
         .ok(
             "SELECT *\n"
@@ -4372,7 +4372,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`))");
   }
 
-  @Test void testSomeEveryAndIntersectionAggQuery() {
+  @Test void someEveryAndIntersectionAggQuery() {
     sql("select some(deptno = 10), every(deptno > 0), intersection(multiset[1,2]) from dept")
         .ok(
             "SELECT SOME((`DEPTNO` = 10)), EVERY((`DEPTNO` > 0)), INTERSECTION((MULTISET[1, 2]))\n"
@@ -4380,7 +4380,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Tricky for the parser - looks like "IN (scalar, scalar)" but isn't. */
-  @Test void testInQueryWithComma() {
+  @Test void inQueryWithComma() {
     sql("select * from emp where deptno in (select deptno from dept group by 1, 2)")
         .ok(
             "SELECT *\n"
@@ -4390,7 +4390,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "GROUP BY 1, 2))");
   }
 
-  @Test void testInSetop() {
+  @Test void inSetop() {
     sql("select * from emp where deptno in (\n"
             + "(select deptno from dept union select * from dept)"
             + "except\n"
@@ -4408,7 +4408,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`)) AND FALSE)");
   }
 
-  @Test void testSome() {
+  @Test void some() {
     final String sql = "select * from emp\n"
   + "where sal > some (select comm from emp)";
     final String expected =
@@ -4443,7 +4443,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql5).ok(expected5);
   }
 
-  @Test void testAll() {
+  @Test void all() {
     final String sql =
         "select * from emp\n"
   + "where sal <= all (select comm from emp) or sal > 10";
@@ -4455,7 +4455,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testAllList() {
+  @Test void allList() {
     final String sql = "select * from emp\n"
   + "where sal <= all (12, 20, 30)";
     final String expected = "SELECT *\n"
@@ -4464,7 +4464,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testUnion() {
+  @Test void union() {
     sql("select * from a union select * from a")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4485,7 +4485,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `A`");
   }
 
-  @Test void testUnionOrder() {
+  @Test void unionOrder() {
     sql("select a, b from t " + "union all " + "select x, y from u " + "order by 1 asc, 2 desc")
         .ok(
             "SELECT `A`, `B`\n"
@@ -4496,7 +4496,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "ORDER BY 1, 2 DESC");
   }
 
-  @Test void testOrderUnion() {
+  @Test void orderUnion() {
     // ORDER BY inside UNION not allowed
     sql("select a from t order by a\n"
   + "^union^ all\n"
@@ -4504,7 +4504,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"union\" at .*");
   }
 
-  @Test void testLimitUnion() {
+  @Test void limitUnion() {
     // LIMIT inside UNION not allowed
     sql("select a from t limit 10\n"
   + "^union^ all\n"
@@ -4512,7 +4512,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"union\" at .*");
   }
 
-  @Test void testLimitUnion2() {
+  @Test void limitUnion2() {
     // LIMIT is allowed in a parenthesized sub-query inside UNION;
     // the result probably has more parentheses than strictly necessary.
     final String sql =
@@ -4530,7 +4530,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testUnionOffset() {
+  @Test void unionOffset() {
     // Note that the second sub-query has parentheses, to ensure that ORDER BY,
     // OFFSET, FETCH are associated with just that sub-query, not the UNION.
     final String sql =
@@ -4619,7 +4619,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql6).ok(expected6);
   }
 
-  @Test void testUnionIntersect() {
+  @Test void unionIntersect() {
     // Note that the union sub-query has parentheses.
     final String sql = "(select * from a union select * from b)\n"
   + "intersect select * from c";
@@ -4635,7 +4635,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testUnionOfNonQueryFails() {
+  @Test void unionOfNonQueryFails() {
     sql("select 1 from emp union ^2^ + 5")
         .fails("Non-query expression encountered in illegal context");
   }
@@ -4644,14 +4644,14 @@ void checkPeriodPredicate(Checker checker) {
    * In modern SQL, a query can occur almost everywhere that an expression can. This test tests the
    * few exceptions.
    */
-  @Test void testQueryInIllegalContext() {
+  @Test void queryInIllegalContext() {
     sql("select 0, multiset[^(^select * from emp), 2] from dept")
         .fails("Query expression encountered in illegal context");
     sql("select 0, multiset[1, ^(^select * from emp), 2, 3] from dept")
         .fails("Query expression encountered in illegal context");
   }
 
-  @Test void testExcept() {
+  @Test void except() {
     sql("select * from a except select * from a")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4676,7 +4676,7 @@ void checkPeriodPredicate(Checker checker) {
    * Tests MINUS, which is equivalent to EXCEPT but only supported in some conformance levels (e.g.
    * ORACLE).
    */
-  @Test void testSetMinus() {
+  @Test void setMinus() {
     final String pattern = "MINUS is not allowed under the current SQL conformance level";
     final String sql = "select col1 from table1 ^MINUS^ select col1 from table2";
     sql(sql).fails(pattern);
@@ -4704,13 +4704,13 @@ void checkPeriodPredicate(Checker checker) {
    * conformance, where it is not allowed as an alternative to EXCEPT. (It is reserved in Oracle but
    * not in any version of the SQL standard.)
    */
-  @Test void testMinusIsReserved() {
+  @Test void minusIsReserved() {
     sql("select ^minus^ from t").fails("(?s).*Encountered \"minus\" at .*");
     sql("select ^minus^ select").fails("(?s).*Encountered \"minus\" at .*");
     sql("select * from t as ^minus^ where x < y").fails("(?s).*Encountered \"minus\" at .*");
   }
 
-  @Test void testIntersect() {
+  @Test void intersect() {
     sql("select * from a intersect select * from a")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4731,14 +4731,14 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `A`");
   }
 
-  @Test void testJoinCross() {
+  @Test void joinCross() {
     sql("select * from a as a2 cross join b")
         .ok("SELECT *\n"
   + "FROM `A` AS `A2`\n"
   + "CROSS JOIN `B`");
   }
 
-  @Test void testJoinOn() {
+  @Test void joinOn() {
     sql("select * from a left join b on 1 = 1 and 2 = 2 where 3 = 3")
         .ok(
             "SELECT *\n"
@@ -4747,7 +4747,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (3 = 3)");
   }
 
-  @Test void testJoinOnParentheses() {
+  @Test void joinOnParentheses() {
     if (!Bug.TODO_FIXED) {
       return;
     }
@@ -4762,7 +4762,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Same as {@link #testJoinOnParentheses()} but fancy aliases. */
-  @Test void testJoinOnParenthesesPlus() {
+  @Test void joinOnParenthesesPlus() {
     if (!Bug.TODO_FIXED) {
       return;
     }
@@ -4777,7 +4777,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (3 = 3)");
   }
 
-  @Test void testExplicitTableInJoin() {
+  @Test void explicitTableInJoin() {
     sql("select * from a left join (table b) on 2 = 2 where 3 = 3")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4785,7 +4785,7 @@ void checkPeriodPredicate(Checker checker) {
   + "WHERE (3 = 3)");
   }
 
-  @Test void testSubQueryInJoin() {
+  @Test void subQueryInJoin() {
     if (!Bug.TODO_FIXED) {
       return;
     }
@@ -4801,7 +4801,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (4 = 4)");
   }
 
-  @Test void testOuterJoinNoiseWord() {
+  @Test void outerJoinNoiseWord() {
     sql("select * from a left outer join b on 1 = 1 and 2 = 2 where 3 = 3")
         .ok(
             "SELECT *\n"
@@ -4810,7 +4810,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (3 = 3)");
   }
 
-  @Test void testJoinQuery() {
+  @Test void joinQuery() {
     sql("select * from a join (select * from b) as b2 on true")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4818,24 +4818,24 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `B`) AS `B2` ON TRUE");
   }
 
-  @Test void testFullInnerJoinFails() {
+  @Test void fullInnerJoinFails() {
     // cannot have more than one of INNER, FULL, LEFT, RIGHT, CROSS
     sql("select * from a ^full^ inner join b").fails("(?s).*Encountered \"full inner\" at line .*");
   }
 
-  @Test void testFullOuterJoin() {
+  @Test void fullOuterJoin() {
     // OUTER is an optional extra to LEFT, RIGHT, or FULL
     sql("select * from a full outer join b").ok("SELECT *\n"
   + "FROM `A`\n"
   + "FULL JOIN `B`");
   }
 
-  @Test void testInnerOuterJoinFails() {
+  @Test void innerOuterJoinFails() {
     sql("select * from a ^inner^ outer join b")
         .fails("(?s).*Encountered \"inner outer\" at line .*");
   }
 
-  @Test void testJoinAssociativity() {
+  @Test void joinAssociativity() {
     // joins are left-associative
     // 1. no parens needed
     String expected =
@@ -4870,14 +4870,14 @@ void checkPeriodPredicate(Checker checker) {
   // Note: "select * from a natural cross join b" is actually illegal SQL
   // ("cross" is the only join type which cannot be modified with the
   // "natural") but the parser allows it; we and catch it at validate time
-  @Test void testNaturalCrossJoin() {
+  @Test void naturalCrossJoin() {
     sql("select * from a natural cross join b")
         .ok("SELECT *\n"
   + "FROM `A`\n"
   + "NATURAL CROSS JOIN `B`");
   }
 
-  @Test void testJoinUsing() {
+  @Test void joinUsing() {
     sql("select * from a join b using (x)")
         .ok("SELECT *\n"
   + "FROM `A`\n"
@@ -4890,7 +4890,7 @@ void checkPeriodPredicate(Checker checker) {
    * Tests CROSS APPLY, which is equivalent to CROSS JOIN and LEFT JOIN but only supported in some
    * conformance levels (e.g. SQL Server).
    */
-  @Test void testApply() {
+  @Test void apply() {
     final String pattern = "APPLY operator is not allowed under the current SQL conformance level";
     final String sql = "select * from dept\n"
   + "cross apply table(ramp(deptno)) as t(a^)^";
@@ -4909,7 +4909,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Tests OUTER APPLY. */
-  @Test void testOuterApply() {
+  @Test void outerApply() {
     final String sql = "select * from dept outer apply table(ramp(deptno))";
     final String expected =
         "SELECT *\n"
@@ -4918,7 +4918,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(expected);
   }
 
-  @Test void testOuterApplySubQuery() {
+  @Test void outerApplySubQuery() {
     final String sql =
         "select * from dept\n"
   + "outer apply (select * from emp where emp.deptno = dept.deptno)";
@@ -4931,7 +4931,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(expected);
   }
 
-  @Test void testOuterApplyValues() {
+  @Test void outerApplyValues() {
     final String sql =
         "select * from dept\n"
   + "outer apply (select * from emp where emp.deptno = dept.deptno)";
@@ -4948,14 +4948,14 @@ void checkPeriodPredicate(Checker checker) {
    * Even in SQL Server conformance mode, we do not yet support 'function(args)' as an abbreviation
    * for 'table(function(args)'.
    */
-  @Test void testOuterApplyFunctionFails() {
+  @Test void outerApplyFunctionFails() {
     final String sql = "select * from dept outer apply ramp(deptno^)^)";
     sql(sql)
         .withConformance(SqlConformanceEnum.SQL_SERVER_2008)
         .fails("(?s).*Encountered \"\\)\" at .*");
   }
 
-  @Test void testCrossOuterApply() {
+  @Test void crossOuterApply() {
     final String sql =
         "select * from dept\n"
             + "cross apply table(ramp(deptno)) as t(a)\n"
@@ -4968,7 +4968,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).withConformance(SqlConformanceEnum.SQL_SERVER_2008).ok(expected);
   }
 
-  @Test void testTableSample() {
+  @Test void tableSample() {
     final String sql0 =
         "select * from ("
             + "  select * "
@@ -5024,7 +5024,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "can not be parsed to type 'java\\.lang\\.Integer'");
   }
 
-  @Test void testLiteral() {
+  @Test void literal() {
     expr("'foo'").same();
     expr("100").same();
     sql("select 1 as uno, 'x' as x, null as n from emp")
@@ -5042,7 +5042,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("NULL").same();
   }
 
-  @Test void testContinuedLiteral() {
+  @Test void continuedLiteral() {
     expr("'abba'\n'abba'").same();
     expr("'abba'\n'0001'").same();
     expr("N'yabba'\n'dabba'\n'doo'").ok("_ISO-8859-1'yabba'\n'dabba'\n'doo'");
@@ -5059,7 +5059,7 @@ void checkPeriodPredicate(Checker checker) {
    * Tests that ambiguity between extended string literals and character string aliases is always
    * resolved in favor of extended string literals.
    */
-  @Test void testContinuedLiteralAlias() {
+  @Test void continuedLiteralAlias() {
     final String expectingAlias = "Expecting alias, found character literal";
 
     // Not ambiguous, because of 'as'.
@@ -5106,7 +5106,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql2).withConformance(SqlConformanceEnum.BIG_QUERY).ok(sql2b);
   }
 
-  @Test void testMixedFrom() {
+  @Test void mixedFrom() {
     sql("select * from a join b using (x), c join d using (y)")
         .ok(
             "SELECT *\n"
@@ -5116,14 +5116,14 @@ void checkPeriodPredicate(Checker checker) {
                 + "INNER JOIN `D` USING (`Y`)");
   }
 
-  @Test void testMixedStar() {
+  @Test void mixedStar() {
     sql("select emp.*, 1 as foo from emp, dept")
         .ok("SELECT `EMP`.*, 1 AS `FOO`\n"
   + "FROM `EMP`,\n"
   + "`DEPT`");
   }
 
-  @Test void testSchemaTableStar() {
+  @Test void schemaTableStar() {
     sql("select schem.emp.*, emp.empno * dept.deptno\n"
   + "from schem.emp, dept")
         .ok(
@@ -5132,19 +5132,19 @@ void checkPeriodPredicate(Checker checker) {
                 + "`DEPT`");
   }
 
-  @Test void testCatalogSchemaTableStar() {
+  @Test void catalogSchemaTableStar() {
     sql("select cat.schem.emp.* from cat.schem.emp")
         .ok("SELECT `CAT`.`SCHEM`.`EMP`.*\n"
   + "FROM `CAT`.`SCHEM`.`EMP`");
   }
 
-  @Test void testAliasedStar() {
+  @Test void aliasedStar() {
     // OK in parser; validator will give error
     sql("select emp.* as foo from emp").ok("SELECT `EMP`.* AS `FOO`\n"
   + "FROM `EMP`");
   }
 
-  @Test void testNotExists() {
+  @Test void notExists() {
     sql("select * from dept where not not exists (select * from emp) and true")
         .ok(
             "SELECT *\n"
@@ -5153,7 +5153,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMP`)))) AND TRUE)");
   }
 
-  @Test void testOrder() {
+  @Test void order() {
     sql("select * from emp order by empno, gender desc, deptno asc, empno asc, name desc")
         .ok(
             "SELECT *\n"
@@ -5161,7 +5161,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "ORDER BY `EMPNO`, `GENDER` DESC, `DEPTNO`, `EMPNO`, `NAME` DESC");
   }
 
-  @Test void testOrderNullsFirst() {
+  @Test void orderNullsFirst() {
     final String sql =
         "select * from emp\n"
             + "order by gender desc nulls last,\n"
@@ -5175,7 +5175,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testOrderInternal() {
+  @Test void orderInternal() {
     sql("(select * from emp order by empno) union select * from emp")
         .ok(
             "(SELECT *\n"
@@ -5194,7 +5194,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`A` = `B`)");
   }
 
-  @Test void testOrderIllegalInExpression() {
+  @Test void orderIllegalInExpression() {
     sql("select (select 1 from foo order by x,y) from t where a = b")
         .ok(
             "SELECT (SELECT 1\n"
@@ -5205,7 +5205,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select (1 ^order^ by x, y) from t where a = b").fails("ORDER BY unexpected");
   }
 
-  @Test void testOrderOffsetFetch() {
+  @Test void orderOffsetFetch() {
     sql("select a from foo order by b, c offset 1 row fetch first 2 row only")
         .ok(
             "SELECT `A`\n"
@@ -5277,7 +5277,7 @@ void checkPeriodPredicate(Checker checker) {
    * "LIMIT ... OFFSET ..." is the postgres equivalent of SQL:2008 "OFFSET ... FETCH". It all maps
    * down to a parse tree that looks like SQL:2008.
    */
-  @Test void testLimit() {
+  @Test void limit() {
     sql("select a from foo order by b, c limit 2 offset 1")
         .ok(
             "SELECT `A`\n"
@@ -5304,7 +5304,7 @@ void checkPeriodPredicate(Checker checker) {
    * <p>Similar to {@link #testLimit}, but parses and unparses in the Spark dialect, which uses
    * LIMIT and OFFSET rather than OFFSET and FETCH.
    */
-  @Test void testLimitSpark() {
+  @Test void limitSpark() {
     final String sql1 = "select a from foo order by b, c limit 2 offset 1";
     final String expected1 =
         "SELECT A\n"
@@ -5352,14 +5352,14 @@ void checkPeriodPredicate(Checker checker) {
    * Test case that does not reproduce but is related to <a href="https://issues.apache.org/jira/browse/CALCITE-1238">[CALCITE-1238] Unparsing LIMIT
    * without ORDER BY after validation</a>.
    */
-  @Test void testLimitWithoutOrder() {
+  @Test void limitWithoutOrder() {
     final String expected = "SELECT `A`\n"
   + "FROM `FOO`\n"
   + "FETCH NEXT 2 ROWS ONLY";
     sql("select a from foo limit 2").ok(expected);
   }
 
-  @Test void testLimitOffsetWithoutOrder() {
+  @Test void limitOffsetWithoutOrder() {
     final String expected =
         "SELECT `A`\n"
   + "FROM `FOO`\n"
@@ -5368,7 +5368,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select a from foo limit 2 offset 1").ok(expected);
   }
 
-  @Test void testLimitStartCount() {
+  @Test void limitStartCount() {
     final String error =
         "'LIMIT start, count' is not allowed under the " + "current SQL conformance level";
     sql("select a from foo ^limit 1,2^").withConformance(SqlConformanceEnum.DEFAULT).fails(error);
@@ -5417,7 +5417,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5086">[CALCITE-5086]
    * Calcite supports OFFSET start LIMIT count expression</a>.
    */
-  @Test void testOffsetStartLimitCount() {
+  @Test void offsetStartLimitCount() {
     final String error =
         "'OFFSET start LIMIT count' is not allowed under the " + "current SQL conformance level";
     sql("select a from foo order by b, c offset 1 limit 2")
@@ -5454,7 +5454,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"all\" at line 1.*");
   }
 
-  @Test void testSqlInlineComment() {
+  @Test void sqlInlineComment() {
     sql("select 1 from t --this is a comment\n").ok("SELECT 1\n"
   + "FROM `T`");
     sql("select 1 from t--\n").ok("SELECT 1\n"
@@ -5468,7 +5468,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `T`");
   }
 
-  @Test void testMultilineComment() {
+  @Test void multilineComment() {
     // on single line
     sql("select 1 /* , 2 */, 3 from t").ok("SELECT 1, 3\n"
   + "FROM `T`");
@@ -5555,7 +5555,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   // expressions
-  @Test void testParseNumber() {
+  @Test void parseNumber() {
     // Exacts
     expr("1").same();
     expr("+1.").ok("1");
@@ -5593,45 +5593,45 @@ void checkPeriodPredicate(Checker checker) {
     expr("1+-2.*-3.e-1/-4").ok("(1 + ((-2 * -3E-1) / -4))");
   }
 
-  @Test void testParseNumberFails() {
+  @Test void parseNumberFails() {
     sql("SELECT 0.5e1^.1^ from t").fails("(?s).*Encountered .*\\.1.* at line 1.*");
   }
 
-  @Test void testMinusPrefixInExpression() {
+  @Test void minusPrefixInExpression() {
     expr("-(1+2)").ok("(- (1 + 2))");
   }
 
   // operator precedence
-  @Test void testPrecedence0() {
+  @Test void precedence0() {
     expr("1 + 2 * 3 * 4 + 5").ok("((1 + ((2 * 3) * 4)) + 5)");
   }
 
-  @Test void testPrecedence1() {
+  @Test void precedence1() {
     expr("1 + 2 * (3 * (4 + 5))").ok("(1 + (2 * (3 * (4 + 5))))");
   }
 
-  @Test void testPrecedence2() {
+  @Test void precedence2() {
     expr("- - 1").ok("1"); // special case for unary minus
   }
 
-  @Test void testPrecedence2b() {
+  @Test void precedence2b() {
     expr("not not 1").ok("(NOT (NOT 1))"); // two prefixes
   }
 
-  @Test void testPrecedence3() {
+  @Test void precedence3() {
     expr("- 1 is null").ok("(-1 IS NULL)"); // prefix vs. postfix
   }
 
-  @Test void testPrecedence4() {
+  @Test void precedence4() {
     expr("1 - -2").ok("(1 - -2)"); // infix, prefix '-'
   }
 
-  @Test void testPrecedence5() {
+  @Test void precedence5() {
     expr("1++2").ok("(1 + 2)"); // infix, prefix '+'
     expr("1+ +2").ok("(1 + 2)"); // infix, prefix '+'
   }
 
-  @Test void testPrecedenceSetOps() {
+  @Test void precedenceSetOps() {
     final String sql =
         "select * from a union "
             + "select * from b intersect "
@@ -5664,7 +5664,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQueryInFrom() {
+  @Test void queryInFrom() {
     // one query with 'as', the other without
     sql("select * from (select * from emp) as e join (select * from dept) d")
         .ok(
@@ -5675,14 +5675,14 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `DEPT`) AS `D`");
   }
 
-  @Test void testQuotesInString() {
+  @Test void quotesInString() {
     expr("'a''b'").same();
     expr("'''x'").same();
     expr("''").same();
     expr("'Quoted strings aren''t \"hard\"'").same();
   }
 
-  @Test void testScalarQueryInWhere() {
+  @Test void scalarQueryInWhere() {
     sql("select * from emp where 3 = (select count(*) from dept where dept.deptno = emp.deptno)")
         .ok(
             "SELECT *\n"
@@ -5692,7 +5692,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`DEPT`.`DEPTNO` = `EMP`.`DEPTNO`)))");
   }
 
-  @Test void testScalarQueryInSelect() {
+  @Test void scalarQueryInSelect() {
     sql("select x, (select count(*) from dept where dept.deptno = emp.deptno) from emp")
         .ok(
             "SELECT `X`, (SELECT COUNT(*)\n"
@@ -5701,51 +5701,51 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMP`");
   }
 
-  @Test void testSelectList() {
+  @Test void selectList() {
     sql("select * from emp, dept").ok("SELECT *\n"
   + "FROM `EMP`,\n"
   + "`DEPT`");
   }
 
-  @Test void testSelectWithoutFrom() {
+  @Test void selectWithoutFrom() {
     sql("select 2+2").ok("SELECT (2 + 2)");
   }
 
-  @Test void testSelectWithoutFrom2() {
+  @Test void selectWithoutFrom2() {
     sql("select 2+2 as x, 'a' as y").ok("SELECT (2 + 2) AS `X`, 'a' AS `Y`");
   }
 
-  @Test void testSelectDistinctWithoutFrom() {
+  @Test void selectDistinctWithoutFrom() {
     sql("select distinct 2+2 as x, 'a' as y").ok("SELECT DISTINCT (2 + 2) AS `X`, 'a' AS `Y`");
   }
 
-  @Test void testSelectWithoutFromWhereFails() {
+  @Test void selectWithoutFromWhereFails() {
     sql("select 2+2 as x ^where^ 1 > 2").fails("(?s).*Encountered \"where\" at line .*");
   }
 
-  @Test void testSelectWithoutFromGroupByFails() {
+  @Test void selectWithoutFromGroupByFails() {
     sql("select 2+2 as x ^group^ by 1, 2").fails("(?s).*Encountered \"group\" at line .*");
   }
 
-  @Test void testSelectWithoutFromHavingFails() {
+  @Test void selectWithoutFromHavingFails() {
     sql("select 2+2 as x ^having^ 1 > 2").fails("(?s).*Encountered \"having\" at line .*");
   }
 
-  @Test void testSelectList3() {
+  @Test void selectList3() {
     sql("select 1, emp.*, 2 from emp").ok("SELECT 1, `EMP`.*, 2\n"
   + "FROM `EMP`");
   }
 
-  @Test void testSelectList4() {
+  @Test void selectList4() {
     sql("select ^from^ emp").fails("(?s).*Encountered \"from\" at line .*");
   }
 
-  @Test void testStar() {
+  @Test void star() {
     sql("select * from emp").ok("SELECT *\n"
   + "FROM `EMP`");
   }
 
-  @Test void testCompoundStar() {
+  @Test void compoundStar() {
     final String sql =
         "select sales.emp.address.zipcode,\n"
   + " sales.emp.address.*\n"
@@ -5757,12 +5757,12 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testSelectDistinct() {
+  @Test void selectDistinct() {
     sql("select distinct foo from bar").ok("SELECT DISTINCT `FOO`\n"
   + "FROM `BAR`");
   }
 
-  @Test void testSelectAll() {
+  @Test void selectAll() {
     // "unique" is the default -- so drop the keyword
     sql("select * from (select all foo from bar) as xyz")
         .ok("SELECT *\n"
@@ -5770,30 +5770,30 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `BAR`) AS `XYZ`");
   }
 
-  @Test void testSelectStream() {
+  @Test void selectStream() {
     sql("select stream foo from bar").ok("SELECT STREAM `FOO`\n"
   + "FROM `BAR`");
   }
 
-  @Test void testSelectStreamDistinct() {
+  @Test void selectStreamDistinct() {
     sql("select stream distinct foo from bar").ok("SELECT STREAM DISTINCT `FOO`\n"
   + "FROM `BAR`");
   }
 
-  @Test void testWhere() {
+  @Test void where() {
     sql("select * from emp where empno > 5 and gender = 'F'")
         .ok("SELECT *\n"
   + "FROM `EMP`\n"
   + "WHERE ((`EMPNO` > 5) AND (`GENDER` = 'F'))");
   }
 
-  @Test void testNestedSelect() {
+  @Test void nestedSelect() {
     sql("select * from (select * from emp)").ok("SELECT *\n"
   + "FROM (SELECT *\n"
   + "FROM `EMP`)");
   }
 
-  @Test void testValues() {
+  @Test void values() {
     final String expected = "VALUES (ROW(1, 'two'))";
     final String pattern = "VALUE is not allowed under the current SQL conformance level";
     sql("values(1,'two')").ok(expected);
@@ -5804,11 +5804,11 @@ void checkPeriodPredicate(Checker checker) {
     sql("^value^(1,'two')").fails(pattern);
   }
 
-  @Test void testValuesExplicitRow() {
+  @Test void valuesExplicitRow() {
     sql("values row(1,'two')").ok("VALUES (ROW(1, 'two'))");
   }
 
-  @Test void testFromValues() {
+  @Test void fromValues() {
     sql("select * from (values(1,'two'), 3, (4, 'five'))")
         .ok("SELECT *\n"
   + "FROM (VALUES (ROW(1, 'two')),\n"
@@ -5816,7 +5816,7 @@ void checkPeriodPredicate(Checker checker) {
   + "(ROW(4, 'five')))");
   }
 
-  @Test void testFromValuesWithoutParens() {
+  @Test void fromValuesWithoutParens() {
     sql("select 1 from ^values^('x')")
         .fails(
             "(?s)Encountered \"values\" at line 1, column 15\\.\n"
@@ -5834,7 +5834,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "    \"\\(\" \\.\\.\\.\n.*");
   }
 
-  @Test void testEmptyValues() {
+  @Test void emptyValues() {
     sql("select * from (values(^)^)").fails("(?s).*Encountered \"\\)\" at .*");
   }
 
@@ -5842,7 +5842,7 @@ void checkPeriodPredicate(Checker checker) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-493">[CALCITE-493] Add
    * EXTEND clause, for defining columns and their types at query/DML time</a>.
    */
-  @Test void testTableExtend() {
+  @Test void tableExtend() {
     sql("select * from emp extend (x int, y varchar(10) not null)")
         .ok("SELECT *\n"
   + "FROM `EMP` EXTEND (`X` INTEGER, `Y` VARCHAR(10))");
@@ -5877,34 +5877,34 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`X` = `Y`)");
   }
 
-  @Test void testExplicitTable() {
+  @Test void explicitTable() {
     sql("table emp").ok("(TABLE `EMP`)");
 
     sql("table ^123^").fails("(?s)Encountered \"123\" at line 1, column 7\\.\n.*");
   }
 
-  @Test void testExplicitTableOrdered() {
+  @Test void explicitTableOrdered() {
     sql("table emp order by name").ok("(TABLE `EMP`)\n"
   + "ORDER BY `NAME`");
   }
 
-  @Test void testSelectFromExplicitTable() {
+  @Test void selectFromExplicitTable() {
     sql("select * from (table emp)").ok("SELECT *\n"
   + "FROM (TABLE `EMP`)");
   }
 
-  @Test void testSelectFromBareExplicitTableFails() {
+  @Test void selectFromBareExplicitTableFails() {
     sql("select * from table ^emp^").fails("(?s).*Encountered \"emp\" at .*");
 
     sql("select * from (table (^select^ empno from emp))").fails("(?s)Encountered \"select\".*");
   }
 
-  @Test void testCollectionTable() {
+  @Test void collectionTable() {
     sql("select * from table(ramp(3, 4))").ok("SELECT *\n"
   + "FROM TABLE(`RAMP`(3, 4))");
   }
 
-  @Test void testDescriptor() {
+  @Test void descriptor() {
     sql("select * from table(ramp(descriptor(column_name)))")
         .ok("SELECT *\n"
   + "FROM TABLE(`RAMP`(DESCRIPTOR(`COLUMN_NAME`)))");
@@ -5917,14 +5917,14 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM TABLE(`RAMP`(DESCRIPTOR(`COLUMN_NAME1`, `COLUMN_NAME2`, `COLUMN_NAME3`)))");
   }
 
-  @Test void testCollectionTableWithCursorParam() {
+  @Test void collectionTableWithCursorParam() {
     sql("select * from table(dedup(cursor(select * from emps),'name'))")
         .ok("SELECT *\n"
   + "FROM TABLE(`DEDUP`((CURSOR ((SELECT *\n"
   + "FROM `EMPS`))), 'name'))");
   }
 
-  @Test void testCollectionTableWithColumnListParam() {
+  @Test void collectionTableWithColumnListParam() {
     sql("select * from table(dedup(cursor(select * from emps)," + "row(empno, name)))")
         .ok(
             "SELECT *\n"
@@ -5932,7 +5932,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMPS`))), (ROW(`EMPNO`, `NAME`))))");
   }
 
-  @Test void testLateral() {
+  @Test void lateral() {
     // Bad: LATERAL table
     sql("select * from lateral ^emp^").fails("(?s)Encountered \"emp\" at .*");
     sql("select * from lateral table ^emp^ as e").fails("(?s)Encountered \"emp\" at .*");
@@ -5958,7 +5958,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("select * from lateral (select * from emp) as t(x)").ok(expected2 + " AS `T` (`X`)");
   }
 
-  @Test void testTemporalTable() {
+  @Test void temporalTable() {
     final String sql0 =
         "select stream * from orders, products\n"
             + "for system_time as of TIMESTAMP '2011-01-02 00:00:00'";
@@ -6015,7 +6015,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql4).ok(expected4);
   }
 
-  @Test void testCollectionTableWithLateral() {
+  @Test void collectionTableWithLateral() {
     final String sql = "select * from dept, lateral table(ramp(dept.deptno))";
     final String expected =
         "SELECT *\n"
@@ -6024,7 +6024,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testCollectionTableWithLateral2() {
+  @Test void collectionTableWithLateral2() {
     final String sql =
         "select * from dept as d\n"
   + "cross join lateral table(ramp(dept.deptno)) as r";
@@ -6035,7 +6035,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testCollectionTableWithLateral3() {
+  @Test void collectionTableWithLateral3() {
     // LATERAL before first table in FROM clause doesn't achieve anything, but
     // it's valid.
     final String sql = "select * from lateral table(ramp(dept.deptno)), dept";
@@ -6046,14 +6046,14 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunction() {
+  @Test void tableFunction() {
     final String sql = "select * from table(score(table orders))";
     final String expected = "SELECT *\n"
   + "FROM TABLE(`SCORE`((TABLE `ORDERS`)))";
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithPartitionKey() {
+  @Test void tableFunctionWithPartitionKey() {
     // test one partition key for input table
     final String sql = "select * from table(topn(table orders partition by productid, 3))";
     final String expected =
@@ -6062,7 +6062,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultiplePartitionKeys() {
+  @Test void tableFunctionWithMultiplePartitionKeys() {
     // test multiple partition keys for input table
     final String sql =
         "select * from table(topn(table orders partition by (orderId, productid), 3))";
@@ -6072,7 +6072,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithOrderKey() {
+  @Test void tableFunctionWithOrderKey() {
     // test one order key for input table
     final String sql = "select * from table(topn(table orders order by orderId, 3))";
     final String expected =
@@ -6081,7 +6081,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultipleOrderKeys() {
+  @Test void tableFunctionWithMultipleOrderKeys() {
     // test multiple order keys for input table
     final String sql = "select * from table(topn(table orders order by (orderId, productid), 3))";
     final String expected =
@@ -6090,7 +6090,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithComplexOrderBy() {
+  @Test void tableFunctionWithComplexOrderBy() {
     // test complex order-by clause for input table
     final String sql =
         "select * from table(topn(table orders order by (orderId desc, productid asc), 3))";
@@ -6100,7 +6100,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithPartitionKeyAndOrderKey() {
+  @Test void tableFunctionWithPartitionKeyAndOrderKey() {
     // test partition by clause and order by clause for input table
     final String sql =
         "select * from table(topn(table orders partition by productid order by orderId, 3))";
@@ -6110,7 +6110,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithSubQuery() {
+  @Test void tableFunctionWithSubQuery() {
     // test partition by clause and order by clause for subquery
     final String sql =
         "select * from table(topn(select * from Orders partition by productid "
@@ -6122,7 +6122,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultipleInputTables() {
+  @Test void tableFunctionWithMultipleInputTables() {
     final String sql = "select * from table(similarlity(table emp, table emp_b))";
     final String expected =
         "SELECT *\n"
@@ -6130,7 +6130,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testTableFunctionWithMultipleInputTablesAndSubClauses() {
+  @Test void tableFunctionWithMultipleInputTablesAndSubClauses() {
     final String sql =
         "select * from table("
             + "similarlity("
@@ -6143,7 +6143,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testIllegalCursors() {
+  @Test void illegalCursors() {
     sql("select ^cursor^(select * from emps) from emps")
         .fails("CURSOR expression encountered in illegal context");
     sql("call list(^cursor^(select * from emps))")
@@ -6152,7 +6152,7 @@ void checkPeriodPredicate(Checker checker) {
         .fails("CURSOR expression encountered in illegal context");
   }
 
-  @Test void testExplain() {
+  @Test void explain() {
     final String sql = "explain plan for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6162,7 +6162,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainAsXml() {
+  @Test void explainAsXml() {
     final String sql = "explain plan as xml for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6172,7 +6172,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainAsDot() {
+  @Test void explainAsDot() {
     final String sql = "explain plan as dot for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6182,7 +6182,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainAsJson() {
+  @Test void explainAsJson() {
     final String sql = "explain plan as json for select * from emps";
     final String expected =
         "EXPLAIN PLAN"
@@ -6192,7 +6192,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testExplainWithImpl() {
+  @Test void explainWithImpl() {
     sql("explain plan with implementation for select * from emps")
         .ok(
             "EXPLAIN PLAN INCLUDING ATTRIBUTES WITH IMPLEMENTATION FOR\n"
@@ -6200,7 +6200,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMPS`");
   }
 
-  @Test void testExplainWithoutImpl() {
+  @Test void explainWithoutImpl() {
     sql("explain plan without implementation for select * from emps")
         .ok(
             "EXPLAIN PLAN INCLUDING ATTRIBUTES WITHOUT IMPLEMENTATION FOR\n"
@@ -6208,18 +6208,18 @@ void checkPeriodPredicate(Checker checker) {
                 + "FROM `EMPS`");
   }
 
-  @Test void testExplainWithType() {
+  @Test void explainWithType() {
     sql("explain plan with type for (values (true))")
         .ok("EXPLAIN PLAN INCLUDING ATTRIBUTES WITH TYPE FOR\n"
   + "(VALUES (ROW(TRUE)))");
   }
 
-  @Test void testExplainJsonFormat() {
+  @Test void explainJsonFormat() {
     SqlExplain sqlExplain = (SqlExplain) sql("explain plan as json for select * from emps").node();
     assertThat(sqlExplain.isJson(), is(true));
   }
 
-  @Test void testDescribeSchema() {
+  @Test void describeSchema() {
     sql("describe schema A").ok("DESCRIBE SCHEMA `A`");
     // Currently DESCRIBE DATABASE, DESCRIBE CATALOG become DESCRIBE SCHEMA.
     // See [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
@@ -6227,7 +6227,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("describe catalog A").ok("DESCRIBE SCHEMA `A`");
   }
 
-  @Test void testDescribeTable() {
+  @Test void describeTable() {
     sql("describe emps").ok("DESCRIBE TABLE `EMPS`");
     sql("describe \"emps\"").ok("DESCRIBE TABLE `emps`");
     sql("describe s.emps").ok("DESCRIBE TABLE `S`.`EMPS`");
@@ -6246,7 +6246,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("describe emps c1^.^c2").fails("(?s).*Encountered \"\\.\" at .*");
   }
 
-  @Test void testDescribeStatement() {
+  @Test void describeStatement() {
     // Currently DESCRIBE STATEMENT becomes EXPLAIN.
     // See [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
     final String expected0 =
@@ -6287,18 +6287,18 @@ void checkPeriodPredicate(Checker checker) {
         .fails("(?s).*Encountered \"explain\" at .*");
   }
 
-  @Test void testSelectIsNotDdl() {
+  @Test void selectIsNotDdl() {
     sql("select 1 from t").node(not(isDdl()));
   }
 
-  @Test void testInsertSelect() {
+  @Test void insertSelect() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "SELECT *\n"
   + "FROM `EMPS`";
     sql("insert into emps select * from emps").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testInsertUnion() {
+  @Test void insertUnion() {
     final String expected =
         "INSERT INTO `EMPS`\n"
             + "SELECT *\n"
@@ -6309,7 +6309,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("insert into emps select * from emps1 union select * from emps2").ok(expected);
   }
 
-  @Test void testInsertValues() {
+  @Test void insertValues() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "VALUES (ROW(1, 'Fredkin'))";
     final String pattern = "VALUE is not allowed under the current SQL conformance level";
@@ -6321,34 +6321,34 @@ void checkPeriodPredicate(Checker checker) {
     sql("insert into emps ^value^ (1, 'Fredkin')").fails(pattern);
   }
 
-  @Test void testInsertValuesDefault() {
+  @Test void insertValuesDefault() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "VALUES (ROW(1, DEFAULT, 'Fredkin'))";
     sql("insert into emps values (1,DEFAULT,'Fredkin')").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testInsertValuesRawDefault() {
+  @Test void insertValuesRawDefault() {
     final String expected = "INSERT INTO `EMPS`\n"
   + "VALUES (ROW(DEFAULT))";
     sql("insert into emps values ^default^").fails("(?s).*Encountered \"default\" at .*");
     sql("insert into emps values (default)").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testInsertColumnList() {
+  @Test void insertColumnList() {
     final String expected = "INSERT INTO `EMPS` (`X`, `Y`)\n"
   + "SELECT *\n"
   + "FROM `EMPS`";
     sql("insert into emps(x,y) select * from emps").ok(expected);
   }
 
-  @Test void testInsertCaseSensitiveColumnList() {
+  @Test void insertCaseSensitiveColumnList() {
     final String expected = "INSERT INTO `emps` (`x`, `y`)\n"
   + "SELECT *\n"
   + "FROM `EMPS`";
     sql("insert into \"emps\"(\"x\",\"y\") select * from emps").ok(expected);
   }
 
-  @Test void testInsertExtendedColumnList() {
+  @Test void insertExtendedColumnList() {
     String expected =
         "INSERT INTO `EMPS` EXTEND (`Z` BOOLEAN) (`X`, `Y`)\n"
   + "SELECT *\n"
@@ -6363,7 +6363,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testUpdateExtendedColumnList() {
+  @Test void updateExtendedColumnList() {
     final String expected =
         "UPDATE `EMPDEFAULTS` EXTEND (`EXTRA` BOOLEAN, `NOTE` VARCHAR)"
             + " SET `DEPTNO` = 1"
@@ -6378,7 +6378,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testUpdateCaseSensitiveExtendedColumnList() {
+  @Test void updateCaseSensitiveExtendedColumnList() {
     final String expected =
         "UPDATE `EMPDEFAULTS` EXTEND (`extra` BOOLEAN, `NOTE` VARCHAR)"
             + " SET `DEPTNO` = 1"
@@ -6393,7 +6393,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testInsertCaseSensitiveExtendedColumnList() {
+  @Test void insertCaseSensitiveExtendedColumnList() {
     String expected =
         "INSERT INTO `emps` EXTEND (`z` BOOLEAN) (`x`, `y`)\n"
   + "SELECT *\n"
@@ -6408,7 +6408,7 @@ void checkPeriodPredicate(Checker checker) {
         .ok(expected);
   }
 
-  @Test void testExplainInsert() {
+  @Test void explainInsert() {
     final String expected =
         "EXPLAIN PLAN INCLUDING ATTRIBUTES"
             + " WITH IMPLEMENTATION FOR\n"
@@ -6418,7 +6418,7 @@ void checkPeriodPredicate(Checker checker) {
     sql("explain plan for insert into emps1 select * from emps2").ok(expected).node(not(isDdl()));
   }
 
-  @Test void testUpsertValues() {
+  @Test void upsertValues() {
     final String expected = "UPSERT INTO `EMPS`\n"
   + "VALUES (ROW(1, 'Fredkin'))";
     final String sql = "upsert into emps values (1,'Fredkin')";
@@ -6427,7 +6427,7 @@ void checkPeriodPredicate(Checker checker) {
     }
   }
 
-  @Test void testUpsertSelect() {
+  @Test void upsertSelect() {
     final String sql = "upsert into emps select * from emp as e";
     final String expected = "UPSERT INTO `EMPS`\n"
   + "SELECT *\n"
@@ -6437,7 +6437,7 @@ void checkPeriodPredicate(Checker checker) {
     }
   }
 
-  @Test void testExplainUpsert() {
+  @Test void explainUpsert() {
     final String sql = "explain plan for upsert into emps1 values (1, 2)";
     final String expected =
         "EXPLAIN PLAN INCLUDING ATTRIBUTES"
@@ -6449,16 +6449,16 @@ void checkPeriodPredicate(Checker checker) {
     }
   }
 
-  @Test void testDelete() {
+  @Test void delete() {
     sql("delete from emps").ok("DELETE FROM `EMPS`").node(not(isDdl()));
   }
 
-  @Test void testDeleteWhere() {
+  @Test void deleteWhere() {
     sql("delete from emps where empno=12").ok("DELETE FROM `EMPS`\n"
   + "WHERE (`EMPNO` = 12)");
   }
 
-  @Test void testUpdate() {
+  @Test void update() {
     sql("update emps set empno = empno + 1, sal = sal - 1 where empno=12")
         .ok(
             "UPDATE `EMPS` SET `EMPNO` = (`EMPNO` + 1)"
@@ -6466,7 +6466,7 @@ void checkPeriodPredicate(Checker checker) {
                 + "WHERE (`EMPNO` = 12)");
   }
 
-  @Test void testMergeSelectSource() {
+  @Test void mergeSelectSource() {
     final String sql =
         "merge into emps e "
             + "using (select * from tempemps where deptno is null) t "
@@ -6490,7 +6490,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Same as testMergeSelectSource but set with compound identifier. */
-  @Test void testMergeSelectSource2() {
+  @Test void mergeSelectSource2() {
     final String sql =
         "merge into emps e "
             + "using (select * from tempemps where deptno is null) t "
@@ -6513,7 +6513,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected).node(not(isDdl()));
   }
 
-  @Test void testMergeTableRefSource() {
+  @Test void mergeTableRefSource() {
     final String sql =
         "merge into emps e "
             + "using tempemps as t "
@@ -6535,7 +6535,7 @@ void checkPeriodPredicate(Checker checker) {
   }
 
   /** Same with testMergeTableRefSource but set with compound identifier. */
-  @Test void testMergeTableRefSource2() {
+  @Test void mergeTableRefSource2() {
     final String sql =
         "merge into emps e "
             + "using tempemps as t "
@@ -6556,7 +6556,7 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql).ok(expected);
   }
 
-  @Test void testMergeMismatchedParentheses() {
+  @Test void mergeMismatchedParentheses() {
     // Invalid; more '(' than ')'
     final String sql1 =
         "merge into emps as e\n"
@@ -6595,13 +6595,13 @@ void checkPeriodPredicate(Checker checker) {
     sql(sql3).ok(expected);
   }
 
-  @Test void testBitStringNotImplemented() {
+  @Test void bitStringNotImplemented() {
     // Bit-string is longer part of the SQL standard. We do not support it.
     sql("select (B^'1011'^ || 'foobar') from (values (true))")
         .fails("(?s).*Encountered \"\\\\'1011\\\\'\" at .*");
   }
 
-  @Test void testHexAndBinaryString() {
+  @Test void hexAndBinaryString() {
     expr("x''=X'2'").ok("(X'' = X'2')");
     expr("x'fffff'=X''").ok("(X'FFFFF' = X'')");
     expr("x'1' \t\t\f\r\n"
@@ -6617,7 +6617,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("x'001'=X'000102'").ok("(X'001' = X'000102')");
   }
 
-  @Test void testHexAndBinaryStringFails() {
+  @Test void hexAndBinaryStringFails() {
     sql("select ^x'FeedGoats'^ from t")
         .fails("Binary literal string must contain only characters '0' - '9', 'A' - 'F'");
     sql("select ^x'abcdefG'^ from t")
@@ -6630,7 +6630,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `T`");
   }
 
-  @Test void testStringLiteral() {
+  @Test void stringLiteral() {
     expr("_latin1'hi'").ok("_LATIN1'hi'");
     expr("N'is it a plane? no it''s superman!'")
         .ok("_ISO-8859-1'is it a plane? no it''s superman!'");
@@ -6653,7 +6653,7 @@ void checkPeriodPredicate(Checker checker) {
         .same();
   }
 
-  @Test void testStringLiteralFails() {
+  @Test void stringLiteralFails() {
     sql("select (N ^'space'^)").fails("(?s).*Encountered .*space.* at line 1, column ...*");
     sql("select (_latin1\n^'newline'^)")
         .fails("(?s).*Encountered.*newline.* at line 2, column ...*");
@@ -6666,7 +6666,7 @@ void checkPeriodPredicate(Checker checker) {
   + "FROM `T`");
   }
 
-  @Test void testStringLiteralChain() {
+  @Test void stringLiteralChain() {
     final String fooBar = "'foo'\n"
   + "'bar'";
     final String fooBarBaz = "'foo'\n"
@@ -6683,7 +6683,7 @@ void checkPeriodPredicate(Checker checker) {
     expr("   'foo' 'bar'").ok(fooBar);
   }
 
-  @Test void testStringLiteralDoubleQuoted() {
+  @Test void stringLiteralDoubleQuoted() {
     sql("select `deptno` as d, ^\"^deptno\" as d2 from emp")
         .withDialect(MYSQL)
         .fails("(?s)Encountered \"\\\\\"\" at .*")
@@ -6730,7 +6730,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   }
 
   @VisibleForTesting
-  @Test public void testCaseExpression() {
+  @Test void caseExpression() {
     // implicit simple "ELSE NULL" case
     expr("case \t col1 when 1 then 'one' end")
         .ok("(CASE WHEN (`COL1` = 1) THEN 'one' ELSE NULL END)");
@@ -6763,7 +6763,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql("case when b1, b2 ^when^ 2, 4 then 3 else 4 end").fails("(?s)Encountered \"when\" at .*");
   }
 
-  @Test void testCaseExpressionFails() {
+  @Test void caseExpressionFails() {
     // Missing 'END'
     sql("select case col1 when 1 then 'one' ^from^ t").fails("(?s).*from.*");
 
@@ -6781,20 +6781,20 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql("select 1 as if").ok("SELECT 1 AS `IF`");
   }
 
-  @Test void testNullIf() {
+  @Test void nullIf() {
     expr("nullif(v1,v2)").ok("NULLIF(`V1`, `V2`)");
     if (isReserved("NULLIF")) {
       expr("1 + ^nullif^ + 3").fails("(?s)Encountered \"nullif \\+\" at line 1, column 5.*");
     }
   }
 
-  @Test void testCoalesce() {
+  @Test void coalesce() {
     expr("coalesce(v1)").ok("COALESCE(`V1`)");
     expr("coalesce(v1,v2)").ok("COALESCE(`V1`, `V2`)");
     expr("coalesce(v1,v2,v3)").ok("COALESCE(`V1`, `V2`, `V3`)");
   }
 
-  @Test void testLiteralCollate() {
+  @Test void literalCollate() {
     if (!Bug.FRG78_FIXED) {
       return;
     }
@@ -6813,20 +6813,20 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .ok("('str1' COLLATE ISO-8859-1$sv_SE$primary <= 'str2' COLLATE ISO-8859-1$sv_FI$primary)");
   }
 
-  @Test void testCharLength() {
+  @Test void charLength() {
     expr("char_length('string')").ok("CHAR_LENGTH('string')");
     expr("character_length('string')").ok("CHARACTER_LENGTH('string')");
   }
 
-  @Test void testPosition() {
+  @Test void position() {
     expr("posiTion('mouse' in 'house')").ok("POSITION('mouse' IN 'house')");
   }
 
-  @Test void testReplace() {
+  @Test void replace() {
     expr("replace('x', 'y', 'z')").ok("REPLACE('x', 'y', 'z')");
   }
 
-  @Test void testDateLiteral() {
+  @Test void dateLiteral() {
     final String expected = "SELECT DATE '1980-01-01'\n"
   + "FROM `T`";
     sql("select date '1980-01-01' from t").ok(expected);
@@ -6848,7 +6848,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
    * Tests that on BigQuery, DATE, TIME and TIMESTAMP literals can use single- or double-quoted
    * strings.
    */
-  @Test void testDateLiteralBigQuery() {
+  @Test void dateLiteralBigQuery() {
     final SqlParserFixture f = fixture().withDialect(BIG_QUERY);
     f.sql("select date '2020-10-10'").ok("SELECT DATE '2020-10-10'");
     f.sql("select date\"2020-10-10\"").ok("SELECT DATE '2020-10-10'");
@@ -6858,7 +6858,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     f.sql("select time \"13:22:04\"").ok("SELECT TIME '13:22:04'");
   }
 
-  @Test void testIntervalLiteralBigQuery() {
+  @Test void intervalLiteralBigQuery() {
     final SqlParserFixture f = fixture().withDialect(BIG_QUERY).expression(true);
     f.sql("interval '1' day").ok("INTERVAL '1' DAY");
     f.sql("interval \"1\" day").ok("INTERVAL '1' DAY");
@@ -6867,7 +6867,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   }
 
   // check date/time functions.
-  @Test void testTimeDate() {
+  @Test void timeDate() {
     // CURRENT_TIME - returns time w/ timezone
     expr("CURRENT_TIME(3)").same();
 
@@ -6946,7 +6946,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   }
 
   /** Tests for casting to/from date/time types. */
-  @Test void testDateTimeCast() {
+  @Test void dateTimeCast() {
     //   checkExp("CAST(DATE '2001-12-21' AS CHARACTER VARYING)",
     // "CAST(2001-12-21)");
     expr("CAST('2001-12-21' AS DATE)").same();
@@ -6957,7 +6957,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("Cast(DATE '2004-12-21' AS VARCHAR(10))").ok("CAST(DATE '2004-12-21' AS VARCHAR(10))");
   }
 
-  @Test void testTrim() {
+  @Test void trim() {
     expr("trim('mustache' FROM 'beard')").ok("TRIM(BOTH 'mustache' FROM 'beard')");
     expr("trim('mustache')").ok("TRIM(BOTH ' ' FROM 'mustache')");
     expr("trim(TRAILING FROM 'mustache')").ok("TRIM(TRAILING ' ' FROM 'mustache')");
@@ -6974,7 +6974,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql("trim(^from^ 'beard')").fails("(?s).*'FROM' without operands preceding it is illegal.*");
   }
 
-  @Test void testConvertAndTranslate() {
+  @Test void convertAndTranslate() {
     expr("convert('abc', utf8, utf16)").ok("CONVERT('abc', `UTF8`, `UTF16`)");
     sql("select convert(name, latin1, gbk) as newName from t")
         .ok("SELECT CONVERT(`NAME`, `LATIN1`, `GBK`) AS `NEWNAME`\n"
@@ -6991,17 +6991,17 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `T`");
   }
 
-  @Test void testTranslate3() {
+  @Test void translate3() {
     expr("translate('aaabbbccc', 'ab', '+-')").ok("TRANSLATE('aaabbbccc', 'ab', '+-')");
   }
 
-  @Test void testOverlay() {
+  @Test void overlay() {
     expr("overlay('ABCdef' placing 'abc' from 1)").ok("OVERLAY('ABCdef' PLACING 'abc' FROM 1)");
     expr("overlay('ABCdef' placing 'abc' from 1 for 3)")
         .ok("OVERLAY('ABCdef' PLACING 'abc' FROM 1 FOR 3)");
   }
 
-  @Test void testJdbcFunctionCall() {
+  @Test void jdbcFunctionCall() {
     expr("{fn apa(1,'1')}").ok("{fn APA(1, '1') }");
     expr("{ Fn apa(log10(ln(1))+2)}").ok("{fn APA((LOG10(LN(1)) + 2)) }");
     expr("{fN apa(*)}").ok("{fn APA(*) }");
@@ -7028,14 +7028,14 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("{fn convert(1, ^INTERVAL^ YEAR)}").fails("(?s)Encountered \"INTERVAL\" at.*");
   }
 
-  @Test void testWindowReference() {
+  @Test void windowReference() {
     expr("sum(sal) over (w)").ok("(SUM(`SAL`) OVER (`W`))");
 
     // Only 1 window reference allowed
     expr("sum(sal) over (w ^w1^ partition by deptno)").fails("(?s)Encountered \"w1\" at.*");
   }
 
-  @Test void testWindowInSubQuery() {
+  @Test void windowInSubQuery() {
     final String sql =
         "select * from (\n"
             + " select sum(x) over w, sum(y) over w\n"
@@ -7049,7 +7049,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testWindowSpec() {
+  @Test void windowSpec() {
     // Correct syntax
     final String sql1 =
         "select count(z) over w as foo\n"
@@ -7117,7 +7117,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .fails("(?s).*Encountered \"order\".*");
   }
 
-  @Test void testWindowSpecPartial() {
+  @Test void windowSpecPartial() {
     // ALLOW PARTIAL is the default, and is omitted when the statement is
     // unparsed.
     sql("select sum(x) over (order by x allow partial) from bids")
@@ -7137,7 +7137,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `BIDS`");
   }
 
-  @Test void testQualify() {
+  @Test void qualify() {
     final String sql =
         "SELECT empno, ename,\n"
             + " ROW_NUMBER() over (partition by ename order by deptno) as rn\n"
@@ -7151,7 +7151,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyWithoutAlias() {
+  @Test void qualifyWithoutAlias() {
     final String sql =
         "SELECT empno, ename\n"
             + "FROM emp\n"
@@ -7163,7 +7163,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyWithWindowClause() {
+  @Test void qualifyWithWindowClause() {
     final String sql =
         "SELECT empno, ename,\n"
             + " SUM(deptno) OVER myWindow as sumDeptNo\n"
@@ -7179,7 +7179,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyWithEverything() {
+  @Test void qualifyWithEverything() {
     final String sql =
         "SELECT DISTINCT ename,\n"
             + " SUM(deptno) OVER (PARTITION BY ename) as r\n"
@@ -7203,7 +7203,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).ok(expected);
   }
 
-  @Test void testQualifyIllegalAfterOrder() {
+  @Test void qualifyIllegalAfterOrder() {
     final String sql = "SELECT x\n"
   + "FROM t\n"
   + "ORDER BY 1 DESC\n"
@@ -7211,7 +7211,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     sql(sql).fails("(?s).*Encountered \"QUALIFY\" at .*");
   }
 
-  @Test void testNullTreatment() {
+  @Test void nullTreatment() {
     sql("select lead(x) respect nulls over (w) from t")
         .ok("SELECT (LEAD(`X`) RESPECT NULLS OVER (`W`))\n"
   + "FROM `T`");
@@ -7249,7 +7249,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `T`");
   }
 
-  @Test void testAs() {
+  @Test void as() {
     // AS is optional for column aliases
     sql("select x y from t").ok("SELECT `X` AS `Y`\n"
   + "FROM `T`");
@@ -7283,7 +7283,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .fails("(?s).*Encountered \"over\".*");
   }
 
-  @Test void testAsAliases() {
+  @Test void asAliases() {
     sql("select x from t as t1 (a, b) where foo")
         .ok("SELECT `X`\n"
   + "FROM `T` AS `T1` (`A`, `B`)\n"
@@ -7315,7 +7315,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "    \",\" \\.\\.\\..*");
   }
 
-  @Test void testOver() {
+  @Test void over() {
     expr("sum(sal) over ()").ok("(SUM(`SAL`) OVER ())");
     expr("sum(sal) over (partition by x, y)").ok("(SUM(`SAL`) OVER (PARTITION BY `X`, `Y`))");
     expr("sum(sal) over (order by x desc, y asc)").ok("(SUM(`SAL`) OVER (ORDER BY `X` DESC, `Y`))");
@@ -7355,29 +7355,29 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
                 + "AND INTERVAL '5' DAY FOLLOWING))");
   }
 
-  @Test void testElementFunc() {
+  @Test void elementFunc() {
     expr("element(a)").ok("ELEMENT(`A`)");
   }
 
-  @Test void testCardinalityFunc() {
+  @Test void cardinalityFunc() {
     expr("cardinality(a)").ok("CARDINALITY(`A`)");
   }
 
-  @Test void testMemberOf() {
+  @Test void memberOf() {
     expr("a member of b").ok("(`A` MEMBER OF `B`)");
     expr("a member of multiset[b]").ok("(`A` MEMBER OF (MULTISET[`B`]))");
   }
 
-  @Test void testSubMultisetrOf() {
+  @Test void subMultisetrOf() {
     expr("a submultiset of b").ok("(`A` SUBMULTISET OF `B`)");
   }
 
-  @Test void testIsASet() {
+  @Test void isASet() {
     expr("b is a set").ok("(`B` IS A SET)");
     expr("a is a set").ok("(`A` IS A SET)");
   }
 
-  @Test void testMultiset() {
+  @Test void multiset() {
     expr("multiset[1]").ok("(MULTISET[1])");
     expr("multiset[1,2.3]").ok("(MULTISET[1, 2.3])");
     expr("multiset[1,    '2']").ok("(MULTISET[1, '2'])");
@@ -7388,25 +7388,25 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
   + "FROM `T`)))");
   }
 
-  @Test void testMultisetUnion() {
+  @Test void multisetUnion() {
     expr("a multiset union b").ok("(`A` MULTISET UNION ALL `B`)");
     expr("a multiset union all b").ok("(`A` MULTISET UNION ALL `B`)");
     expr("a multiset union distinct b").ok("(`A` MULTISET UNION DISTINCT `B`)");
   }
 
-  @Test void testMultisetExcept() {
+  @Test void multisetExcept() {
     expr("a multiset EXCEPT b").ok("(`A` MULTISET EXCEPT ALL `B`)");
     expr("a multiset EXCEPT all b").ok("(`A` MULTISET EXCEPT ALL `B`)");
     expr("a multiset EXCEPT distinct b").ok("(`A` MULTISET EXCEPT DISTINCT `B`)");
   }
 
-  @Test void testMultisetIntersect() {
+  @Test void multisetIntersect() {
     expr("a multiset INTERSECT b").ok("(`A` MULTISET INTERSECT ALL `B`)");
     expr("a multiset INTERSECT all b").ok("(`A` MULTISET INTERSECT ALL `B`)");
     expr("a multiset INTERSECT distinct b").ok("(`A` MULTISET INTERSECT DISTINCT `B`)");
   }
 
-  @Test void testMultisetMixed() {
+  @Test void multisetMixed() {
     expr("multiset[1] MULTISET union b").ok("((MULTISET[1]) MULTISET UNION ALL `B`)");
     final String sql =
         "a MULTISET union b " + "multiset intersect c " + "multiset except d " + "multiset union e";
@@ -7417,32 +7417,32 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr(sql).ok(expected);
   }
 
-  @Test void testMapItem() {
+  @Test void mapItem() {
     expr("a['foo']").ok("`A`['foo']");
     expr("a['x' || 'y']").ok("`A`[('x' || 'y')]");
     expr("a['foo'] ['bar']").ok("`A`['foo']['bar']");
     expr("a['foo']['bar']").ok("`A`['foo']['bar']");
   }
 
-  @Test void testMapItemPrecedence() {
+  @Test void mapItemPrecedence() {
     expr("1 + a['foo'] * 3").ok("(1 + (`A`['foo'] * 3))");
     expr("1 * a['foo'] + 3").ok("((1 * `A`['foo']) + 3)");
     expr("a['foo']['bar']").ok("`A`['foo']['bar']");
     expr("a[b['foo' || 'bar']]").ok("`A`[`B`[('foo' || 'bar')]]");
   }
 
-  @Test void testArrayElement() {
+  @Test void arrayElement() {
     expr("a[1]").ok("`A`[1]");
     expr("a[b[1]]").ok("`A`[`B`[1]]");
     expr("a[b[1 + 2] + 3]").ok("`A`[(`B`[(1 + 2)] + 3)]");
   }
 
-  @Test void testArrayElementWithDot() {
+  @Test void arrayElementWithDot() {
     expr("a[1+2].b.c[2].d").ok("(((`A`[(1 + 2)].`B`).`C`)[2].`D`)");
     expr("a[b[1]].c.f0[d[1]]").ok("((`A`[`B`[1]].`C`).`F0`)[`D`[1]]");
   }
 
-  @Test void testArrayValueConstructor() {
+  @Test void arrayValueConstructor() {
     expr("array[1, 2]").ok("(ARRAY[1, 2])");
     expr("array [1, 2]").ok("(ARRAY[1, 2])"); // with space
 
@@ -7451,12 +7451,12 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("array[(1, 'a'), (2, 'b')]").ok("(ARRAY[(ROW(1, 'a')), (ROW(2, 'b'))])");
   }
 
-  @Test void testArrayFunction() {
+  @Test void arrayFunction() {
     expr("array()").ok("ARRAY()");
     expr("array(1)").ok("ARRAY(1)");
   }
 
-  @Test void testArrayQueryConstructor() {
+  @Test void arrayQueryConstructor() {
     sql("SELECT array(SELECT x FROM (VALUES(1)) x)")
         .ok("SELECT (ARRAY ((SELECT `X`\n"
   + "FROM (VALUES (ROW(1))) AS `X`)))");
@@ -7470,7 +7470,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .fails("(?s)Incorrect syntax near the keyword 'SELECT'.*");
   }
 
-  @Test void testCastAsCollectionType() {
+  @Test void castAsCollectionType() {
     // test array type.
     expr("cast(a as int array)").ok("CAST(`A` AS INTEGER ARRAY)");
     expr("cast(a as varchar(5) array)").ok("CAST(`A` AS VARCHAR(5) ARRAY)");
@@ -7493,7 +7493,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     expr("cast(a as MyUDT array multiset)").ok("CAST(`A` AS `MYUDT` ARRAY MULTISET)");
   }
 
-  @Test void testCastAsRowType() {
+  @Test void castAsRowType() {
     expr("cast(a as row(f0 int, f1 varchar))").ok("CAST(`A` AS ROW(`F0` INTEGER, `F1` VARCHAR))");
     expr("cast(a as row(f0 int not null, f1 varchar null))")
         .ok("CAST(`A` AS ROW(`F0` INTEGER, `F1` VARCHAR NULL))");
@@ -7512,13 +7512,13 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
         .ok("CAST(`A` AS ROW(`F0` VARCHAR, `F1` TIMESTAMP NULL) MULTISET)");
   }
 
-  @Test void testMapValueConstructor() {
+  @Test void mapValueConstructor() {
     expr("map[1, 'x', 2, 'y']").ok("(MAP[1, 'x', 2, 'y'])");
     expr("map [1, 'x', 2, 'y']").ok("(MAP[1, 'x', 2, 'y'])");
     expr("map[]").ok("(MAP[])");
   }
 
-  @Test void testVisitSqlInsertWithSqlShuttle() {
+  @Test void visitSqlInsertWithSqlShuttle() {
     final String sql = "insert into emps select * from emps";
     final SqlNode sqlNode = sql(sql).node();
     final SqlNode sqlNodeVisited =
@@ -7533,7 +7533,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     assertThat(sqlNodeVisited.getKind(), is(SqlKind.INSERT));
   }
 
-  @Test void testSqlInsertSqlBasicCallToString() {
+  @Test void sqlInsertSqlBasicCallToString() {
     final String sql0 = "insert into emps select * from emps";
     final SqlNode sqlNode0 = sql(sql0).node();
     final SqlNode sqlNodeVisited0 =
@@ -7565,7 +7565,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
     assertThat(str1, is(toLinux(sqlNodeVisited1.toString())));
   }
 
-  @Test void testVisitSqlMatchRecognizeWithSqlShuttle() {
+  @Test void visitSqlMatchRecognizeWithSqlShuttle() {
     final String sql =
         "select *\n"
             + "from emp \n"
@@ -7599,7 +7599,7 @@ private static Matcher<SqlNode> isCharLiteral(String s) {
    * <p>A substantially identical set of tests exists in SqlValidatorTest, and any changes here
    * should be synchronized there.
    */
-  @Test void testIntervalLiterals() {
+  @Test void intervalLiterals() {
     final SqlParserFixture f = fixture();
     final IntervalTest.Fixture intervalFixture =
         new IntervalTest.Fixture() {
@@ -7632,7 +7632,7 @@ private IntervalTest.Fixture2 getFixture2(SqlParserFixture f2, String expectedSq
     new IntervalTest(intervalFixture).testAll();
   }
 
-  @Test void testUnparseableIntervalQualifiers() {
+  @Test void unparseableIntervalQualifiers() {
     // No qualifier
     expr("interval '1^'^")
         .fails(
@@ -7794,7 +7794,7 @@ private IntervalTest.Fixture2 getFixture2(SqlParserFixture f2, String expectedSq
     expr("interval '1-2' month(3) ^to^ second(2,6)").fails(ANY);
   }
 
-  @Test void testUnparseableIntervalQualifiers2() {
+  @Test void unparseableIntervalQualifiers2() {
     expr("interval '1-2' day(3) ^to^ year(2)").fails(ANY);
     expr("interval '1-2' day(3) ^to^ month(2)").fails(ANY);
     expr("interval '1-2' day(3) ^to^ day(2)").fails(ANY);
@@ -7861,7 +7861,7 @@ private IntervalTest.Fixture2 getFixture2(SqlParserFixture f2, String expectedSq
   }
 
   /** Tests that plural time units are allowed when not in strict mode. */
-  @Test void testIntervalPluralUnits() {
+  @Test void intervalPluralUnits() {
     expr("interval '2' years").hasWarning(checkWarnings("YEARS")).ok("INTERVAL '2' YEAR");
     expr("interval '2:1' years to months")
         .hasWarning(checkWarnings("YEARS", "MONTHS"))
@@ -7894,7 +7894,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     };
   }
 
-  @Test void testMiscIntervalQualifier() {
+  @Test void miscIntervalQualifier() {
     expr("interval '-' day").ok("INTERVAL '-' DAY");
 
     expr("interval '1 2:3:4.567' day to hour ^to^ second").fails("(?s)Encountered \"to\" at.*");
@@ -7903,7 +7903,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval '1:x:2' hour to second").ok("INTERVAL '1:x:2' HOUR TO SECOND");
   }
 
-  @Test void testIntervalExpression() {
+  @Test void intervalExpression() {
     expr("interval 0 day").ok("INTERVAL 0 DAY");
     expr("interval 0 days").ok("INTERVAL 0 DAY");
     expr("interval -10 days").ok("INTERVAL (- 10) DAY");
@@ -7918,7 +7918,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval '1 1' day to hour").ok("INTERVAL '1 1' DAY TO HOUR");
   }
 
-  @Test void testIntervalOperators() {
+  @Test void intervalOperators() {
     expr("-interval '1' day").ok("(- INTERVAL '1' DAY)");
     expr("interval '1' day + interval '1' day").ok("(INTERVAL '1' DAY + INTERVAL '1' DAY)");
     expr("interval '1' day - interval '1:2:3' hour to second")
@@ -7932,7 +7932,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval 'wael was here' HOUR").ok("INTERVAL 'wael was here' HOUR");
   }
 
-  @Test void testDateMinusDate() {
+  @Test void dateMinusDate() {
     expr("(date1 - date2) HOUR").ok("((`DATE1` - `DATE2`) HOUR)");
     expr("(date1 - date2) YEAR TO MONTH").ok("((`DATE1` - `DATE2`) YEAR TO MONTH)");
     expr("(date1 - date2) HOUR > interval '1' HOUR")
@@ -7947,7 +7947,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "Was expecting ..DATETIME - DATETIME. INTERVALQUALIFIER.*");
   }
 
-  @Test void testExtract() {
+  @Test void extract() {
     expr("extract(year from x)").ok("EXTRACT(YEAR FROM `X`)");
     expr("extract(month from x)").ok("EXTRACT(MONTH FROM `X`)");
     expr("extract(day from x)").ok("EXTRACT(DAY FROM `X`)");
@@ -7970,7 +7970,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Tests that EXTRACT, FLOOR, CEIL, DATE_TRUNC functions accept abbreviations for time units (such
    * as "Y" for "YEAR") when configured via {@link Config#timeUnitCodes()}.
    */
-  @Test protected void testTimeUnitCodes() {
+  @Test void timeUnitCodes() {
     // YEAR is a built-in time frame. When unparsed, it looks like a keyword.
     // (Note no backticks around YEAR.)
     expr("floor(d to year)").ok("FLOOR(`D` TO YEAR)");
@@ -8006,7 +8006,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("date_trunc(d , week(tuesday))").ok("(DATE_TRUNC(`D`, `WEEK_TUESDAY`))");
   }
 
-  @Test void testGeometry() {
+  @Test void geometry() {
     expr("cast(null as ^geometry^)")
         .fails("Geo-spatial extensions and the GEOMETRY data type are not enabled");
     expr("cast(null as geometry)")
@@ -8014,7 +8014,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("CAST(NULL AS GEOMETRY)");
   }
 
-  @Test void testIntervalArithmetics() {
+  @Test void intervalArithmetics() {
     expr("TIME '23:59:59' - interval '1' hour ").ok("(TIME '23:59:59' - INTERVAL '1' HOUR)");
     expr("TIMESTAMP '2000-01-01 23:59:59.1' - interval '1' hour ")
         .ok("(TIMESTAMP '2000-01-01 23:59:59.1' - INTERVAL '1' HOUR)");
@@ -8032,7 +8032,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("interval '1' hour / 8").ok("(INTERVAL '1' HOUR / 8)");
   }
 
-  @Test void testIntervalCompare() {
+  @Test void intervalCompare() {
     expr("interval '1' hour = interval '1' second").ok("(INTERVAL '1' HOUR = INTERVAL '1' SECOND)");
     expr("interval '1' hour <> interval '1' second")
         .ok("(INTERVAL '1' HOUR <> INTERVAL '1' SECOND)");
@@ -8044,7 +8044,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("(INTERVAL '1' HOUR >= INTERVAL '1' SECOND)");
   }
 
-  @Test void testCastToInterval() {
+  @Test void castToInterval() {
     expr("cast(x as interval year)").ok("CAST(`X` AS INTERVAL YEAR)");
     expr("cast(x as interval month)").ok("CAST(`X` AS INTERVAL MONTH)");
     expr("cast(x as interval year to month)").ok("CAST(`X` AS INTERVAL YEAR TO MONTH)");
@@ -8062,14 +8062,14 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("CAST(INTERVAL '3-2' YEAR TO MONTH AS CHAR(5))");
   }
 
-  @Test void testCastToVarchar() {
+  @Test void castToVarchar() {
     expr("cast(x as varchar(5))").ok("CAST(`X` AS VARCHAR(5))");
     expr("cast(x as varchar)").ok("CAST(`X` AS VARCHAR)");
     expr("cast(x as varBINARY(5))").ok("CAST(`X` AS VARBINARY(5))");
     expr("cast(x as varbinary)").ok("CAST(`X` AS VARBINARY)");
   }
 
-  @Test void testTimestampAdd() {
+  @Test void timestampAdd() {
     final String sql = "select * from t\n"
   + "where timestampadd(month, 5, hiredate) < curdate";
     final String expected =
@@ -8096,7 +8096,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("TIMESTAMPADD(`INCORRECT`, 1, CURRENT_TIMESTAMP)");
   }
 
-  @Test void testTimestampDiff() {
+  @Test void timestampDiff() {
     final String sql =
         "select * from t\n"
   + "where timestampdiff(microsecond, 5, hiredate) < curdate";
@@ -8124,7 +8124,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("TIMESTAMPDIFF(`INCORRECT`, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)");
   }
 
-  @Test void testTimeTrunc() {
+  @Test void timeTrunc() {
     final String sql = "select time_trunc(TIME '15:30:00', hour) from t";
     final String expected = "SELECT TIME_TRUNC(TIME '15:30:00', HOUR)\n"
   + "FROM `T`";
@@ -8144,7 +8144,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testTimestampTrunc() {
+  @Test void timestampTrunc() {
     final String sql = "select timestamp_trunc(timestamp '2008-12-25 15:30:00', week) from t";
     final String expected =
         "SELECT TIMESTAMP_TRUNC(TIMESTAMP '2008-12-25 15:30:00', WEEK)\n"
@@ -8158,7 +8158,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testUnnest() {
+  @Test void unnest() {
     sql("select*from unnest(x)").ok("SELECT *\n"
   + "FROM UNNEST(`X`)");
     sql("select*from unnest(x) AS T").ok("SELECT *\n"
@@ -8200,7 +8200,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql1).ok(expected1);
   }
 
-  @Test void testUnnestWithOrdinality() {
+  @Test void unnestWithOrdinality() {
     sql("select * from unnest(x) with ordinality")
         .ok("SELECT *\n"
   + "FROM UNNEST(`X`) WITH ORDINALITY");
@@ -8213,7 +8213,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql("select*from unnest(x) as T ^with^ ordinality").fails("(?s)Encountered \"with\" at .*");
   }
 
-  @Test void testParensInFrom() {
+  @Test void parensInFrom() {
     // UNNEST may not occur within parentheses.
     // FIXME should fail at "unnest"
     sql("select *from (^unnest(x)^)").fails("Expected query or join");
@@ -8269,7 +8269,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-35">[CALCITE-35] Support
    * parenthesized sub-clause in JOIN</a>.
    */
-  @Test void testParenthesizedJoins() {
+  @Test void parenthesizedJoins() {
     final String sql =
         "SELECT * FROM "
             + "(((S.C c INNER JOIN S.N n ON n.id = c.id) "
@@ -8300,7 +8300,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5194">[CALCITE-5194]
    * Cannot parse parenthesized UNION in FROM</a>.
    */
-  @Test void testParenthesizedUnionInFrom() {
+  @Test void parenthesizedUnionInFrom() {
     final String sql =
         "select *\n"
   + "from (\n"
@@ -8317,7 +8317,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testParenthesizedUnionAndJoinInFrom() {
+  @Test void parenthesizedUnionAndJoinInFrom() {
     final String sql =
         "select *\n"
             + "from (\n"
@@ -8341,7 +8341,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   /**
    * As {@link #testParenthesizedUnionAndJoinInFrom()} but the UNION is the first input to the JOIN.
    */
-  @Test void testParenthesizedUnionAndJoinInFrom2() {
+  @Test void parenthesizedUnionAndJoinInFrom2() {
     final String sql =
         "select *\n"
             + "from (\n"
@@ -8363,7 +8363,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** As {@link #testParenthesizedUnionAndJoinInFrom2()} but INNER JOIN rather than CROSS JOIN. */
-  @Test void testParenthesizedUnionAndJoinInFrom3() {
+  @Test void parenthesizedUnionAndJoinInFrom3() {
     final String sql =
         "select *\n"
             + "from (\n"
@@ -8384,7 +8384,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testParenthesizedUnion() {
+  @Test void parenthesizedUnion() {
     final String sql =
         "(select x from a\n"
             + "  union\n"
@@ -8403,7 +8403,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testFromExpr() {
+  @Test void fromExpr() {
     String sql0 = "select * from a cross join b";
     String sql1 = "select * from (a cross join b)";
     String expected = "SELECT *\n"
@@ -8414,7 +8414,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Tests parsing parenthesized queries. */
-  @Test void testParenthesizedQueries() {
+  @Test void parenthesizedQueries() {
     final String expected = "SELECT *\n"
   + "FROM (SELECT *\n"
   + "FROM `TAB`) AS `X`";
@@ -8456,30 +8456,30 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql6).fails(message);
   }
 
-  @Test void testProcedureCall() {
+  @Test void procedureCall() {
     sql("call blubber(5)").ok("CALL `BLUBBER`(5)");
     sql("call \"blubber\"(5)").ok("CALL `blubber`(5)");
     sql("call whale.blubber(5)").ok("CALL `WHALE`.`BLUBBER`(5)");
   }
 
-  @Test void testNewSpecification() {
+  @Test void newSpecification() {
     expr("new udt()").ok("(NEW `UDT`())");
     expr("new my.udt(1, 'hey')").ok("(NEW `MY`.`UDT`(1, 'hey'))");
     expr("new udt() is not null").ok("((NEW `UDT`()) IS NOT NULL)");
     expr("1 + new udt()").ok("(1 + (NEW `UDT`()))");
   }
 
-  @Test void testMultisetCast() {
+  @Test void multisetCast() {
     expr("cast(multiset[1] as double multiset)").ok("CAST((MULTISET[1]) AS DOUBLE MULTISET)");
   }
 
-  @Test void testAddCarets() {
+  @Test void addCarets() {
     assertEquals("values (^foo^)", SqlParserUtil.addCarets("values (foo)", 1, 9, 1, 12));
     assertEquals("abc^def", SqlParserUtil.addCarets("abcdef", 1, 4, 1, 4));
     assertEquals("abcdef^", SqlParserUtil.addCarets("abcdef", 1, 7, 1, 7));
   }
 
-  @Test void testSnapshotForSystemTimeWithAlias() {
+  @Test void snapshotForSystemTimeWithAlias() {
     sql("SELECT * FROM orders LEFT JOIN products FOR SYSTEM_TIME AS OF "
             + "orders.proctime as products ON orders.product_id = products.pro_id")
         .ok(
@@ -8489,7 +8489,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + ".`PRODUCT_ID` = `PRODUCTS`.`PRO_ID`)");
   }
 
-  @Test protected void testMetadata() {
+  @Test void metadata() {
     SqlAbstractParserImpl.Metadata metadata = sql("").parser().getMetadata();
     assertThat(metadata.isReservedFunctionName("ABS"), is(true));
     assertThat(metadata.isReservedFunctionName("FOO"), is(false));
@@ -8535,7 +8535,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * #RESERVED_KEYWORDS} list. If not, add the keyword to the non-reserved keyword list in the
    * parser.
    */
-  @Test void testNoUnintendedNewReservedKeywords() {
+  @Test void noUnintendedNewReservedKeywords() {
     assumeTrue(isNotSubclass(), "don't run this test for sub-classes");
     final SqlAbstractParserImpl.Metadata metadata = fixture().parser().getMetadata();
 
@@ -8559,7 +8559,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertThat(reason, reservedKeywords, is(getReservedKeywords()));
   }
 
-  @Test void testTabStop() {
+  @Test void tabStop() {
     sql("SELECT *\n\tFROM mytable").ok("SELECT *\n"
   + "FROM `MYTABLE`");
 
@@ -8569,7 +8569,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .fails("(?s).*Encountered \"= =\" at line 1, column 32\\..*");
   }
 
-  @Test void testLongIdentifiers() {
+  @Test void longIdentifiers() {
     StringBuilder ident128Builder = new StringBuilder();
     for (int i = 0; i < 128; i++) {
       ident128Builder.append((char) ('a' + (i % 26)));
@@ -8602,7 +8602,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    *
    * <p>See {@code org.apache.calcite.test.SqlValidatorTest#testQuotedFunction()}.
    */
-  @Test void testQuotedFunction() {
+  @Test void quotedFunction() {
     expr("\"CAST\"(1 ^as^ double)").fails("(?s).*Encountered \"as\" at .*");
     expr("\"POSITION\"('b' ^in^ 'alphabet')")
         .fails("(?s).*Encountered \"in \\\\'alphabet\\\\'\" at .*");
@@ -8611,7 +8611,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Tests applying a member function of a specific type as a suffix function. */
-  @Test void testMemberFunction() {
+  @Test void memberFunction() {
     sql("SELECT myColumn.func(a, b) FROM tbl")
         .ok("SELECT `MYCOLUMN`.`FUNC`(`A`, `B`)\n"
   + "FROM `TBL`");
@@ -8626,7 +8626,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   + "FROM `TBL`");
   }
 
-  @Test void testUnicodeLiteral() {
+  @Test void unicodeLiteral() {
     // Note that here we are constructing a SQL statement which directly
     // contains Unicode characters (not SQL Unicode escape sequences).  The
     // escaping here is Java-only, so by the time it gets to the SQL
@@ -8648,7 +8648,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(in3).ok(out3);
   }
 
-  @Test void testUnicodeEscapedLiteral() {
+  @Test void unicodeEscapedLiteral() {
     // Note that here we are constructing a SQL statement which
     // contains SQL-escaped Unicode characters to be handled
     // by the SQL parser.
@@ -8660,7 +8660,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(in.replace("\\", "!") + "UESCAPE '!'").ok(out);
   }
 
-  @Test void testIllegalUnicodeEscape() {
+  @Test void illegalUnicodeEscape() {
     expr("U&'abc' UESCAPE '!!'").fails(".*must be exactly one character.*");
     expr("U&'abc' UESCAPE ''").fails(".*must be exactly one character.*");
     expr("U&'abc' UESCAPE '0'").fails(".*hex digit.*");
@@ -8674,7 +8674,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("^U&'\\wxyz'^").fails(".*is not exactly four hex digits.*");
   }
 
-  @Test void testSqlOptions() {
+  @Test void sqlOptions() {
     SqlNode node = sql("alter system set schema = true").node();
     SqlSetOption opt = (SqlSetOption) node;
     assertThat(opt.getScope(), equalTo("SYSTEM"));
@@ -8718,7 +8718,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql("alter system set x = 1^,^ y = 2").fails("(?s)Encountered \",\" at line 1, column 23\\..*");
   }
 
-  @Test void testSequence() {
+  @Test void sequence() {
     sql("select next value for my_schema.my_seq from t")
         .ok("SELECT (NEXT VALUE FOR `MY_SCHEMA`.`MY_SEQ`)\n"
   + "FROM `T`");
@@ -8752,7 +8752,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   + "VALUES (ROW(1, (CURRENT VALUE FOR `MY_SEQ`)))");
   }
 
-  @Test void testPivot() {
+  @Test void pivot() {
     final String sql = "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) AS sal FOR job in ('CLERK' AS c))";
     final String expected =
@@ -8768,7 +8768,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** As {@link #testPivot()} but composite FOR and two composite values. */
-  @Test void testPivotComposite() {
+  @Test void pivotComposite() {
     final String sql =
         "SELECT * FROM emp\n"
             + "PIVOT (sum(sal) AS sal FOR (job, deptno) IN\n"
@@ -8781,7 +8781,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Pivot with no values. */
-  @Test void testPivotWithoutValues() {
+  @Test void pivotWithoutValues() {
     final String sql = "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) AS sal FOR job IN ())";
     final String expected = "SELECT *\n"
@@ -8793,7 +8793,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4746">[CALCITE-4746]
    * Pivots with pivotAgg without alias fail with Babel Parser Implementation</a>.
    */
-  @Test void testPivotWithoutAlias() {
+  @Test void pivotWithoutAlias() {
     final String sql = "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) FOR job in ('CLERK'))";
     final String expected =
@@ -8803,7 +8803,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** In PIVOT, FOR clause must contain only simple identifiers. */
-  @Test void testPivotErrorExpressionInFor() {
+  @Test void pivotErrorExpressionInFor() {
     final String sql =
         "SELECT * FROM emp\n"
   + "PIVOT (sum(sal) AS sal FOR deptno ^-^10 IN (10, 20)";
@@ -8811,7 +8811,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** As {@link #testPivotErrorExpressionInFor()} but more than one column. */
-  @Test void testPivotErrorExpressionInCompositeFor() {
+  @Test void pivotErrorExpressionInCompositeFor() {
     final String sql =
         "SELECT * FROM emp\n"
             + "PIVOT (sum(sal) AS sal FOR (job, deptno ^-^10)\n"
@@ -8823,7 +8823,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * More complex PIVOT case (multiple aggregates, composite FOR, multiple values with and without
    * aliases).
    */
-  @Test void testPivot2() {
+  @Test void pivot2() {
     final String sql =
         "SELECT *\n"
             + "FROM (SELECT deptno, job, sal\n"
@@ -8846,7 +8846,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testUnpivot() {
+  @Test void unpivot() {
     final String sql =
         "SELECT *\n"
             + "FROM emp_pivoted\n"
@@ -8867,7 +8867,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testPivotThroughShuttle() {
+  @Test void pivotThroughShuttle() {
     final String sql =
         ""
             + "SELECT *\n"
@@ -8893,7 +8893,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertThat(toLinux(shuttled.toString()), is(expected));
   }
 
-  @Test void testMatchRecognize1() {
+  @Test void matchRecognize1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8918,7 +8918,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize2() {
+  @Test void matchRecognize2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8939,7 +8939,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize3() {
+  @Test void matchRecognize3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8960,7 +8960,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize4() {
+  @Test void matchRecognize4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -8981,7 +8981,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize5() {
+  @Test void matchRecognize5() {
     final String sql =
         "select *\n"
             + "  from (select * from t) match_recognize\n"
@@ -9003,7 +9003,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize6() {
+  @Test void matchRecognize6() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9024,7 +9024,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize7() {
+  @Test void matchRecognize7() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9045,7 +9045,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize8() {
+  @Test void matchRecognize8() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9066,7 +9066,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize9() {
+  @Test void matchRecognize9() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9087,7 +9087,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize10() {
+  @Test void matchRecognize10() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9111,7 +9111,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognize11() {
+  @Test void matchRecognize11() {
     final String sql =
         "select *\n"
             + "  from t match_recognize (\n"
@@ -9130,7 +9130,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause() {
+  @Test void matchRecognizeDefineClause() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9151,7 +9151,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause2() {
+  @Test void matchRecognizeDefineClause2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9171,7 +9171,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause3() {
+  @Test void matchRecognizeDefineClause3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9192,7 +9192,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeDefineClause4() {
+  @Test void matchRecognizeDefineClause4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9212,7 +9212,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures1() {
+  @Test void matchRecognizeMeasures1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9243,7 +9243,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures2() {
+  @Test void matchRecognizeMeasures2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9269,7 +9269,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures3() {
+  @Test void matchRecognizeMeasures3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9295,7 +9295,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures4() {
+  @Test void matchRecognizeMeasures4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9323,7 +9323,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures5() {
+  @Test void matchRecognizeMeasures5() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9350,7 +9350,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeMeasures6() {
+  @Test void matchRecognizeMeasures6() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9377,7 +9377,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip1() {
+  @Test void matchRecognizePatternSkip1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9400,7 +9400,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip2() {
+  @Test void matchRecognizePatternSkip2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9423,7 +9423,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip3() {
+  @Test void matchRecognizePatternSkip3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9446,7 +9446,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip4() {
+  @Test void matchRecognizePatternSkip4() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9469,7 +9469,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizePatternSkip5() {
+  @Test void matchRecognizePatternSkip5() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9496,7 +9496,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-2993">[CALCITE-2993]
    * ParseException may be thrown for legal SQL queries due to incorrect "LOOKAHEAD(1)" hints</a>.
    */
-  @Test void testMatchRecognizePatternSkip6() {
+  @Test void matchRecognizePatternSkip6() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9519,7 +9519,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeSubset1() {
+  @Test void matchRecognizeSubset1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9542,7 +9542,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeSubset2() {
+  @Test void matchRecognizeSubset2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9570,7 +9570,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeSubset3() {
+  @Test void matchRecognizeSubset3() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9598,7 +9598,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeRowsPerMatch1() {
+  @Test void matchRecognizeRowsPerMatch1() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9628,7 +9628,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeRowsPerMatch2() {
+  @Test void matchRecognizeRowsPerMatch2() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9658,7 +9658,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testMatchRecognizeWithin() {
+  @Test void matchRecognizeWithin() {
     final String sql =
         "select *\n"
             + "  from t match_recognize\n"
@@ -9688,7 +9688,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause1() {
+  @Test void withinGroupClause1() {
     final String sql =
         "select col1,\n"
             + " collect(col2) within group (order by col3)\n"
@@ -9703,7 +9703,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause2() {
+  @Test void withinGroupClause2() {
     final String sql =
         "select collect(col2) within group (order by col3)\n"
             + "from t\n"
@@ -9717,12 +9717,12 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause3() {
+  @Test void withinGroupClause3() {
     final String sql = "select collect(col2) within group (^)^ " + "from t order by col1 limit 10";
     sql(sql).fails("(?s).*Encountered \"\\)\" at line 1, column 36\\..*");
   }
 
-  @Test void testWithinGroupClause4() {
+  @Test void withinGroupClause4() {
     final String sql =
         "select col1,\n"
             + " collect(col2) within group (order by col3, col4)\n"
@@ -9737,7 +9737,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinGroupClause5() {
+  @Test void withinGroupClause5() {
     final String sql =
         "select col1,\n"
             + " collect(col2) within group (\n"
@@ -9753,7 +9753,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testStringAgg() {
+  @Test void stringAgg() {
     final String sql =
         "select\n"
             + "  string_agg(ename order by deptno, ename) as c1,\n"
@@ -9774,7 +9774,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testArrayAgg() {
+  @Test void arrayAgg() {
     final String sql =
         "select\n"
             + "  array_agg(ename respect nulls order by deptno, ename) as c1,\n"
@@ -9793,7 +9793,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testGroupConcat() {
+  @Test void groupConcat() {
     final String sql =
         "select\n"
             + "  group_concat(ename order by deptno, ename desc) as c2,\n"
@@ -9810,7 +9810,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinDistinct() {
+  @Test void withinDistinct() {
     final String sql =
         "select col1,\n"
             + " sum(col2) within distinct (col3 + col4, col5)\n"
@@ -9825,7 +9825,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testWithinDistinct2() {
+  @Test void withinDistinct2() {
     final String sql =
         "select col1,\n"
             + " sum(col2) within distinct (col3 + col4, col5)\n"
@@ -9843,7 +9843,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testJsonValueExpressionOperator() {
+  @Test void jsonValueExpressionOperator() {
     expr("foo format json").ok("`FOO` FORMAT JSON");
     // Currently, encoding js not valid
     expr("foo format json encoding utf8").ok("`FOO` FORMAT JSON");
@@ -9859,14 +9859,14 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   + "FROM `TAB`");
   }
 
-  @Test void testJsonExists() {
+  @Test void jsonExists() {
     expr("json_exists('{\"foo\": \"bar\"}', 'lax $.foo')")
         .ok("JSON_EXISTS('{\"foo\": \"bar\"}', 'lax $.foo')");
     expr("json_exists('{\"foo\": \"bar\"}', 'lax $.foo' error on error)")
         .ok("JSON_EXISTS('{\"foo\": \"bar\"}', 'lax $.foo' ERROR ON ERROR)");
   }
 
-  @Test void testJsonValue() {
+  @Test void jsonValue() {
     expr("json_value('{\"foo\": \"100\"}', 'lax $.foo' " + "returning integer)")
         .ok("JSON_VALUE('{\"foo\": \"100\"}', 'lax $.foo' " + "RETURNING INTEGER)");
     expr("json_value('{\"foo\": \"100\"}', 'lax $.foo' "
@@ -9876,7 +9876,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "RETURNING INTEGER DEFAULT 10 ON EMPTY ERROR ON ERROR)");
   }
 
-  @Test void testJsonQuery() {
+  @Test void jsonQuery() {
     expr("json_query('{\"foo\": \"bar\"}', 'lax $' WITHOUT ARRAY WRAPPER)")
         .ok(
             "JSON_QUERY('{\"foo\": \"bar\"}', "
@@ -9932,7 +9932,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "'lax $' WITHOUT ARRAY WRAPPER EMPTY ARRAY ON EMPTY EMPTY OBJECT ON ERROR)");
   }
 
-  @Test void testJsonObject() {
+  @Test void jsonObject() {
     expr("json_object('foo': 'bar')").ok("JSON_OBJECT(KEY 'foo' VALUE 'bar' NULL ON NULL)");
     expr("json_object('foo': 'bar', 'foo2': 'bar2')")
         .ok("JSON_OBJECT(KEY 'foo' VALUE 'bar', KEY 'foo2' VALUE 'bar2' NULL ON NULL)");
@@ -9960,7 +9960,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("json_object(key: value)").ok("JSON_OBJECT(KEY `KEY` VALUE `VALUE` NULL ON NULL)");
   }
 
-  @Test void testJsonType() {
+  @Test void jsonType() {
     expr("json_type('11.56')").ok("JSON_TYPE('11.56')");
     expr("json_type('{}')").ok("JSON_TYPE('{}')");
     expr("json_type(null)").ok("JSON_TYPE(NULL)");
@@ -9968,7 +9968,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("json_type('{\"foo\": \"100\"}')").ok("JSON_TYPE('{\"foo\": \"100\"}')");
   }
 
-  @Test void testJsonDepth() {
+  @Test void jsonDepth() {
     expr("json_depth('11.56')").ok("JSON_DEPTH('11.56')");
     expr("json_depth('{}')").ok("JSON_DEPTH('{}')");
     expr("json_depth(null)").ok("JSON_DEPTH(NULL)");
@@ -9976,7 +9976,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("json_depth('{\"foo\": \"100\"}')").ok("JSON_DEPTH('{\"foo\": \"100\"}')");
   }
 
-  @Test void testJsonLength() {
+  @Test void jsonLength() {
     expr("json_length('{\"foo\": \"bar\"}')").ok("JSON_LENGTH('{\"foo\": \"bar\"}')");
     expr("json_length('{\"foo\": \"bar\"}', 'lax $')")
         .ok("JSON_LENGTH('{\"foo\": \"bar\"}', 'lax $')");
@@ -9986,7 +9986,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("JSON_LENGTH('{\"foo\": \"bar\"}', 'invalid $')");
   }
 
-  @Test void testJsonKeys() {
+  @Test void jsonKeys() {
     expr("json_keys('{\"foo\": \"bar\"}', 'lax $')").ok("JSON_KEYS('{\"foo\": \"bar\"}', 'lax $')");
     expr("json_keys('{\"foo\": \"bar\"}', 'strict $')")
         .ok("JSON_KEYS('{\"foo\": \"bar\"}', 'strict $')");
@@ -9994,14 +9994,14 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("JSON_KEYS('{\"foo\": \"bar\"}', 'invalid $')");
   }
 
-  @Test void testJsonRemove() {
+  @Test void jsonRemove() {
     expr("json_remove('[\"a\", [\"b\", \"c\"], \"d\"]', '$')")
         .ok("JSON_REMOVE('[\"a\", [\"b\", \"c\"], \"d\"]', '$')");
     expr("json_remove('[\"a\", [\"b\", \"c\"], \"d\"]', '$[1]', '$[0]')")
         .ok("JSON_REMOVE('[\"a\", [\"b\", \"c\"], \"d\"]', '$[1]', '$[0]')");
   }
 
-  @Test void testJsonObjectAgg() {
+  @Test void jsonObjectAgg() {
     expr("json_objectagg(k_column: v_column)")
         .ok("JSON_OBJECTAGG(KEY `K_COLUMN` VALUE `V_COLUMN` NULL ON NULL)");
     expr("json_objectagg(k_column value v_column)")
@@ -10019,7 +10019,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "FORMAT JSON NULL ON NULL)");
   }
 
-  @Test void testJsonArray() {
+  @Test void jsonArray() {
     expr("json_array('foo')").ok("JSON_ARRAY('foo' ABSENT ON NULL)");
     expr("json_array(null)").ok("JSON_ARRAY(NULL ABSENT ON NULL)");
     expr("json_array(null null on null)").ok("JSON_ARRAY(NULL NULL ON NULL)");
@@ -10027,24 +10027,24 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
         .ok("JSON_ARRAY(JSON_ARRAY('foo', 'bar' ABSENT ON NULL) FORMAT JSON ABSENT ON NULL)");
   }
 
-  @Test void testJsonPretty() {
+  @Test void jsonPretty() {
     expr("json_pretty('foo')").ok("JSON_PRETTY('foo')");
     expr("json_pretty(null)").ok("JSON_PRETTY(NULL)");
   }
 
-  @Test void testJsonStorageSize() {
+  @Test void jsonStorageSize() {
     expr("json_storage_size('foo')").ok("JSON_STORAGE_SIZE('foo')");
     expr("json_storage_size(null)").ok("JSON_STORAGE_SIZE(NULL)");
   }
 
-  @Test void testJsonArrayAgg1() {
+  @Test void jsonArrayAgg1() {
     expr("json_arrayagg(\"column\")").ok("JSON_ARRAYAGG(`column` ABSENT ON NULL)");
     expr("json_arrayagg(\"column\" null on null)").ok("JSON_ARRAYAGG(`column` NULL ON NULL)");
     expr("json_arrayagg(json_array(\"column\") format json)")
         .ok("JSON_ARRAYAGG(JSON_ARRAY(`column` ABSENT ON NULL) FORMAT JSON ABSENT ON NULL)");
   }
 
-  @Test void testJsonArrayAgg2() {
+  @Test void jsonArrayAgg2() {
     expr("json_arrayagg(\"column\" order by \"column\")")
         .ok("JSON_ARRAYAGG(`column` ABSENT ON NULL) WITHIN GROUP (ORDER BY `column`)");
     expr("json_arrayagg(\"column\") within group (order by \"column\")")
@@ -10055,7 +10055,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
                 + "in a single JSON_ARRAYAGG call is not allowed.*");
   }
 
-  @Test void testJsonPredicate() {
+  @Test void jsonPredicate() {
     expr("'{}' is json").ok("('{}' IS JSON VALUE)");
     expr("'{}' is json value").ok("('{}' IS JSON VALUE)");
     expr("'{}' is json object").ok("('{}' IS JSON OBJECT)");
@@ -10068,7 +10068,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     expr("'100' is not json scalar").ok("('100' IS NOT JSON SCALAR)");
   }
 
-  @Test void testParseWithReader() throws Exception {
+  @Test void parseWithReader() throws Exception {
     String query = "select * from dual";
     SqlParser sqlParserReader = sqlParser(new StringReader(query), b -> b);
     SqlNode node1 = sqlParserReader.parseQuery();
@@ -10076,7 +10076,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertEquals(node2.toString(), node1.toString());
   }
 
-  @Test void testConfigureFromDialect() {
+  @Test void configureFromDialect() {
     // Calcite's default converts unquoted identifiers to upper case
     sql("select unquotedColumn from \"double\"\"QuotedTable\"")
         .withDialect(CALCITE)
@@ -10113,7 +10113,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4230">[CALCITE-4230] In
    * Babel for BigQuery, split quoted table names that contain dots</a>.
    */
-  @Test void testSplitIdentifier() {
+  @Test void splitIdentifier() {
     final String sql = "select *\n"
   + "from `bigquery-public-data.samples.natality`";
     final String sql2 = "select *\n"
@@ -10135,7 +10135,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql2).withDialect(MYSQL).ok(expectedSplitMysql);
   }
 
-  @Test void testParenthesizedSubQueries() {
+  @Test void parenthesizedSubQueries() {
     final String expected = "SELECT *\n"
   + "FROM (SELECT *\n"
   + "FROM `TAB`) AS `X`";
@@ -10147,7 +10147,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql2).ok(expected);
   }
 
-  @Test void testQueryHint() {
+  @Test void queryHint() {
     final String sql1 =
         "select "
             + "/*+ properties(k1='v1', k2='v2', 'a.b.c'='v3'), "
@@ -10182,7 +10182,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testTableHintsInQuery() {
+  @Test void tableHintsInQuery() {
     final String hint = "/*+ PROPERTIES(K1 ='v1', K2 ='v2'), INDEX(IDX0, IDX1) */";
     final String sql1 = String.format(Locale.ROOT, "select * from t %s", hint);
     final String expected1 =
@@ -10217,7 +10217,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql3).ok(expected3);
   }
 
-  @Test void testTableHintsInInsert() {
+  @Test void tableHintsInInsert() {
     final String sql =
         "insert into emps\n"
             + "/*+ PROPERTIES(k1='v1', k2='v2'), INDEX(idx0, idx1) */\n"
@@ -10230,7 +10230,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testTableHintsInDelete() {
+  @Test void tableHintsInDelete() {
     final String sql =
         "delete from emps\n"
             + "/*+ properties(k1='v1', k2='v2'), index(idx1, idx2), no_hash_join */\n"
@@ -10242,7 +10242,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testTableHintsInUpdate() {
+  @Test void tableHintsInUpdate() {
     final String sql =
         "update emps\n"
             + "/*+ properties(k1='v1', k2='v2'), index(idx1, idx2), no_hash_join */\n"
@@ -10258,7 +10258,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testTableHintsInMerge() {
+  @Test void tableHintsInMerge() {
     final String sql =
         "merge into emps\n"
             + "/*+ properties(k1='v1', k2='v2'), index(idx1, idx2), no_hash_join */ e\n"
@@ -10283,7 +10283,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     sql(sql).ok(expected);
   }
 
-  @Test void testHintThroughShuttle() {
+  @Test void hintThroughShuttle() {
     final String sql = "select * from emp /*+ options('key1' = 'val1') */";
     final SqlNode sqlNode = sql(sql).node();
     final SqlNode shuttled =
@@ -10300,7 +10300,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
     assertThat(toLinux(shuttled.toString()), is(expected));
   }
 
-  @Test void testInvalidHintFormat() {
+  @Test void invalidHintFormat() {
     final String sql1 =
         "select "
             + "/*+ properties(^k1^=123, k2='v2'), no_hash_join() */ "
@@ -10325,7 +10325,7 @@ private static Consumer<List<? extends Throwable>> checkWarnings(String... token
   }
 
   /** Tests {@link Hoist}. */
-  @Test protected void testHoist() {
+  @Test void hoist() {
     final String sql =
         "select 1 as x,\n"
             + "  'ab' || 'c' as y\n"
diff --git a/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java b/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java
index f859b6ac0..9b2f90320 100644
--- a/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java
+++ b/testkit/src/main/java/org/apache/calcite/sql/test/ResultCheckers.java
@@ -32,7 +32,6 @@
 import java.time.LocalTime;
 import java.time.ZoneOffset;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.regex.Pattern;
@@ -97,7 +96,7 @@ public static SqlTester.ResultChecker isSet(String... values) {
   }
 
   public static SqlTester.ResultChecker isNullValue() {
-    return new RefSetResultChecker(Collections.singleton(null));
+    return new RefSetResultChecker(ImmutableSet.of(null));
   }
 
   /**
diff --git a/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java b/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java
index 4f1d0ba37..24108efed 100644
--- a/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java
+++ b/testkit/src/main/java/org/apache/calcite/sql/test/SqlTests.java
@@ -212,7 +212,7 @@ public static String generateWinAggQuery(String expr, String windowSpec, String[
    */
   public static void checkEx(
       @Nullable Throwable ex, @Nullable String expectedMsgPattern, StringAndPos sap, Stage stage) {
-    if (null == ex) {
+    if (ex == null) {
       if (expectedMsgPattern == null) {
         // No error expected, and no error happened.
         return;
@@ -300,7 +300,7 @@ public static void checkEx(
       }
     }
 
-    if (null == expectedMsgPattern) {
+    if (expectedMsgPattern == null) {
       actualException.printStackTrace();
       fail(
           stage.componentName
diff --git a/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java b/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java
index 146edd264..1464eaa1e 100644
--- a/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java
+++ b/testkit/src/main/java/org/apache/calcite/test/CalciteAssert.java
@@ -128,6 +128,8 @@
 import java.util.stream.Collectors;
 import javax.sql.DataSource;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.apache.calcite.test.Matchers.compose;
 import static org.apache.calcite.test.Matchers.containsStringLinux;
 import static org.apache.calcite.test.Matchers.isLinux;
@@ -1145,9 +1147,7 @@ public AssertThat with(String property, Object value) {
     }
 
     public AssertThat with(ConnectionProperty property, Object value) {
-      if (!property.type().valid(value, property.valueClass())) {
-        throw new IllegalArgumentException();
-      }
+      checkArgument(property.type().valid(value, property.valueClass()));
       return with(connectionFactory.with(property, value));
     }
 
diff --git a/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java b/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java
index 81ab196b1..7ede96bd2 100644
--- a/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java
+++ b/testkit/src/main/java/org/apache/calcite/test/ConnectionFactories.java
@@ -38,6 +38,8 @@
 import java.util.Objects;
 import java.util.Properties;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -135,9 +137,7 @@ private static class MapConnectionFactory implements ConnectionFactory {
     }
 
     @Override public ConnectionFactory with(ConnectionProperty property, Object value) {
-      if (!property.type().valid(value, property.valueClass())) {
-        throw new IllegalArgumentException();
-      }
+      checkArgument(property.type().valid(value, property.valueClass()));
       return with(property.camelName(), value.toString());
     }
 
diff --git a/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java b/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java
index 744304d90..e1279be2d 100644
--- a/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java
+++ b/testkit/src/main/java/org/apache/calcite/test/DiffRepository.java
@@ -58,6 +58,8 @@
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -270,18 +272,12 @@ public void checkActualAndReferenceFiles() {
 
     final String diff = DiffTestCase.diff(new File(resourceFile), logFile);
 
-    if (!diff.isEmpty()) {
-      throw new IllegalArgumentException(
-          "Actual and reference files differ. "
-              + "If you are adding new tests, replace the reference file with the "
-              + "current actual file, after checking its content."
-              + "\ndiff "
-              + logFile.getAbsolutePath()
-              + " "
-              + resourceFile
-              + "\n"
-              + diff);
-    }
+    checkArgument(
+        diff.isEmpty(),
+        "Actual and reference files differ. If you are adding new tests, replace the reference file with the current actual file, after checking its content.\ndiff %s %s\n%s",
+        logFile.getAbsolutePath(),
+        resourceFile,
+        diff);
   }
 
   private static URL findFile(Class<?> clazz, final String suffix) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java b/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java
index 1e41d6ddb..de7a8188c 100644
--- a/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java
+++ b/testkit/src/main/java/org/apache/calcite/test/DiffTestCase.java
@@ -140,10 +140,10 @@ protected Writer openTestLog() throws Exception {
   protected OutputStream openTestLogOutputStream(File testFileSansExt) throws IOException {
     assert logOutputStream == null;
 
-    logFile = new File(testFileSansExt.toString() + ".log");
+    logFile = new File(testFileSansExt + ".log");
     logFile.delete();
 
-    refFile = new File(testFileSansExt.toString() + ".ref");
+    refFile = new File(testFileSansExt + ".ref");
 
     logOutputStream = new FileOutputStream(logFile);
     return logOutputStream;
@@ -247,7 +247,7 @@ protected void diffFile(File logFile, File refFile) throws IOException {
    */
   protected void addDiffMask(String mask) {
     // diffMasks.add(mask);
-    if (diffMasks.length() == 0) {
+    if (diffMasks.isEmpty()) {
       diffMasks = mask;
     } else {
       diffMasks = diffMasks + "|" + mask;
@@ -257,7 +257,7 @@ protected void addDiffMask(String mask) {
   }
 
   protected void addIgnorePattern(String javaPattern) {
-    if (ignorePatterns.length() == 0) {
+    if (ignorePatterns.isEmpty()) {
       ignorePatterns = javaPattern;
     } else {
       ignorePatterns = ignorePatterns + "|" + javaPattern;
diff --git a/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java b/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java
index 9e727c614..ca01133b8 100644
--- a/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java
+++ b/testkit/src/main/java/org/apache/calcite/test/MockRelOptPlanner.java
@@ -31,11 +31,11 @@
 import org.apache.calcite.util.Pair;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -201,7 +201,7 @@ private class MockRuleCall extends RelOptRuleCall {
      * @param rels List of matched relational expressions
      */
     MockRuleCall(RelOptPlanner planner, RelOptRuleOperand operand, RelNode[] rels) {
-      super(planner, operand, rels, Collections.emptyMap());
+      super(planner, operand, rels, ImmutableMap.of());
     }
 
     @Override public void transformTo(RelNode rel, Map<RelNode, RelNode> equiv, RelHintsPropagator handler) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java b/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java
index 34290f907..35efed2d6 100644
--- a/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java
+++ b/testkit/src/main/java/org/apache/calcite/test/RelMetadataFixture.java
@@ -224,7 +224,7 @@ public RelNode toRel() {
   /**
    * Checks the CPU component of {@link RelNode#computeSelfCost(RelOptPlanner, RelMetadataQuery)}.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertCpuCost(Matcher<Double> matcher, String reason) {
     RelNode rel = toRel();
     RelOptCost cost = computeRelSelfCost(rel);
@@ -250,7 +250,7 @@ private static RelOptCost computeRelSelfCost(RelNode rel) {
   /**
    * Checks {@link RelMetadataQuery#areRowsUnique(RelNode)} for all values of {@code ignoreNulls}.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertRowsUnique(Matcher<Boolean> matcher, String reason) {
     return assertRowsUnique(false, matcher, reason).assertRowsUnique(true, matcher, reason);
   }
@@ -275,7 +275,7 @@ public RelMetadataFixture assertRowsUnique(
   }
 
   /** Checks {@link RelMetadataQuery#getPercentageOriginalRows(RelNode)}. */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertPercentageOriginalRows(Matcher<Double> matcher) {
     RelNode rel = toRel();
     final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();
@@ -297,7 +297,7 @@ private RelMetadataFixture checkColumnOrigin(Consumer<Set<RelColumnOrigin>> acti
    * Checks that {@link RelMetadataQuery#getColumnOrigins(RelNode, int)} for column 0 returns no
    * origins.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertColumnOriginIsEmpty() {
     return checkColumnOrigin(
         result -> {
@@ -324,7 +324,7 @@ private static void checkColumnOrigin(
    * Checks that {@link RelMetadataQuery#getColumnOrigins(RelNode, int)} for column 0 returns one
    * origin.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertColumnOriginSingle(
       String expectedTableName, String expectedColumnName, boolean expectedDerived) {
     return checkColumnOrigin(
@@ -340,7 +340,7 @@ public RelMetadataFixture assertColumnOriginSingle(
    * Checks that {@link RelMetadataQuery#getColumnOrigins(RelNode, int)} for column 0 returns two
    * origins.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertColumnOriginDouble(
       String expectedTableName1,
       String expectedColumnName1,
@@ -369,7 +369,7 @@ public RelMetadataFixture assertColumnOriginDouble(
   }
 
   /** Checks result of getting unique keys for SQL. */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertThatUniqueKeysAre(ImmutableBitSet... expectedUniqueKeys) {
     RelNode rel = toRel();
     final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();
@@ -425,7 +425,7 @@ private static boolean isUnique(Set<ImmutableBitSet> uniqueKeys, ImmutableBitSet
    * RelMetadataQuery#getMaxRowCount(RelNode)}, and {@link
    * RelMetadataQuery#getMinRowCount(RelNode)}.
    */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertThatRowCount(
       Matcher<Number> rowCountMatcher,
       Matcher<Number> minRowCountMatcher,
@@ -550,7 +550,7 @@ public RelMetadataFixture assertThatAreColumnsUnique(
   }
 
   /** Checks {@link RelMetadataQuery#areRowsUnique(RelNode)}. */
-  @SuppressWarnings({"UnusedReturnValue"})
+  @SuppressWarnings("UnusedReturnValue")
   public RelMetadataFixture assertThatAreRowsUnique(Matcher<Boolean> matcher) {
     RelNode rel = toRel();
     final RelMetadataQuery mq = rel.getCluster().getMetadataQuery();
diff --git a/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java b/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java
index d32481aa0..b8b74c5f1 100644
--- a/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java
+++ b/testkit/src/main/java/org/apache/calcite/test/RexImplicationCheckerFixtures.java
@@ -148,7 +148,7 @@ public RexInputRef ref(int i, RelDataType type) {
     }
 
     public RexLiteral literal(int i) {
-      return rexBuilder.makeExactLiteral(new BigDecimal(i));
+      return rexBuilder.makeExactLiteral(BigDecimal.valueOf(i));
     }
 
     public RexNode gt(RexNode node1, RexNode node2) {
@@ -200,7 +200,7 @@ public RexNode shortLiteral(short value) {
     }
 
     public RexLiteral floatLiteral(double value) {
-      return rexBuilder.makeApproxLiteral(new BigDecimal(value));
+      return rexBuilder.makeApproxLiteral(BigDecimal.valueOf(value));
     }
 
     public RexLiteral charLiteral(String z) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
index d9231dee0..aadbec670 100644
--- a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
+++ b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorFixtureImpl.java
@@ -214,7 +214,7 @@ void forEachQueryValidateAndThen(
   }
 
   @Override public void checkBoolean(String expression, @Nullable Boolean result) {
-    if (null == result) {
+    if (result == null) {
       checkNull(expression);
     } else {
       SqlTester.ResultChecker resultChecker =
diff --git a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
index 25bb61ee2..d22628ecb 100644
--- a/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
+++ b/testkit/src/main/java/org/apache/calcite/test/SqlOperatorTest.java
@@ -192,7 +192,7 @@
  * </ul>
  */
 @SuppressWarnings("MethodCanBeStatic")
-public class SqlOperatorTest {
+final class SqlOperatorTest {
   // ~ Static fields/initializers ---------------------------------------------
 
   public static final TesterImpl TESTER = new TesterImpl();
@@ -249,9 +249,9 @@ enum Numeric {
     BIGINT(
         "BIGINT",
         Long.toString(Long.MIN_VALUE),
-        new BigDecimal(Long.MIN_VALUE).subtract(BigDecimal.ONE).toString(),
+        BigDecimal.valueOf(Long.MIN_VALUE).subtract(BigDecimal.ONE).toString(),
         Long.toString(Long.MAX_VALUE),
-        new BigDecimal(Long.MAX_VALUE).add(BigDecimal.ONE).toString()),
+        BigDecimal.valueOf(Long.MAX_VALUE).add(BigDecimal.ONE).toString()),
     DECIMAL5_2("DECIMAL(5, 2)", "-999.99", "-1000.00", "999.99", "1000.00"),
     REAL(
         "REAL",
@@ -369,9 +369,9 @@ protected SqlOperatorFixture fixture() {
   // --- Tests -----------------------------------------------------------
 
   /** For development. Put any old code in here. */
-  @Test void testDummy() {}
+  @Test void dummy() {}
 
-  @Test void testSqlOperatorOverloading() {
+  @Test void sqlOperatorOverloading() {
     final SqlStdOperatorTable operatorTable = SqlStdOperatorTable.instance();
     for (SqlOperator sqlOperator : operatorTable.getOperatorList()) {
       String operatorName = sqlOperator.getName();
@@ -386,7 +386,7 @@ protected SqlOperatorFixture fixture() {
     }
   }
 
-  @Test void testBetween() {
+  @Test void between() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BETWEEN, VmName.EXPAND);
     f.checkBoolean("2 between 1 and 3", true);
@@ -416,7 +416,7 @@ protected SqlOperatorFixture fixture() {
     f.checkBoolean("x'0A00015A' between x'0A0001A0' and x'0A0001B0'", false);
   }
 
-  @Test void testNotBetween() {
+  @Test void notBetween() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_BETWEEN, VM_EXPAND);
     f.checkBoolean("2 not between 1 and 3", false);
@@ -449,7 +449,7 @@ static Stream<Arguments> safeParameters() {
    */
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCast(CastType castType, SqlOperatorFixture f) {
+  void cast(CastType castType, SqlOperatorFixture f) {
     // SAFE_CAST is available in BigQuery library but not by default.
     // TRY_CAST is available in MSSQL library but not by default.
     final SqlOperatorFixture f0 = fixture();
@@ -467,7 +467,7 @@ void testCast(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToString(CastType castType, SqlOperatorFixture f) {
+  void castToString(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     f.checkCastToString("cast(cast('abc' as char(4)) as varchar(6))", null, "abc ", castType);
 
@@ -551,7 +551,7 @@ void testCastToString(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastBooleanToNumeric(CastType castType, SqlOperatorFixture f) {
+  void castBooleanToNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     SqlOperatorFixture f0 = f.withConformance(SqlConformanceEnum.DEFAULT);
     f0.checkFails(
@@ -579,7 +579,7 @@ void testCastBooleanToNumeric(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastExactNumericLimits(CastType castType, SqlOperatorFixture f) {
+  void castExactNumericLimits(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // Test casting for min,max, out of range for exact numeric types
@@ -660,7 +660,7 @@ void testCastExactNumericLimits(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToExactNumeric(CastType castType, SqlOperatorFixture f) {
+  void castToExactNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkCastToScalarOkay("1", "BIGINT", castType);
@@ -689,7 +689,7 @@ void testCastToExactNumeric(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastStringToDecimal(CastType castType, SqlOperatorFixture f) {
+  void castStringToDecimal(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     if (!DECIMAL) {
       return;
@@ -706,7 +706,7 @@ void testCastStringToDecimal(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastIntervalToNumeric(CastType castType, SqlOperatorFixture f) {
+  void castIntervalToNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // interval to decimal
@@ -766,7 +766,7 @@ void testCastIntervalToNumeric(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToInterval(CastType castType, SqlOperatorFixture f) {
+  void castToInterval(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     f.checkScalar("cast(5 as interval second)", "+5.000000", "INTERVAL SECOND NOT NULL");
     f.checkScalar("cast(5 as interval minute)", "+5", "INTERVAL MINUTE NOT NULL");
@@ -788,7 +788,7 @@ void testCastToInterval(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastIntervalToInterval(CastType castType, SqlOperatorFixture f) {
+  void castIntervalToInterval(CastType castType, SqlOperatorFixture f) {
     f.checkScalar(
         "cast(interval '2 5' day to hour as interval hour to minute)",
         "+53:00",
@@ -811,7 +811,7 @@ void testCastIntervalToInterval(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastWithRoundingToScalar(CastType castType, SqlOperatorFixture f) {
+  void castWithRoundingToScalar(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkFails("cast(1.25 as int)", "INTEGER", true);
@@ -851,7 +851,7 @@ void testCastWithRoundingToScalar(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastDecimalToDoubleToInteger(CastType castType, SqlOperatorFixture f) {
+  void castDecimalToDoubleToInteger(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkFails("cast( cast(1.25 as double) as integer)", OUT_OF_RANGE_MESSAGE, true);
@@ -867,7 +867,7 @@ void testCastDecimalToDoubleToInteger(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastApproxNumericLimits(CastType castType, SqlOperatorFixture f) {
+  void castApproxNumericLimits(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // Test casting for min, max, out of range for approx numeric types
@@ -995,7 +995,7 @@ void testCastApproxNumericLimits(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToApproxNumeric(CastType castType, SqlOperatorFixture f) {
+  void castToApproxNumeric(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkCastToApproxOkay("1", "DOUBLE", isExactly(1), castType);
@@ -1009,7 +1009,7 @@ void testCastToApproxNumeric(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastNull(CastType castType, SqlOperatorFixture f) {
+  void castNull(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // null
@@ -1045,7 +1045,7 @@ void testCastNull(CastType castType, SqlOperatorFixture f) {
    */
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastInvalid(CastType castType, SqlOperatorFixture f) {
+  void castInvalid(CastType castType, SqlOperatorFixture f) {
     // Before CALCITE-1439 was fixed, constant reduction would kick in and
     // generate Java constants that throw when the class is loaded, thus
     // ExceptionInInitializerError.
@@ -1065,7 +1065,7 @@ void testCastInvalid(CastType castType, SqlOperatorFixture f) {
   /** Test cast for DATE, TIME, TIMESTAMP types. */
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastDateTime(CastType castType, SqlOperatorFixture f) {
+  void castDateTime(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     f.checkScalar(
@@ -1131,7 +1131,7 @@ void testCastDateTime(CastType castType, SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastStringToDateTime(CastType castType, SqlOperatorFixture f) {
+  void castStringToDateTime(CastType castType, SqlOperatorFixture f) {
     f.checkScalar("cast('12:42:25' as TIME)", "12:42:25", "TIME(0) NOT NULL");
     f.checkScalar("cast('1:42:25' as TIME)", "01:42:25", "TIME(0) NOT NULL");
     f.checkScalar("cast('1:2:25' as TIME)", "01:02:25", "TIME(0) NOT NULL");
@@ -1221,7 +1221,7 @@ void testCastStringToDateTime(CastType castType, SqlOperatorFixture f) {
     f.checkNull("cast(cast(null as timestamp) as time)");
   }
 
-  @Test void testMssqlConvert() {
+  @Test void mssqlConvert() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.MSSQL_CONVERT, VmName.EXPAND);
     // happy-paths (no need to test all, proper functionality is tested by CAST already
@@ -1233,7 +1233,7 @@ void testCastStringToDateTime(CastType castType, SqlOperatorFixture f) {
     f.checkNull("convert(DATE, NULL)");
   }
 
-  @Test void testMssqlConvertWithStyle() {
+  @Test void mssqlConvertWithStyle() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.MSSQL_CONVERT, VmName.EXPAND);
     // ensure 'style' argument is ignored
@@ -1302,7 +1302,7 @@ protected static Calendar getCalendarNotTooNear(int timeUnit) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
+  void castToBoolean(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
 
     // string to boolean
@@ -1322,7 +1322,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-4861">[CALCITE-4861]
    * Optimisation of chained cast calls can lead to unexpected behaviour.</a>.
    */
-  @Test void testChainedCast() {
+  @Test void chainedCast() {
     final SqlOperatorFixture f = fixture();
     f.checkFails(
         "CAST(CAST(CAST(123456 AS TINYINT) AS INT) AS BIGINT)",
@@ -1496,14 +1496,14 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     // TODO: Check case with multisets
   }
 
-  @Test void testCaseNull() {
+  @Test void caseNull() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CASE, VmName.EXPAND);
     f.checkScalarExact("case when 1 = 1 then 10 else null end", 10);
     f.checkNull("case when 1 = 2 then 10 else null end");
   }
 
-  @Test void testCaseType() {
+  @Test void caseType() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CASE, VmName.EXPAND);
     f.checkType("case 1 when 1 then current_timestamp else null end", "TIMESTAMP(0)");
@@ -1520,7 +1520,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
    *
    * <p>See FRG-97 "Support for JDBC escape syntax is incomplete".
    */
-  @Test void testJdbcFn() {
+  @Test void jdbcFn() {
     final SqlOperatorFixture f = fixture();
     f.setFor(new SqlJdbcFunctionCall("dummy"), VmName.EXPAND);
 
@@ -1700,7 +1700,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testChr() {
+  @Test void chr() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CHR, VM_FENNEL, VM_JAVA);
     f0.checkFails("^chr(97.1)^", "No match found for function signature CHR\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -1714,7 +1714,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
         list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE, SqlLibrary.POSTGRESQL), consumer);
   }
 
-  @Test void testSelect() {
+  @Test void select() {
     final SqlOperatorFixture f = fixture();
     f.check("select * from (values(1))", SqlTests.INTEGER_TYPE_CHECKER, 1);
 
@@ -1761,7 +1761,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     }
   }
 
-  @Test void testLiteralChain() {
+  @Test void literalChain() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LITERAL_CHAIN, VM_EXPAND);
     f.checkString("'buttered'\n"
@@ -1786,19 +1786,19 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
   + "'ab' = x'ab'", true);
   }
 
-  @Test void testComplexLiteral() {
+  @Test void complexLiteral() {
     final SqlOperatorFixture f = fixture();
     f.check("select 2 * 2 * x from (select 2 as x)", SqlTests.INTEGER_TYPE_CHECKER, 8);
     f.check("select 1 * 2 * 3 * x from (select 2 as x)", SqlTests.INTEGER_TYPE_CHECKER, 12);
     f.check("select 1 + 2 + 3 + 4 + x from (select 2 as x)", SqlTests.INTEGER_TYPE_CHECKER, 12);
   }
 
-  @Test void testRow() {
+  @Test void row() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ROW, VM_FENNEL);
   }
 
-  @Test void testAndOperator() {
+  @Test void andOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.AND, VmName.EXPAND);
     f.checkBoolean("true and false", false);
@@ -1809,14 +1809,14 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     f.checkBoolean("true and (not false)", true);
   }
 
-  @Test void testAndOperator2() {
+  @Test void andOperator2() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("case when false then unknown else true end and true", true);
     f.checkBoolean("case when false then cast(null as boolean) " + "else true end and true", true);
     f.checkBoolean("case when false then null else true end and true", true);
   }
 
-  @Test void testAndOperatorLazy() {
+  @Test void andOperatorLazy() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.AND, VmName.EXPAND);
 
@@ -1830,7 +1830,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
         new ValueOrExceptionResultChecker(false, INVALID_ARG_FOR_POWER, CODE_2201F));
   }
 
-  @Test void testConcatOperator() {
+  @Test void concatOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CONCAT, VmName.EXPAND);
     f.checkString(" 'a'||'b' ", "ab", "CHAR(2) NOT NULL");
@@ -1863,7 +1863,7 @@ void testCastToBoolean(CastType castType, SqlOperatorFixture f) {
     f.checkNull("cast(null as integer array) || array[1]");
   }
 
-  @Test void testConcatFunc() {
+  @Test void concatFunc() {
     final SqlOperatorFixture f = fixture();
     checkConcatFunc(f.withLibrary(SqlLibrary.MYSQL));
     checkConcatFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -1934,7 +1934,7 @@ private static void checkConcat2Func(SqlOperatorFixture f) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5741">[CALCITE-5741] Add
    * CONCAT_WS function (enabled in MSSQL, MySQL, Postgres libraries)</a>.
    */
-  @Test void testConcatWSFunc() {
+  @Test void concatWSFunc() {
     final SqlOperatorFixture f = fixture();
     checkConcatWithSeparator(f.withLibrary(SqlLibrary.MYSQL));
     checkConcatWithSeparator(f.withLibrary(SqlLibrary.POSTGRESQL));
@@ -1988,7 +1988,7 @@ private static void checkConcatWithSeparatorInMSSQL(SqlOperatorFixture f) {
     f.checkString("concat_ws('', '', '', '')", "", "VARCHAR(0) NOT NULL");
   }
 
-  @Test void testModOperator() {
+  @Test void modOperator() {
     // "%" is allowed under BIG_QUERY, MYSQL_5 SQL conformance levels
     final SqlOperatorFixture f0 = fixture().setFor(SqlStdOperatorTable.PERCENT_REMAINDER);
     final List<SqlConformanceEnum> conformances =
@@ -2039,7 +2039,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkFails("3 % case 'a' when 'a' then 0 end", DIVISION_BY_ZERO_MESSAGE, true);
   }
 
-  @Test void testDivideOperator() {
+  @Test void divideOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DIVIDE, VmName.EXPAND);
     f.checkScalarExact("10 / 5", "INTEGER NOT NULL", "2");
@@ -2059,7 +2059,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkScalarExact("100.1 / 0.00000000000000001", "DECIMAL(19, 0) NOT NULL", "1.001E+19");
   }
 
-  @Test void testDivideOperatorIntervals() {
+  @Test void divideOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "interval '-2:2' hour to minute / 3", "-0:41", "INTERVAL HOUR TO MINUTE NOT NULL");
@@ -2074,7 +2074,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkScalar("interval '3-4' year to month / 4.5", "+0-09", "INTERVAL YEAR TO MONTH NOT NULL");
   }
 
-  @Test void testEqualsOperator() {
+  @Test void equalsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EQUALS, VmName.EXPAND);
     f.checkBoolean("1=1", true);
@@ -2102,7 +2102,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("cast(null as varchar(10))='a'");
   }
 
-  @Test void testEqualsOperatorInterval() {
+  @Test void equalsOperatorInterval() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day = interval '1' day", false);
     f.checkBoolean("interval '2' day = interval '2' day", true);
@@ -2110,7 +2110,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("cast(null as interval hour) = interval '2' minute");
   }
 
-  @Test void testGreaterThanOperator() {
+  @Test void greaterThanOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.GREATER_THAN, VmName.EXPAND);
     f.checkBoolean("1>2", false);
@@ -2138,7 +2138,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("x'0A000130'>x'0A0001B0'", false);
   }
 
-  @Test void testGreaterThanOperatorIntervals() {
+  @Test void greaterThanOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day > interval '1' day", true);
     f.checkBoolean("interval '2' day > interval '5' day", false);
@@ -2152,7 +2152,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("interval '2:2' hour to minute > cast(null as interval second)");
   }
 
-  @Test void testIsDistinctFromOperator() {
+  @Test void isDistinctFromOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_DISTINCT_FROM, VM_EXPAND);
     f.checkBoolean("1 is distinct from 1", false);
@@ -2175,7 +2175,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("interval '10' hour is distinct from interval '10' hour", false);
   }
 
-  @Test void testIsNotDistinctFromOperator() {
+  @Test void isNotDistinctFromOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_DISTINCT_FROM, VM_EXPAND);
     f.checkBoolean("1 is not distinct from 1", true);
@@ -2198,7 +2198,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("interval '10' hour is not distinct from interval '10' hour", true);
   }
 
-  @Test void testGreaterThanOrEqualOperator() {
+  @Test void greaterThanOrEqualOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.GREATER_THAN_OR_EQUAL, VmName.EXPAND);
     f.checkBoolean("1>=2", false);
@@ -2222,7 +2222,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkBoolean("x'0A0001B0'>=x'0A0001B0'", true);
   }
 
-  @Test void testGreaterThanOrEqualOperatorIntervals() {
+  @Test void greaterThanOrEqualOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day >= interval '1' day", true);
     f.checkBoolean("interval '2' day >= interval '5' day", false);
@@ -2236,7 +2236,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkNull("interval '2:2' hour to minute >= cast(null as interval second)");
   }
 
-  @Test void testInOperator() {
+  @Test void inOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IN, VM_EXPAND);
     f.checkBoolean("1 in (0, 1, 2)", true);
@@ -2260,7 +2260,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkFails("'foo' in (^)^", "(?s).*Encountered \"\\)\" at .*", false);
   }
 
-  @Test void testNotInOperator() {
+  @Test void notInOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_IN, VM_EXPAND);
     f.checkBoolean("1 not in (0, 1, 2)", false);
@@ -2284,7 +2284,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
     f.checkFails("'foo' not in (^)^", "(?s).*Encountered \"\\)\" at .*", false);
   }
 
-  @Test void testOverlapsOperator() {
+  @Test void overlapsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OVERLAPS, VM_EXPAND);
     f.checkBoolean(
@@ -2335,7 +2335,7 @@ void checkModOperatorDivByZero(SqlOperatorFixture f) {
    * <p>Tests OVERLAP and similar period operators CONTAINS, EQUALS, PRECEDES, SUCCEEDS, IMMEDIATELY
    * PRECEDES, IMMEDIATELY SUCCEEDS for DATE, TIME and TIMESTAMP values.
    */
-  @Test void testPeriodOperators() {
+  @Test void periodOperators() {
     String[] times = {
       "TIME '01:00:00'", "TIME '02:00:00'", "TIME '03:00:00'", "TIME '04:00:00'",
     };
@@ -2478,7 +2478,7 @@ static void checkOverlaps(OverlapChecker c) {
     c.isTrue("($3,$0) IMMEDIATELY SUCCEEDS ($0,$0)");
   }
 
-  @Test void testLessThanOperator() {
+  @Test void lessThanOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LESS_THAN, VmName.EXPAND);
     f.checkBoolean("1<2", true);
@@ -2503,7 +2503,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkBoolean("x'0A000130'<x'0A0001B0'", true);
   }
 
-  @Test void testLessThanOperatorInterval() {
+  @Test void lessThanOperatorInterval() {
     if (!DECIMAL) {
       return;
     }
@@ -2520,7 +2520,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkNull("interval '2:2' hour to minute " + "< cast(null as interval second)");
   }
 
-  @Test void testLessThanOrEqualOperator() {
+  @Test void lessThanOrEqualOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LESS_THAN_OR_EQUAL, VmName.EXPAND);
     f.checkBoolean("1<=2", true);
@@ -2547,7 +2547,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkBoolean("x'0A0001B0'<=x'0A0001B0'", true);
   }
 
-  @Test void testLessThanOrEqualOperatorInterval() {
+  @Test void lessThanOrEqualOperatorInterval() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day <= interval '1' day", false);
     f.checkBoolean("interval '2' day <= interval '5' day", true);
@@ -2561,7 +2561,7 @@ static void checkOverlaps(OverlapChecker c) {
     f.checkNull("interval '2:2' hour to minute " + "<= cast(null as interval second)");
   }
 
-  @Test void testMinusOperator() {
+  @Test void minusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUS, VmName.EXPAND);
     f.checkScalarExact("-2-1", -3);
@@ -2591,7 +2591,7 @@ static void checkOverlaps(OverlapChecker c) {
     }
   }
 
-  @Test void testMinusIntervalOperator() {
+  @Test void minusIntervalOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUS, VmName.EXPAND);
     f.checkScalar("interval '2' day - interval '1' day", "+1", "INTERVAL DAY NOT NULL");
@@ -2663,7 +2663,7 @@ static void checkOverlaps(OverlapChecker c) {
         "date '2003-08-02' - interval '12-3' year to month", "1991-05-02", "DATE NOT NULL");
   }
 
-  @Test void testMinusDateOperator() {
+  @Test void minusDateOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUS_DATE, VmName.EXPAND);
     f.checkScalar(
@@ -2711,7 +2711,7 @@ static void checkOverlaps(OverlapChecker c) {
     // TODO: Add tests for year month intervals (currently not supported)
   }
 
-  @Test void testMultiplyOperator() {
+  @Test void multiplyOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTIPLY, VmName.EXPAND);
     f.checkScalarExact("2*3", 6);
@@ -2740,7 +2740,7 @@ static void checkOverlaps(OverlapChecker c) {
     }
   }
 
-  @Test void testMultiplyIntervals() {
+  @Test void multiplyIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("interval '2:2' hour to minute * 3", "+6:06", "INTERVAL HOUR TO MINUTE NOT NULL");
     f.checkScalar(
@@ -2757,7 +2757,7 @@ static void checkOverlaps(OverlapChecker c) {
     }
   }
 
-  @Test void testDatePlusInterval() {
+  @Test void datePlusInterval() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("date '2014-02-11' + interval '2' day", "2014-02-13", "DATE NOT NULL");
     // 60 days is more than 2^32 milliseconds
@@ -2768,7 +2768,7 @@ static void checkOverlaps(OverlapChecker c) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-1864">[CALCITE-1864] Allow
    * NULL literal as argument</a>.
    */
-  @Test void testNullOperand() {
+  @Test void nullOperand() {
     final SqlOperatorFixture f = fixture();
     checkNullOperand(f, "=");
     checkNullOperand(f, ">");
@@ -2788,7 +2788,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("null " + op + " null", null);
   }
 
-  @Test void testNotEqualsOperator() {
+  @Test void notEqualsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_EQUALS, VmName.EXPAND);
     f.checkBoolean("1<>1", false);
@@ -2817,7 +2817,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.forEachConformance(conformances, consumer);
   }
 
-  @Test void testNotEqualsOperatorIntervals() {
+  @Test void notEqualsOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("interval '2' day <> interval '1' day", true);
     f.checkBoolean("interval '2' day <> interval '2' day", false);
@@ -2825,7 +2825,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("cast(null as interval hour) <> interval '2' minute");
   }
 
-  @Test void testOrOperator() {
+  @Test void orOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OR, VmName.EXPAND);
     f.checkBoolean("true or false", true);
@@ -2834,7 +2834,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("false or cast(null as boolean)");
   }
 
-  @Test void testOrOperatorLazy() {
+  @Test void orOperatorLazy() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OR, VmName.EXPAND);
 
@@ -2870,7 +2870,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("1 < cast(null as integer) or sqrt(4) = 2", true);
   }
 
-  @Test void testPlusOperator() {
+  @Test void plusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PLUS, VmName.EXPAND);
     f.checkScalarExact("1+2", 3);
@@ -2902,13 +2902,13 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     }
   }
 
-  @Test void testPlusOperatorAny() {
+  @Test void plusOperatorAny() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PLUS, VmName.EXPAND);
     f.checkScalar("1+CAST(2 AS ANY)", "3", "ANY NOT NULL");
   }
 
-  @Test void testPlusIntervalOperator() {
+  @Test void plusIntervalOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PLUS, VmName.EXPAND);
     f.checkScalar("interval '2' day + interval '1' day", "+3", "INTERVAL DAY NOT NULL");
@@ -2983,26 +2983,26 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
         "TIMESTAMP(0) NOT NULL");
   }
 
-  @Test void testDescendingOperator() {
+  @Test void descendingOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DESC, VM_EXPAND);
   }
 
-  @Test void testIsNotNullOperator() {
+  @Test void isNotNullOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_NULL, VmName.EXPAND);
     f.checkBoolean("true is not null", true);
     f.checkBoolean("cast(null as boolean) is not null", false);
   }
 
-  @Test void testIsNullOperator() {
+  @Test void isNullOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NULL, VmName.EXPAND);
     f.checkBoolean("true is null", false);
     f.checkBoolean("cast(null as boolean) is null", true);
   }
 
-  @Test void testIsNotTrueOperator() {
+  @Test void isNotTrueOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_TRUE, VmName.EXPAND);
     f.checkBoolean("true is not true", false);
@@ -3016,7 +3016,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
         false);
   }
 
-  @Test void testIsTrueOperator() {
+  @Test void isTrueOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_TRUE, VmName.EXPAND);
     f.checkBoolean("true is true", true);
@@ -3024,7 +3024,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("cast(null as boolean) is true", false);
   }
 
-  @Test void testIsNotFalseOperator() {
+  @Test void isNotFalseOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_FALSE, VmName.EXPAND);
     f.checkBoolean("false is not false", false);
@@ -3032,7 +3032,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("cast(null as boolean) is not false", true);
   }
 
-  @Test void testIsFalseOperator() {
+  @Test void isFalseOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_FALSE, VmName.EXPAND);
     f.checkBoolean("false is false", true);
@@ -3040,7 +3040,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("cast(null as boolean) is false", false);
   }
 
-  @Test void testIsNotUnknownOperator() {
+  @Test void isNotUnknownOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_UNKNOWN, VM_EXPAND);
     f.checkBoolean("false is not unknown", true);
@@ -3050,7 +3050,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkFails("^'abc' IS NOT UNKNOWN^", "(?s).*Cannot apply 'IS NOT UNKNOWN'.*", false);
   }
 
-  @Test void testIsUnknownOperator() {
+  @Test void isUnknownOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_UNKNOWN, VM_EXPAND);
     f.checkBoolean("false is unknown", false);
@@ -3060,7 +3060,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkFails("0 = 1 AND ^2 IS UNKNOWN^ AND 3 > 4", "(?s).*Cannot apply 'IS UNKNOWN'.*", false);
   }
 
-  @Test void testIsASetOperator() {
+  @Test void isASetOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_A_SET, VM_EXPAND);
     f.checkBoolean("multiset[1] is a set", true);
@@ -3072,7 +3072,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("multiset['a', 'b', 'a'] is a set", false);
   }
 
-  @Test void testIsNotASetOperator() {
+  @Test void isNotASetOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_A_SET, VM_EXPAND);
     f.checkBoolean("multiset[1] is not a set", false);
@@ -3085,7 +3085,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("multiset['a', 'b', 'a'] is not a set", true);
   }
 
-  @Test void testIntersectOperator() {
+  @Test void intersectOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_INTERSECT, VM_EXPAND);
     f.checkScalar(
@@ -3127,7 +3127,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
         "INTEGER MULTISET NOT NULL");
   }
 
-  @Test void testExceptOperator() {
+  @Test void exceptOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_EXCEPT, VM_EXPAND);
     f.checkScalar(
@@ -3165,24 +3165,24 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("(multiset[1] multiset except multiset[1]) is empty", true);
   }
 
-  @Test void testIsEmptyOperator() {
+  @Test void isEmptyOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_EMPTY, VM_EXPAND);
     f.checkBoolean("multiset[1] is empty", false);
   }
 
-  @Test void testIsNotEmptyOperator() {
+  @Test void isNotEmptyOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.IS_NOT_EMPTY, VM_EXPAND);
     f.checkBoolean("multiset[1] is not empty", true);
   }
 
-  @Test void testExistsOperator() {
+  @Test void existsOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXISTS, VM_EXPAND);
   }
 
-  @Test void testNotOperator() {
+  @Test void notOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT, VmName.EXPAND);
     f.checkBoolean("not true", false);
@@ -3191,7 +3191,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("not cast(null as boolean)");
   }
 
-  @Test void testPrefixMinusOperator() {
+  @Test void prefixMinusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.UNARY_MINUS, VmName.EXPAND);
     f.enableTypeCoercion(false)
@@ -3207,7 +3207,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("-cast(null as tinyint)");
   }
 
-  @Test void testPrefixMinusOperatorIntervals() {
+  @Test void prefixMinusOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "-interval '-6:2:8' hour to second", "+6:02:08.000000", "INTERVAL HOUR TO SECOND NOT NULL");
@@ -3219,7 +3219,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("-cast(null as interval day to minute)");
   }
 
-  @Test void testPrefixPlusOperator() {
+  @Test void prefixPlusOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.UNARY_PLUS, VM_EXPAND);
     f.checkScalarExact("+1", 1);
@@ -3229,7 +3229,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("+cast(null as tinyint)");
   }
 
-  @Test void testPrefixPlusOperatorIntervals() {
+  @Test void prefixPlusOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "+interval '-6:2:8' hour to second", "-6:02:08.000000", "INTERVAL HOUR TO SECOND NOT NULL");
@@ -3247,18 +3247,18 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkNull("+cast(null as interval day to minute)");
   }
 
-  @Test void testExplicitTableOperator() {
+  @Test void explicitTableOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXPLICIT_TABLE, VM_EXPAND);
   }
 
-  @Test void testValuesOperator() {
+  @Test void valuesOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VALUES, VM_EXPAND);
     f.check("select 'abc' from (values(true))", "CHAR(3) NOT NULL", "abc");
   }
 
-  @Test void testNotLikeOperator() {
+  @Test void notLikeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_LIKE, VM_EXPAND);
     f.checkBoolean("'abc' not like '_b_'", false);
@@ -3268,7 +3268,7 @@ private static void checkNullOperand(SqlOperatorFixture f, String op) {
     f.checkBoolean("'ab\ncd\nef' not like '%cde%'", true);
   }
 
-  @Test void testRlikeOperator() {
+  @Test void rlikeOperator() {
     SqlOperatorFixture f = fixture().setFor(SqlLibraryOperators.RLIKE, VM_EXPAND);
     checkRlike(f.withLibrary(SqlLibrary.SPARK));
     checkRlike(f.withLibrary(SqlLibrary.HIVE));
@@ -3302,7 +3302,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkFails("^'Merrisa@gmail.com' not rlike 'Merrisa_'^", noNotRlike, false);
   }
 
-  @Test void testLikeEscape() {
+  @Test void likeEscape() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LIKE, VmName.EXPAND);
     f.checkBoolean("'a_c' like 'a#_c' escape '#'", true);
@@ -3315,7 +3315,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("'abbc' like 'a\\%c' escape '\\'", false);
   }
 
-  @Test void testIlikeEscape() {
+  @Test void ilikeEscape() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.ILIKE, VmName.EXPAND)
@@ -3331,13 +3331,13 @@ static void checkRlikeFails(SqlOperatorFixture f) {
   }
 
   @Disabled("[CALCITE-525] Exception-handling in built-in functions")
-  @Test void testLikeEscape2() {
+  @Test void likeEscape2() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("'x' not like 'x' escape 'x'", true);
     f.checkBoolean("'xyz' not like 'xyz' escape 'xyz'", true);
   }
 
-  @Test void testLikeOperator() {
+  @Test void likeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LIKE, VmName.EXPAND);
     f.checkBoolean("''  like ''", true);
@@ -3362,7 +3362,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("'ab\ncd\nef' like '%cde%'", false);
   }
 
-  @Test void testIlikeOperator() {
+  @Test void ilikeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.ILIKE, VmName.EXPAND);
     final String noLike = "No match found for function signature ILIKE";
@@ -3409,14 +3409,14 @@ static void checkRlikeFails(SqlOperatorFixture f) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-1898">[CALCITE-1898] LIKE
    * must match '.' (period) literally</a>.
    */
-  @Test void testLikeDot() {
+  @Test void likeDot() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("'abc' like 'a.c'", false);
     f.checkBoolean("'abcde' like '%c.e'", false);
     f.checkBoolean("'abc.e' like '%c.e'", true);
   }
 
-  @Test void testIlikeDot() {
+  @Test void ilikeDot() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.ILIKE, VmName.EXPAND)
@@ -3427,7 +3427,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("'abc.e' ilike '%c.E'", true);
   }
 
-  @Test void testNotSimilarToOperator() {
+  @Test void notSimilarToOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_SIMILAR_TO, VM_EXPAND);
     f.checkBoolean("'ab' not similar to 'a_'", false);
@@ -3438,7 +3438,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkBoolean("cast(null as varchar(3))" + " not similar to cast(null as char(2))", null);
   }
 
-  @Test void testSimilarToOperator() {
+  @Test void similarToOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SIMILAR_TO, VmName.EXPAND);
 
@@ -3628,12 +3628,12 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     }
   }
 
-  @Test void testEscapeOperator() {
+  @Test void escapeOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ESCAPE, VM_EXPAND);
   }
 
-  @Test void testConvertFunc() {
+  @Test void convertFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CONVERT, VM_FENNEL, VM_JAVA);
     f.checkFails("convert('a', utf8, utf10)", "UTF10", false);
@@ -3656,7 +3656,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkType("convert(cast(1 as varchar(2)), utf8, latin1)", "VARCHAR(2) NOT NULL");
   }
 
-  @Test void testTranslateFunc() {
+  @Test void translateFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TRANSLATE, VM_FENNEL, VM_JAVA);
     f.checkFails("translate('a' using utf10)", "UTF10", false);
@@ -3698,7 +3698,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkType("convert(cast(1 as varchar(2)) using latin1)", "VARCHAR(2) NOT NULL");
   }
 
-  @Test void testTranslate3Func() {
+  @Test void translate3Func() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TRANSLATE3);
     f0.checkFails(
         "^translate('aabbcc', 'ab', '+-')^",
@@ -3724,7 +3724,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testOverlayFunc() {
+  @Test void overlayFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OVERLAY, VmName.EXPAND);
     f.checkString("overlay('ABCdef' placing 'abc' from 1)", "abcdef", "VARCHAR(9) NOT NULL");
@@ -3768,7 +3768,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("overlay(x'abcd' placing x'abcd' from cast(null as integer))");
   }
 
-  @Test void testPositionFunc() {
+  @Test void positionFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.POSITION, VmName.EXPAND);
     f.checkScalarExact("position('b' in 'abc')", 2);
@@ -3799,7 +3799,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkScalar("position(cast('a' as char) in cast('bca' as varchar))", 3, "INTEGER NOT NULL");
   }
 
-  @Test void testReplaceFunc() {
+  @Test void replaceFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.REPLACE, VmName.EXPAND);
     f.checkString("REPLACE('ciao', 'ciao', '')", "", "VARCHAR(4) NOT NULL");
@@ -3809,21 +3809,21 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("REPLACE('ciao', 'bella', cast(null as varchar(3)))");
   }
 
-  @Test void testCharLengthFunc() {
+  @Test void charLengthFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CHAR_LENGTH, VmName.EXPAND);
     f.checkScalarExact("char_length('abc')", 3);
     f.checkNull("char_length(cast(null as varchar(1)))");
   }
 
-  @Test void testCharacterLengthFunc() {
+  @Test void characterLengthFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CHARACTER_LENGTH, VmName.EXPAND);
     f.checkScalarExact("CHARACTER_LENGTH('abc')", 3);
     f.checkNull("CHARACTER_LENGTH(cast(null as varchar(1)))");
   }
 
-  @Test void testLengthFunc() {
+  @Test void lengthFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LENGTH);
     f0.checkFails(
         "^length('hello')^",
@@ -3842,14 +3842,14 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY), consumer);
   }
 
-  @Test void testOctetLengthFunc() {
+  @Test void octetLengthFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.OCTET_LENGTH, VmName.EXPAND);
     f.checkScalarExact("OCTET_LENGTH(x'aabbcc')", 3);
     f.checkNull("OCTET_LENGTH(cast(null as varbinary(1)))");
   }
 
-  @Test void testBitLengthFunc() {
+  @Test void bitLengthFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.BIT_LENGTH, VmName.EXPAND);
     f0.checkFails(
@@ -3866,7 +3866,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f1.checkNull("BIT_LENGTH(cast(null as binary))");
   }
 
-  @Test void testAsciiFunc() {
+  @Test void asciiFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ASCII, VmName.EXPAND);
     f.checkScalarExact("ASCII('')", 0);
@@ -3880,7 +3880,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("ASCII(cast(null as varchar(1)))");
   }
 
-  @Test void testToBase64() {
+  @Test void toBase64() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.setFor(SqlLibraryOperators.TO_BASE64);
     f.checkString(
@@ -3938,7 +3938,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkString("to_base64(x'61')", "YQ==", "VARCHAR NOT NULL");
   }
 
-  @Test void testToChar() {
+  @Test void toChar() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.POSTGRESQL);
     f.setFor(SqlLibraryOperators.TO_CHAR);
     f.checkString(
@@ -3947,7 +3947,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
         "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testFromBase64() {
+  @Test void fromBase64() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.FROM_BASE64);
     f0.checkFails(
         "^from_base64('2fjoeiwjfoj==')^",
@@ -3977,7 +3977,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.MYSQL), consumer);
   }
 
-  @Test void testToBase32() {
+  @Test void toBase32() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TO_BASE32);
     f0.checkFails(
         "^to_base32('')^",
@@ -4000,7 +4000,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkString("to_base32('')", "", "VARCHAR NOT NULL");
   }
 
-  @Test void testFromBase32() {
+  @Test void fromBase32() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.FROM_BASE32);
     f0.checkFails(
         "^from_base32('')^",
@@ -4018,7 +4018,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("from_base32(cast (null as varchar))");
   }
 
-  @Test void testMd5() {
+  @Test void md5() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.MD5);
     f0.checkFails("^md5(x'')^", "No match found for function signature MD5\\(<BINARY>\\)", false);
     final List<SqlLibrary> libraries =
@@ -4033,7 +4033,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testSha1() {
+  @Test void sha1() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SHA1);
     f0.checkFails("^sha1(x'')^", "No match found for function signature SHA1\\(<BINARY>\\)", false);
     final List<SqlLibrary> libraries =
@@ -4051,7 +4051,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testSha256() {
+  @Test void sha256() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SHA1);
     f0.checkFails(
         "^sha256(x'')^", "No match found for function signature SHA256\\(<BINARY>\\)", false);
@@ -4080,7 +4080,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testSha512() {
+  @Test void sha512() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SHA1);
     f0.checkFails(
         "^sha512(x'')^", "No match found for function signature SHA512\\(<BINARY>\\)", false);
@@ -4114,7 +4114,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testToHex() {
+  @Test void toHex() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TO_HEX);
     f0.checkFails(
         "^to_hex(x'')^", "No match found for function signature TO_HEX\\(<BINARY>\\)", false);
@@ -4124,7 +4124,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("to_hex(cast(null as varbinary))");
   }
 
-  @Test void testFromHex() {
+  @Test void fromHex() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.FROM_HEX);
     f0.checkFails(
         "^from_hex('')^", "No match found for function signature FROM_HEX\\(<CHARACTER>\\)", false);
@@ -4137,7 +4137,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("from_hex(cast(null as varchar))");
   }
 
-  @Test void testRepeatFunc() {
+  @Test void repeatFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.REPEAT);
     f0.checkFails(
         "^repeat('a', -100)^",
@@ -4158,7 +4158,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.MYSQL), consumer);
   }
 
-  @Test void testSpaceFunc() {
+  @Test void spaceFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.SPACE).withLibrary(SqlLibrary.MYSQL);
     f.checkString("SPACE(-100)", "", "VARCHAR(2000) NOT NULL");
@@ -4169,7 +4169,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("SPACE(cast(null as integer))");
   }
 
-  @Test void testStrcmpFunc() {
+  @Test void strcmpFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.STRCMP).withLibrary(SqlLibrary.MYSQL);
     f.checkString("STRCMP('mytesttext', 'mytesttext')", "0", "INTEGER NOT NULL");
@@ -4179,7 +4179,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("STRCMP(cast(null as varchar(1)), 'mytesttext')");
   }
 
-  @Test void testSoundexFunc() {
+  @Test void soundexFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SOUNDEX);
     f0.checkFails(
         "^soundex('tech on the net')^",
@@ -4204,7 +4204,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(libraries, consumer);
   }
 
-  @Test void testDifferenceFunc() {
+  @Test void differenceFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.DIFFERENCE).withLibrary(SqlLibrary.POSTGRESQL);
     f.checkScalarExact("DIFFERENCE('Miller', 'miller')", 4);
@@ -4219,7 +4219,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f.checkNull("DIFFERENCE(cast(null as varchar(1)), 'muller')");
   }
 
-  @Test void testReverseFunc() {
+  @Test void reverseFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.REVERSE);
     f0.checkFails(
         "^reverse('abc')^",
@@ -4238,7 +4238,7 @@ static void checkRlikeFails(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.MYSQL), consumer);
   }
 
-  @Test void testIfFunc() {
+  @Test void ifFunc() {
     final SqlOperatorFixture f = fixture();
     checkIf(f.withLibrary(SqlLibrary.BIG_QUERY));
     checkIf(f.withLibrary(SqlLibrary.HIVE));
@@ -4257,7 +4257,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkScalar("if(nullif(true,true), 5, 10)", 10, "INTEGER NOT NULL");
   }
 
-  @Test void testUpperFunc() {
+  @Test void upperFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.UPPER, VmName.EXPAND);
     f.checkString("upper('a')", "A", "CHAR(1) NOT NULL");
@@ -4267,7 +4267,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("upper(cast(null as varchar(1)))");
   }
 
-  @Test void testLeftFunc() {
+  @Test void leftFunc() {
     final SqlOperatorFixture f0 = fixture();
     final Consumer<SqlOperatorFixture> consumer =
         f -> {
@@ -4290,7 +4290,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.MYSQL, SqlLibrary.POSTGRESQL), consumer);
   }
 
-  @Test void testRightFunc() {
+  @Test void rightFunc() {
     final SqlOperatorFixture f0 = fixture();
     final Consumer<SqlOperatorFixture> consumer =
         f -> {
@@ -4314,7 +4314,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.MYSQL, SqlLibrary.POSTGRESQL), consumer);
   }
 
-  @Test void testRegexpReplaceFunc() {
+  @Test void regexpReplaceFunc() {
     final SqlOperatorFixture f0 = fixture();
     final Consumer<SqlOperatorFixture> consumer =
         f -> {
@@ -4366,7 +4366,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.MYSQL, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testJsonExists() {
+  @Test void jsonExists() {
     // default pathmode the default is: strict mode
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("json_exists('{\"foo\":\"bar\"}', " + "'$.foo')", true);
@@ -4400,7 +4400,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_exists(cast(null as varchar), " + "'lax $.foo1' unknown on error)");
   }
 
-  @Test public void testJsonInsert() {
+  @Test void jsonInsert() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkString("json_insert('10', '$.a', 10, '$.c', '[true]')", "10", "VARCHAR(2000)");
     f.checkString(
@@ -4427,7 +4427,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_insert(cast(null as varchar), '$', 10)");
   }
 
-  @Test public void testJsonReplace() {
+  @Test void jsonReplace() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkString("json_replace('10', '$.a', 10, '$.c', '[true]')", "10", "VARCHAR(2000)");
     f.checkString(
@@ -4453,7 +4453,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_replace(cast(null as varchar), '$', 10)");
   }
 
-  @Test public void testJsonSet() {
+  @Test void jsonSet() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkString("json_set('10', '$.a', 10, '$.c', '[true]')", "10", "VARCHAR(2000)");
     f.checkString(
@@ -4475,7 +4475,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_set(cast(null as varchar), '$', 10)");
   }
 
-  @Test void testJsonValue() {
+  @Test void jsonValue() {
     final SqlOperatorFixture f = fixture();
     if (false) {
       f.checkFails(
@@ -4586,7 +4586,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_value(cast(null as varchar), 'strict $')");
   }
 
-  @Test void testJsonQuery() {
+  @Test void jsonQuery() {
     final SqlOperatorFixture f = fixture();
     // default pathmode the default is: strict mode
     f.checkString(
@@ -4709,7 +4709,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_query(cast(null as varchar), 'lax $')");
   }
 
-  @Test void testJsonPretty() {
+  @Test void jsonPretty() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_pretty('{\"foo\":100}')", "{\n  \"foo\" : 100\n}", "VARCHAR(2000)");
     f.checkString("json_pretty('[1,2,3]')", "[ 1, 2, 3 ]", "VARCHAR(2000)");
@@ -4722,7 +4722,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_pretty(cast(null as varchar))");
   }
 
-  @Test void testJsonStorageSize() {
+  @Test void jsonStorageSize() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_storage_size('[100, \"sakila\", [1, 3, 5], 425.05]')", "29", "INTEGER");
     f.checkString(
@@ -4742,7 +4742,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_storage_size(cast(null as varchar))");
   }
 
-  @Test void testJsonType() {
+  @Test void jsonType() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.JSON_TYPE, VmName.EXPAND);
     f.checkString("json_type('\"1\"')", "STRING", "VARCHAR(20)");
@@ -4763,7 +4763,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_type(cast(null as varchar))");
   }
 
-  @Test void testJsonDepth() {
+  @Test void jsonDepth() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.JSON_DEPTH, VmName.EXPAND);
     f.checkString("json_depth('1')", "1", "INTEGER");
@@ -4786,7 +4786,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_depth(cast(null as varchar))");
   }
 
-  @Test void testJsonLength() {
+  @Test void jsonLength() {
     final SqlOperatorFixture f = fixture();
     // no path context
     f.checkString("json_length('{}')", "0", "INTEGER");
@@ -4828,7 +4828,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_length(cast(null as varchar))");
   }
 
-  @Test void testJsonKeys() {
+  @Test void jsonKeys() {
     final SqlOperatorFixture f = fixture();
     // no path context
     f.checkString("json_keys('{}')", "[]", "VARCHAR(2000)");
@@ -4873,7 +4873,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_keys(cast(null as varchar))");
   }
 
-  @Test void testJsonRemove() {
+  @Test void jsonRemove() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_remove('{\"foo\":100}', '$.foo')", "{}", "VARCHAR(2000)");
     f.checkString(
@@ -4898,7 +4898,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("json_remove(cast(null as varchar), '$')");
   }
 
-  @Test void testJsonObject() {
+  @Test void jsonObject() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_object()", "{}", "VARCHAR(2000) NOT NULL");
     f.checkString("json_object('foo': 'bar')", "{\"foo\":\"bar\"}", "VARCHAR(2000) NOT NULL");
@@ -4921,7 +4921,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testJsonObjectAgg() {
+  @Test void jsonObjectAgg() {
     final SqlOperatorFixture f = fixture();
     f.checkAggType("json_objectagg('foo': 'bar')", "VARCHAR(2000) NOT NULL");
     f.checkAggType("json_objectagg('foo': null)", "VARCHAR(2000) NOT NULL");
@@ -4947,7 +4947,7 @@ private static void checkIf(SqlOperatorFixture f) {
         isSingle("{\"foo\":\"bar\",\"foo3\":\"bar3\"}"));
   }
 
-  @Test void testJsonValueExpressionOperator() {
+  @Test void jsonValueExpressionOperator() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("'{}' format json", "{}", "ANY NOT NULL");
     f.checkScalar("'[1, 2, 3]' format json", "[1,2,3]", "ANY NOT NULL");
@@ -4957,7 +4957,7 @@ private static void checkIf(SqlOperatorFixture f) {
         .checkFails("^null^ format json", "(?s).*Illegal use of .NULL.*", false);
   }
 
-  @Test void testJsonArray() {
+  @Test void jsonArray() {
     final SqlOperatorFixture f = fixture();
     f.checkString("json_array()", "[]", "VARCHAR(2000) NOT NULL");
     f.checkString("json_array('foo')", "[\"foo\"]", "VARCHAR(2000) NOT NULL");
@@ -4971,7 +4971,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "json_array(json_array('foo') format json)", "[[\"foo\"]]", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testJsonArrayAgg() {
+  @Test void jsonArrayAgg() {
     final SqlOperatorFixture f = fixture();
     f.checkAggType("json_arrayagg('foo')", "VARCHAR(2000) NOT NULL");
     f.checkAggType("json_arrayagg(null)", "VARCHAR(2000) NOT NULL");
@@ -4981,7 +4981,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkAgg("json_arrayagg(x absent on null)", values, isSingle("[\"foo\",\"foo3\"]"));
   }
 
-  @Test void testJsonPredicate() {
+  @Test void jsonPredicate() {
     final SqlOperatorFixture f = fixture();
     f.checkBoolean("'{}' is json value", true);
     f.checkBoolean("'{]' is json value", false);
@@ -5001,7 +5001,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkBoolean("'[]' is not json scalar", true);
   }
 
-  @Test void testCompress() {
+  @Test void compress() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkNull("COMPRESS(NULL)");
     f.checkString("COMPRESS('')", "", "VARBINARY NOT NULL");
@@ -5019,7 +5019,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "COMPRESS('example')", "07000000789c4bad48cc2dc84905000bc002ed", "VARBINARY NOT NULL");
   }
 
-  @Test void testExtractValue() {
+  @Test void extractValue() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.MYSQL);
     f.checkNull("ExtractValue(NULL, '//b')");
     f.checkNull("ExtractValue('', NULL)");
@@ -5037,7 +5037,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkString("ExtractValue('<a><b/></a>', 'count(/a/b)')", "1", "VARCHAR(2000)");
   }
 
-  @Test void testXmlTransform() {
+  @Test void xmlTransform() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.ORACLE);
     f.checkNull("XMLTRANSFORM('', NULL)");
     f.checkNull("XMLTRANSFORM(NULL,'')");
@@ -5077,7 +5077,7 @@ private static void checkIf(SqlOperatorFixture f) {
         sql2, "    Article - My Article    Authors:     - Mr. Foo    - Mr. Bar", "VARCHAR(2000)");
   }
 
-  @Test void testExtractXml() {
+  @Test void extractXml() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.ORACLE);
 
     f.checkFails("\"EXTRACT\"('', '<','a')", "Invalid input for EXTRACT xpath: '.*", true);
@@ -5124,7 +5124,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "VARCHAR(2000)");
   }
 
-  @Test void testExistsNode() {
+  @Test void existsNode() {
     SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.ORACLE);
 
     f.checkFails("EXISTSNODE('', '<','a')", "Invalid input for EXISTSNODE xpath: '.*", true);
@@ -5184,7 +5184,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "INTEGER");
   }
 
-  @Test void testLowerFunc() {
+  @Test void lowerFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LOWER, VmName.EXPAND);
 
@@ -5196,7 +5196,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("lower(cast(null as varchar(1)))");
   }
 
-  @Test void testInitcapFunc() {
+  @Test void initcapFunc() {
     // Note: the initcap function is an Oracle defined function and is not
     // defined in the SQL:2003 standard
     // todo: implement in fennel
@@ -5220,7 +5220,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkType("initcap(cast(null as date))", "VARCHAR");
   }
 
-  @Test void testPowerFunc() {
+  @Test void powerFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.POWER, VmName.EXPAND);
     f.checkScalarApprox("power(2,-2)", "DOUBLE NOT NULL", isExactly("0.25"));
@@ -5234,7 +5234,7 @@ private static void checkIf(SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testSqrtFunc() {
+  @Test void sqrtFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SQRT, VmName.EXPAND);
     f.checkType("sqrt(2)", "DOUBLE NOT NULL");
@@ -5255,7 +5255,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("sqrt(cast(null as double))");
   }
 
-  @Test void testExpFunc() {
+  @Test void expFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXP, VM_FENNEL);
     f.checkScalarApprox("exp(2)", "DOUBLE NOT NULL", isWithin(7.389056, 0.000001));
@@ -5264,7 +5264,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("exp(cast(null as double))");
   }
 
-  @Test void testModFunc() {
+  @Test void modFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MOD, VmName.EXPAND);
     f.checkScalarExact("mod(4,2)", 0);
@@ -5285,7 +5285,7 @@ private static void checkIf(SqlOperatorFixture f) {
         "-2");
   }
 
-  @Test void testModFuncNull() {
+  @Test void modFuncNull() {
     final SqlOperatorFixture f = fixture();
     f.checkNull("mod(cast(null as integer),2)");
     f.checkNull("mod(4,cast(null as tinyint))");
@@ -5295,7 +5295,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("mod(4,cast(null as decimal(12,0)))");
   }
 
-  @Test void testModFuncDivByZero() {
+  @Test void modFuncDivByZero() {
     // The extra CASE expression is to fool Janino.  It does constant
     // reduction and will throw the divide by zero exception while
     // compiling the expression.  The test frame work would then issue
@@ -5306,7 +5306,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkFails("mod(3,case 'a' when 'a' then 0 end)", DIVISION_BY_ZERO_MESSAGE, true);
   }
 
-  @Test void testLnFunc() {
+  @Test void lnFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LN, VmName.EXPAND);
     f.checkScalarApprox("ln(2.71828)", "DOUBLE NOT NULL", isWithin(1.0, 0.000001));
@@ -5314,7 +5314,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("ln(cast(null as tinyint))");
   }
 
-  @Test void testLog10Func() {
+  @Test void log10Func() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LOG10, VmName.EXPAND);
     f.checkScalarApprox("log10(10)", "DOUBLE NOT NULL", isWithin(1.0, 0.000001));
@@ -5325,7 +5325,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("log10(cast(null as real))");
   }
 
-  @Test void testLogFunc() {
+  @Test void logFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LOG, VmName.EXPAND);
     f0.checkFails(
         "^log(100, 10)^",
@@ -5346,7 +5346,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("log(10, cast(null as real))");
   }
 
-  @Test void testRandFunc() {
+  @Test void randFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND, VmName.EXPAND);
     f.checkFails("^rand^", "Column 'RAND' not found in any table", false);
@@ -5356,14 +5356,14 @@ private static void checkIf(SqlOperatorFixture f) {
     }
   }
 
-  @Test void testRandSeedFunc() {
+  @Test void randSeedFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND, VmName.EXPAND);
     f.checkScalarApprox("rand(1)", "DOUBLE NOT NULL", isWithin(0.6016, 0.0001));
     f.checkScalarApprox("rand(2)", "DOUBLE NOT NULL", isWithin(0.4728, 0.0001));
   }
 
-  @Test void testRandIntegerFunc() {
+  @Test void randIntegerFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND_INTEGER, VmName.EXPAND);
     for (int i = 0; i < 100; i++) {
@@ -5372,7 +5372,7 @@ private static void checkIf(SqlOperatorFixture f) {
     }
   }
 
-  @Test void testRandIntegerSeedFunc() {
+  @Test void randIntegerSeedFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RAND_INTEGER, VmName.EXPAND);
     f.checkScalar("rand_integer(1, 11)", 4, "INTEGER NOT NULL");
@@ -5380,7 +5380,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_APPEND} function from Spark. */
-  @Test void testArrayAppendFunc() {
+  @Test void arrayAppendFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_APPEND);
     f0.checkFails(
@@ -5409,7 +5409,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_COMPACT} function from Spark. */
-  @Test void testArrayCompactFunc() {
+  @Test void arrayCompactFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_COMPACT);
     f0.checkFails(
@@ -5426,7 +5426,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_CONCAT} function from BigQuery. */
-  @Test void testArrayConcat() {
+  @Test void arrayConcat() {
     SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.ARRAY_CONCAT).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkFails("^array_concat()^", INVALID_ARGUMENTS_NUMBER, false);
@@ -5444,7 +5444,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_CONTAINS} function from Spark. */
-  @Test void testArrayContainsFunc() {
+  @Test void arrayContainsFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_CONTAINS);
     f0.checkFails(
@@ -5474,7 +5474,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_DISTINCT} function from Spark. */
-  @Test void testArrayDistinctFunc() {
+  @Test void arrayDistinctFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_DISTINCT);
     f0.checkFails(
@@ -5487,7 +5487,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("array_distinct(null)");
   }
 
-  @Test void testArrayJoinFunc() {
+  @Test void arrayJoinFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_JOIN);
     f0.checkFails(
@@ -5519,7 +5519,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_MAX} function from Spark. */
-  @Test void testArrayMaxFunc() {
+  @Test void arrayMaxFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_MAX);
     f0.checkFails(
@@ -5537,7 +5537,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_MIN} function from Spark. */
-  @Test void testArrayMinFunc() {
+  @Test void arrayMinFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_MIN);
     f0.checkFails(
@@ -5554,7 +5554,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_POSITION} function from Spark. */
-  @Test void testArrayPositionFunc() {
+  @Test void arrayPositionFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_POSITION);
     f0.checkFails(
@@ -5578,7 +5578,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_PREPEND} function from Spark. */
-  @Test void testArrayPrependFunc() {
+  @Test void arrayPrependFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_PREPEND);
     f0.checkFails(
@@ -5607,7 +5607,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_REMOVE} function from Spark. */
-  @Test void testArrayRemoveFunc() {
+  @Test void arrayRemoveFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_REMOVE);
     f0.checkFails(
@@ -5645,7 +5645,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_REPEAT} function from Spark. */
-  @Test void testArrayRepeatFunc() {
+  @Test void arrayRepeatFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_REPEAT);
     f0.checkFails(
@@ -5670,7 +5670,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_REVERSE} function from BigQuery. */
-  @Test void testArrayReverseFunc() {
+  @Test void arrayReverseFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_REVERSE);
     f0.checkFails(
@@ -5684,7 +5684,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_SIZE} function from Spark. */
-  @Test void testArraySizeFunc() {
+  @Test void arraySizeFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_SIZE);
     f0.checkFails(
@@ -5699,7 +5699,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_LENGTH} function from BigQuery. */
-  @Test void testArrayLengthFunc() {
+  @Test void arrayLengthFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_LENGTH);
     f0.checkFails(
@@ -5712,7 +5712,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("array_length(null)");
   }
 
-  @Test void testArrayToStringFunc() {
+  @Test void arrayToStringFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_TO_STRING);
     f0.checkFails(
@@ -5744,7 +5744,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_EXCEPT} function from Spark. */
-  @Test void testArrayExceptFunc() {
+  @Test void arrayExceptFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_EXCEPT);
     f0.checkFails(
@@ -5765,7 +5765,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_INTERSECT} function from Spark. */
-  @Test void testArrayIntersectFunc() {
+  @Test void arrayIntersectFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_INTERSECT);
     f0.checkFails(
@@ -5789,7 +5789,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAY_UNION} function from Spark. */
-  @Test void testArrayUnionFunc() {
+  @Test void arrayUnionFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAY_UNION);
     f0.checkFails(
@@ -5811,7 +5811,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAYS_OVERLAP} function from Spark. */
-  @Test void testArraysOverlapFunc() {
+  @Test void arraysOverlapFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAYS_OVERLAP);
     f0.checkFails(
@@ -5850,7 +5850,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code ARRAYS_ZIP} function from Spark. */
-  @Test void testArraysZipFunc() {
+  @Test void arraysZipFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ARRAYS_ZIP);
     f0.checkFails(
@@ -5915,7 +5915,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code SORT_ARRAY} function from Spark. */
-  @Test void testSortArrayFunc() {
+  @Test void sortArrayFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.SORT_ARRAY);
     f0.checkFails(
@@ -5954,7 +5954,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_CONCAT} function from Spark. */
-  @Test void testMapConcatFunc() {
+  @Test void mapConcatFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_CONCAT);
     f0.checkFails(
@@ -6020,7 +6020,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_ENTRIES} function from Spark. */
-  @Test void testMapEntriesFunc() {
+  @Test void mapEntriesFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_ENTRIES);
     f0.checkFails(
@@ -6040,7 +6040,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_KEYS} function from Spark. */
-  @Test void testMapKeysFunc() {
+  @Test void mapKeysFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_KEYS);
     f0.checkFails(
@@ -6054,7 +6054,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_VALUES} function from Spark. */
-  @Test void testMapValuesFunc() {
+  @Test void mapValuesFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_VALUES);
     f0.checkFails(
@@ -6072,7 +6072,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_FROM_ARRAYS} function from Spark. */
-  @Test void testMapFromArraysFunc() {
+  @Test void mapFromArraysFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_FROM_ARRAYS);
     f0.checkFails(
@@ -6125,7 +6125,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code MAP_FROM_ENTRIES} function from Spark. */
-  @Test void testMapFromEntriesFunc() {
+  @Test void mapFromEntriesFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.MAP_FROM_ENTRIES);
     f0.checkFails(
@@ -6181,7 +6181,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code STR_TO_MAP} function from Spark. */
-  @Test void testStrToMapFunc() {
+  @Test void strToMapFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.STR_TO_MAP);
     f0.checkFails(
@@ -6233,7 +6233,7 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   /** Tests {@code UNIX_SECONDS} and other datetime functions from BigQuery. */
-  @Test void testUnixSecondsFunc() {
+  @Test void unixSecondsFunc() {
     SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.UNIX_SECONDS).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkScalar("unix_seconds(timestamp '1970-01-01 00:00:00')", 0, "BIGINT NOT NULL");
@@ -6255,7 +6255,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkType("CURRENT_DATETIME(CAST(NULL AS VARCHAR(20)))", "TIMESTAMP(0)");
   }
 
-  @Test void testAbsFunc() {
+  @Test void absFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ABS, VmName.EXPAND);
     f.checkScalarExact("abs(-1)", 1);
@@ -6272,7 +6272,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("abs(cast(null as double))");
   }
 
-  @Test void testAbsFuncIntervals() {
+  @Test void absFuncIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("abs(interval '-2' day)", "+2", "INTERVAL DAY NOT NULL");
     f.checkScalar(
@@ -6280,7 +6280,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("abs(cast(null as interval hour))");
   }
 
-  @Test void testAcosFunc() {
+  @Test void acosFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ACOS, VmName.EXPAND);
     f.checkType("acos(0)", "DOUBLE NOT NULL");
@@ -6301,7 +6301,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("acos(cast(null as double))");
   }
 
-  @Test void testAsinFunc() {
+  @Test void asinFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ASIN, VmName.EXPAND);
     f.checkType("asin(0)", "DOUBLE NOT NULL");
@@ -6322,7 +6322,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("asin(cast(null as double))");
   }
 
-  @Test void testAtanFunc() {
+  @Test void atanFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ATAN, VmName.EXPAND);
     f.checkType("atan(2)", "DOUBLE NOT NULL");
@@ -6343,7 +6343,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("atan(cast(null as double))");
   }
 
-  @Test void testAtan2Func() {
+  @Test void atan2Func() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ATAN2, VmName.EXPAND);
     f.checkType("atan2(2, -2)", "DOUBLE NOT NULL");
@@ -6367,7 +6367,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("atan2(1, cast(null as double))");
   }
 
-  @Test void testAcoshFunc() {
+  @Test void acoshFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.ACOSH);
     f0.checkFails(
         "^acosh(1)^", "No match found for function signature ACOSH\\(<NUMERIC>\\)", false);
@@ -6387,7 +6387,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testAsinhFunc() {
+  @Test void asinhFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.ASINH);
     f0.checkFails(
         "^asinh(1)^", "No match found for function signature ASINH\\(<NUMERIC>\\)", false);
@@ -6406,7 +6406,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testAtanhFunc() {
+  @Test void atanhFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.ATANH);
     f0.checkFails(
         "^atanh(1)^", "No match found for function signature ATANH\\(<NUMERIC>\\)", false);
@@ -6431,7 +6431,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testCbrtFunc() {
+  @Test void cbrtFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CBRT, VmName.EXPAND);
     f.checkType("cbrt(1)", "DOUBLE NOT NULL");
@@ -6452,7 +6452,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("cbrt(cast(null as double))");
   }
 
-  @Test void testCosFunc() {
+  @Test void cosFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COS, VmName.EXPAND);
     f.checkType("cos(1)", "DOUBLE NOT NULL");
@@ -6473,7 +6473,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("cos(cast(null as double))");
   }
 
-  @Test void testCoshFunc() {
+  @Test void coshFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.COSH);
     f0.checkFails("^cosh(1)^", "No match found for function signature COSH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6491,7 +6491,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testCotFunc() {
+  @Test void cotFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COT, VmName.EXPAND);
     f.checkType("cot(1)", "DOUBLE NOT NULL");
@@ -6512,7 +6512,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("cot(cast(null as double))");
   }
 
-  @Test void testCothFunc() {
+  @Test void cothFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.COTH);
     f0.checkFails("^coth(1)^", "No match found for function signature COTH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6530,7 +6530,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testCschFunc() {
+  @Test void cschFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CSCH);
     f0.checkFails("^csch(1)^", "No match found for function signature CSCH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6548,7 +6548,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testCscFunc() {
+  @Test void cscFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CSC);
     f0.checkFails("^csc(1)^", "No match found for function signature CSC\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6567,7 +6567,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testSecFunc() {
+  @Test void secFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SEC);
     f0.checkFails("^sec(1)^", "No match found for function signature SEC\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6586,7 +6586,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testDegreesFunc() {
+  @Test void degreesFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DEGREES, VmName.EXPAND);
     f.checkType("degrees(1)", "DOUBLE NOT NULL");
@@ -6607,7 +6607,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("degrees(cast(null as double))");
   }
 
-  @Test void testPiFunc() {
+  @Test void piFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PI, VmName.EXPAND);
     f.checkScalarApprox("PI", "DOUBLE NOT NULL", isWithin(3.1415d, 0.0001d));
@@ -6620,7 +6620,7 @@ private static void checkIf(SqlOperatorFixture f) {
         is(false));
   }
 
-  @Test void testRadiansFunc() {
+  @Test void radiansFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RADIANS, VmName.EXPAND);
     f.checkType("radians(42)", "DOUBLE NOT NULL");
@@ -6641,7 +6641,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("radians(cast(null as double))");
   }
 
-  @Test void testPowFunc() {
+  @Test void powFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.POW).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkScalarApprox("pow(2,3)", "DOUBLE NOT NULL", isExactly("8.0"));
@@ -6649,7 +6649,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("pow(cast(null as integer), 2)");
   }
 
-  @Test void testRoundFunc() {
+  @Test void roundFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ROUND, VmName.EXPAND);
     f.checkType("round(42, -1)", "INTEGER NOT NULL");
@@ -6686,7 +6686,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkScalar("round(42.724)", BigDecimal.valueOf(43, 0), "DECIMAL(5, 3) NOT NULL");
   }
 
-  @Test void testSignFunc() {
+  @Test void signFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SIGN, VmName.EXPAND);
     f.checkType("sign(1)", "INTEGER NOT NULL");
@@ -6708,7 +6708,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("sign(cast(null as double))");
   }
 
-  @Test void testSechFunc() {
+  @Test void sechFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SECH);
     f0.checkFails("^sech(1)^", "No match found for function signature SECH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6726,7 +6726,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testSinFunc() {
+  @Test void sinFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SIN, VmName.EXPAND);
     f.checkType("sin(1)", "DOUBLE NOT NULL");
@@ -6747,7 +6747,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("sin(cast(null as double))");
   }
 
-  @Test void testSinhFunc() {
+  @Test void sinhFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SINH);
     f0.checkFails("^sinh(1)^", "No match found for function signature SINH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6765,7 +6765,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testTanFunc() {
+  @Test void tanFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TAN, VmName.EXPAND);
     f.checkType("tan(1)", "DOUBLE NOT NULL");
@@ -6786,7 +6786,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("tan(cast(null as double))");
   }
 
-  @Test void testTanhFunc() {
+  @Test void tanhFunc() {
     SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TANH);
     f0.checkFails("^tanh(1)^", "No match found for function signature TANH\\(<NUMERIC>\\)", false);
     final Consumer<SqlOperatorFixture> consumer =
@@ -6804,7 +6804,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f0.forEachLibrary(list(SqlLibrary.ALL), consumer);
   }
 
-  @Test void testTruncFunc() {
+  @Test void truncFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.TRUNC).withLibrary(SqlLibrary.BIG_QUERY);
     f.checkType("trunc(42, -1)", "INTEGER NOT NULL");
@@ -6842,7 +6842,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("trunc(cast(null as double))");
   }
 
-  @Test void testTruncateFunc() {
+  @Test void truncateFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TRUNCATE, VmName.EXPAND);
     f.checkType("truncate(42, -1)", "INTEGER NOT NULL");
@@ -6880,7 +6880,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("truncate(cast(null as double))");
   }
 
-  @Test void testNullifFunc() {
+  @Test void nullifFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NULLIF, VM_EXPAND);
     f.checkNull("nullif(1,1)");
@@ -6912,7 +6912,7 @@ private static void checkIf(SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testNullIfOperatorIntervals() {
+  @Test void nullIfOperatorIntervals() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar("nullif(interval '2' month, interval '3' year)", "+2", "INTERVAL MONTH");
     f.checkScalar(
@@ -6922,7 +6922,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkNull("nullif(interval '3' day, interval '3' day)");
   }
 
-  @Test void testCoalesceFunc() {
+  @Test void coalesceFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COALESCE, VM_EXPAND);
     f.checkString("coalesce('a','b')", "a", "CHAR(1) NOT NULL");
@@ -6935,38 +6935,38 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkType("1 + coalesce('a', 'b', 1, null) + 2", "INTEGER");
   }
 
-  @Test void testUserFunc() {
+  @Test void userFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.USER, VM_FENNEL);
     f.checkString("USER", "sa", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentUserFunc() {
+  @Test void currentUserFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_USER, VM_FENNEL);
     f.checkString("CURRENT_USER", "sa", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testSessionUserFunc() {
+  @Test void sessionUserFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SESSION_USER, VM_FENNEL);
     f.checkString("SESSION_USER", "sa", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testSystemUserFunc() {
+  @Test void systemUserFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SYSTEM_USER, VM_FENNEL);
     String user = System.getProperty("user.name"); // e.g. "jhyde"
     f.checkString("SYSTEM_USER", user, "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentPathFunc() {
+  @Test void currentPathFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_PATH, VM_FENNEL);
     f.checkString("CURRENT_PATH", "", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentRoleFunc() {
+  @Test void currentRoleFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_ROLE, VM_FENNEL);
     // By default, the CURRENT_ROLE function returns
@@ -6974,7 +6974,7 @@ private static void checkIf(SqlOperatorFixture f) {
     f.checkString("CURRENT_ROLE", "", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testCurrentCatalogFunc() {
+  @Test void currentCatalogFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CURRENT_CATALOG, VM_FENNEL);
     // By default, the CURRENT_CATALOG function returns
@@ -6983,11 +6983,11 @@ private static void checkIf(SqlOperatorFixture f) {
   }
 
   @Tag("slow")
-  @Test void testLocalTimeFuncWithCurrentTime() {
+  @Test void localTimeFuncWithCurrentTime() {
     testLocalTimeFunc(currentTimeString(LOCAL_TZ));
   }
 
-  @Test void testLocalTimeFuncWithFixedTime() {
+  @Test void localTimeFuncWithFixedTime() {
     testLocalTimeFunc(fixedTimeString(LOCAL_TZ));
   }
 
@@ -7010,11 +7010,11 @@ private void testLocalTimeFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   @Tag("slow")
-  @Test void testLocalTimestampFuncWithCurrentTime() {
+  @Test void localTimestampFuncWithCurrentTime() {
     testLocalTimestampFunc(currentTimeString(LOCAL_TZ));
   }
 
-  @Test void testLocalTimestampFuncWithFixedTime() {
+  @Test void localTimestampFuncWithFixedTime() {
     testLocalTimestampFunc(fixedTimeString(LOCAL_TZ));
   }
 
@@ -7042,11 +7042,11 @@ private void testLocalTimestampFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   @Tag("slow")
-  @Test void testCurrentTimeFuncWithCurrentTime() {
+  @Test void currentTimeFuncWithCurrentTime() {
     testCurrentTimeFunc(currentTimeString(CURRENT_TZ));
   }
 
-  @Test void testCurrentTimeFuncWithFixedTime() {
+  @Test void currentTimeFuncWithFixedTime() {
     testCurrentTimeFunc(fixedTimeString(CURRENT_TZ));
   }
 
@@ -7070,11 +7070,11 @@ private void testCurrentTimeFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   @Tag("slow")
-  @Test void testCurrentTimestampFuncWithCurrentTime() {
+  @Test void currentTimestampFuncWithCurrentTime() {
     testCurrentTimestampFunc(currentTimeString(CURRENT_TZ));
   }
 
-  @Test void testCurrentTimestampFuncWithFixedTime() {
+  @Test void currentTimestampFuncWithFixedTime() {
     testCurrentTimestampFunc(fixedTimeString(CURRENT_TZ));
   }
 
@@ -7129,11 +7129,11 @@ private static String toTimeString(TimeZone tz, Calendar cal) {
   }
 
   @Tag("slow")
-  @Test void testCurrentDateFuncWithCurrentTime() {
+  @Test void currentDateFuncWithCurrentTime() {
     testCurrentDateFunc(currentTimeString(LOCAL_TZ));
   }
 
-  @Test void testCurrentDateFuncWithFixedTime() {
+  @Test void currentDateFuncWithFixedTime() {
     testCurrentDateFunc(fixedTimeString(LOCAL_TZ));
   }
 
@@ -7178,7 +7178,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     }
   }
 
-  @Test void testLastDayFunc() {
+  @Test void lastDayFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LAST_DAY, VmName.EXPAND);
     f.checkScalar("last_day(DATE '2019-02-10')", "2019-02-28", "DATE NOT NULL");
@@ -7224,7 +7224,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f.checkNull("last_day(cast(null as timestamp))");
   }
 
-  @Test void testLpadFunction() {
+  @Test void lpadFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.LPAD);
     f.check("select lpad('12345', 8, 'a')", "VARCHAR(5) NOT NULL", "aaa12345");
@@ -7251,7 +7251,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
         true);
   }
 
-  @Test void testRpadFunction() {
+  @Test void rpadFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.RPAD);
     f.check("select rpad('12345', 8, 'a')", "VARCHAR(5) NOT NULL", "12345aaa");
@@ -7279,7 +7279,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
         true);
   }
 
-  @Test void testStrposFunction() {
+  @Test void strposFunction() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.STRPOS);
     f0.checkFails(
         "^strpos('abc', 'a')^",
@@ -7305,7 +7305,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f.checkNull("STRPOS(x'', null)");
   }
 
-  @Test void testInstrFunction() {
+  @Test void instrFunction() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.CHR, VM_FENNEL, VM_JAVA);
     f0.checkFails(
         "^INSTR('abc', 'a', 1, 1)^",
@@ -7338,7 +7338,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testStartsWithFunction() {
+  @Test void startsWithFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.STARTS_WITH);
     f.checkBoolean("starts_with('12345', '123')", true);
@@ -7363,7 +7363,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
     f.checkBoolean("starts_with(x'', x'')", true);
   }
 
-  @Test void testEndsWithFunction() {
+  @Test void endsWithFunction() {
     final SqlOperatorFixture f = fixture().withLibrary(SqlLibrary.BIG_QUERY);
     f.setFor(SqlLibraryOperators.ENDS_WITH);
     f.checkBoolean("ends_with('12345', '345')", true);
@@ -7389,7 +7389,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
   }
 
   /** Tests the {@code SPLIT} operator. */
-  @Test void testSplitFunction() {
+  @Test void splitFunction() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.SPLIT);
     f0.checkFails(
         "^split('hello')^", "No match found for function signature SPLIT\\(<CHARACTER>\\)", false);
@@ -7419,7 +7419,7 @@ private void testCurrentDateFunc(Pair<String, Hook.Closeable> pair) {
    * SubFunChecker#assertSubFunReturns}, and are called for both {@code SUBSTRING} and {@code
    * SUBSTR}.
    */
-  @Test void testSubstringFunction() {
+  @Test void substringFunction() {
     final SqlOperatorFixture f = fixture();
     checkSubstringFunction(f);
     checkSubstringFunction(f.withConformance(SqlConformanceEnum.BIG_QUERY));
@@ -7462,7 +7462,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in BigQuery.
    */
-  @Test void testBigQuerySubstrFunction() {
+  @Test void bigQuerySubstrFunction() {
     substrChecker(SqlLibrary.BIG_QUERY, SqlLibraryOperators.SUBSTR_BIG_QUERY).check();
   }
 
@@ -7470,7 +7470,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in Oracle.
    */
-  @Test void testMysqlSubstrFunction() {
+  @Test void mysqlSubstrFunction() {
     substrChecker(SqlLibrary.MYSQL, SqlLibraryOperators.SUBSTR_MYSQL).check();
   }
 
@@ -7478,7 +7478,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in Oracle.
    */
-  @Test void testOracleSubstrFunction() {
+  @Test void oracleSubstrFunction() {
     substrChecker(SqlLibrary.ORACLE, SqlLibraryOperators.SUBSTR_ORACLE).check();
   }
 
@@ -7486,7 +7486,7 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the non-standard SUBSTR function, that has syntax "SUBSTR(value, start [, length ])", as
    * used in PostgreSQL.
    */
-  @Test void testPostgresqlSubstrFunction() {
+  @Test void postgresqlSubstrFunction() {
     substrChecker(SqlLibrary.POSTGRESQL, SqlLibraryOperators.SUBSTR_POSTGRESQL).check();
   }
 
@@ -7494,12 +7494,12 @@ private static void checkSubstringFunction(SqlOperatorFixture f) {
    * Tests the standard {@code SUBSTRING} function in the mode that has BigQuery's non-standard
    * semantics.
    */
-  @Test void testBigQuerySubstringFunction() {
+  @Test void bigQuerySubstringFunction() {
     substringChecker(SqlConformanceEnum.BIG_QUERY, SqlLibrary.BIG_QUERY).check();
   }
 
   /** Tests the standard {@code SUBSTRING} function in ISO standard semantics. */
-  @Test void testStandardSubstringFunction() {
+  @Test void standardSubstringFunction() {
     substringChecker(SqlConformanceEnum.STRICT_2003, SqlLibrary.POSTGRESQL).check();
   }
 
@@ -7698,7 +7698,7 @@ void assertSubFunReturns(
     }
   }
 
-  @Test void testTrimFunc() {
+  @Test void trimFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TRIM, VmName.EXPAND);
 
@@ -7728,7 +7728,7 @@ void assertSubFunReturns(
     f1.checkString("trim('eh' from 'hehe__hehe')", "__", "VARCHAR(10) NOT NULL");
   }
 
-  @Test void testRtrimFunc() {
+  @Test void rtrimFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.RTRIM, VmName.EXPAND);
     f0.checkFails(
         "^rtrim(' aaa')^", "No match found for function signature RTRIM\\(<CHARACTER>\\)", false);
@@ -7740,7 +7740,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testLtrimFunc() {
+  @Test void ltrimFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LTRIM, VmName.EXPAND);
     f0.checkFails(
         "^ltrim('  aa')^", "No match found for function signature LTRIM\\(<CHARACTER>\\)", false);
@@ -7752,7 +7752,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testGreatestFunc() {
+  @Test void greatestFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.GREATEST, VmName.EXPAND);
     f0.checkFails(
         "^greatest('on', 'earth')^",
@@ -7772,7 +7772,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testLeastFunc() {
+  @Test void leastFunc() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.LEAST, VmName.EXPAND);
     f0.checkFails(
         "^least('on', 'earth')^",
@@ -7792,7 +7792,7 @@ void assertSubFunReturns(
     f0.forEachLibrary(list(SqlLibrary.BIG_QUERY, SqlLibrary.ORACLE), consumer);
   }
 
-  @Test void testNvlFunc() {
+  @Test void nvlFunc() {
     final SqlOperatorFixture f =
         fixture().setFor(SqlLibraryOperators.NVL, VmName.EXPAND).withLibrary(SqlLibrary.ORACLE);
     f.checkScalar("nvl(1, 2)", "1", "INTEGER NOT NULL");
@@ -7817,7 +7817,7 @@ void assertSubFunReturns(
    * Tests {@code IFNULL}, which is a synonym for {@code NVL}, and is related to {@code COALESCE}
    * but requires precisely two arguments.
    */
-  @Test void testIfnullFunc() {
+  @Test void ifnullFunc() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.IFNULL, VM_EXPAND);
 
@@ -7841,7 +7841,7 @@ void assertSubFunReturns(
         false);
   }
 
-  @Test void testDecodeFunc() {
+  @Test void decodeFunc() {
     checkDecodeFunc(fixture().withLibrary(SqlLibrary.ORACLE));
   }
 
@@ -7864,7 +7864,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         "CHAR(1) NOT NULL");
   }
 
-  @Test void testWindow() {
+  @Test void window() {
     final SqlOperatorFixture f = fixture();
     f.check(
         "select sum(1) over (order by x)\n"
@@ -7874,14 +7874,14 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         1);
   }
 
-  @Test void testElementFunc() {
+  @Test void elementFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ELEMENT, VM_FENNEL, VM_JAVA);
     f.checkString("element(multiset['abc'])", "abc", "CHAR(3) NOT NULL");
     f.checkNull("element(multiset[cast(null as integer)])");
   }
 
-  @Test void testCardinalityFunc() {
+  @Test void cardinalityFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CARDINALITY, VM_FENNEL, VM_JAVA);
     f.checkScalarExact("cardinality(multiset[cast(null as integer),2])", 2);
@@ -7897,7 +7897,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkScalarExact("cardinality(map['foo', 1, 'bar', 2])", 2);
   }
 
-  @Test void testMemberOfOperator() {
+  @Test void memberOfOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MEMBER_OF, VM_FENNEL, VM_JAVA);
     f.checkBoolean("1 member of multiset[1]", true);
@@ -7907,7 +7907,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkBoolean("1.1 member of multiset[cast(null as double)]", false);
   }
 
-  @Test void testMultisetUnionOperator() {
+  @Test void multisetUnionOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_UNION_DISTINCT, VM_FENNEL, VM_JAVA);
     f.checkBoolean(
@@ -7958,7 +7958,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         "BOOLEAN MULTISET NOT NULL");
   }
 
-  @Test void testMultisetUnionAllOperator() {
+  @Test void multisetUnionAllOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_UNION, VM_FENNEL, VM_JAVA);
     f.checkScalar(
@@ -7999,7 +7999,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
         "BOOLEAN MULTISET NOT NULL");
   }
 
-  @Test void testSubMultisetOfOperator() {
+  @Test void subMultisetOfOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SUBMULTISET_OF, VM_FENNEL, VM_JAVA);
     f.checkBoolean("multiset[2] submultiset of multiset[1]", false);
@@ -8013,7 +8013,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkBoolean("multiset['q', 'a'] submultiset of multiset['a', 'q']", true);
   }
 
-  @Test void testNotSubMultisetOfOperator() {
+  @Test void notSubMultisetOfOperator() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.NOT_SUBMULTISET_OF, VM_FENNEL, VM_JAVA);
     f.checkBoolean("multiset[2] not submultiset of multiset[1]", true);
@@ -8027,7 +8027,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkBoolean("multiset['q', 'a'] not submultiset of " + "multiset['a', 'q']", false);
   }
 
-  @Test void testCollectFunc() {
+  @Test void collectFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COLLECT, VM_FENNEL, VM_JAVA);
     f.checkFails("collect(^*^)", "Unknown identifier '\\*'", false);
@@ -8053,7 +8053,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkAgg("collect(DISTINCT x)", values, isSingle(2));
   }
 
-  @Test void testListAggFunc() {
+  @Test void listAggFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LISTAGG, VM_FENNEL, VM_JAVA);
     f.checkFails("listagg(^*^)", "Unknown identifier '\\*'", false);
@@ -8082,7 +8082,7 @@ private static void checkDecodeFunc(SqlOperatorFixture f) {
     f.checkAgg("listagg(cast(x as CHAR))", values2, isSingle("0,1,2,3"));
   }
 
-  @Test void testStringAggFunc() {
+  @Test void stringAggFunc() {
     final SqlOperatorFixture f = fixture();
     checkStringAggFunc(f.withLibrary(SqlLibrary.POSTGRESQL));
     checkStringAggFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8126,7 +8126,7 @@ private static void checkStringAggFuncFails(SqlOperatorFixture f) {
         false);
   }
 
-  @Test void testGroupConcatFunc() {
+  @Test void groupConcatFunc() {
     final SqlOperatorFixture f = fixture();
     checkGroupConcatFunc(f.withLibrary(SqlLibrary.MYSQL));
     checkGroupConcatFuncFails(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8171,7 +8171,7 @@ private static void checkGroupConcatFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testArrayAggFunc() {
+  @Test void arrayAggFunc() {
     final SqlOperatorFixture f = fixture();
     checkArrayAggFunc(f.withLibrary(SqlLibrary.POSTGRESQL));
     checkArrayAggFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8203,7 +8203,7 @@ private static void checkArrayAggFuncFails(SqlOperatorFixture t) {
     t.checkAggFails("^array_agg(x, ',' order by x desc)^", values, expectedError2, false);
   }
 
-  @Test void testArrayConcatAggFunc() {
+  @Test void arrayConcatAggFunc() {
     final SqlOperatorFixture f = fixture();
     checkArrayConcatAggFunc(f.withLibrary(SqlLibrary.POSTGRESQL));
     checkArrayConcatAggFunc(f.withLibrary(SqlLibrary.BIG_QUERY));
@@ -8246,7 +8246,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     t.checkAggFails("^array_concat_agg(x, ',' order by x desc)^", values, expectedError2, false);
   }
 
-  @Test void testFusionFunc() {
+  @Test void fusionFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.FUSION, VM_FENNEL, VM_JAVA);
     f.checkFails("fusion(^*^)", "Unknown identifier '\\*'", false);
@@ -8259,7 +8259,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkAgg("fusion(x)", values2, isSingle("[0, 1, 1, 2]"));
   }
 
-  @Test void testIntersectionFunc() {
+  @Test void intersectionFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.INTERSECTION, VM_FENNEL, VM_JAVA);
     f.checkFails("intersection(^*^)", "Unknown identifier '\\*'", false);
@@ -8275,7 +8275,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkAgg("intersection(x)", values3, isSingle("[0, 1, 1]"));
   }
 
-  @Test void testModeFunc() {
+  @Test void modeFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MODE, VM_EXPAND);
     f.checkFails("mode(^*^)", "Unknown identifier '\\*'", false);
@@ -8308,7 +8308,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkAgg("mode(DISTINCT x)", values, isSingle(0));
   }
 
-  @Test void testYear() {
+  @Test void year() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.YEAR, VM_FENNEL, VM_JAVA);
 
@@ -8316,7 +8316,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("year(cast(null as date))");
   }
 
-  @Test void testQuarter() {
+  @Test void quarter() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.QUARTER, VM_FENNEL, VM_JAVA);
 
@@ -8335,7 +8335,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("quarter(cast(null as date))");
   }
 
-  @Test void testMonth() {
+  @Test void month() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MONTH, VM_FENNEL, VM_JAVA);
 
@@ -8343,35 +8343,35 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("month(cast(null as date))");
   }
 
-  @Test void testWeek() {
+  @Test void week() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.WEEK, VM_FENNEL, VM_JAVA);
     f.checkScalar("week(date '2008-1-23')", "4", "BIGINT NOT NULL");
     f.checkNull("week(cast(null as date))");
   }
 
-  @Test void testDayOfYear() {
+  @Test void dayOfYear() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DAYOFYEAR, VM_FENNEL, VM_JAVA);
     f.checkScalar("dayofyear(date '2008-01-23')", "23", "BIGINT NOT NULL");
     f.checkNull("dayofyear(cast(null as date))");
   }
 
-  @Test void testDayOfMonth() {
+  @Test void dayOfMonth() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DAYOFMONTH, VM_FENNEL, VM_JAVA);
     f.checkScalar("dayofmonth(date '2008-1-23')", "23", "BIGINT NOT NULL");
     f.checkNull("dayofmonth(cast(null as date))");
   }
 
-  @Test void testDayOfWeek() {
+  @Test void dayOfWeek() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DAYOFWEEK, VM_FENNEL, VM_JAVA);
     f.checkScalar("dayofweek(date '2008-1-23')", "4", "BIGINT NOT NULL");
     f.checkNull("dayofweek(cast(null as date))");
   }
 
-  @Test void testHour() {
+  @Test void hour() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.HOUR, VM_FENNEL, VM_JAVA);
 
@@ -8379,7 +8379,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("hour(cast(null as timestamp))");
   }
 
-  @Test void testMinute() {
+  @Test void minute() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MINUTE, VM_FENNEL, VM_JAVA);
 
@@ -8387,7 +8387,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("minute(cast(null as timestamp))");
   }
 
-  @Test void testSecond() {
+  @Test void second() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SECOND, VM_FENNEL, VM_JAVA);
 
@@ -8395,7 +8395,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("second(cast(null as timestamp))");
   }
 
-  @Test void testExtractIntervalYearMonth() {
+  @Test void extractIntervalYearMonth() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8465,7 +8465,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "extract(millennium from " + "interval '2005-3' year(4) to month)", "2", "BIGINT NOT NULL");
   }
 
-  @Test void testExtractIntervalDayTime() {
+  @Test void extractIntervalDayTime() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8560,7 +8560,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testExtractDate() {
+  @Test void extractDate() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8610,7 +8610,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkScalar("extract(millennium from date '2001-01-01')", "3", "BIGINT NOT NULL");
   }
 
-  @Test void testExtractTimestamp() {
+  @Test void extractTimestamp() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8652,7 +8652,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "extract(millennium from timestamp '2000-2-23 12:34:56')", "2", "BIGINT NOT NULL");
   }
 
-  @Test void testExtractInterval() {
+  @Test void extractInterval() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
 
@@ -8694,7 +8694,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("extract(month from cast(null as interval year))");
   }
 
-  @Test void testExtractFuncFromDateTime() {
+  @Test void extractFuncFromDateTime() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EXTRACT, VM_FENNEL, VM_JAVA);
     f.checkScalar("extract(year from date '2008-2-23')", "2008", "BIGINT NOT NULL");
@@ -8711,7 +8711,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("extract(nanosecond from cast(null as time))");
   }
 
-  @Test void testExtractWithDatesBeforeUnixEpoch() {
+  @Test void extractWithDatesBeforeUnixEpoch() {
     final SqlOperatorFixture f = fixture();
     f.checkScalar(
         "extract(millisecond from" + " TIMESTAMP '1969-12-31 21:13:17.357')",
@@ -8747,7 +8747,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "BIGINT NOT NULL");
   }
 
-  @Test void testArrayValueConstructor() {
+  @Test void arrayValueConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ARRAY_VALUE_CONSTRUCTOR, VmName.EXPAND);
     f.checkScalar("Array['foo']", "[foo]", "CHAR(3) NOT NULL ARRAY NOT NULL");
@@ -8761,7 +8761,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
   }
 
   /** Test case for {@link SqlLibraryOperators#ARRAY} (Spark). */
-  @Test void testArrayFunction() {
+  @Test void arrayFunction() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlLibraryOperators.ARRAY, VmName.EXPAND);
     f.checkFails("^array()^", "No match found for function signature ARRAY\\(\\)", false);
@@ -8781,7 +8781,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * ARRAY, MULTISET functions should return an collection of scalars if a sub-query returns 1
    * column</a>.
    */
-  @Test void testArrayQueryConstructor() {
+  @Test void arrayQueryConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ARRAY_QUERY, SqlOperatorFixture.VmName.EXPAND);
     f.checkScalar("array(select 1)", "[1]", "INTEGER NOT NULL ARRAY NOT NULL");
@@ -8796,7 +8796,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * ARRAY, MULTISET functions should return an collection of scalars if a sub-query returns 1
    * column</a>.
    */
-  @Test void testMultisetQueryConstructor() {
+  @Test void multisetQueryConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MULTISET_QUERY, SqlOperatorFixture.VmName.EXPAND);
     f.checkScalar("multiset(select 1)", "[1]", "INTEGER NOT NULL MULTISET NOT NULL");
@@ -8806,7 +8806,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "[{1, 2}]");
   }
 
-  @Test void testItemOp() {
+  @Test void itemOp() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ITEM, VmName.EXPAND);
     f.checkScalar("ARRAY ['foo', 'bar'][1]", "foo", "CHAR(3)");
@@ -8858,7 +8858,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testOffsetOperator() {
+  @Test void offsetOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.OFFSET);
     f0.checkFails(
@@ -8878,7 +8878,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testOrdinalOperator() {
+  @Test void ordinalOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.ORDINAL);
     f0.checkFails(
@@ -8898,7 +8898,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testSafeOffsetOperator() {
+  @Test void safeOffsetOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.SAFE_OFFSET);
     f0.checkFails(
@@ -8920,7 +8920,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testSafeOrdinalOperator() {
+  @Test void safeOrdinalOperator() {
     final SqlOperatorFixture f0 = fixture();
     f0.setFor(SqlLibraryOperators.SAFE_ORDINAL);
     f0.checkFails(
@@ -8942,7 +8942,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         false);
   }
 
-  @Test void testMapValueConstructor() {
+  @Test void mapValueConstructor() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MAP_VALUE_CONSTRUCTOR, VM_JAVA);
 
@@ -8961,7 +8961,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
         "(VARCHAR(10) NOT NULL, INTEGER NOT NULL) MAP NOT NULL");
   }
 
-  @Test void testCeilFunc() {
+  @Test void ceilFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CEIL, VM_FENNEL);
     f.checkScalarApprox("ceil(10.1e0)", "DOUBLE NOT NULL", isExactly(11));
@@ -8973,7 +8973,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("ceiling(cast(null as double))");
   }
 
-  @Test void testCeilFuncInterval() {
+  @Test void ceilFuncInterval() {
     final SqlOperatorFixture f = fixture();
     if (!f.brokenTestsEnabled()) {
       return;
@@ -8989,7 +8989,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("ceil(cast(null as interval year))");
   }
 
-  @Test void testFloorFunc() {
+  @Test void floorFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.FLOOR, VM_FENNEL);
     f.checkScalarApprox("floor(2.5e0)", "DOUBLE NOT NULL", isExactly(2));
@@ -9001,7 +9001,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as real))");
   }
 
-  @Test void testBigQueryCeilFunc() {
+  @Test void bigQueryCeilFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.checkType("ceil(cast(3 as tinyint))", "TINYINT NOT NULL");
     final SqlOperatorFixture f =
@@ -9018,7 +9018,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("ceil(cast(null as tinyint))");
   }
 
-  @Test void testBigQueryFloorFunc() {
+  @Test void bigQueryFloorFunc() {
     final SqlOperatorFixture f0 = fixture();
     f0.checkType("floor(cast(3 as tinyint))", "TINYINT NOT NULL");
     final SqlOperatorFixture f =
@@ -9035,7 +9035,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as tinyint))");
   }
 
-  @Test void testFloorFuncDateTime() {
+  @Test void floorFuncDateTime() {
     final SqlOperatorFixture f = fixture();
     f.enableTypeCoercion(false)
         .checkFails(
@@ -9087,7 +9087,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as date) to month)");
   }
 
-  @Test void testCeilFuncDateTime() {
+  @Test void ceilFuncDateTime() {
     final SqlOperatorFixture f = fixture();
     f.enableTypeCoercion(false)
         .checkFails(
@@ -9156,7 +9156,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * Tests {@code FLOOR}, {@code CEIL}, {@code TIMESTAMPADD}, {@code TIMESTAMPDIFF} functions with
    * custom time frames.
    */
-  @Test void testCustomTimeFrame() {
+  @Test void customTimeFrame() {
     final SqlOperatorFixture f =
         fixture()
             .withFactory(
@@ -9254,7 +9254,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
             "INTEGER NOT NULL");
   }
 
-  @Test void testFloorFuncInterval() {
+  @Test void floorFuncInterval() {
     final SqlOperatorFixture f = fixture();
     if (!f.brokenTestsEnabled()) {
       return;
@@ -9297,7 +9297,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
     f.checkNull("floor(cast(null as interval year))");
   }
 
-  @Test void testTimestampAdd() {
+  @Test void timestampAdd() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TIMESTAMP_ADD, VmName.EXPAND);
     MICROSECOND_VARIANTS.forEach(
@@ -9485,7 +9485,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
                 "timestampadd(" + s + ", -1, time '23:59:59')", "23:59:59", "TIME(0) NOT NULL"));
   }
 
-  @Test void testTimestampAddFractionalSeconds() {
+  @Test void timestampAddFractionalSeconds() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.TIMESTAMP_ADD, VmName.EXPAND);
     f.checkType(
@@ -9520,7 +9520,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * Tests {@code TIMESTAMP_ADD}, BigQuery's 2-argument variant of the 3-argument {@code
    * TIMESTAMPADD} function.
    */
-  @Test void testTimestampAdd2() {
+  @Test void timestampAdd2() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIMESTAMP_ADD2);
     f0.checkFails(
         "^timestamp_add(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -9574,7 +9574,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * TIMESTAMP} values rather than the {@code DATETIME} alias because the operator fixture does not
    * currently support type aliases.
    */
-  @Test void testDatetimeAdd() {
+  @Test void datetimeAdd() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATETIME_ADD);
     f0.checkFails(
         "^datetime_add(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -9627,7 +9627,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * timestamps. In {@code TIMESTAMPDIFF} it is (t2 - t1) while for {@code TIMESTAMP_DIFF} is is (t1
    * - t2).
    */
-  @Test void testTimestampDiff3() {
+  @Test void timestampDiff3() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIMESTAMP_DIFF3);
     f0.checkFails(
         "^timestamp_diff(timestamp '2008-12-25 15:30:00', "
@@ -9794,7 +9794,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
    * below use {@code TIMESTAMP} values rather than the {@code DATETIME} alias because the operator
    * fixture does not currently support type aliases.
    */
-  @Test void testDatetimeDiff() {
+  @Test void datetimeDiff() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATETIME_DIFF);
     f0.checkFails(
         "^datetime_diff(timestamp '2008-12-25 15:30:00', "
@@ -9956,7 +9956,7 @@ private static void checkArrayConcatAggFuncFails(SqlOperatorFixture t) {
 
   @ValueSource(booleans = {true, false})
   @ParameterizedTest(name = "CoercionEnabled: {0}")
-  void testTimestampDiff(boolean coercionEnabled) {
+  void timestampDiff(boolean coercionEnabled) {
     final SqlOperatorFixture f =
         fixture().withValidatorConfig(c -> c.withTypeCoercionEnabled(coercionEnabled));
     f.setFor(SqlStdOperatorTable.TIMESTAMP_DIFF, VmName.EXPAND);
@@ -10163,7 +10163,7 @@ void testTimestampDiff(boolean coercionEnabled) {
                 "INTEGER"));
   }
 
-  @Test void testTimestampSub() {
+  @Test void timestampSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIMESTAMP_SUB);
     f0.checkFails(
         "^timestamp_sub(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -10226,7 +10226,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("timestamp_sub(CAST(NULL AS TIMESTAMP), interval 5 minute)");
   }
 
-  @Test void testTimeSub() {
+  @Test void timeSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIME_SUB);
     f0.checkFails(
         "^time_sub(time '15:30:00', " + "interval 5 minute)^",
@@ -10253,7 +10253,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("time_sub(CAST(NULL AS TIME), interval 5 minute)");
   }
 
-  @Test void testDateSub() {
+  @Test void dateSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATE_SUB);
     f0.checkFails(
         "^date_sub(date '2008-12-25', " + "interval 5 day)^",
@@ -10278,7 +10278,7 @@ void testTimestampDiff(boolean coercionEnabled) {
    * support type aliases, TIMESTAMPs are used in place of DATETIMEs (a Calcite alias of TIMESTAMP)
    * for the function's first argument.
    */
-  @Test void testDatetimeSub() {
+  @Test void datetimeSub() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.DATETIME_SUB);
     f0.checkFails(
         "^datetime_sub(timestamp '2008-12-25 15:30:00', " + "interval 5 minute)^",
@@ -10329,7 +10329,7 @@ void testTimestampDiff(boolean coercionEnabled) {
    * The {@code DATEDIFF} function is implemented in the Babel parser but not the Core parser, and
    * therefore gives validation errors.
    */
-  @Test void testDateDiff() {
+  @Test void dateDiff() {
     final SqlOperatorFixture f = fixture().setFor(SqlLibraryOperators.DATEDIFF);
     f.checkFails(
         "datediff(^\"MONTH\"^, '2019-09-14',  '2019-09-15')",
@@ -10338,7 +10338,7 @@ void testTimestampDiff(boolean coercionEnabled) {
   }
 
   /** Tests BigQuery's {@code TIME_ADD}, which adds an interval to a time expression. */
-  @Test void testTimeAdd() {
+  @Test void timeAdd() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIME_ADD);
     f0.checkFails(
         "^time_add(time '15:30:00', interval 5 minute)^",
@@ -10367,7 +10367,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("time_add(cast(null as time), interval 5 minute)");
   }
 
-  @Test void testTimeDiff() {
+  @Test void timeDiff() {
     final SqlOperatorFixture f0 = fixture().setFor(SqlLibraryOperators.TIME_DIFF);
     f0.checkFails(
         "^time_diff(time '15:30:00', " + "time '16:30:00', " + "minute)^",
@@ -10412,7 +10412,7 @@ void testTimestampDiff(boolean coercionEnabled) {
                 "INTEGER"));
   }
 
-  @Test void testTimeTrunc() {
+  @Test void timeTrunc() {
     SqlOperatorFixture nonBigQuery = fixture().setFor(SqlLibraryOperators.TIME_TRUNC);
     nonBigQuery.checkFails(
         "^time_trunc(time '15:30:00', hour)^",
@@ -10434,7 +10434,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkNull("time_trunc(cast(null as time), second)");
   }
 
-  @Test void testTimestampTrunc() {
+  @Test void timestampTrunc() {
     SqlOperatorFixture nonBigQuery = fixture().setFor(SqlLibraryOperators.TIMESTAMP_TRUNC);
     nonBigQuery.checkFails(
         "^timestamp_trunc(timestamp '2012-05-02 15:30:00', hour)^",
@@ -10526,7 +10526,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testDatetimeTrunc() {
+  @Test void datetimeTrunc() {
     SqlOperatorFixture nonBigQuery = fixture().setFor(SqlLibraryOperators.DATETIME_TRUNC);
     nonBigQuery.checkFails(
         "^datetime_trunc(timestamp '2012-05-02 15:30:00', hour)^",
@@ -10604,7 +10604,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testDateTrunc() {
+  @Test void dateTrunc() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.DATE_TRUNC);
     f.checkFails(
@@ -10643,7 +10643,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkScalar("date_trunc(date '2015-02-19', millennium)", "2001-01-01", "DATE NOT NULL");
   }
 
-  @Test void testFormatTime() {
+  @Test void formatTime() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.FORMAT_TIME);
     f.checkFails(
@@ -10660,7 +10660,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "The time is 34-33", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testFormatDate() {
+  @Test void formatDate() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.FORMAT_DATE);
     f.checkFails(
@@ -10682,7 +10682,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "The date is: 12/25/08", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testFormatTimestamp() {
+  @Test void formatTimestamp() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.FORMAT_TIMESTAMP);
     f.checkFails(
@@ -10717,7 +10717,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "The time is: 15:30.123", "VARCHAR(2000) NOT NULL");
   }
 
-  @Test void testParseDate() {
+  @Test void parseDate() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_DATE);
     f.checkScalar(
@@ -10729,7 +10729,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkScalar("PARSE_DATE('%F', '2022-06-01')", "2022-06-01", "DATE NOT NULL");
   }
 
-  @Test void testParseDatetime() {
+  @Test void parseDatetime() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_DATETIME);
     f.checkScalar(
@@ -10749,7 +10749,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         "2018-12-19 00:00:00", "TIMESTAMP(0) NOT NULL");
   }
 
-  @Test void testParseTime() {
+  @Test void parseTime() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_TIME);
     f.checkScalar("PARSE_TIME('%I:%M:%S', '07:30:00')", "07:30:00", "TIME(0) NOT NULL");
@@ -10758,7 +10758,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkScalar("PARSE_TIME('%I:%M:%S %p', '2:23:38 pm')", "14:23:38", "TIME(0) NOT NULL");
   }
 
-  @Test void testParseTimestamp() {
+  @Test void parseTimestamp() {
     final SqlOperatorFixture f =
         fixture().withLibrary(SqlLibrary.BIG_QUERY).setFor(SqlLibraryOperators.PARSE_TIMESTAMP);
     f.checkScalar(
@@ -10772,32 +10772,32 @@ void testTimestampDiff(boolean coercionEnabled) {
         "2008-12-25 07:30:00", "TIMESTAMP_WITH_LOCAL_TIME_ZONE(0) NOT NULL");
   }
 
-  @Test void testDenseRankFunc() {
+  @Test void denseRankFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.DENSE_RANK, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testPercentRankFunc() {
+  @Test void percentRankFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENT_RANK, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testRankFunc() {
+  @Test void rankFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.RANK, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testCumeDistFunc() {
+  @Test void cumeDistFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CUME_DIST, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testRowNumberFunc() {
+  @Test void rowNumberFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ROW_NUMBER, VM_FENNEL, VM_JAVA);
   }
 
-  @Test void testPercentileContFunc() {
+  @Test void percentileContFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENTILE_CONT, VM_FENNEL, VM_JAVA);
     f.checkType("percentile_cont(0.25) within group (order by 1)", "INTEGER NOT NULL");
@@ -10820,7 +10820,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testPercentileDiscFunc() {
+  @Test void percentileDiscFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.PERCENTILE_DISC, VM_FENNEL, VM_JAVA);
     f.checkType("percentile_disc(0.25) within group (order by 1)", "INTEGER NOT NULL");
@@ -10843,7 +10843,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testPercentileContBigQueryFunc() {
+  @Test void percentileContBigQueryFunc() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.PERCENTILE_CONT2, SqlOperatorFixture.VmName.EXPAND)
@@ -10858,7 +10858,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testPercentileDiscBigQueryFunc() {
+  @Test void percentileDiscBigQueryFunc() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.PERCENTILE_DISC2, SqlOperatorFixture.VmName.EXPAND)
@@ -10873,7 +10873,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         false);
   }
 
-  @Test void testCountFunc() {
+  @Test void countFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COUNT, VM_EXPAND);
     f.checkType("count(*)", "BIGINT NOT NULL");
@@ -10900,7 +10900,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("COUNT(DISTINCT 123)", stringValues, isSingle(1));
   }
 
-  @Test void testCountifFunc() {
+  @Test void countifFunc() {
     final SqlOperatorFixture f =
         fixture()
             .setFor(SqlLibraryOperators.COUNTIF, VM_FENNEL, VM_JAVA)
@@ -10928,7 +10928,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("countif(x < 0)", values, isSingle(0));
   }
 
-  @Test void testApproxCountDistinctFunc() {
+  @Test void approxCountDistinctFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COUNT, VM_EXPAND);
     f.checkFails("approx_count_distinct(^*^)", "Unknown identifier '\\*'", false);
@@ -10957,7 +10957,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("APPROX_COUNT_DISTINCT(DISTINCT 123)", stringValues, isSingle(1));
   }
 
-  @Test void testSumFunc() {
+  @Test void sumFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SUM, VM_EXPAND);
     f.checkFails("sum(^*^)", "Unknown identifier '\\*'", false);
@@ -10998,7 +10998,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("sum(DISTINCT x)", values, isSingle(2));
   }
 
-  @Test void testAvgFunc() {
+  @Test void avgFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.AVG, VM_EXPAND);
     f.checkFails("avg(^*^)", "Unknown identifier '\\*'", false);
@@ -11024,7 +11024,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("avg(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)", values, isSingle(-1));
   }
 
-  @Test void testCovarPopFunc() {
+  @Test void covarPopFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COVAR_POP, VM_EXPAND);
     f.checkFails("covar_pop(^*^)", "Unknown identifier '\\*'", false);
@@ -11046,7 +11046,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("covar_pop(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testCovarSampFunc() {
+  @Test void covarSampFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.COVAR_SAMP, VM_EXPAND);
     f.checkFails("covar_samp(^*^)", "Unknown identifier '\\*'", false);
@@ -11068,7 +11068,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("covar_samp(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testRegrSxxFunc() {
+  @Test void regrSxxFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.REGR_SXX, VM_EXPAND);
     f.checkFails("regr_sxx(^*^)", "Unknown identifier '\\*'", false);
@@ -11090,7 +11090,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("regr_sxx(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testRegrSyyFunc() {
+  @Test void regrSyyFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.REGR_SYY, VM_EXPAND);
     f.checkFails("regr_syy(^*^)", "Unknown identifier '\\*'", false);
@@ -11112,7 +11112,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("regr_syy(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testStddevPopFunc() {
+  @Test void stddevPopFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.STDDEV_POP, VM_EXPAND);
     f.checkFails("stddev_pop(^*^)", "Unknown identifier '\\*'", false);
@@ -11140,7 +11140,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("stddev_pop(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testStddevSampFunc() {
+  @Test void stddevSampFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.STDDEV_SAMP, VM_EXPAND);
     f.checkFails("stddev_samp(^*^)", "Unknown identifier '\\*'", false);
@@ -11170,7 +11170,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("stddev_samp(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testStddevFunc() {
+  @Test void stddevFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.STDDEV, VM_EXPAND);
     f.checkFails("stddev(^*^)", "Unknown identifier '\\*'", false);
@@ -11190,7 +11190,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("stddev(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testVarPopFunc() {
+  @Test void varPopFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VAR_POP, VM_EXPAND);
     f.checkFails("var_pop(^*^)", "Unknown identifier '\\*'", false);
@@ -11220,7 +11220,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("var_pop(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testVarSampFunc() {
+  @Test void varSampFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VAR_SAMP, VM_EXPAND);
     f.checkFails("var_samp(^*^)", "Unknown identifier '\\*'", false);
@@ -11250,7 +11250,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("var_samp(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testVarFunc() {
+  @Test void varFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.VARIANCE, VM_EXPAND);
     f.checkFails("variance(^*^)", "Unknown identifier '\\*'", false);
@@ -11280,7 +11280,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("variance(x)", new String[] {}, isNullValue());
   }
 
-  @Test void testMinFunc() {
+  @Test void minFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MIN, VM_EXPAND);
     f.checkFails("min(^*^)", "Unknown identifier '\\*'", false);
@@ -11305,7 +11305,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("min(DISTINCT x)", values, isSingle("0"));
   }
 
-  @Test void testMaxFunc() {
+  @Test void maxFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.MAX, VM_EXPAND);
     f.checkFails("max(^*^)", "Unknown identifier '\\*'", false);
@@ -11330,7 +11330,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("max(DISTINCT x)", values, isSingle("2"));
   }
 
-  @Test void testLastValueFunc() {
+  @Test void lastValueFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.LAST_VALUE, VM_EXPAND);
     final String[] values = {"0", "CAST(null AS INTEGER)", "3", "3"};
@@ -11354,7 +11354,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         isSet("foo ", "bar ", "name"));
   }
 
-  @Test void testFirstValueFunc() {
+  @Test void firstValueFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.FIRST_VALUE, VM_EXPAND);
     final String[] values = {"0", "CAST(null AS INTEGER)", "3", "3"};
@@ -11369,7 +11369,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkWinAgg("first_value(x)", values3, "ROWS 3 PRECEDING", "CHAR(4) NOT NULL", isSet("foo "));
   }
 
-  @Test void testEveryFunc() {
+  @Test void everyFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.EVERY, VM_EXPAND);
     f.checkFails("every(^*^)", "Unknown identifier '\\*'", false);
@@ -11388,7 +11388,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("every(x = 2)", values, isSingle("false"));
   }
 
-  @Test void testSomeAggFunc() {
+  @Test void someAggFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.SOME, VM_EXPAND);
     f.checkFails("some(^*^)", "Unknown identifier '\\*'", false);
@@ -11411,7 +11411,7 @@ void testTimestampDiff(boolean coercionEnabled) {
    * Test case for <a href="https://issues.apache.org/jira/browse/CALCITE-5160">[CALCITE-5160]
    * ANY/SOME, ALL operators should support collection expressions</a>.
    */
-  @Test void testQuantifyCollectionOperators() {
+  @Test void quantifyCollectionOperators() {
     final SqlOperatorFixture f = fixture();
     QUANTIFY_OPERATORS.forEach(operator -> f.setFor(operator, SqlOperatorFixture.VmName.EXPAND));
 
@@ -11503,7 +11503,7 @@ void testTimestampDiff(boolean coercionEnabled) {
         true);
   }
 
-  @Test void testAnyValueFunc() {
+  @Test void anyValueFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.ANY_VALUE, VM_EXPAND);
     f.checkFails("any_value(^*^)", "Unknown identifier '\\*'", false);
@@ -11528,7 +11528,7 @@ void testTimestampDiff(boolean coercionEnabled) {
     f.checkAgg("any_value(DISTINCT x)", values, isSingle("0"));
   }
 
-  @Test void testBoolAndFunc() {
+  @Test void boolAndFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11570,7 +11570,7 @@ private static void checkBoolAndFunc(SqlOperatorFixture f) {
     f.checkAgg("bool_and(x)", values4, isNullValue());
   }
 
-  @Test void testBoolOrFunc() {
+  @Test void boolOrFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11612,7 +11612,7 @@ private static void checkBoolOrFunc(SqlOperatorFixture f) {
     f.checkAgg("bool_or(x)", values4, isNullValue());
   }
 
-  @Test void testLogicalAndFunc() {
+  @Test void logicalAndFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11654,7 +11654,7 @@ private static void checkLogicalAndFunc(SqlOperatorFixture f) {
     f.checkAgg("logical_and(x)", values4, isNullValue());
   }
 
-  @Test void testLogicalOrFunc() {
+  @Test void logicalOrFunc() {
     final SqlOperatorFixture f = fixture();
     // not in standard dialect
     final String[] values = {"true", "true", "null"};
@@ -11696,7 +11696,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
     f.checkAgg("logical_or(x)", values4, isNullValue());
   }
 
-  @Test void testBitAndFunc() {
+  @Test void bitAndFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BIT_AND, VM_FENNEL, VM_JAVA);
     f.checkFails("bit_and(^*^)", "Unknown identifier '\\*'", false);
@@ -11740,7 +11740,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
         true);
   }
 
-  @Test void testBitOrFunc() {
+  @Test void bitOrFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BIT_OR, VM_FENNEL, VM_JAVA);
     f.checkFails("bit_or(^*^)", "Unknown identifier '\\*'", false);
@@ -11776,7 +11776,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
     f.checkAgg("bit_or(x)", new String[] {"CAST(x'02' AS BINARY)"}, isSingle("02"));
   }
 
-  @Test void testBitXorFunc() {
+  @Test void bitXorFunc() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.BIT_XOR, VM_FENNEL, VM_JAVA);
     f.checkFails("bit_xor(^*^)", "Unknown identifier '\\*'", false);
@@ -11816,7 +11816,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
         isSingle("02"));
   }
 
-  @Test void testArgMin() {
+  @Test void argMin() {
     final SqlOperatorFixture f0 = fixture().withTester(t -> TESTER);
     final String[] xValues = {"2", "3", "4", "4", "5", "7"};
 
@@ -11846,7 +11846,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
    *   <li>CAST(123.4567891234567 AS FLOAT) fails because the value loses precision.
    * </ul>
    */
-  @Test void testLiteralAtLimit() {
+  @Test void literalAtLimit() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     if (!f.brokenTestsEnabled()) {
@@ -11885,7 +11885,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
    *   <li>CAST(123.4567891234567 AS FLOAT) fails because the value loses precision.
    * </ul>
    */
-  @Test void testLiteralBeyondLimit() {
+  @Test void literalBeyondLimit() {
     final SqlOperatorFixture f = fixture();
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     final List<RelDataType> types = SqlTests.getTypes(f.getFactory().getTypeFactory());
@@ -11927,7 +11927,7 @@ private static void checkLogicalOrFunc(SqlOperatorFixture f) {
 
   @ParameterizedTest
   @MethodSource("safeParameters")
-  void testCastTruncates(CastType castType, SqlOperatorFixture f) {
+  void castTruncates(CastType castType, SqlOperatorFixture f) {
     f.setFor(SqlStdOperatorTable.CAST, VmName.EXPAND);
     f.checkScalar("CAST('ABCD' AS CHAR(2))", "AB", "CHAR(2) NOT NULL");
     f.checkScalar("CAST('ABCD' AS VARCHAR(2))", "AB", "VARCHAR(2) NOT NULL");
@@ -11960,7 +11960,7 @@ void testCastTruncates(CastType castType, SqlOperatorFixture f) {
    */
   @Disabled("Too slow and not really a unit test")
   @Tag("slow")
-  @Test void testArgumentBounds() {
+  @Test void argumentBounds() {
     final SqlOperatorFixture f = fixture();
     final SqlValidatorImpl validator = (SqlValidatorImpl) f.getFactory().createValidator();
     final SqlValidatorScope scope = validator.getEmptyScope();
@@ -12051,7 +12051,7 @@ void testCastTruncates(CastType castType, SqlOperatorFixture f) {
             // difficult to read since it either contains too much information
             // or very few details.
             Throwable cause = findMostDescriptiveCause(e);
-            LOGGER.info("Failed: " + s + ": " + cause);
+            LOGGER.info("Failed: {}: {}", s, cause);
           }
         }
       }
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java b/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java
index b7f739eb7..06f7c40f4 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/CompoundNameColumnResolver.java
@@ -28,11 +28,12 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import static java.util.Map.Entry.comparingByValue;
+
 /**
  * ColumnResolver implementation that resolves CompoundNameColumn by simulating Phoenix behaviors.
  */
@@ -101,7 +102,7 @@ final class CompoundNameColumnResolver implements MockCatalogReader.ColumnResolv
       Map<String, Integer> subMap = groupMap.get(columnName);
       if (subMap != null) {
         PairList<String, Integer> entries = PairList.of(subMap);
-        entries.sort(Comparator.comparingInt(Map.Entry::getValue));
+        entries.sort(comparingByValue());
         ret.add(
             new Pair<>(
                 new RelDataTypeFieldImpl(
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java b/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java
index 877651971..5b8130921 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/CountingFactory.java
@@ -27,8 +27,6 @@
 import org.apache.calcite.sql2rel.InitializerExpressionFactory;
 import org.apache.calcite.sql2rel.NullInitializerExpressionFactory;
 
-import com.google.common.collect.ImmutableList;
-
 import java.math.BigDecimal;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -45,7 +43,7 @@ public class CountingFactory extends NullInitializerExpressionFactory {
   private final List<String> defaultColumns;
 
   CountingFactory(List<String> defaultColumns) {
-    this.defaultColumns = ImmutableList.copyOf(defaultColumns);
+    this.defaultColumns = defaultColumns;
   }
 
   @Override public ColumnStrategy generationStrategy(RelOptTable table, int iColumn) {
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java b/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java
index 310f520e7..56e952508 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/EmpInitializerExpressionFactory.java
@@ -46,12 +46,12 @@ class EmpInitializerExpressionFactory extends NullInitializerExpressionFactory {
     switch (iColumn) {
       case 0:
         return rexBuilder.makeExactLiteral(
-            new BigDecimal(123), typeFactory.createSqlType(SqlTypeName.INTEGER));
+            BigDecimal.valueOf(123), typeFactory.createSqlType(SqlTypeName.INTEGER));
       case 1:
         return rexBuilder.makeLiteral("Bob");
       case 5:
         return rexBuilder.makeExactLiteral(
-            new BigDecimal(555), typeFactory.createSqlType(SqlTypeName.INTEGER));
+            BigDecimal.valueOf(555), typeFactory.createSqlType(SqlTypeName.INTEGER));
       default:
         return super.newColumnDefaultValue(table, iColumn, context);
     }
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java
index 6dc407d80..f3dbdb194 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReader.java
@@ -376,7 +376,7 @@ private MockTable(
       this.names = names;
       this.resolver = resolver;
       this.initializerFactory = initializerFactory;
-      this.wraps = ImmutableList.copyOf(wraps);
+      this.wraps = wraps;
       this.maxRowCount = maxRowCount;
     }
 
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java
index 73e95e57a..e046369b9 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderDynamic.java
@@ -23,10 +23,11 @@
 import org.apache.calcite.schema.impl.ViewTable;
 import org.apache.calcite.sql.type.SqlTypeName;
 
+import com.google.common.collect.ImmutableList;
+
 import org.checkerframework.checker.nullness.qual.NonNull;
 
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import java.util.function.Supplier;
 
@@ -87,9 +88,9 @@ protected MockCatalogReaderDynamic(RelDataTypeFactory typeFactory, boolean caseS
             rootSchema,
             "select n_name from SALES.CUSTOMER",
             custModifiableViewNames.subList(0, 2),
-            Collections.singletonList(custModifiableViewNames.get(2)),
+            ImmutableList.of(custModifiableViewNames.get(2)),
             true);
-    TranslatableTable empModifiableView = custModifiableViewMacro.apply(Collections.emptyList());
+    TranslatableTable empModifiableView = custModifiableViewMacro.apply(ImmutableList.of());
     MockTable mockCustViewTable =
         MockRelViewTable.create(
             (ViewTable) empModifiableView,
diff --git a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java
index 7cbd92548..a602dff9a 100644
--- a/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java
+++ b/testkit/src/main/java/org/apache/calcite/test/catalog/MockCatalogReaderSimple.java
@@ -454,7 +454,7 @@ private void registerStructTypeTables(Fixture fixture) {
             return rexBuilder.makeCall(
                 SqlStdOperatorTable.EQUALS,
                 rexBuilder.makeInputRef(c0Field.getType(), c0Field.getIndex()),
-                rexBuilder.makeExactLiteral(BigDecimal.valueOf(10L), c0Field.getType()));
+                rexBuilder.makeExactLiteral(BigDecimal.TEN, c0Field.getType()));
           }
         };
     structTypeSchema.addTable(Util.last(struct10View.getQualifiedName()));
diff --git a/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java b/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java
index 2b9fda790..0da60fc86 100644
--- a/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java
+++ b/testkit/src/main/java/org/apache/calcite/test/schemata/bookstore/BookstoreSchema.java
@@ -16,9 +16,10 @@
  */
 package org.apache.calcite.test.schemata.bookstore;
 
+import com.google.common.collect.ImmutableList;
+
 import java.math.BigDecimal;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 /**
@@ -43,8 +44,8 @@ public final class BookstoreSchema {
             new Coordinate(BigDecimal.valueOf(47.24), BigDecimal.valueOf(6.02)),
             "Besançon",
             "France"),
-        Collections.singletonList(
-            new Book("Les Misérables", 1862, Collections.singletonList(new Page(1, "Contents"))))),
+        ImmutableList.of(
+            new Book("Les Misérables", 1862, ImmutableList.of(new Page(1, "Contents"))))),
     new Author(
         2,
         "Nikos Kazantzakis",
@@ -58,10 +59,8 @@ public final class BookstoreSchema {
                 1946,
                 Arrays.asList(new Page(1, "Contents"), new Page(2, "Acknowledgements"))),
             new Book(
-                "The Last Temptation of Christ",
-                1955,
-                Collections.singletonList(new Page(1, "Contents"))))),
-    new Author(3, "Homer", new Place(null, "Ionia", "Greece"), Collections.emptyList())
+                "The Last Temptation of Christ", 1955, ImmutableList.of(new Page(1, "Contents"))))),
+    new Author(3, "Homer", new Place(null, "Ionia", "Greece"), ImmutableList.of())
   };
 
   /** Author. */
diff --git a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java
index d51203e05..e8f87b76d 100644
--- a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java
+++ b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchema.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.Arrays;
-import java.util.Collections;
 
 /**
  * A schema that contains two tables by reflection.
@@ -70,7 +69,7 @@ public class HrSchema {
   public final Department[] depts = {
     new Department(10, "Sales", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(30, "Marketing", ImmutableList.of(), new Location(0, 52)),
-    new Department(40, "HR", Collections.singletonList(emps[1]), null),
+    new Department(40, "HR", ImmutableList.of(emps[1]), null),
   };
   public final Dependent[] dependents = {
     new Dependent(10, "Michael"), new Dependent(10, "Jane"),
diff --git a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java
index a862cd283..05a9db780 100644
--- a/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java
+++ b/testkit/src/main/java/org/apache/calcite/test/schemata/hr/HrSchemaBig.java
@@ -19,7 +19,6 @@
 import com.google.common.collect.ImmutableList;
 
 import java.util.Arrays;
-import java.util.Collections;
 
 /** HR schema with more data than in {@link HrSchema}. */
 public class HrSchemaBig {
@@ -80,15 +79,15 @@ public class HrSchemaBig {
   public final Department[] depts = {
     new Department(10, "Sales", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(20, "Marketing", ImmutableList.of(), new Location(0, 52)),
-    new Department(30, "HR", Collections.singletonList(emps[1]), null),
+    new Department(30, "HR", ImmutableList.of(emps[1]), null),
     new Department(40, "Administration", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(50, "Design", ImmutableList.of(), new Location(0, 52)),
-    new Department(60, "IT", Collections.singletonList(emps[1]), null),
+    new Department(60, "IT", ImmutableList.of(emps[1]), null),
     new Department(70, "Production", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(80, "Finance", ImmutableList.of(), new Location(0, 52)),
-    new Department(90, "Accounting", Collections.singletonList(emps[1]), null),
+    new Department(90, "Accounting", ImmutableList.of(emps[1]), null),
     new Department(100, "Research", Arrays.asList(emps[0], emps[2]), new Location(-122, 38)),
     new Department(110, "Maintenance", ImmutableList.of(), new Location(0, 52)),
-    new Department(120, "Client Support", Collections.singletonList(emps[1]), null),
+    new Department(120, "Client Support", ImmutableList.of(emps[1]), null),
   };
 }
diff --git a/testkit/src/main/java/org/apache/calcite/util/Smalls.java b/testkit/src/main/java/org/apache/calcite/util/Smalls.java
index 5a3560273..7f6afb054 100644
--- a/testkit/src/main/java/org/apache/calcite/util/Smalls.java
+++ b/testkit/src/main/java/org/apache/calcite/util/Smalls.java
@@ -73,7 +73,6 @@
 import java.sql.Timestamp;
 import java.util.AbstractList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
@@ -597,7 +596,7 @@ public static String eval(@Parameter(name = "o") Object o) {
       if (o == null) {
         return "<null>";
       }
-      return "<" + o.toString() + ">";
+      return "<" + o + ">";
     }
   }
 
@@ -1378,7 +1377,7 @@ public static class SimpleTableMacro implements TableMacro {
     }
 
     @Override public List<FunctionParameter> getParameters() {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
   }
 
diff --git a/testkit/src/main/java/org/apache/calcite/util/TestUtil.java b/testkit/src/main/java/org/apache/calcite/util/TestUtil.java
index 03914e006..5023d5cb4 100644
--- a/testkit/src/main/java/org/apache/calcite/util/TestUtil.java
+++ b/testkit/src/main/java/org/apache/calcite/util/TestUtil.java
@@ -33,6 +33,8 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import static org.junit.jupiter.api.Assertions.fail;
 
 import static java.util.Objects.requireNonNull;
@@ -248,7 +250,7 @@ public static String correctRoundedFloat(String s) {
     final Matcher m2 = TRAILING_NINE_PATTERN.matcher(s);
     if (m2.matches()) {
       s = s.substring(0, s.length() - m2.group(2).length());
-      if (s.length() > 0) {
+      if (!s.isEmpty()) {
         final char c = s.charAt(s.length() - 1);
         switch (c) {
           case '0':
@@ -298,9 +300,7 @@ static int majorVersionFromString(String version) {
     }
     // probably running on > 8 (just get first integer which is major version)
     Matcher matcher = Pattern.compile("^\\d+").matcher(version);
-    if (!matcher.lookingAt()) {
-      throw new IllegalArgumentException("Can't parse (detect) JDK version from " + version);
-    }
+    checkArgument(matcher.lookingAt(), "Can't parse (detect) JDK version from %s", version);
 
     return Integer.parseInt(matcher.group());
   }
